{\rtf1\ansi\ansicpg1251\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset204\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset204\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset204\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment UnitIestExample }UnitIestExample}
{\comment \'D1\'EE\'E7\'E4\'E0\'ED\'EE \'F1\'E8\'F1\'F2\'E5\'EC\'EE\'E9 doxygen1.9.3.}
{\creatim \yr2022\mo4\dy17\hr1\min3\sec57}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt UnitIestExample}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
\'C2\'E5\'F0\'F1\'E8\'FF \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt \'C2\'F1 17 \'C0\'EF\'F0 2022 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \'CE\'E3\'EB\'E0\'E2\'EB\'E5\'ED\'E8\'E5\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'D1\'EF\'E8\'F1\'EE\'EA \'E7\'E0\'E4\'E0\'F7{\tc \v \'D1\'EF\'E8\'F1\'EE\'EA \'E7\'E0\'E4\'E0\'F7}\par \pard\plain 
{\bkmkstart AAAAAAACBE}
{\bkmkend AAAAAAACBE}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'C3\'EB\'EE\'E1\'E0\'EB\'FC\'ED\'FB\'E9 {\b calcSum}  (int a, int b)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
\'EC\'EE\'E6\'ED\'EE \'E4\'EE\'E1\'E0\'E2\'E8\'F2\'FC \'E5\'F9\'E5 \'F4\'F3\'ED\'F6\'E8\'FE \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CE\'F8\'E8\'E1\'EA\'E8{\tc \v \'CE\'F8\'E8\'E1\'EA\'E8}\par \pard\plain 
{\bkmkstart AAAAAAACBF}
{\bkmkend AAAAAAACBF}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'C3\'EB\'EE\'E1\'E0\'EB\'FC\'ED\'FB\'E9 {\b calcSum}  (int a, int b)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
 \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'C0\'EB\'F4\'E0\'E2\'E8\'F2\'ED\'FB\'E9 \'F3\'EA\'E0\'E7\'E0\'F2\'E5\'EB\'FC \'EF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2 \'E8\'EC\'E5\'ED\par \pard\plain 
{\tc \v \'C0\'EB\'F4\'E0\'E2\'E8\'F2\'ED\'FB\'E9 \'F3\'EA\'E0\'E7\'E0\'F2\'E5\'EB\'FC \'EF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2 \'E8\'EC\'E5\'ED}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \'CF\'EE\'EB\'ED\'FB\'E9 \'F1\'EF\'E8\'F1\'EE\'EA \'EF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2 \'E8\'EC\'E5\'ED.}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b proto2} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal2} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::edit_distance} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::posix} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing_internal} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'C8\'E5\'F0\'E0\'F0\'F5\'E8\'F7\'E5\'F1\'EA\'E8\'E9 \'F1\'EF\'E8\'F1\'EE\'EA \'EA\'EB\'E0\'F1\'F1\'EE\'E2\par \pard\plain 
{\tc \v \'C8\'E5\'F0\'E0\'F0\'F5\'E8\'F7\'E5\'F1\'EA\'E8\'E9 \'F1\'EF\'E8\'F1\'EE\'EA \'EA\'EB\'E0\'F1\'F1\'EE\'E2}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'C8\'E5\'F0\'E0\'F0\'F5\'E8\'FF \'EA\'EB\'E0\'F1\'F1\'EE\'E2\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \'C8\'E5\'F0\'E0\'F0\'F5\'E8\'FF \'EA\'EB\'E0\'F1\'F1\'EE\'E2.}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
std::tr1::gtest_internal::AddRef< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::AddRef< T & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::AddReference< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::AddReference< T & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::AssertHelper\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::AssertionResult\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::bool_constant< bool_value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
testing::internal::is_pointer< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::is_pointer< T * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
testing::internal::bool_constant< ImplicitlyConvertible< const T *, const ::ProtocolMessage * >::value||ImplicitlyConvertible< const T *, const ::proto2::Message * >::value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
testing::internal::IsAProtocolMessage< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
std::tr1::gtest_internal::ByRef< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::ByRef< T & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::CodeLocation\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::CompileAssert< bool >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::CompileAssertTypesEqual< T1, T2 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::CompileAssertTypesEqual< T, T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::ConstCharPtr\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::EnableIf< bool >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::EnableIf< true >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::Environment\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::EqHelper< lhs_is_null_literal >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::EqHelper< true >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::FilePath\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::FloatingPoint< RawType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::FormatForComparison< ToPrint, OtherOperand >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::FormatForComparison< ToPrint[N], OtherOperand >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::Get< k >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::Get< 0 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::Get< 1 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::Get< 2 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::Get< 3 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::Get< 4 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::Get< 5 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::Get< 6 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::Get< 7 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::Get< 8 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::Get< 9 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::GTestFlagSaver\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::GTestLog\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::GTestMutexLock\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::ImplicitlyConvertible< From, To >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::IteratorTraits< Iterator >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::IteratorTraits< const T * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::IteratorTraits< T * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::linked_ptr< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::linked_ptr_internal\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::Message\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::Mutex\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::NativeArray< Element >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::OsStackTraceGetterInterface\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRN \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
testing::internal::OsStackTraceGetter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
testing::internal::Random\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::RE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::RelationToSourceCopy\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::RelationToSourceReference\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::RemoveConst< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::RemoveConst< const T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::RemoveConst< const T[N]>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::RemoveReference< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::RemoveReference< T & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABST \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::SameSizeTuplePrefixComparator< kSize1, kSize2 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::SameSizeTuplePrefixComparator< 0, 0 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::SameSizeTuplePrefixComparator< k, k >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::scoped_ptr< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::scoped_ptr< ::std::string >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::scoped_ptr< ::std::stringstream >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::scoped_ptr< const ::std::string >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::scoped_ptr< GTEST_FLAG_SAVER_ >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::ScopedPrematureExitFile\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::ScopedTrace\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::SingleFailureChecker\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::StaticAssertTypeEqHelper< T1, T2 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::StaticAssertTypeEqHelper< T, T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::String\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::Test\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::TestCase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::TestCaseNameIs\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::TestEventListener\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
testing::EmptyTestEventListener\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
testing::internal::XmlUnitTestResultPrinter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
testing::internal::PrettyUnitTestResultPrinter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::TestEventRepeater\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
testing::TestEventListeners\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::TestFactoryBase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUN \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
testing::internal::TestFactoryImpl< TestClass >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
testing::TestInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::TestPartResult\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::TestPartResultArray\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::TestPartResultReporterInterface\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
testing::ScopedFakeTestPartResultReporter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::DefaultGlobalTestPartResultReporter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::DefaultPerThreadTestPartResultReporter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::HasNewFatalFailureHelper\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
testing::TestProperty\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::TestPropertyKeyIs\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::TestResult\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::TestResultAccessor\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::ThreadLocal< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::ThreadLocal< std::vector< testing::internal::TraceInfo > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::ThreadLocal< testing::TestPartResultReporterInterface * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::TraceInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple<>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple<>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple_element< k, Tuple >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple_size< Tuple >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple_size< GTEST_0_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple_size< GTEST_10_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple_size< GTEST_1_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple_size< GTEST_2_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple_size< GTEST_3_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple_size< GTEST_4_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple_size< GTEST_5_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple_size< GTEST_6_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAON \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple_size< GTEST_7_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple_size< GTEST_8_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::tuple_size< GTEST_9_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::TupleElement< kIndexValid, kIndex, Tuple >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::TupleElement< true, 0, GTEST_10_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::TupleElement< true, 1, GTEST_10_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::TupleElement< true, 2, GTEST_10_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::TupleElement< true, 3, GTEST_10_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::TupleElement< true, 4, GTEST_10_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::TupleElement< true, 5, GTEST_10_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::TupleElement< true, 6, GTEST_10_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::TupleElement< true, 7, GTEST_10_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::TupleElement< true, 8, GTEST_10_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tr1::gtest_internal::TupleElement< true, 9, GTEST_10_TUPLE_(T) >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::TuplePolicy< TupleT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::TypeIdHelper< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal2::TypeWithoutFormatter< T, kTypeKind >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal2::TypeWithoutFormatter< T, kConvertibleToInteger >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal2::TypeWithoutFormatter< T, kProtobuf >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::TypeWithSize< size >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::TypeWithSize< 4 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::TypeWithSize< 8 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::TypeWithSize< sizeof(RawType)>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::UnitTest\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::UnitTestImpl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::UnitTestOptions\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::UniversalPrinter< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::UniversalPrinter< T & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::UniversalPrinter< T[N]>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::UniversalTersePrinter< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::UniversalTersePrinter< char * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::UniversalTersePrinter< const char * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::UniversalTersePrinter< T & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::UniversalTersePrinter< T[N]>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::UniversalTersePrinter< wchar_t * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::internal::WrapPrinterType< type >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'C0\'EB\'F4\'E0\'E2\'E8\'F2\'ED\'FB\'E9 \'F3\'EA\'E0\'E7\'E0\'F2\'E5\'EB\'FC \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0 \'E4\'E0\'ED\'ED\'FB\'F5\par \pard\plain 
{\tc \v \'C0\'EB\'F4\'E0\'E2\'E8\'F2\'ED\'FB\'E9 \'F3\'EA\'E0\'E7\'E0\'F2\'E5\'EB\'FC \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0 \'E4\'E0\'ED\'ED\'FB\'F5}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5 \'F1 \'E8\'F5 \'EA\'F0\'E0\'F2\'EA\'E8\'EC \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\'EC.}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b std::tr1::gtest_internal::AddRef< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::AddRef< T & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::AddReference< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::AddReference< T & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::AssertHelper} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::AssertionResult} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::bool_constant< bool_value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::ByRef< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::ByRef< T & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::CodeLocation} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::CompileAssert< bool >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::CompileAssertTypesEqual< T1, T2 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::CompileAssertTypesEqual< T, T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::ConstCharPtr} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::DefaultGlobalTestPartResultReporter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::DefaultPerThreadTestPartResultReporter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::EmptyTestEventListener} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::EnableIf< bool >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::EnableIf< true >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::Environment} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::EqHelper< lhs_is_null_literal >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::EqHelper< true >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::FilePath} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::FloatingPoint< RawType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::FormatForComparison< ToPrint, OtherOperand >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::FormatForComparison< ToPrint[N], OtherOperand >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::Get< k >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::Get< 0 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::Get< 1 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::Get< 2 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::Get< 3 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::Get< 4 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::Get< 5 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::Get< 6 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::Get< 7 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::Get< 8 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::Get< 9 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::GTestFlagSaver} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::GTestLog} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::GTestMutexLock} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::HasNewFatalFailureHelper} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::ImplicitlyConvertible< From, To >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::is_pointer< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::is_pointer< T * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::IsAProtocolMessage< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::IteratorTraits< Iterator >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::IteratorTraits< const T * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::IteratorTraits< T * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::linked_ptr< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::linked_ptr_internal} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::Message} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::Mutex} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::NativeArray< Element >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::OsStackTraceGetter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::OsStackTraceGetterInterface} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::PrettyUnitTestResultPrinter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::Random} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::RE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::RelationToSourceCopy} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::RelationToSourceReference} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::RemoveConst< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::RemoveConst< const T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::RemoveConst< const T[N]>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::RemoveReference< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::RemoveReference< T & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABST \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::SameSizeTuplePrefixComparator< kSize1, kSize2 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::SameSizeTuplePrefixComparator< 0, 0 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::SameSizeTuplePrefixComparator< k, k >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::scoped_ptr< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::ScopedFakeTestPartResultReporter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::ScopedPrematureExitFile} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::ScopedTrace} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::SingleFailureChecker} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::StaticAssertTypeEqHelper< T1, T2 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::StaticAssertTypeEqHelper< T, T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::String} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::Test} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::TestCase} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::TestCaseNameIs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::TestEventListener} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::TestEventListeners} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::TestEventRepeater} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::TestFactoryBase} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::TestFactoryImpl< TestClass >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::TestInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::TestPartResult} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::TestPartResultArray} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::TestPartResultReporterInterface} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::TestProperty} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::TestPropertyKeyIs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::TestResult} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::TestResultAccessor} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::ThreadLocal< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::TraceInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple<>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple<>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple_element< k, Tuple >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple_size< Tuple >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple_size< GTEST_0_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple_size< GTEST_10_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple_size< GTEST_1_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple_size< GTEST_2_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple_size< GTEST_3_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple_size< GTEST_4_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple_size< GTEST_5_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple_size< GTEST_6_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAON \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple_size< GTEST_7_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple_size< GTEST_8_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::tuple_size< GTEST_9_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::TupleElement< kIndexValid, kIndex, Tuple >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::TupleElement< true, 0, GTEST_10_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::TupleElement< true, 1, GTEST_10_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::TupleElement< true, 2, GTEST_10_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::TupleElement< true, 3, GTEST_10_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::TupleElement< true, 4, GTEST_10_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::TupleElement< true, 5, GTEST_10_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::TupleElement< true, 6, GTEST_10_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::TupleElement< true, 7, GTEST_10_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::TupleElement< true, 8, GTEST_10_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tr1::gtest_internal::TupleElement< true, 9, GTEST_10_TUPLE_(T) >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::TuplePolicy< TupleT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::TypeIdHelper< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal2::TypeWithoutFormatter< T, kTypeKind >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal2::TypeWithoutFormatter< T, kConvertibleToInteger >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal2::TypeWithoutFormatter< T, kProtobuf >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::TypeWithSize< size >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::TypeWithSize< 4 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::TypeWithSize< 8 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::UnitTest} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::UnitTestImpl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::UnitTestOptions} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::UniversalPrinter< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::UniversalPrinter< T & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::UniversalPrinter< T[N]>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::UniversalTersePrinter< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::UniversalTersePrinter< char * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::UniversalTersePrinter< const char * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::UniversalTersePrinter< T & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::UniversalTersePrinter< T[N]>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::UniversalTersePrinter< wchar_t * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::WrapPrinterType< type >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b testing::internal::XmlUnitTestResultPrinter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'D1\'EF\'E8\'F1\'EE\'EA \'F4\'E0\'E9\'EB\'EE\'E2\par \pard\plain 
{\tc \v \'D1\'EF\'E8\'F1\'EE\'EA \'F4\'E0\'E9\'EB\'EE\'E2}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB\'FB\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \'CF\'EE\'EB\'ED\'FB\'E9 \'F1\'EF\'E8\'F1\'EE\'EA \'F4\'E0\'E9\'EB\'EE\'E2.}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b main.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/{\b gtest-death-test.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/{\b gtest-message.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/{\b gtest-param-test.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/{\b gtest-printers.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/{\b gtest-spi.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/{\b gtest-test-part.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/{\b gtest-typed-test.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/{\b gtest.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/{\b gtest_pred_impl.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/{\b gtest_prod.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/internal/{\b gtest-death-test-internal.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAII \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/internal/{\b gtest-filepath.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/internal/{\b gtest-internal.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/internal/{\b gtest-linked_ptr.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/internal/{\b gtest-param-util-generated.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/internal/{\b gtest-param-util.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/internal/{\b gtest-port-arch.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/internal/{\b gtest-port.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/internal/{\b gtest-string.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/internal/{\b gtest-tuple.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/internal/{\b gtest-type-util.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/internal/custom/{\b gtest-port.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/internal/custom/{\b gtest-printers.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/include/gtest/internal/custom/{\b gtest.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/src/{\b gtest-all.cc} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/src/{\b gtest-death-test.cc} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/src/{\b gtest-filepath.cc} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/src/{\b gtest-internal-inl.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/src/{\b gtest-port.cc} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/src/{\b gtest-printers.cc} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/src/{\b gtest-test-part.cc} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/src/{\b gtest-typed-test.cc} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/src/{\b gtest.cc} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b gtest/src/{\b gtest_main.cc} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'EE \'E8\'EC\'E5\'ED proto2\par \pard\plain 
{\tc\tcl2 \v proto2}
{\xe \v proto2}
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'EE \'E8\'EC\'E5\'ED std\par \pard\plain 
{\tc\tcl2 \v std}
{\xe \v std}
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b tr1}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'EE \'E8\'EC\'E5\'ED std::tr1\par \pard\plain 
{\tc\tcl2 \v std::tr1}
{\xe \v std::tr1}
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b gtest_internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b tuple}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b tuple<>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_element}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_size< GTEST_0_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_size< GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_size< GTEST_1_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_size< GTEST_2_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_size< GTEST_3_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_size< GTEST_4_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_size< GTEST_5_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_size< GTEST_6_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_size< GTEST_7_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_size< GTEST_8_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_size< GTEST_9_TUPLE_(T) >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_1_TYPENAMES_}(T) > class {\b GTEST_1_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_2_TYPENAMES_}(T) > class {\b GTEST_2_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_3_TYPENAMES_}(T) > class {\b GTEST_3_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_4_TYPENAMES_}(T) > class {\b GTEST_4_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_5_TYPENAMES_}(T) > class {\b GTEST_5_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_6_TYPENAMES_}(T) > class {\b GTEST_6_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_7_TYPENAMES_}(T) > class {\b GTEST_7_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_8_TYPENAMES_}(T) > class {\b GTEST_8_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_9_TYPENAMES_}(T) > class {\b GTEST_9_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b tuple} {\b make_tuple} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_1_TYPENAMES_}(T) > {\b GTEST_1_TUPLE_} (T) {\b make_tuple}(const T0 &f0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_2_TYPENAMES_}(T) > {\b GTEST_2_TUPLE_} (T) {\b make_tuple}(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_3_TYPENAMES_}(T) > {\b GTEST_3_TUPLE_} (T) {\b make_tuple}(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_4_TYPENAMES_}(T) > {\b GTEST_4_TUPLE_} (T) {\b make_tuple}(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_5_TYPENAMES_}(T) > {\b GTEST_5_TUPLE_} (T) {\b make_tuple}(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_6_TYPENAMES_}(T) > {\b GTEST_6_TUPLE_} (T) {\b make_tuple}(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_7_TYPENAMES_}(T) > {\b GTEST_7_TUPLE_} (T) {\b make_tuple}(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_8_TYPENAMES_}(T) > {\b GTEST_8_TUPLE_} (T) {\b make_tuple}(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_9_TYPENAMES_}(T) > {\b GTEST_9_TUPLE_} (T) {\b make_tuple}(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T) > {\b GTEST_10_TUPLE_} (T) {\b make_tuple}(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<int k, {\b GTEST_10_TYPENAMES_}(T) > {\b GTEST_ADD_REF_} ({\b GTEST_TUPLE_ELEMENT_}(k, {\b GTEST_10_TUPLE_}(T))) get({\b GTEST_10_TUPLE_}(T) &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<int k, {\b GTEST_10_TYPENAMES_}(T) > {\b GTEST_BY_REF_} ({\b GTEST_TUPLE_ELEMENT_}(k, {\b GTEST_10_TUPLE_}(T))) get(const {\b GTEST_10_TUPLE_}(T) &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T) , {\b GTEST_10_TYPENAMES_}(U) > bool {\b operator==} (const {\b GTEST_10_TUPLE_}(T)&t, const {\b GTEST_10_TUPLE_}(U)&u)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T) , {\b GTEST_10_TYPENAMES_}(U) > bool {\b operator!=} (const {\b GTEST_10_TUPLE_}(T)&t, const {\b GTEST_10_TUPLE_}(U)&u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 & {\b f1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 & {\b f2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 const T3 & {\b f3}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 const T3 const T4 & {\b f4}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 const T3 const T4 const T5 & {\b f5}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 const T3 const T4 const T5 const T6 & {\b f6}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 const T3 const T4 const T5 const T6 const T7 & {\b f7}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 const T3 const T4 const T5 const T6 const T7 const T8 & {\b f8}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 const T3 const T4 const T5 const T6 const T7 const T8 const T9 & {\b f9}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 
{\xe \v GTEST_10_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_10_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > std::tr1::GTEST_10_TUPLE_ (T ) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b operator==()}.}\par
}
{\xe \v GTEST_1_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_1_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_1_TYPENAMES_}(T) > class std::tr1::GTEST_1_TUPLE_ (T )}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00213                         \{\par
00214  {\cf17 public}:\par
00215   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00216 \par
00217   tuple() : f0_() \{\}\par
00218 \par
00219   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0) : f0_(f0) \{\}\par
00220 \par
00221   tuple({\cf17 const} tuple& t) : f0_(t.f0_) \{\}\par
00222 \par
00223   {\cf17 template} <GTEST_1_TYPENAMES_(U)>\par
00224   tuple({\cf17 const} GTEST_1_TUPLE_(U)& t) : f0_(t.f0_) \{\}\par
00225 \par
00226   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00227 \par
00228   {\cf17 template} <GTEST_1_TYPENAMES_(U)>\par
00229   tuple& operator=({\cf17 const} GTEST_1_TUPLE_(U)& t) \{\par
00230     {\cf19 return} CopyFrom(t);\par
00231   \}\par
00232 \par
00233   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00234 \par
00235   {\cf17 template} <GTEST_1_TYPENAMES_(U)>\par
00236   tuple& CopyFrom({\cf17 const} GTEST_1_TUPLE_(U)& t) \{\par
00237     f0_ = t.f0_;\par
00238     {\cf19 return} *{\cf17 this};\par
00239   \}\par
00240 \par
00241   T0 f0_;\par
00242 \};\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b GTEST_1_TUPLE_()}.}\par
}
{\xe \v GTEST_1_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_1_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_1_TYPENAMES_}(T) > std::tr1::GTEST_1_TUPLE_ (T ) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 678}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00678                                                   \{\par
00679   {\cf19 return} GTEST_1_TUPLE_(T)(f0);\par
00680 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GTEST_1_TUPLE_()}.}\par
}
{\xe \v GTEST_2_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_2_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_2_TYPENAMES_}(T) > class std::tr1::GTEST_2_TUPLE_ (T )}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00245                         \{\par
00246  {\cf17 public}:\par
00247   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00248 \par
00249   tuple() : f0_(), f1_() \{\}\par
00250 \par
00251   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1) : f0_(f0),\par
00252       f1_(f1) \{\}\par
00253 \par
00254   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_) \{\}\par
00255 \par
00256   {\cf17 template} <GTEST_2_TYPENAMES_(U)>\par
00257   tuple({\cf17 const} GTEST_2_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_) \{\}\par
00258   {\cf17 template} <{\cf17 typename} U0, {\cf17 typename} U1>\par
00259   tuple(const ::std::pair<U0, U1>& p) : f0_(p.first), f1_(p.second) \{\}\par
00260 \par
00261   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00262 \par
00263   {\cf17 template} <GTEST_2_TYPENAMES_(U)>\par
00264   tuple& operator=({\cf17 const} GTEST_2_TUPLE_(U)& t) \{\par
00265     {\cf19 return} CopyFrom(t);\par
00266   \}\par
00267   {\cf17 template} <{\cf17 typename} U0, {\cf17 typename} U1>\par
00268   tuple& operator=(const ::std::pair<U0, U1>& p) \{\par
00269     f0_ = p.first;\par
00270     f1_ = p.second;\par
00271     {\cf19 return} *{\cf17 this};\par
00272   \}\par
00273 \par
00274   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00275 \par
00276   {\cf17 template} <GTEST_2_TYPENAMES_(U)>\par
00277   tuple& CopyFrom({\cf17 const} GTEST_2_TUPLE_(U)& t) \{\par
00278     f0_ = t.f0_;\par
00279     f1_ = t.f1_;\par
00280     {\cf19 return} *{\cf17 this};\par
00281   \}\par
00282 \par
00283   T0 f0_;\par
00284   T1 f1_;\par
00285 \};\par
}
}
{\xe \v GTEST_2_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_2_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_2_TYPENAMES_}(T) > std::tr1::GTEST_2_TUPLE_ (T ) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_3_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_3_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_3_TYPENAMES_}(T) > class std::tr1::GTEST_3_TUPLE_ (T )}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00288                         \{\par
00289  {\cf17 public}:\par
00290   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00291 \par
00292   tuple() : f0_(), f1_(), f2_() \{\}\par
00293 \par
00294   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00295       GTEST_BY_REF_(T2) f2) : f0_(f0), f1_(f1), f2_(f2) \{\}\par
00296 \par
00297   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_) \{\}\par
00298 \par
00299   {\cf17 template} <GTEST_3_TYPENAMES_(U)>\par
00300   tuple({\cf17 const} GTEST_3_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_) \{\}\par
00301 \par
00302   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00303 \par
00304   {\cf17 template} <GTEST_3_TYPENAMES_(U)>\par
00305   tuple& operator=({\cf17 const} GTEST_3_TUPLE_(U)& t) \{\par
00306     {\cf19 return} CopyFrom(t);\par
00307   \}\par
00308 \par
00309   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00310 \par
00311   {\cf17 template} <GTEST_3_TYPENAMES_(U)>\par
00312   tuple& CopyFrom({\cf17 const} GTEST_3_TUPLE_(U)& t) \{\par
00313     f0_ = t.f0_;\par
00314     f1_ = t.f1_;\par
00315     f2_ = t.f2_;\par
00316     {\cf19 return} *{\cf17 this};\par
00317   \}\par
00318 \par
00319   T0 f0_;\par
00320   T1 f1_;\par
00321   T2 f2_;\par
00322 \};\par
}
}
{\xe \v GTEST_3_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_3_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_3_TYPENAMES_}(T) > std::tr1::GTEST_3_TUPLE_ (T ) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_4_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_4_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_4_TYPENAMES_}(T) > class std::tr1::GTEST_4_TUPLE_ (T )}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00325                         \{\par
00326  {\cf17 public}:\par
00327   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00328 \par
00329   tuple() : f0_(), f1_(), f2_(), f3_() \{\}\par
00330 \par
00331   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00332       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3) : f0_(f0), f1_(f1), f2_(f2),\par
00333       f3_(f3) \{\}\par
00334 \par
00335   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_) \{\}\par
00336 \par
00337   {\cf17 template} <GTEST_4_TYPENAMES_(U)>\par
00338   tuple({\cf17 const} GTEST_4_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),\par
00339       f3_(t.f3_) \{\}\par
00340 \par
00341   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00342 \par
00343   {\cf17 template} <GTEST_4_TYPENAMES_(U)>\par
00344   tuple& operator=({\cf17 const} GTEST_4_TUPLE_(U)& t) \{\par
00345     {\cf19 return} CopyFrom(t);\par
00346   \}\par
00347 \par
00348   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00349 \par
00350   {\cf17 template} <GTEST_4_TYPENAMES_(U)>\par
00351   tuple& CopyFrom({\cf17 const} GTEST_4_TUPLE_(U)& t) \{\par
00352     f0_ = t.f0_;\par
00353     f1_ = t.f1_;\par
00354     f2_ = t.f2_;\par
00355     f3_ = t.f3_;\par
00356     {\cf19 return} *{\cf17 this};\par
00357   \}\par
00358 \par
00359   T0 f0_;\par
00360   T1 f1_;\par
00361   T2 f2_;\par
00362   T3 f3_;\par
00363 \};\par
}
}
{\xe \v GTEST_4_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_4_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_4_TYPENAMES_}(T) > std::tr1::GTEST_4_TUPLE_ (T ) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_5_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_5_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_5_TYPENAMES_}(T) > class std::tr1::GTEST_5_TUPLE_ (T )}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00366                         \{\par
00367  {\cf17 public}:\par
00368   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00369 \par
00370   tuple() : f0_(), f1_(), f2_(), f3_(), f4_() \{\}\par
00371 \par
00372   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00373       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3,\par
00374       GTEST_BY_REF_(T4) f4) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4) \{\}\par
00375 \par
00376   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),\par
00377       f4_(t.f4_) \{\}\par
00378 \par
00379   {\cf17 template} <GTEST_5_TYPENAMES_(U)>\par
00380   tuple({\cf17 const} GTEST_5_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),\par
00381       f3_(t.f3_), f4_(t.f4_) \{\}\par
00382 \par
00383   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00384 \par
00385   {\cf17 template} <GTEST_5_TYPENAMES_(U)>\par
00386   tuple& operator=({\cf17 const} GTEST_5_TUPLE_(U)& t) \{\par
00387     {\cf19 return} CopyFrom(t);\par
00388   \}\par
00389 \par
00390   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00391 \par
00392   {\cf17 template} <GTEST_5_TYPENAMES_(U)>\par
00393   tuple& CopyFrom({\cf17 const} GTEST_5_TUPLE_(U)& t) \{\par
00394     f0_ = t.f0_;\par
00395     f1_ = t.f1_;\par
00396     f2_ = t.f2_;\par
00397     f3_ = t.f3_;\par
00398     f4_ = t.f4_;\par
00399     {\cf19 return} *{\cf17 this};\par
00400   \}\par
00401 \par
00402   T0 f0_;\par
00403   T1 f1_;\par
00404   T2 f2_;\par
00405   T3 f3_;\par
00406   T4 f4_;\par
00407 \};\par
}
}
{\xe \v GTEST_5_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_5_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_5_TYPENAMES_}(T) > std::tr1::GTEST_5_TUPLE_ (T ) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_6_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_6_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_6_TYPENAMES_}(T) > class std::tr1::GTEST_6_TUPLE_ (T )}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00410                         \{\par
00411  {\cf17 public}:\par
00412   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00413 \par
00414   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_() \{\}\par
00415 \par
00416   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00417       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,\par
00418       GTEST_BY_REF_(T5) f5) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4),\par
00419       f5_(f5) \{\}\par
00420 \par
00421   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),\par
00422       f4_(t.f4_), f5_(t.f5_) \{\}\par
00423 \par
00424   {\cf17 template} <GTEST_6_TYPENAMES_(U)>\par
00425   tuple({\cf17 const} GTEST_6_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),\par
00426       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_) \{\}\par
00427 \par
00428   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00429 \par
00430   {\cf17 template} <GTEST_6_TYPENAMES_(U)>\par
00431   tuple& operator=({\cf17 const} GTEST_6_TUPLE_(U)& t) \{\par
00432     {\cf19 return} CopyFrom(t);\par
00433   \}\par
00434 \par
00435   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00436 \par
00437   {\cf17 template} <GTEST_6_TYPENAMES_(U)>\par
00438   tuple& CopyFrom({\cf17 const} GTEST_6_TUPLE_(U)& t) \{\par
00439     f0_ = t.f0_;\par
00440     f1_ = t.f1_;\par
00441     f2_ = t.f2_;\par
00442     f3_ = t.f3_;\par
00443     f4_ = t.f4_;\par
00444     f5_ = t.f5_;\par
00445     {\cf19 return} *{\cf17 this};\par
00446   \}\par
00447 \par
00448   T0 f0_;\par
00449   T1 f1_;\par
00450   T2 f2_;\par
00451   T3 f3_;\par
00452   T4 f4_;\par
00453   T5 f5_;\par
00454 \};\par
}
}
{\xe \v GTEST_6_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_6_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_6_TYPENAMES_}(T) > std::tr1::GTEST_6_TUPLE_ (T ) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_7_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_7_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_7_TYPENAMES_}(T) > class std::tr1::GTEST_7_TUPLE_ (T )}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00457                         \{\par
00458  {\cf17 public}:\par
00459   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00460 \par
00461   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_() \{\}\par
00462 \par
00463   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00464       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,\par
00465       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6) : f0_(f0), f1_(f1), f2_(f2),\par
00466       f3_(f3), f4_(f4), f5_(f5), f6_(f6) \{\}\par
00467 \par
00468   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),\par
00469       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_) \{\}\par
00470 \par
00471   {\cf17 template} <GTEST_7_TYPENAMES_(U)>\par
00472   tuple({\cf17 const} GTEST_7_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),\par
00473       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_) \{\}\par
00474 \par
00475   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00476 \par
00477   {\cf17 template} <GTEST_7_TYPENAMES_(U)>\par
00478   tuple& operator=({\cf17 const} GTEST_7_TUPLE_(U)& t) \{\par
00479     {\cf19 return} CopyFrom(t);\par
00480   \}\par
00481 \par
00482   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00483 \par
00484   {\cf17 template} <GTEST_7_TYPENAMES_(U)>\par
00485   tuple& CopyFrom({\cf17 const} GTEST_7_TUPLE_(U)& t) \{\par
00486     f0_ = t.f0_;\par
00487     f1_ = t.f1_;\par
00488     f2_ = t.f2_;\par
00489     f3_ = t.f3_;\par
00490     f4_ = t.f4_;\par
00491     f5_ = t.f5_;\par
00492     f6_ = t.f6_;\par
00493     {\cf19 return} *{\cf17 this};\par
00494   \}\par
00495 \par
00496   T0 f0_;\par
00497   T1 f1_;\par
00498   T2 f2_;\par
00499   T3 f3_;\par
00500   T4 f4_;\par
00501   T5 f5_;\par
00502   T6 f6_;\par
00503 \};\par
}
}
{\xe \v GTEST_7_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_7_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_7_TYPENAMES_}(T) > std::tr1::GTEST_7_TUPLE_ (T ) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_8_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_8_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_8_TYPENAMES_}(T) > class std::tr1::GTEST_8_TUPLE_ (T )}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00506                         \{\par
00507  {\cf17 public}:\par
00508   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00509 \par
00510   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_(), f7_() \{\}\par
00511 \par
00512   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00513       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,\par
00514       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6,\par
00515       GTEST_BY_REF_(T7) f7) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4),\par
00516       f5_(f5), f6_(f6), f7_(f7) \{\}\par
00517 \par
00518   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),\par
00519       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_) \{\}\par
00520 \par
00521   {\cf17 template} <GTEST_8_TYPENAMES_(U)>\par
00522   tuple({\cf17 const} GTEST_8_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),\par
00523       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_) \{\}\par
00524 \par
00525   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00526 \par
00527   {\cf17 template} <GTEST_8_TYPENAMES_(U)>\par
00528   tuple& operator=({\cf17 const} GTEST_8_TUPLE_(U)& t) \{\par
00529     {\cf19 return} CopyFrom(t);\par
00530   \}\par
00531 \par
00532   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00533 \par
00534   {\cf17 template} <GTEST_8_TYPENAMES_(U)>\par
00535   tuple& CopyFrom({\cf17 const} GTEST_8_TUPLE_(U)& t) \{\par
00536     f0_ = t.f0_;\par
00537     f1_ = t.f1_;\par
00538     f2_ = t.f2_;\par
00539     f3_ = t.f3_;\par
00540     f4_ = t.f4_;\par
00541     f5_ = t.f5_;\par
00542     f6_ = t.f6_;\par
00543     f7_ = t.f7_;\par
00544     {\cf19 return} *{\cf17 this};\par
00545   \}\par
00546 \par
00547   T0 f0_;\par
00548   T1 f1_;\par
00549   T2 f2_;\par
00550   T3 f3_;\par
00551   T4 f4_;\par
00552   T5 f5_;\par
00553   T6 f6_;\par
00554   T7 f7_;\par
00555 \};\par
}
}
{\xe \v GTEST_8_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_8_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_8_TYPENAMES_}(T) > std::tr1::GTEST_8_TUPLE_ (T ) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_9_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_9_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_9_TYPENAMES_}(T) > class std::tr1::GTEST_9_TUPLE_ (T )}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00558                         \{\par
00559  {\cf17 public}:\par
00560   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00561 \par
00562   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_(), f7_(), f8_() \{\}\par
00563 \par
00564   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00565       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,\par
00566       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6, GTEST_BY_REF_(T7) f7,\par
00567       GTEST_BY_REF_(T8) f8) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4),\par
00568       f5_(f5), f6_(f6), f7_(f7), f8_(f8) \{\}\par
00569 \par
00570   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),\par
00571       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_) \{\}\par
00572 \par
00573   {\cf17 template} <GTEST_9_TYPENAMES_(U)>\par
00574   tuple({\cf17 const} GTEST_9_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),\par
00575       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_) \{\}\par
00576 \par
00577   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00578 \par
00579   {\cf17 template} <GTEST_9_TYPENAMES_(U)>\par
00580   tuple& operator=({\cf17 const} GTEST_9_TUPLE_(U)& t) \{\par
00581     {\cf19 return} CopyFrom(t);\par
00582   \}\par
00583 \par
00584   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00585 \par
00586   {\cf17 template} <GTEST_9_TYPENAMES_(U)>\par
00587   tuple& CopyFrom({\cf17 const} GTEST_9_TUPLE_(U)& t) \{\par
00588     f0_ = t.f0_;\par
00589     f1_ = t.f1_;\par
00590     f2_ = t.f2_;\par
00591     f3_ = t.f3_;\par
00592     f4_ = t.f4_;\par
00593     f5_ = t.f5_;\par
00594     f6_ = t.f6_;\par
00595     f7_ = t.f7_;\par
00596     f8_ = t.f8_;\par
00597     {\cf19 return} *{\cf17 this};\par
00598   \}\par
00599 \par
00600   T0 f0_;\par
00601   T1 f1_;\par
00602   T2 f2_;\par
00603   T3 f3_;\par
00604   T4 f4_;\par
00605   T5 f5_;\par
00606   T6 f6_;\par
00607   T7 f7_;\par
00608   T8 f8_;\par
00609 \};\par
}
}
{\xe \v GTEST_9_TUPLE_\:std::tr1}
{\xe \v std::tr1\:GTEST_9_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_9_TYPENAMES_}(T) > std::tr1::GTEST_9_TUPLE_ (T ) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_ADD_REF_\:std::tr1}
{\xe \v std::tr1\:GTEST_ADD_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<int k, {\b GTEST_10_TYPENAMES_}(T) > std::tr1::GTEST_ADD_REF_ ({\b GTEST_TUPLE_ELEMENT_}(k, {\b GTEST_10_TUPLE_}(T)) ) &}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 930}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00931                            \{\par
00932   {\cf19 return} gtest_internal::Get<k>::Field(t);\par
00933 \}\par
}
}
{\xe \v GTEST_BY_REF_\:std::tr1}
{\xe \v std::tr1\:GTEST_BY_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<int k, {\b GTEST_10_TYPENAMES_}(T) > std::tr1::GTEST_BY_REF_ ({\b GTEST_TUPLE_ELEMENT_}(k, {\b GTEST_10_TUPLE_}(T)) ) const &}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 936}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00937                                  \{\par
00938   {\cf19 return} gtest_internal::Get<k>::ConstField(t);\par
00939 \}\par
}
}
{\xe \v make_tuple\:std::tr1}
{\xe \v std::tr1\:make_tuple}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b tuple} std::tr1::make_tuple (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 675}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00675 \{ {\cf19 return} tuple<>(); \}\par
}
}
{\xe \v operator!=\:std::tr1}
{\xe \v std::tr1\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) , {\b GTEST_10_TYPENAMES_}(U) > bool std::tr1::operator!= (const {\b GTEST_10_TUPLE_}(T)&  {\i t}, const {\b GTEST_10_TUPLE_}(U)&  {\i u}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 982}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00983                                                     \{ {\cf19 return} !(t == u); \}\par
}
}
{\xe \v operator==\:std::tr1}
{\xe \v std::tr1\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) , {\b GTEST_10_TYPENAMES_}(U) > bool std::tr1::operator== (const {\b GTEST_10_TUPLE_}(T)&  {\i t}, const {\b GTEST_10_TUPLE_}(U)&  {\i u}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 974}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00975                                                     \{\par
00976   {\cf19 return} gtest_internal::SameSizeTuplePrefixComparator<\par
00977       tuple_size<GTEST_10_TUPLE_(T) >::value,\par
00978       tuple_size<GTEST_10_TUPLE_(U) >::value>::Eq(t, u);\par
00979 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GTEST_10_TUPLE_()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 
{\xe \v f1\:std::tr1}
{\xe \v std::tr1\:f1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const T1 & std::tr1::f1}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'C8\'ED\'E8\'F6\'E8\'E0\'EB\'E8\'E7\'E0\'F2\'EE\'F0}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  {\cf19 return} GTEST_2_TUPLE_(T)(f0, f1)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 683}}\par
}
{\xe \v f2\:std::tr1}
{\xe \v std::tr1\:f2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const T1 const T2 & std::tr1::f2}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'C8\'ED\'E8\'F6\'E8\'E0\'EB\'E8\'E7\'E0\'F2\'EE\'F0}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  {\cf19 return} GTEST_3_TUPLE_(T)(f0, f1, f2)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 688}}\par
}
{\xe \v f3\:std::tr1}
{\xe \v std::tr1\:f3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const T1 const T2 const T3 & std::tr1::f3}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'C8\'ED\'E8\'F6\'E8\'E0\'EB\'E8\'E7\'E0\'F2\'EE\'F0}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  {\cf19 return} GTEST_4_TUPLE_(T)(f0, f1, f2, f3)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 694}}\par
}
{\xe \v f4\:std::tr1}
{\xe \v std::tr1\:f4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const T1 const T2 const T3 const T4 & std::tr1::f4}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'C8\'ED\'E8\'F6\'E8\'E0\'EB\'E8\'E7\'E0\'F2\'EE\'F0}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  {\cf19 return} GTEST_5_TUPLE_(T)(f0, f1, f2, f3, f4)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 700}}\par
}
{\xe \v f5\:std::tr1}
{\xe \v std::tr1\:f5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const T1 const T2 const T3 const T4 const T5 & std::tr1::f5}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'C8\'ED\'E8\'F6\'E8\'E0\'EB\'E8\'E7\'E0\'F2\'EE\'F0}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  {\cf19 return} GTEST_6_TUPLE_(T)(f0, f1, f2, f3, f4, f5)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 706}}\par
}
{\xe \v f6\:std::tr1}
{\xe \v std::tr1\:f6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const T1 const T2 const T3 const T4 const T5 const T6 & std::tr1::f6}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'C8\'ED\'E8\'F6\'E8\'E0\'EB\'E8\'E7\'E0\'F2\'EE\'F0}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  {\cf19 return} GTEST_7_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 712}}\par
}
{\xe \v f7\:std::tr1}
{\xe \v std::tr1\:f7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const T1 const T2 const T3 const T4 const T5 const T6 const T7 & std::tr1::f7}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'C8\'ED\'E8\'F6\'E8\'E0\'EB\'E8\'E7\'E0\'F2\'EE\'F0}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  {\cf19 return} GTEST_8_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6, f7)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 718}}\par
}
{\xe \v f8\:std::tr1}
{\xe \v std::tr1\:f8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const T1 const T2 const T3 const T4 const T5 const T6 const T7 const T8 & std::tr1::f8}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'C8\'ED\'E8\'F6\'E8\'E0\'EB\'E8\'E7\'E0\'F2\'EE\'F0}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  {\cf19 return} GTEST_9_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6, f7, f8)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 725}}\par
}
{\xe \v f9\:std::tr1}
{\xe \v std::tr1\:f9}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const T1 const T2 const T3 const T4 const T5 const T6 const T7 const T8 const T9& std::tr1::f9}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'C8\'ED\'E8\'F6\'E8\'E0\'EB\'E8\'E7\'E0\'F2\'EE\'F0}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  {\cf19 return} GTEST_10_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6, f7, f8, f9)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 732}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'EE \'E8\'EC\'E5\'ED std::tr1::gtest_internal\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal}
{\xe \v std::tr1::gtest_internal}
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b AddRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b AddRef< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ByRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ByRef< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Get}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Get< 0 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Get< 1 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Get< 2 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Get< 3 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Get< 4 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Get< 5 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Get< 6 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Get< 7 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Get< 8 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Get< 9 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SameSizeTuplePrefixComparator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SameSizeTuplePrefixComparator< 0, 0 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SameSizeTuplePrefixComparator< k, k >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TupleElement}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TupleElement< true, 0, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TupleElement< true, 1, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TupleElement< true, 2, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TupleElement< true, 3, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TupleElement< true, 4, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TupleElement< true, 5, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TupleElement< true, 6, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TupleElement< true, 7, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TupleElement< true, 8, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TupleElement< true, 9, GTEST_10_TUPLE_(T) >}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'EE \'E8\'EC\'E5\'ED testing\par \pard\plain 
{\tc\tcl2 \v testing}
{\xe \v testing}
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b internal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b internal2}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AssertionResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EmptyTestEventListener}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Environment}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Message}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ScopedFakeTestPartResultReporter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Test}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestCase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestEventListener}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestEventListeners}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestPartResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestPartResultArray}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestPartResultReporterInterface}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestProperty}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UnitTest}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b internal::TimeInMillis} {\b TimeInMillis}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_string_} (death_test_style)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, const {\b Message} &sb)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > ::std::string {\b PrintToString} (const T &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, const {\b TestPartResult} &result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (also_run_disabled_tests)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (break_on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (catch_exceptions)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_string_} (color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_string_} (filter)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (list_tests)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_string_} (output)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (print_time)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_int32_} (random_seed)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_int32_} (repeat)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (show_internal_stack_frames)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (shuffle)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_int32_} (stack_trace_depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (throw_on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_string_} (stream_result_to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b AssertionSuccess} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b AssertionFailure} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b AssertionFailure} (const {\b Message} &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Environment} * {\b AddGlobalTestEnvironment} ({\b Environment} *env)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b InitGoogleTest} (int *argc, char **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b InitGoogleTest} (int *argc, wchar_t **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b IsSubstring} (const char *needle_expr, const char *haystack_expr, const char *needle, const char *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b IsSubstring} (const char *needle_expr, const char *haystack_expr, const wchar_t *needle, const wchar_t *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b IsNotSubstring} (const char *needle_expr, const char *haystack_expr, const char *needle, const char *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b IsNotSubstring} (const char *needle_expr, const char *haystack_expr, const wchar_t *needle, const wchar_t *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b IsSubstring} (const char *needle_expr, const char *haystack_expr, const ::std::string &needle, const ::std::string &haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b IsNotSubstring} (const char *needle_expr, const char *haystack_expr, const ::std::string &needle, const ::std::string &haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b FloatLE} (const char *expr1, const char *expr2, float val1, float val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b DoubleLE} (const char *expr1, const char *expr2, double val1, double val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > bool {\b StaticAssertTypeEq} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b TempDir} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_string_} (death_test_style, {\b internal::StringFromGTestEnv}("death_test_style", kDefaultDeathTestStyle), "Indicates how to run a death test in a forked child process: " "\\"threadsafe\\" (child process re-executes the test binary " "from the beginning, running only the specific death test) or " "\\"fast\\" (child process runs the death test immediately " "after forking).")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (death_test_use_fork, {\b internal::BoolFromGTestEnv}("death_test_use_fork", false), "Instructs to use fork()/_exit() instead of clone() in death tests. " "Ignored and always uses fork() on POSIX systems where clone() is not " "implemented. Useful when running under valgrind or similar tools if " "those do not support clone(). Valgrind 3.3.1 will just fail if " "it sees an unsupported combination of clone() flags. " "It is not recommended to use this flag w/o valgrind though it will " "work in 99% of the cases. Once valgrind is fixed, this flag will " "most likely be removed.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_bool_} (death_test_use_fork)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (also_run_disabled_tests, {\b internal::BoolFromGTestEnv}("also_run_disabled_tests", false), "Run disabled tests too, in addition to the tests normally being run.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (break_on_failure, {\b internal::BoolFromGTestEnv}("break_on_failure", false), "True iff a failed assertion should be a debugger break-point.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (catch_exceptions, {\b internal::BoolFromGTestEnv}("catch_exceptions", true), "True iff " GTEST_NAME_ " should catch exceptions and treat them as test failures.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_string_} (color, {\b internal::StringFromGTestEnv}("color", "auto"), "Whether to use colors in the output.  Valid values: yes, no, " "and auto.  'auto' means to use colors if the output is " "being sent to a terminal and the TERM environment variable " "is set to a terminal type that supports colors.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_string_} (filter, {\b internal::StringFromGTestEnv}("filter", GetDefaultFilter()), "A colon-separated list of glob (not regex) patterns " "for filtering the tests to run, optionally followed by a " "'-' and a : separated list of negative patterns (tests to " "exclude).  A test is run if it matches one of the positive " "patterns and does not match any of the negative patterns.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (list_tests, false, "List all tests without running them.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_string_} (output, {\b internal::StringFromGTestEnv}("output", ""), "A format (currently must be \\"xml\\"), optionally followed " "by a colon and an output file name or directory. A directory " "is indicated by a trailing pathname separator. " "Examples: \\"xml:filename.xml\\", \\"xml::directoryname/\\". " "If a directory is specified, output files will be created " "within that directory, with file-names based on the test " "executable's name and, if necessary, made unique by adding " "digits.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (print_time, {\b internal::BoolFromGTestEnv}("print_time", true), "True iff " GTEST_NAME_ " should display elapsed time in text output.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_int32_} (random_seed, {\b internal::Int32FromGTestEnv}("random_seed", 0), "Random number seed to use when shuffling test orders.  Must be in range " "[1, 99999], or 0 to use a seed based on the current time.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_int32_} (repeat, {\b internal::Int32FromGTestEnv}("repeat", 1), "How many times to repeat each test.  Specify a negative number " "for repeating forever.  Useful for shaking out flaky tests.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (show_internal_stack_frames, false, "True iff " GTEST_NAME_ " should include internal stack frames when " "printing test failure stack traces.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (shuffle, {\b internal::BoolFromGTestEnv}("shuffle", false), "True iff " GTEST_NAME_ " should randomize tests' order on every run.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_int32_} (stack_trace_depth, {\b internal::Int32FromGTestEnv}("stack_trace_depth", kMaxStackTraceDepth), "The maximum number of stack frames to print when an " "assertion fails.  The valid range is 0 through 100, inclusive.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_string_} (stream_result_to, {\b internal::StringFromGTestEnv}("stream_result_to", ""), "This flag specifies the host name and the port number on which to stream " "test results. Example: \\"localhost:555\\". The flag is effective only on " "Linux.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_bool_} (throw_on_failure, {\b internal::BoolFromGTestEnv}("throw_on_failure", false), "When this flag is specified, a failed assertion will throw an exception " "if exceptions are enabled or exit the program with a non-zero code " "otherwise.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<int kSize> std::vector< std::string > {\b ArrayAsVector} (const char *const (&array)[kSize])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ValidateTestPropertyName} (const std::string &property_name, const std::vector< std::string > &reserved_names)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b kMaxStackTraceDepth} = 100\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D2\'E8\'EF\'FB\par
\pard\plain 
{\xe \v TimeInMillis\:testing}
{\xe \v testing\:TimeInMillis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b internal::TimeInMillis} {\b testing::TimeInMillis}}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 480}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 
{\xe \v AddGlobalTestEnvironment\:testing}
{\xe \v testing\:AddGlobalTestEnvironment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Environment} * testing::AddGlobalTestEnvironment ({\b Environment} *  {\i env}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1350}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01350                                                                \{\par
01351   {\cf19 return} UnitTest::GetInstance()->AddEnvironment(env);\par
01352 \}\par
}
}
{\xe \v ArrayAsVector\:testing}
{\xe \v testing\:ArrayAsVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<int kSize> std::vector< std::string > testing::ArrayAsVector (const char *const (&)  {\i array}[kSize])}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2105}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02105                                                                       \{\par
02106   {\cf19 return} std::vector<std::string>(array, array + kSize);\par
02107 \}\par
}
}
{\xe \v AssertionFailure\:testing}
{\xe \v testing\:AssertionFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::AssertionFailure ()}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1012}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01012                                    \{\par
01013   {\cf19 return} AssertionResult({\cf17 false});\par
01014 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b AssertionFailure()}, {\b AssertPred1Helper()}, {\b AssertPred2Helper()}, {\b AssertPred3Helper()}, {\b AssertPred4Helper()}, {\b AssertPred5Helper()}, {\b testing::internal::CmpHelperOpFailure()}, {\b testing::internal::CmpHelperSTRCASENE()}, {\b testing::internal::CmpHelperSTRNE()}, {\b testing::internal::DoubleNearPredFormat()}, {\b testing::internal::EqFailure()}, {\b testing::internal::FloatingPointLE()} \'E8 {\b testing::internal::HasOneFailure()}.}\par
}
{\xe \v AssertionFailure\:testing}
{\xe \v testing\:AssertionFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::AssertionFailure (const {\b Message} &  {\i msg})}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1018}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01018                                                          \{\par
01019   {\cf19 return} AssertionFailure() << message;\par
01020 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b AssertionFailure()}.}\par
}
{\xe \v AssertionSuccess\:testing}
{\xe \v testing\:AssertionSuccess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::AssertionSuccess ()}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1007}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01007                                    \{\par
01008   {\cf19 return} AssertionResult({\cf17 true});\par
01009 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b AssertPred1Helper()}, {\b AssertPred2Helper()}, {\b AssertPred3Helper()}, {\b AssertPred4Helper()}, {\b AssertPred5Helper()}, {\b testing::internal::CmpHelperEQ()}, {\b testing::internal::CmpHelperFloatingPointEQ()}, {\b testing::internal::CmpHelperSTRCASEEQ()}, {\b testing::internal::CmpHelperSTRCASENE()}, {\b testing::internal::CmpHelperSTREQ()}, {\b testing::internal::CmpHelperSTRNE()}, {\b testing::internal::DoubleNearPredFormat()}, {\b testing::internal::FloatingPointLE()} \'E8 {\b testing::internal::HasOneFailure()}.}\par
}
{\xe \v DoubleLE\:testing}
{\xe \v testing\:DoubleLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::DoubleLE (const char *  {\i expr1}, const char *  {\i expr2}, double  {\i val1}, double  {\i val2})}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1425}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01426                                                    \{\par
01427   {\cf19 return} internal::FloatingPointLE<double>(expr1, expr2, val1, val2);\par
01428 \}\par
}
}
{\xe \v FloatLE\:testing}
{\xe \v testing\:FloatLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::FloatLE (const char *  {\i expr1}, const char *  {\i expr2}, float  {\i val1}, float  {\i val2})}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1418}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01419                                                 \{\par
01420   {\cf19 return} internal::FloatingPointLE<float>(expr1, expr2, val1, val2);\par
01421 \}\par
}
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (also_run_disabled_tests )}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (break_on_failure )}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (catch_exceptions )}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (death_test_use_fork )}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (list_tests )}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (print_time )}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (show_internal_stack_frames )}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (shuffle )}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_bool_\:testing}
{\xe \v testing\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_bool_ (throw_on_failure )}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_int32_\:testing}
{\xe \v testing\:GTEST_DECLARE_int32_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_int32_ (random_seed )}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_int32_\:testing}
{\xe \v testing\:GTEST_DECLARE_int32_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_int32_ (repeat )}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_int32_\:testing}
{\xe \v testing\:GTEST_DECLARE_int32_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_int32_ (stack_trace_depth )}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_string_\:testing}
{\xe \v testing\:GTEST_DECLARE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_string_ (color )}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_string_\:testing}
{\xe \v testing\:GTEST_DECLARE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_string_ (death_test_style )}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_string_\:testing}
{\xe \v testing\:GTEST_DECLARE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_string_ (filter )}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_string_\:testing}
{\xe \v testing\:GTEST_DECLARE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_string_ (output )}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_string_\:testing}
{\xe \v testing\:GTEST_DECLARE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DECLARE_string_ (stream_result_to )}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (also_run_disabled_tests , {\b internal::BoolFromGTestEnv}("also_run_disabled_tests", false) , "Run disabled tests  {\i too}, in addition to the tests normally being run." )}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (break_on_failure , {\b internal::BoolFromGTestEnv}("break_on_failure", false) , "True iff a failed assertion should be a debugger break-point." )}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (catch_exceptions , {\b internal::BoolFromGTestEnv}("catch_exceptions", true) , "True iff " GTEST_NAME_ " should catch exceptions and treat them as test failures." )}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (death_test_use_fork , {\b internal::BoolFromGTestEnv}("death_test_use_fork", false) , "Instructs to use fork()/_exit() instead of clone() in death tests. " "Ignored and always uses fork() on POSIX systems where clone() is not " "implemented. Useful when running under valgrind or similar tools if " "those do not support clone(). Valgrind 3.3.1 will just fail if " "it sees an unsupported combination of clone() flags. " "It is not recommended to use this flag w/o valgrind though it will " "work in 99% of the cases. Once valgrind is  {\i fixed}, this flag will " "most likely be removed." )}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (list_tests , false , "List all tests without running them." )}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (print_time , {\b internal::BoolFromGTestEnv}("print_time", true) , "True iff " GTEST_NAME_ " should display elapsed time in text output." )}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (show_internal_stack_frames , false , "True iff " GTEST_NAME_ " should include internal stack frames when " "printing test failure stack traces." )}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (shuffle , {\b internal::BoolFromGTestEnv}("shuffle", false) , "True iff " GTEST_NAME_ " should randomize tests' order on every run." )}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_bool_\:testing}
{\xe \v testing\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_bool_ (throw_on_failure , {\b internal::BoolFromGTestEnv}("throw_on_failure", false) , "When this flag is  {\i specified}, a failed assertion will throw an exception " "if exceptions are enabled or exit the program with a non-zero code " "otherwise." )}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_int32_\:testing}
{\xe \v testing\:GTEST_DEFINE_int32_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_int32_ (random_seed , {\b internal::Int32FromGTestEnv}("random_seed", 0) , "Random number seed to use when shuffling test orders. Must be in range " " [1, 99999], or 0 to use a seed based on the current time." )}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_int32_\:testing}
{\xe \v testing\:GTEST_DEFINE_int32_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_int32_ (repeat , {\b internal::Int32FromGTestEnv}("repeat", 1) , "How many times to repeat each test. Specify a negative number " "for repeating forever. Useful for shaking out flaky tests." )}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_int32_\:testing}
{\xe \v testing\:GTEST_DEFINE_int32_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_int32_ (stack_trace_depth , {\b internal::Int32FromGTestEnv}("stack_trace_depth", kMaxStackTraceDepth) , "The maximum number of stack frames to print when an " "assertion fails. The valid range is 0 through  {\i 100}, inclusive." )}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_string_\:testing}
{\xe \v testing\:GTEST_DEFINE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_string_ (color , {\b internal::StringFromGTestEnv}("color", "auto") , "Whether to use colors in the output. Valid values:  {\i yes}, no , " "and auto. 'auto' means to use colors if the output is " "being sent to a terminal and the TERM environment variable " "is set to a terminal type that supports colors." )}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_string_\:testing}
{\xe \v testing\:GTEST_DEFINE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_string_ (death_test_style , {\b internal::StringFromGTestEnv}("death_test_style", kDefaultDeathTestStyle) , "Indicates how to run a death test in a forked child process: " "\\"threadsafe\\" (child process re-executes the test binary " "from the beginning, running only the specific death test) or " "\\"fast\\" (child process runs the death test immediately " "after forking)." )}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_string_\:testing}
{\xe \v testing\:GTEST_DEFINE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_string_ (filter , {\b internal::StringFromGTestEnv}("filter", GetDefaultFilter()) , "A colon-separated list of glob (not regex) patterns " "for filtering the tests to  {\i run}, optionally followed by a " "'-' and a :separated list of negative patterns(tests to " "exclude). A test is run if it matches one of the positive " "patterns and does not match any of the negative patterns." )}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_string_\:testing}
{\xe \v testing\:GTEST_DEFINE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_string_ (output , {\b internal::StringFromGTestEnv}("output", "") , "A format  currently must be \\"xml\\", optionally followed " "by a colon and an output file name or directory. A directory " "is indicated by a trailing pathname separator. " "Examples:\\"xml:filename.xml\\" , \\"xml::directoryname/\\". " "If a directory is  {\i specified}, output files will be created " "within that  {\i directory}, with file-names based on the test " "executable 's name  {\i and}, if  {\i necessary}, made unique by adding " "digits." )}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_string_\:testing}
{\xe \v testing\:GTEST_DEFINE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::GTEST_DEFINE_string_ (stream_result_to , {\b internal::StringFromGTestEnv}("stream_result_to", "") , "This flag specifies the host name and the port number on which to stream " "test results. Example: \\"localhost:555\\". The flag is effective only on " "Linux." )}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v InitGoogleTest\:testing}
{\xe \v testing\:InitGoogleTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::InitGoogleTest (int *  {\i argc}, char **  {\i argv})}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 5369}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 05369                                             \{\par
05370 {\cf21 #if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
05371   GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);\par
05372 {\cf21 #else  }{\cf20 // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
05373   internal::InitGoogleTestImpl(argc, argv);\par
05374 {\cf21 #endif  }{\cf20 // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
05375 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::InitGoogleTestImpl()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b main()}.}\par
}
{\xe \v InitGoogleTest\:testing}
{\xe \v testing\:InitGoogleTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::InitGoogleTest (int *  {\i argc}, wchar_t **  {\i argv})}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 5379}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 05379                                                \{\par
05380 {\cf21 #if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
05381   GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);\par
05382 {\cf21 #else  }{\cf20 // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
05383   internal::InitGoogleTestImpl(argc, argv);\par
05384 {\cf21 #endif  }{\cf20 // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
05385 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::InitGoogleTestImpl()}.}\par
}
{\xe \v IsNotSubstring\:testing}
{\xe \v testing\:IsNotSubstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::IsNotSubstring (const char *  {\i needle_expr}, const char *  {\i haystack_expr}, const ::std::string &  {\i needle}, const ::std::string &  {\i haystack})}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1633}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01635                                                         \{\par
01636   {\cf19 return} IsSubstringImpl({\cf17 false}, needle_expr, haystack_expr, needle, haystack);\par
01637 \}\par
}
}
{\xe \v IsNotSubstring\:testing}
{\xe \v testing\:IsNotSubstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::IsNotSubstring (const char *  {\i needle_expr}, const char *  {\i haystack_expr}, const char *  {\i needle}, const char *  {\i haystack})}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1615}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01617                                               \{\par
01618   {\cf19 return} IsSubstringImpl({\cf17 false}, needle_expr, haystack_expr, needle, haystack);\par
01619 \}\par
}
}
{\xe \v IsNotSubstring\:testing}
{\xe \v testing\:IsNotSubstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::IsNotSubstring (const char *  {\i needle_expr}, const char *  {\i haystack_expr}, const wchar_t *  {\i needle}, const wchar_t *  {\i haystack})}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1621}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01623                                                     \{\par
01624   {\cf19 return} IsSubstringImpl({\cf17 false}, needle_expr, haystack_expr, needle, haystack);\par
01625 \}\par
}
}
{\xe \v IsSubstring\:testing}
{\xe \v testing\:IsSubstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::IsSubstring (const char *  {\i needle_expr}, const char *  {\i haystack_expr}, const ::std::string &  {\i needle}, const ::std::string &  {\i haystack})}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1627}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01629                                                         \{\par
01630   {\cf19 return} IsSubstringImpl({\cf17 true}, needle_expr, haystack_expr, needle, haystack);\par
01631 \}\par
}
}
{\xe \v IsSubstring\:testing}
{\xe \v testing\:IsSubstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::IsSubstring (const char *  {\i needle_expr}, const char *  {\i haystack_expr}, const char *  {\i needle}, const char *  {\i haystack})}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1603}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01605                                               \{\par
01606   {\cf19 return} IsSubstringImpl({\cf17 true}, needle_expr, haystack_expr, needle, haystack);\par
01607 \}\par
}
}
{\xe \v IsSubstring\:testing}
{\xe \v testing\:IsSubstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::IsSubstring (const char *  {\i needle_expr}, const char *  {\i haystack_expr}, const wchar_t *  {\i needle}, const wchar_t *  {\i haystack})}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1609}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01611                                                     \{\par
01612   {\cf19 return} IsSubstringImpl({\cf17 true}, needle_expr, haystack_expr, needle, haystack);\par
01613 \}\par
}
}
{\xe \v operator<<\:testing}
{\xe \v testing\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & testing::operator<< (std::ostream &  {\i os}, const {\b Message} &  {\i sb}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-message.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 232}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00232                                                                   \{\par
00233   {\cf19 return} os << sb.GetString();\par
00234 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::Message::GetString()}.}\par
}
{\xe \v operator<<\:testing}
{\xe \v testing\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & testing::operator<< (std::ostream &  {\i os}, const {\b TestPartResult} &  {\i result})}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 58}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00058                                                                      \{\par
00059   {\cf19 return} os\par
00060       << result.file_name() << {\cf22 ":"} << result.line_number() << {\cf22 ": "}\par
00061       << (result.type() == TestPartResult::kSuccess ? {\cf22 "Success"} :\par
00062           result.type() == TestPartResult::kFatalFailure ? {\cf22 "Fatal failure"} :\par
00063           {\cf22 "Non-fatal failure"}) << {\cf22 ":\\n"}\par
00064       << result.message() << std::endl;\par
00065 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestPartResult::file_name()}, {\b testing::TestPartResult::kFatalFailure}, {\b testing::TestPartResult::kSuccess}, {\b testing::TestPartResult::line_number()}, {\b testing::TestPartResult::message()} \'E8 {\b testing::TestPartResult::type()}.}\par
}
{\xe \v PrintToString\:testing}
{\xe \v testing\:PrintToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > ::std::string testing::PrintToString (const T &  {\i value})}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 993}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00993                                         \{\par
00994   ::std::stringstream ss;\par
00995   internal::UniversalTersePrinter<T>::Print(value, &ss);\par
00996   {\cf19 return} ss.str();\par
00997 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UniversalTersePrinter< T >::Print()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::CmpHelperSTRCASEEQ()}, {\b testing::internal::CmpHelperSTREQ()}, {\b testing::internal::CmpHelperSTRNE()} \'E8 {\b testing::internal::FormatForComparison< ToPrint, OtherOperand >::Format()}.}\par
}
{\xe \v StaticAssertTypeEq\:testing}
{\xe \v testing\:StaticAssertTypeEq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T1 , typename T2 > bool testing::StaticAssertTypeEq ()}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2150}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02150                           \{\par
02151   (void)internal::StaticAssertTypeEqHelper<T1, T2>();\par
02152   {\cf19 return} {\cf17 true};\par
02153 \}\par
}
}
{\xe \v TempDir\:testing}
{\xe \v testing\:TempDir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::TempDir ()}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 5387}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 05387                     \{\par
05388 {\cf21 #if defined(GTEST_CUSTOM_TEMPDIR_FUNCTION_)}\par
05389     {\cf19 return} GTEST_CUSTOM_TEMPDIR_FUNCTION_();\par
05390 {\cf21 #endif}\par
05391 {\cf21 #if GTEST_OS_WINDOWS_MOBILE}\par
05392   {\cf19 return} {\cf22 "\\\\temp\\\\"};\par
05393 {\cf21 #elif GTEST_OS_WINDOWS}\par
05394   {\cf17 const} {\cf18 char}* temp_dir = internal::posix::GetEnv({\cf22 "TEMP"});\par
05395   {\cf19 if} (temp_dir == NULL || temp_dir[0] == {\cf23 '\\0'})\par
05396     {\cf19 return} {\cf22 "\\\\temp\\\\"};\par
05397   {\cf19 else} {\cf19 if} (temp_dir[strlen(temp_dir) - 1] == {\cf23 '\\\\'})\par
05398     {\cf19 return} temp_dir;\par
05399   {\cf19 else}\par
05400     {\cf19 return} std::string(temp_dir) + {\cf22 "\\\\"};\par
05401 {\cf21 #elif GTEST_OS_LINUX_ANDROID}\par
05402   {\cf19 return} {\cf22 "/sdcard/"};\par
05403 {\cf21 #else}\par
05404   {\cf19 return} {\cf22 "/tmp/"};\par
05405 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
05406 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::posix::GetEnv()}.}\par
}
{\xe \v ValidateTestPropertyName\:testing}
{\xe \v testing\:ValidateTestPropertyName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::ValidateTestPropertyName (const std::string &  {\i property_name}, const std::vector< std::string > &  {\i reserved_names})}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2138}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02139                                                                           \{\par
02140   {\cf19 if} (std::find(reserved_names.begin(), reserved_names.end(), property_name) !=\par
02141           reserved_names.end()) \{\par
02142     ADD_FAILURE() << {\cf22 "Reserved key used in RecordProperty(): "} << property_name\par
02143                   << {\cf22 " ("} << FormatWordList(reserved_names)\par
02144                   << {\cf22 " are reserved by "} << GTEST_NAME_ << {\cf22 ")"};\par
02145     {\cf19 return} {\cf17 false};\par
02146   \}\par
02147   {\cf19 return} {\cf17 true};\par
02148 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ADD_FAILURE} \'E8 {\b GTEST_NAME_}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 
{\xe \v kMaxStackTraceDepth\:testing}
{\xe \v testing\:kMaxStackTraceDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int testing::kMaxStackTraceDepth = 100}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 147}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'EE \'E8\'EC\'E5\'ED testing::internal\par \pard\plain 
{\tc\tcl2 \v testing::internal}
{\xe \v testing::internal}
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b edit_distance}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b posix}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b AddReference}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b AddReference< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AssertHelper}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b bool_constant}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CodeLocation}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CompileAssert}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CompileAssertTypesEqual}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CompileAssertTypesEqual< T, T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ConstCharPtr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DefaultGlobalTestPartResultReporter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DefaultPerThreadTestPartResultReporter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b EnableIf}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b EnableIf< true >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EqHelper}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EqHelper< true >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FilePath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FloatingPoint}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FormatForComparison}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FormatForComparison< ToPrint[N], OtherOperand >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GTestFlagSaver}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GTestLog}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GTestMutexLock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b HasNewFatalFailureHelper}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ImplicitlyConvertible}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_pointer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_pointer< T * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IsAProtocolMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IteratorTraits}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IteratorTraits< const T * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IteratorTraits< T * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b linked_ptr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b linked_ptr_internal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Mutex}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NativeArray}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b OsStackTraceGetter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b OsStackTraceGetterInterface}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PrettyUnitTestResultPrinter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Random}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b RelationToSourceCopy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b RelationToSourceReference}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b RemoveConst}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b RemoveConst< const T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b RemoveConst< const T[N]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b RemoveReference}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b RemoveReference< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b scoped_ptr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ScopedPrematureExitFile}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ScopedTrace}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SingleFailureChecker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StaticAssertTypeEqHelper}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StaticAssertTypeEqHelper< T, T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b String}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestCaseNameIs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestEventRepeater}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestFactoryBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestFactoryImpl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestPropertyKeyIs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestResultAccessor}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ThreadLocal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TraceInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TuplePolicy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TypeIdHelper}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TypeWithSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TypeWithSize< 4 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TypeWithSize< 8 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UnitTestImpl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UnitTestOptions}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UniversalPrinter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UniversalPrinter< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UniversalPrinter< T[N]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UniversalTersePrinter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UniversalTersePrinter< char * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UniversalTersePrinter< const char * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UniversalTersePrinter< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UniversalTersePrinter< T[N]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UniversalTersePrinter< wchar_t * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b WrapPrinterType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XmlUnitTestResultPrinter}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef ::std::vector< {\b string} > {\b Strings}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b FloatingPoint}< float > {\b Float}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b FloatingPoint}< double > {\b Double}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef const void * {\b TypeId}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b SetUpTestCaseFunc}) ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b TearDownTestCaseFunc}) ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef int {\b IsContainer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef char {\b IsNotContainer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef ::std::string {\b string}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef ::std::wstring {\b wstring}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GTestMutexLock} {\b MutexLock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b bool_constant}< false > {\b false_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b bool_constant}< true > {\b true_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef long long {\b BiggestInt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b TypeWithSize}< 4 >::Int {\b Int32}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b TypeWithSize}< 4 >::UInt {\b UInt32}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b TypeWithSize}< 8 >::Int {\b Int64}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b TypeWithSize}< 8 >::UInt {\b UInt64}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b TypeWithSize}< 8 >::Int {\b TimeInMillis}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b DefaultPrinterType} \{ {\b kPrintContainer}
, {\b kPrintPointer}
, {\b kPrintFunctionPointer}
, {\b kPrintOther}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b GTestLogSeverity} \{ {\b GTEST_INFO}
, {\b GTEST_WARNING}
, {\b GTEST_ERROR}
, {\b GTEST_FATAL}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b CharFormat} \{ {\b kAsIs}
, {\b kHexEscape}
, {\b kSpecialEscape}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b GTestColor} \{ {\b COLOR_DEFAULT}
, {\b COLOR_RED}
, {\b COLOR_GREEN}
, {\b COLOR_YELLOW}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::string {\b StreamableToString} (const T &streamable)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_} (wchar_t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_FORMAT_C_STRING_AS_STRING_} (char, ::std::string)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > std::string {\b FormatForComparisonFailureMessage} (const T1 &value, const T2 &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b UniversalPrint} (const T &value, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C > void {\b DefaultPrintTo} ({\b WrapPrinterType}< {\b kPrintContainer} >, const C &container, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b DefaultPrintTo} ({\b WrapPrinterType}< {\b kPrintPointer} >, T *p, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b DefaultPrintTo} ({\b WrapPrinterType}< {\b kPrintFunctionPointer} >, T *p, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b DefaultPrintTo} ({\b WrapPrinterType}< {\b kPrintOther} >, const T &value, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b PrintTo} (const T &value, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b PrintTo} (unsigned char c, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b PrintTo} (signed char c, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (char c, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (bool x, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b PrintTo} (wchar_t wc, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b PrintTo} (const char *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (char *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (const signed char *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (signed char *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (const unsigned char *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (unsigned char *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b PrintTo} (const wchar_t *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (wchar_t *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b PrintRawArrayTo} (const T a[], size_t count, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b PrintStringTo} (const ::std::string &s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (const ::std::string &s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > void {\b PrintTo} (const ::std::pair< T1, T2 > &value, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b UniversalPrintArray} (const T *begin, size_t len, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b UniversalPrintArray} (const char *begin, size_t len, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b UniversalPrintArray} (const wchar_t *begin, size_t len, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b UniversalTersePrint} (const T &value, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UnitTestImpl} * {\b GetUnitTestImpl} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ReportFailureInUnknownLocation} ({\b TestPartResult::Type} result_type, const std::string &message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > {\b AssertionResult} {\b CmpHelperEQFailure} (const char *lhs_expression, const char *rhs_expression, const T1 &lhs, const T2 &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > {\b AssertionResult} {\b CmpHelperEQ} (const char *lhs_expression, const char *rhs_expression, const T1 &lhs, const T2 &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b CmpHelperEQ} (const char *lhs_expression, const char *rhs_expression, {\b BiggestInt} lhs, {\b BiggestInt} rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > {\b AssertionResult} {\b CmpHelperOpFailure} (const char *expr1, const char *expr2, const T1 &val1, const T2 &val2, const char *op)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_CMP_HELPER_} (NE, !=)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_CMP_HELPER_} (LE,<=)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_CMP_HELPER_} (LT,<)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_CMP_HELPER_} (GE, >=)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_IMPL_CMP_HELPER_} (GT, >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b CmpHelperSTREQ} (const char *s1_expression, const char *s2_expression, const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b CmpHelperSTRCASEEQ} (const char *s1_expression, const char *s2_expression, const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b CmpHelperSTRNE} (const char *s1_expression, const char *s2_expression, const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b CmpHelperSTRCASENE} (const char *s1_expression, const char *s2_expression, const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b CmpHelperSTREQ} (const char *s1_expression, const char *s2_expression, const wchar_t *s1, const wchar_t *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b CmpHelperSTRNE} (const char *s1_expression, const char *s2_expression, const wchar_t *s1, const wchar_t *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename RawType > {\b AssertionResult} {\b CmpHelperFloatingPointEQ} (const char *lhs_expression, const char *rhs_expression, RawType lhs_value, RawType rhs_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b DoubleNearPredFormat} (const char *expr1, const char *expr2, const char *abs_error_expr, double val1, double val2, double abs_error)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DECLARE_string_} (internal_run_death_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b IsNullLiteralHelper} (Secret *p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char(& {\b IsNullLiteralHelper} (...))[2]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b AppendUserMessage} (const std::string &gtest_msg, const {\b Message} &user_msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b DiffStrings} (const std::string &left, const std::string &right, size_t *total_line_count)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b AssertionResult} {\b EqFailure} (const char *expected_expression, const char *actual_expression, const std::string &expected_value, const std::string &actual_value, bool ignoring_case)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b GetBoolAssertionFailureMessage} (const {\b AssertionResult} &assertion_result, const char *expression_text, const char *actual_predicate_value, const char *expected_predicate_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b TypeId} {\b GetTypeId} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b TypeId} {\b GetTestTypeId} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b TestInfo} * {\b MakeAndRegisterTestInfo} (const char *test_case_name, const char *name, const char *type_param, const char *value_param, {\b CodeLocation} code_location, {\b TypeId} fixture_class_id, {\b SetUpTestCaseFunc} set_up_tc, {\b TearDownTestCaseFunc} tear_down_tc, {\b TestFactoryBase} *factory)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b SkipPrefix} (const char *prefix, const char **pstr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b GetCurrentOsStackTraceExceptTop} ({\b UnitTest} *unit_test, int skip_count)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b AlwaysTrue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b AlwaysFalse} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class C > {\b IsContainer} {\b IsContainerTest} (int, typename C::iterator *=NULL, typename C::const_iterator *=NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class C > {\b IsNotContainer} {\b IsContainerTest} (long)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U > bool {\b ArrayEq} (const T *lhs, size_t size, const U *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U > bool {\b ArrayEq} (const T &lhs, const U &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U , size_t N> bool {\b ArrayEq} (const T(&lhs)[N], const U(&rhs)[N])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Iter , typename Element > Iter {\b ArrayAwareFind} (Iter begin, Iter end, const Element &elem)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U > void {\b CopyArray} (const T *from, size_t size, U *to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U > void {\b CopyArray} (const T &from, U *to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U , size_t N> void {\b CopyArray} (const T(&from)[N], U(*to)[N])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b GTEST_DECLARE_STATIC_MUTEX_} (g_linked_ptr_mutex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > bool {\b operator==} (T *ptr, const {\b linked_ptr}< T > &x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > bool {\b operator!=} (T *ptr, const {\b linked_ptr}< T > &x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b linked_ptr}< T > {\b make_linked_ptr} (T *ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b IsTrue} (bool condition)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GTEST_API_::std::string {\b FormatFileLocation} (const char *file, int line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GTEST_API_::std::string {\b FormatCompilerIndependentFileLocation} (const char *file, int line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b LogToStderr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b FlushInfoLog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > const T & {\b move} (const T &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename To > To {\b ImplicitCast_} (To x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename To , typename From > To {\b DownCast_} (From *f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Derived , class Base > Derived * {\b CheckedDowncastToActualType} (Base *base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b CaptureStdout} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b GetCapturedStdout} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b CaptureStderr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b GetCapturedStderr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} size_t {\b GetFileSize} (FILE *file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b ReadEntireFile} (FILE *file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} const ::std::vector< {\b testing::internal::string} > & {\b GetArgvs} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} size_t {\b GetThreadCount} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsAlpha} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsAlNum} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsDigit} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsLower} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsSpace} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsUpper} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsXDigit} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsXDigit} (wchar_t ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b ToLower} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b ToUpper} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b StripTrailingSpaces} (std::string str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ParseInt32} (const {\b Message} &src_text, const char *str, {\b Int32} *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b BoolFromGTestEnv} (const char *flag, bool default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b Int32} {\b Int32FromGTestEnv} (const char *flag, {\b Int32} default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b StringFromGTestEnv} (const char *flag, const char *default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b StringStreamToString} (::std::stringstream *stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::string {\b GetTypeName} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_DEFINE_string_} (internal_run_death_test, "", "Indicates the file, line number, temporal index of " "the single death test to run, and a file descriptor to " "which a success code may be sent, all separated by " "the '|' characters.  This flag is specified if and only if the current " "process is a sub-process launched for running a thread-safe " "death test.  FOR INTERNAL USE ONLY.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b TimeInMillis} {\b GetTimeInMillis} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b ShouldUseColor} (bool stdout_is_tty)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b FormatTimeInMillisAsSeconds} ({\b TimeInMillis} ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b FormatEpochTimeInMillisAsIso8601} ({\b TimeInMillis} ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b ParseInt32Flag} (const char *str, const char *flag, {\b Int32} *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetRandomSeedFromFlag} ({\b Int32} random_seed_flag)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetNextRandomSeed} (int seed)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b CodePointToUtf8} ({\b UInt32} code_point)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b WideStringToUtf8} (const wchar_t *str, int num_chars)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b WriteToShardStatusFileIfNeeded} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b ShouldShard} (const char *total_shards_str, const char *shard_index_str, bool in_subprocess_for_death_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b Int32} {\b Int32FromEnvOrDie} (const char *env_var, {\b Int32} default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b ShouldRunTestOnShard} (int total_shards, int shard_index, int test_id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Container , typename Predicate > int {\b CountIf} (const Container &c, Predicate predicate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Container , typename Functor > void {\b ForEach} (const Container &c, Functor functor)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename E > E {\b GetElementOr} (const std::vector< E > &v, int i, E default_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename E > void {\b ShuffleRange} ({\b internal::Random} *random, int begin, int end, std::vector< E > *v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename E > void {\b Shuffle} ({\b internal::Random} *random, std::vector< E > *v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b FilePath} {\b GetCurrentExecutableName} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b ParseGoogleTestFlagsOnly} (int *argc, char **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b ParseGoogleTestFlagsOnly} (int *argc, wchar_t **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsPrintableAscii} (wchar_t c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UnsignedChar , typename Char > void {\b PrintCharAndCodeTo} (Char c, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (wchar_t wc, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UniversalPrintArray} (const char *begin, size_t len, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UniversalPrintArray} (const wchar_t *begin, size_t len, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (const char *s, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTo} (const wchar_t *s, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintStringTo} (const ::std::string &s, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b GTEST_DEFINE_STATIC_MUTEX_} (g_linked_ptr_mutex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b HasOneFailure} (const char *, const char *, const char *, const {\b TestPartResultArray} &results, {\b TestPartResult::Type} type, const std::string &substr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SplitString} (const ::std::string &str, char delimiter, ::std::vector< ::std::string > *dest)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename RawType > {\b AssertionResult} {\b FloatingPointLE} (const char *expr1, const char *expr2, RawType val1, RawType val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt32} {\b ChopLowBits} ({\b UInt32} *bits, int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsUtf16SurrogatePair} (wchar_t first, wchar_t second)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt32} {\b CreateCodePointFromUtf16SurrogatePair} (wchar_t first, wchar_t second)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T , typename Result > Result {\b HandleSehExceptionsInMethodIfSupported} (T *object, Result(T::*method)(), const char *location)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T , typename Result > Result {\b HandleExceptionsInMethodIfSupported} (T *object, Result(T::*method)(), const char *location)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b GetAnsiColorCode} ({\b GTestColor} color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ColoredPrintf} ({\b GTestColor} color, const char *fmt,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintFullTestCommentIfPresent} (const {\b TestInfo} &test_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b ParseFlagValue} (const char *str, const char *flag, bool def_optional)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ParseBoolFlag} (const char *str, const char *flag, bool *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ParseStringFlag} (const char *str, const char *flag, std::string *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ParseGoogleTestFlag} (const char *const arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CharType > void {\b ParseGoogleTestFlagsOnlyImpl} (int *argc, CharType **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CharType > void {\b InitGoogleTestImpl} (int *argc, CharType **argv)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kDeathTestStyleFlag} [] = "death_test_style"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kDeathTestUseFork} [] = "death_test_use_fork"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kInternalRunDeathTestFlag} [] = "internal_run_death_test"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} const char {\b kStackTraceMarker} [] = "\\nStack trace:\\n"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GTEST_API_} {\b testing::internal::ScopedTrace} {\b GTEST_ATTRIBUTE_UNUSED_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b BiggestInt} {\b kMaxBiggestInt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kPathSeparator} = '/'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kCurrentDirectoryString} [] = "./"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} const {\b TypeId} {\b kTestTypeIdInGoogleTest} = {\b GetTestTypeId}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kAlsoRunDisabledTestsFlag} [] = "also_run_disabled_tests"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kBreakOnFailureFlag} [] = "break_on_failure"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kCatchExceptionsFlag} [] = "catch_exceptions"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kColorFlag} [] = "color"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kFilterFlag} [] = "filter"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kListTestsFlag} [] = "list_tests"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kOutputFlag} [] = "output"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kPrintTimeFlag} [] = "print_time"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kRandomSeedFlag} [] = "random_seed"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kRepeatFlag} [] = "repeat"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kShuffleFlag} [] = "shuffle"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kStackTraceDepthFlag} [] = "stack_trace_depth"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kStreamResultToFlag} [] = "stream_result_to"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kThrowOnFailureFlag} [] = "throw_on_failure"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kFlagfileFlag} [] = "flagfile"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b kMaxRandomSeed} = 99999\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b g_help_flag} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b kStdOutFileno} = STDOUT_FILENO\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b kStdErrFileno} = STDERR_FILENO\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b kUnknownFile} [] = "unknown file"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
::std::vector< {\b testing::internal::string} > {\b g_argvs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UInt32} {\b kMaxCodePoint1} = (static_cast<{\b UInt32}>(1) << 7) - 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UInt32} {\b kMaxCodePoint2} = (static_cast<{\b UInt32}>(1) << (5 + 6)) - 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UInt32} {\b kMaxCodePoint3} = (static_cast<{\b UInt32}>(1) << (4 + 2*6)) - 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UInt32} {\b kMaxCodePoint4} = (static_cast<{\b UInt32}>(1) << (3 + 3*6)) - 1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D2\'E8\'EF\'FB\par
\pard\plain 
{\xe \v BiggestInt\:testing::internal}
{\xe \v testing::internal\:BiggestInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef long long {\b testing::internal::BiggestInt}}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2273}}\par
}
{\xe \v Double\:testing::internal}
{\xe \v testing::internal\:Double}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b FloatingPoint}<double> {\b testing::internal::Double}}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 421}}\par
}
{\xe \v false_type\:testing::internal}
{\xe \v testing::internal\:false_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b bool_constant}<false> {\b testing::internal::false_type}}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2241}}\par
}
{\xe \v Float\:testing::internal}
{\xe \v testing::internal\:Float}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b FloatingPoint}<float> {\b testing::internal::Float}}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 420}}\par
}
{\xe \v Int32\:testing::internal}
{\xe \v testing::internal\:Int32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b TypeWithSize}<4>::Int {\b testing::internal::Int32}}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2526}}\par
}
{\xe \v Int64\:testing::internal}
{\xe \v testing::internal\:Int64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b TypeWithSize}<8>::Int {\b testing::internal::Int64}}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2528}}\par
}
{\xe \v IsContainer\:testing::internal}
{\xe \v testing::internal\:IsContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef int {\b testing::internal::IsContainer}}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 931}}\par
}
{\xe \v IsNotContainer\:testing::internal}
{\xe \v testing::internal\:IsNotContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef char {\b testing::internal::IsNotContainer}}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 939}}\par
}
{\xe \v MutexLock\:testing::internal}
{\xe \v testing::internal\:MutexLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GTestMutexLock} {\b testing::internal::MutexLock}}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2191}}\par
}
{\xe \v SetUpTestCaseFunc\:testing::internal}
{\xe \v testing::internal\:SetUpTestCaseFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* testing::internal::SetUpTestCaseFunc) ()}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 501}}\par
}
{\xe \v string\:testing::internal}
{\xe \v testing::internal\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef ::std::string {\b testing::internal::string}}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1132}}\par
}
{\xe \v Strings\:testing::internal}
{\xe \v testing::internal\:Strings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef ::std::vector<{\b string}> {\b testing::internal::Strings}}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 872}}\par
}
{\xe \v TearDownTestCaseFunc\:testing::internal}
{\xe \v testing::internal\:TearDownTestCaseFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* testing::internal::TearDownTestCaseFunc) ()}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 502}}\par
}
{\xe \v TimeInMillis\:testing::internal}
{\xe \v testing::internal\:TimeInMillis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b TypeWithSize}<8>::Int {\b testing::internal::TimeInMillis}}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2530}}\par
}
{\xe \v true_type\:testing::internal}
{\xe \v testing::internal\:true_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b bool_constant}<true> {\b testing::internal::true_type}}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2242}}\par
}
{\xe \v TypeId\:testing::internal}
{\xe \v testing::internal\:TypeId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef const void* {\b testing::internal::TypeId}}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 429}}\par
}
{\xe \v UInt32\:testing::internal}
{\xe \v testing::internal\:UInt32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b TypeWithSize}<4>::UInt {\b testing::internal::UInt32}}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2527}}\par
}
{\xe \v UInt64\:testing::internal}
{\xe \v testing::internal\:UInt64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b TypeWithSize}<8>::UInt {\b testing::internal::UInt64}}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2529}}\par
}
{\xe \v wstring\:testing::internal}
{\xe \v testing::internal\:wstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef ::std::wstring {\b testing::internal::wstring}}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1138}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 
{\xe \v CharFormat\:testing::internal}
{\xe \v testing::internal\:CharFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b testing::internal::CharFormat}}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'DD\'EB\'E5\'EC\'E5\'ED\'F2\'FB \'EF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'E9:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v kAsIs\:testing::internal}
{\xe \v testing::internal\:kAsIs}
{\qr kAsIs{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
\cell }{\cell }{\row }
{\xe \v kHexEscape\:testing::internal}
{\xe \v testing::internal\:kHexEscape}
{\qr kHexEscape{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
\cell }{\cell }{\row }
{\xe \v kSpecialEscape\:testing::internal}
{\xe \v testing::internal\:kSpecialEscape}
{\qr kSpecialEscape{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
\cell }{\cell }{\row }
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 128}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00128                 \{\par
00129   kAsIs,\par
00130   kHexEscape,\par
00131   kSpecialEscape\par
00132 \};\par
}
}
{\xe \v DefaultPrinterType\:testing::internal}
{\xe \v testing::internal\:DefaultPrinterType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b testing::internal::DefaultPrinterType}}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'DD\'EB\'E5\'EC\'E5\'ED\'F2\'FB \'EF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'E9:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v kPrintContainer\:testing::internal}
{\xe \v testing::internal\:kPrintContainer}
{\qr kPrintContainer{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
\cell }{\cell }{\row }
{\xe \v kPrintPointer\:testing::internal}
{\xe \v testing::internal\:kPrintPointer}
{\qr kPrintPointer{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
\cell }{\cell }{\row }
{\xe \v kPrintFunctionPointer\:testing::internal}
{\xe \v testing::internal\:kPrintFunctionPointer}
{\qr kPrintFunctionPointer{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
\cell }{\cell }{\row }
{\xe \v kPrintOther\:testing::internal}
{\xe \v testing::internal\:kPrintOther}
{\qr kPrintOther{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
\cell }{\cell }{\row }
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 367}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00367                         \{\par
00368   kPrintContainer,\par
00369   kPrintPointer,\par
00370   kPrintFunctionPointer,\par
00371   kPrintOther,\par
00372 \};\par
}
}
{\xe \v GTestColor\:testing::internal}
{\xe \v testing::internal\:GTestColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b testing::internal::GTestColor}}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'DD\'EB\'E5\'EC\'E5\'ED\'F2\'FB \'EF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'E9:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v COLOR_DEFAULT\:testing::internal}
{\xe \v testing::internal\:COLOR_DEFAULT}
{\qr COLOR_DEFAULT{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
\cell }{\cell }{\row }
{\xe \v COLOR_RED\:testing::internal}
{\xe \v testing::internal\:COLOR_RED}
{\qr COLOR_RED{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
\cell }{\cell }{\row }
{\xe \v COLOR_GREEN\:testing::internal}
{\xe \v testing::internal\:COLOR_GREEN}
{\qr COLOR_GREEN{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
\cell }{\cell }{\row }
{\xe \v COLOR_YELLOW\:testing::internal}
{\xe \v testing::internal\:COLOR_YELLOW}
{\qr COLOR_YELLOW{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
\cell }{\cell }{\row }
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2877}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02877                 \{\par
02878   COLOR_DEFAULT,\par
02879   COLOR_RED,\par
02880   COLOR_GREEN,\par
02881   COLOR_YELLOW\par
02882 \};\par
}
}
{\xe \v GTestLogSeverity\:testing::internal}
{\xe \v testing::internal\:GTestLogSeverity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b testing::internal::GTestLogSeverity}}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'DD\'EB\'E5\'EC\'E5\'ED\'F2\'FB \'EF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'E9:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v GTEST_INFO\:testing::internal}
{\xe \v testing::internal\:GTEST_INFO}
{\qr GTEST_INFO{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
\cell }{\cell }{\row }
{\xe \v GTEST_WARNING\:testing::internal}
{\xe \v testing::internal\:GTEST_WARNING}
{\qr GTEST_WARNING{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
\cell }{\cell }{\row }
{\xe \v GTEST_ERROR\:testing::internal}
{\xe \v testing::internal\:GTEST_ERROR}
{\qr GTEST_ERROR{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
\cell }{\cell }{\row }
{\xe \v GTEST_FATAL\:testing::internal}
{\xe \v testing::internal\:GTEST_FATAL}
{\qr GTEST_FATAL{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
\cell }{\cell }{\row }
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1279}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01279                       \{\par
01280   GTEST_INFO,\par
01281   GTEST_WARNING,\par
01282   GTEST_ERROR,\par
01283   GTEST_FATAL\par
01284 \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 
{\xe \v AlwaysFalse\:testing::internal}
{\xe \v testing::internal\:AlwaysFalse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::AlwaysFalse (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 737}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00737 \{ {\cf19 return} !AlwaysTrue(); \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b AlwaysTrue()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ColoredPrintf()}.}\par
}
{\xe \v AlwaysTrue\:testing::internal}
{\xe \v testing::internal\:AlwaysTrue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::AlwaysTrue ()}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4987}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04987                   \{\par
04988 {\cf21 #if GTEST_HAS_EXCEPTIONS}\par
04989   {\cf20 // This condition is always false so AlwaysTrue() never actually throws,}\par
04990   {\cf20 // but it makes the compiler think that it may throw.}\par
04991   {\cf19 if} (IsTrue({\cf17 false}))\par
04992     {\cf19 throw} ClassUniqueToAlwaysTrue();\par
04993 {\cf21 #endif  }{\cf20 // GTEST_HAS_EXCEPTIONS}\par
04994   {\cf19 return} {\cf17 true};\par
04995 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b IsTrue()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b AlwaysFalse()} \'E8 {\b SplitString()}.}\par
}
{\xe \v AppendUserMessage\:testing::internal}
{\xe \v testing::internal\:AppendUserMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::AppendUserMessage (const std::string &  {\i gtest_msg}, const {\b Message} &  {\i user_msg})}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1998}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01999                                                        \{\par
02000   {\cf20 // Appends the user message if it's non-empty.}\par
02001   {\cf17 const} std::string user_msg_string = user_msg.GetString();\par
02002   {\cf19 if} (user_msg_string.empty()) \{\par
02003     {\cf19 return} gtest_msg;\par
02004   \}\par
02005 \par
02006   {\cf19 return} gtest_msg + {\cf22 "\\n"} + user_msg_string;\par
02007 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::Message::GetString()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::AssertHelper::operator=()}.}\par
}
{\xe \v ArrayAwareFind\:testing::internal}
{\xe \v testing::internal\:ArrayAwareFind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Iter , typename Element > Iter testing::internal::ArrayAwareFind (Iter  {\i begin}, Iter  {\i end}, const Element &  {\i elem})}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 984}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00984                                                                \{\par
00985   {\cf19 for} (Iter it = begin; it != end; ++it) \{\par
00986     {\cf19 if} (internal::ArrayEq(*it, elem))\par
00987       {\cf19 return} it;\par
00988   \}\par
00989   {\cf19 return} end;\par
00990 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ArrayEq()}.}\par
}
{\xe \v ArrayEq\:testing::internal}
{\xe \v testing::internal\:ArrayEq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U > bool testing::internal::ArrayEq (const T &  {\i lhs}, const U &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 961}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00961 \{ {\cf19 return} lhs == rhs; \}\par
}
}
{\xe \v ArrayEq\:testing::internal}
{\xe \v testing::internal\:ArrayEq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U > bool testing::internal::ArrayEq (const T *  {\i lhs}, size_t  {\i size}, const U *  {\i rhs})}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 973}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00973                                                       \{\par
00974   {\cf19 for} ({\cf18 size_t} i = 0; i != size; i++) \{\par
00975     {\cf19 if} (!internal::ArrayEq(lhs[i], rhs[i]))\par
00976       {\cf19 return} {\cf17 false};\par
00977   \}\par
00978   {\cf19 return} {\cf17 true};\par
00979 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ArrayEq()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ArrayAwareFind()}, {\b ArrayEq()} \'E8 {\b testing::internal::NativeArray< Element >::operator==()}.}\par
}
{\xe \v ArrayEq\:testing::internal}
{\xe \v testing::internal\:ArrayEq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U , size_t N> bool testing::internal::ArrayEq (const T(&)  {\i lhs}[N], const U(&)  {\i rhs}[N]){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 965}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00965                                                         \{\par
00966   {\cf19 return} internal::ArrayEq(lhs, N, rhs);\par
00967 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ArrayEq()}.}\par
}
{\xe \v BoolFromGTestEnv\:testing::internal}
{\xe \v testing::internal\:BoolFromGTestEnv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::BoolFromGTestEnv (const char *  {\i flag}, bool  {\i default_val})}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1173}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01173                                                             \{\par
01174 {\cf21 #if defined(GTEST_GET_BOOL_FROM_ENV_)}\par
01175   {\cf19 return} GTEST_GET_BOOL_FROM_ENV_(flag, default_value);\par
01176 {\cf21 #endif  }{\cf20 // defined(GTEST_GET_BOOL_FROM_ENV_)}\par
01177   {\cf17 const} std::string env_var = FlagToEnvVar(flag);\par
01178   {\cf17 const} {\cf18 char}* {\cf17 const} string_value = posix::GetEnv(env_var.c_str());\par
01179   {\cf19 return} string_value == NULL ?\par
01180       default_value : strcmp(string_value, {\cf22 "0"}) != 0;\par
01181 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::posix::GetEnv()}.}\par
}
{\xe \v CaptureStderr\:testing::internal}
{\xe \v testing::internal\:CaptureStderr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::CaptureStderr ()}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CaptureStdout\:testing::internal}
{\xe \v testing::internal\:CaptureStdout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::CaptureStdout ()}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CheckedDowncastToActualType\:testing::internal}
{\xe \v testing::internal\:CheckedDowncastToActualType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Derived , class Base > Derived * testing::internal::CheckedDowncastToActualType (Base *  {\i base})}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1427}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01427                                                  \{\par
01428 {\cf21 #if GTEST_HAS_RTTI}\par
01429   GTEST_CHECK_({\cf17 typeid}(*base) == {\cf17 typeid}(Derived));\par
01430 {\cf21 #endif}\par
01431 \par
01432 {\cf21 #if GTEST_HAS_DOWNCAST_}\par
01433   return ::down_cast<Derived*>(base);\par
01434 {\cf21 #elif GTEST_HAS_RTTI}\par
01435   {\cf19 return} {\cf17 dynamic_cast<}Derived*{\cf17 >}(base);  {\cf20 // NOLINT}\par
01436 {\cf21 #else}\par
01437   {\cf19 return} {\cf17 static_cast<}Derived*{\cf17 >}(base);  {\cf20 // Poor man's downcast.}\par
01438 {\cf21 #endif}\par
01439 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GTEST_CHECK_}.}\par
}
{\xe \v ChopLowBits\:testing::internal}
{\xe \v testing::internal\:ChopLowBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt32} testing::internal::ChopLowBits ({\b UInt32} *  {\i bits}, int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1744}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01744                                                \{\par
01745   {\cf17 const} UInt32 low_bits = *bits & (({\cf17 static_cast<}UInt32{\cf17 >}(1) << n) - 1);\par
01746   *bits >>= n;\par
01747   {\cf19 return} low_bits;\par
01748 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CodePointToUtf8()}.}\par
}
{\xe \v CmpHelperEQ\:testing::internal}
{\xe \v testing::internal\:CmpHelperEQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::internal::CmpHelperEQ (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, {\b BiggestInt}  {\i lhs}, {\b BiggestInt}  {\i rhs})}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1434}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01437                                             \{\par
01438   {\cf19 if} (lhs == rhs) \{\par
01439     {\cf19 return} AssertionSuccess();\par
01440   \}\par
01441 \par
01442   {\cf19 return} EqFailure(lhs_expression,\par
01443                    rhs_expression,\par
01444                    FormatForComparisonFailureMessage(lhs, rhs),\par
01445                    FormatForComparisonFailureMessage(rhs, lhs),\par
01446                    {\cf17 false});\par
01447 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionSuccess()}, {\b EqFailure()} \'E8 {\b FormatForComparisonFailureMessage()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::EqHelper< lhs_is_null_literal >::Compare()} \'E8 {\b testing::internal::EqHelper< true >::Compare()}.}\par
}
{\xe \v CmpHelperEQ\:testing::internal}
{\xe \v testing::internal\:CmpHelperEQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T1 , typename T2 > {\b AssertionResult} testing::internal::CmpHelperEQ (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, const T1 &  {\i lhs}, const T2 &  {\i rhs})}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1387}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01390                                            \{\par
01391 GTEST_DISABLE_MSC_WARNINGS_PUSH_(4389 {\cf20 /* signed/unsigned mismatch */})\par
01392   if (lhs == rhs) \{\par
01393     {\cf19 return} AssertionSuccess();\par
01394   \}\par
01395 GTEST_DISABLE_MSC_WARNINGS_POP_()\par
01396 \par
01397   return CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);\par
01398 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionSuccess()}, {\b CmpHelperEQFailure()}, {\b GTEST_DISABLE_MSC_WARNINGS_POP_} \'E8 {\b GTEST_DISABLE_MSC_WARNINGS_PUSH_}.}\par
}
{\xe \v CmpHelperEQFailure\:testing::internal}
{\xe \v testing::internal\:CmpHelperEQFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T1 , typename T2 > {\b AssertionResult} testing::internal::CmpHelperEQFailure (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, const T1 &  {\i lhs}, const T2 &  {\i rhs})}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1375}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01377                                                                  \{\par
01378   {\cf19 return} EqFailure(lhs_expression,\par
01379                    rhs_expression,\par
01380                    FormatForComparisonFailureMessage(lhs, rhs),\par
01381                    FormatForComparisonFailureMessage(rhs, lhs),\par
01382                    {\cf17 false});\par
01383 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b EqFailure()} \'E8 {\b FormatForComparisonFailureMessage()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CmpHelperEQ()}.}\par
}
{\xe \v CmpHelperFloatingPointEQ\:testing::internal}
{\xe \v testing::internal\:CmpHelperFloatingPointEQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > {\b AssertionResult} testing::internal::CmpHelperFloatingPointEQ (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, RawType  {\i lhs_value}, RawType  {\i rhs_value})}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1631}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01634                                                             \{\par
01635   {\cf17 const} FloatingPoint<RawType> lhs(lhs_value), rhs(rhs_value);\par
01636 \par
01637   {\cf19 if} (lhs.AlmostEquals(rhs)) \{\par
01638     {\cf19 return} AssertionSuccess();\par
01639   \}\par
01640 \par
01641   ::std::stringstream lhs_ss;\par
01642   lhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\par
01643          << lhs_value;\par
01644 \par
01645   ::std::stringstream rhs_ss;\par
01646   rhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\par
01647          << rhs_value;\par
01648 \par
01649   {\cf19 return} EqFailure(lhs_expression,\par
01650                    rhs_expression,\par
01651                    StringStreamToString(&lhs_ss),\par
01652                    StringStreamToString(&rhs_ss),\par
01653                    {\cf17 false});\par
01654 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionSuccess()}, {\b EqFailure()} \'E8 {\b StringStreamToString()}.}\par
}
{\xe \v CmpHelperOpFailure\:testing::internal}
{\xe \v testing::internal\:CmpHelperOpFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T1 , typename T2 > {\b AssertionResult} testing::internal::CmpHelperOpFailure (const char *  {\i expr1}, const char *  {\i expr2}, const T1 &  {\i val1}, const T2 &  {\i val2}, const char *  {\i op})}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1486}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01488                                                    \{\par
01489   {\cf19 return} AssertionFailure()\par
01490          << {\cf22 "Expected: ("} << expr1 << {\cf22 ") "} << op << {\cf22 " ("} << expr2\par
01491          << {\cf22 "), actual: "} << FormatForComparisonFailureMessage(val1, val2)\par
01492          << {\cf22 " vs "} << FormatForComparisonFailureMessage(val2, val1);\par
01493 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionFailure()} \'E8 {\b FormatForComparisonFailureMessage()}.}\par
}
{\xe \v CmpHelperSTRCASEEQ\:testing::internal}
{\xe \v testing::internal\:CmpHelperSTRCASEEQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::internal::CmpHelperSTRCASEEQ (const char *  {\i s1_expression}, const char *  {\i s2_expression}, const char *  {\i s1}, const char *  {\i s2})}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1500}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01503                                                     \{\par
01504   {\cf19 if} (String::CaseInsensitiveCStringEquals(lhs, rhs)) \{\par
01505     {\cf19 return} AssertionSuccess();\par
01506   \}\par
01507 \par
01508   {\cf19 return} EqFailure(lhs_expression,\par
01509                    rhs_expression,\par
01510                    PrintToString(lhs),\par
01511                    PrintToString(rhs),\par
01512                    {\cf17 true});\par
01513 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionSuccess()}, {\b testing::internal::String::CaseInsensitiveCStringEquals()}, {\b EqFailure()} \'E8 {\b testing::PrintToString()}.}\par
}
{\xe \v CmpHelperSTRCASENE\:testing::internal}
{\xe \v testing::internal\:CmpHelperSTRCASENE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::internal::CmpHelperSTRCASENE (const char *  {\i s1_expression}, const char *  {\i s2_expression}, const char *  {\i s1}, const char *  {\i s2})}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1530}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01533                                                    \{\par
01534   {\cf19 if} (!String::CaseInsensitiveCStringEquals(s1, s2)) \{\par
01535     {\cf19 return} AssertionSuccess();\par
01536   \} {\cf19 else} \{\par
01537     {\cf19 return} AssertionFailure()\par
01538         << {\cf22 "Expected: ("} << s1_expression << {\cf22 ") != ("}\par
01539         << s2_expression << {\cf22 ") (ignoring case), actual: \\""}\par
01540         << s1 << {\cf22 "\\" vs \\""} << s2 << {\cf22 "\\""};\par
01541   \}\par
01542 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionFailure()}, {\b testing::AssertionSuccess()} \'E8 {\b testing::internal::String::CaseInsensitiveCStringEquals()}.}\par
}
{\xe \v CmpHelperSTREQ\:testing::internal}
{\xe \v testing::internal\:CmpHelperSTREQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::internal::CmpHelperSTREQ (const char *  {\i s1_expression}, const char *  {\i s2_expression}, const char *  {\i s1}, const char *  {\i s2})}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1484}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01487                                                 \{\par
01488   {\cf19 if} (String::CStringEquals(lhs, rhs)) \{\par
01489     {\cf19 return} AssertionSuccess();\par
01490   \}\par
01491 \par
01492   {\cf19 return} EqFailure(lhs_expression,\par
01493                    rhs_expression,\par
01494                    PrintToString(lhs),\par
01495                    PrintToString(rhs),\par
01496                    {\cf17 false});\par
01497 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionSuccess()}, {\b testing::internal::String::CStringEquals()}, {\b EqFailure()} \'E8 {\b testing::PrintToString()}.}\par
}
{\xe \v CmpHelperSTREQ\:testing::internal}
{\xe \v testing::internal\:CmpHelperSTREQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::internal::CmpHelperSTREQ (const char *  {\i s1_expression}, const char *  {\i s2_expression}, const wchar_t *  {\i s1}, const wchar_t *  {\i s2})}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1866}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01869                                                    \{\par
01870   {\cf19 if} (String::WideCStringEquals(lhs, rhs)) \{\par
01871     {\cf19 return} AssertionSuccess();\par
01872   \}\par
01873 \par
01874   {\cf19 return} EqFailure(lhs_expression,\par
01875                    rhs_expression,\par
01876                    PrintToString(lhs),\par
01877                    PrintToString(rhs),\par
01878                    {\cf17 false});\par
01879 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionSuccess()}, {\b EqFailure()}, {\b testing::PrintToString()} \'E8 {\b testing::internal::String::WideCStringEquals()}.}\par
}
{\xe \v CmpHelperSTRNE\:testing::internal}
{\xe \v testing::internal\:CmpHelperSTRNE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::internal::CmpHelperSTRNE (const char *  {\i s1_expression}, const char *  {\i s2_expression}, const char *  {\i s1}, const char *  {\i s2})}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1516}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01519                                                \{\par
01520   {\cf19 if} (!String::CStringEquals(s1, s2)) \{\par
01521     {\cf19 return} AssertionSuccess();\par
01522   \} {\cf19 else} \{\par
01523     {\cf19 return} AssertionFailure() << {\cf22 "Expected: ("} << s1_expression << {\cf22 ") != ("}\par
01524                               << s2_expression << {\cf22 "), actual: \\""}\par
01525                               << s1 << {\cf22 "\\" vs \\""} << s2 << {\cf22 "\\""};\par
01526   \}\par
01527 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionFailure()}, {\b testing::AssertionSuccess()} \'E8 {\b testing::internal::String::CStringEquals()}.}\par
}
{\xe \v CmpHelperSTRNE\:testing::internal}
{\xe \v testing::internal\:CmpHelperSTRNE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::internal::CmpHelperSTRNE (const char *  {\i s1_expression}, const char *  {\i s2_expression}, const wchar_t *  {\i s1}, const wchar_t *  {\i s2})}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1882}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01885                                                   \{\par
01886   {\cf19 if} (!String::WideCStringEquals(s1, s2)) \{\par
01887     {\cf19 return} AssertionSuccess();\par
01888   \}\par
01889 \par
01890   {\cf19 return} AssertionFailure() << {\cf22 "Expected: ("} << s1_expression << {\cf22 ") != ("}\par
01891                             << s2_expression << {\cf22 "), actual: "}\par
01892                             << PrintToString(s1)\par
01893                             << {\cf22 " vs "} << PrintToString(s2);\par
01894 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionFailure()}, {\b testing::AssertionSuccess()}, {\b testing::PrintToString()} \'E8 {\b testing::internal::String::WideCStringEquals()}.}\par
}
{\xe \v CodePointToUtf8\:testing::internal}
{\xe \v testing::internal\:CodePointToUtf8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::CodePointToUtf8 ({\b UInt32}  {\i code_point})}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1756}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01756                                              \{\par
01757   {\cf19 if} (code_point > kMaxCodePoint4) \{\par
01758     {\cf19 return} {\cf22 "(Invalid Unicode 0x"} + String::FormatHexInt(code_point) + {\cf22 ")"};\par
01759   \}\par
01760 \par
01761   {\cf18 char} str[5];  {\cf20 // Big enough for the largest valid code point.}\par
01762   {\cf19 if} (code_point <= kMaxCodePoint1) \{\par
01763     str[1] = {\cf23 '\\0'};\par
01764     str[0] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(code_point);                          {\cf20 // 0xxxxxxx}\par
01765   \} {\cf19 else} {\cf19 if} (code_point <= kMaxCodePoint2) \{\par
01766     str[2] = {\cf23 '\\0'};\par
01767     str[1] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
01768     str[0] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xC0 | code_point);                   {\cf20 // 110xxxxx}\par
01769   \} {\cf19 else} {\cf19 if} (code_point <= kMaxCodePoint3) \{\par
01770     str[3] = {\cf23 '\\0'};\par
01771     str[2] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
01772     str[1] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
01773     str[0] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xE0 | code_point);                   {\cf20 // 1110xxxx}\par
01774   \} {\cf19 else} \{  {\cf20 // code_point <= kMaxCodePoint4}\par
01775     str[4] = {\cf23 '\\0'};\par
01776     str[3] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
01777     str[2] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
01778     str[1] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
01779     str[0] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xF0 | code_point);                   {\cf20 // 11110xxx}\par
01780   \}\par
01781   {\cf19 return} str;\par
01782 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ChopLowBits()}, {\b testing::internal::String::FormatHexInt()}, {\b kMaxCodePoint1}, {\b kMaxCodePoint2}, {\b kMaxCodePoint3} \'E8 {\b kMaxCodePoint4}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b WideStringToUtf8()}.}\par
}
{\xe \v ColoredPrintf\:testing::internal}
{\xe \v testing::internal\:ColoredPrintf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::ColoredPrintf ({\b GTestColor}  {\i color}, const char *  {\i fmt},   {\i ...})}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2954}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02954                                                            \{\par
02955   va_list args;\par
02956   va_start(args, fmt);\par
02957 \par
02958 {\cf21 #if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || GTEST_OS_ZOS || \\}\par
02959 {\cf21     GTEST_OS_IOS || GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT}\par
02960   {\cf17 const} {\cf18 bool} use_color = AlwaysFalse();\par
02961 {\cf21 #else}\par
02962   {\cf17 static} {\cf17 const} {\cf18 bool} in_color_mode =\par
02963       ShouldUseColor(posix::IsATTY(posix::FileNo(stdout)) != 0);\par
02964   {\cf17 const} {\cf18 bool} use_color = in_color_mode && (color != COLOR_DEFAULT);\par
02965 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || GTEST_OS_ZOS}\par
02966   {\cf20 // The '!= 0' comparison is necessary to satisfy MSVC 7.1.}\par
02967 \par
02968   {\cf19 if} (!use_color) \{\par
02969     vprintf(fmt, args);\par
02970     va_end(args);\par
02971     {\cf19 return};\par
02972   \}\par
02973 \par
02974 {\cf21 #if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE && \\}\par
02975 {\cf21     !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT}\par
02976   {\cf17 const} HANDLE stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE);\par
02977 \par
02978   {\cf20 // Gets the current text color.}\par
02979   CONSOLE_SCREEN_BUFFER_INFO buffer_info;\par
02980   GetConsoleScreenBufferInfo(stdout_handle, &buffer_info);\par
02981   {\cf17 const} WORD old_color_attrs = buffer_info.wAttributes;\par
02982 \par
02983   {\cf20 // We need to flush the stream buffers into the console before each}\par
02984   {\cf20 // SetConsoleTextAttribute call lest it affect the text that is already}\par
02985   {\cf20 // printed but has not yet reached the console.}\par
02986   fflush(stdout);\par
02987   SetConsoleTextAttribute(stdout_handle,\par
02988                           GetColorAttribute(color) | FOREGROUND_INTENSITY);\par
02989   vprintf(fmt, args);\par
02990 \par
02991   fflush(stdout);\par
02992   {\cf20 // Restores the text color.}\par
02993   SetConsoleTextAttribute(stdout_handle, old_color_attrs);\par
02994 {\cf21 #else}\par
02995   printf({\cf22 "\\033[0;3%sm"}, GetAnsiColorCode(color));\par
02996   vprintf(fmt, args);\par
02997   printf({\cf22 "\\033[m"});  {\cf20 // Resets the terminal to default.}\par
02998 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE}\par
02999   va_end(args);\par
03000 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b AlwaysFalse()}, {\b COLOR_DEFAULT}, {\b testing::internal::posix::FileNo()}, {\b GetAnsiColorCode()}, {\b testing::internal::posix::IsATTY()} \'E8 {\b ShouldUseColor()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestCaseEnd()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestCaseStart()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestEnd()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestStart()}, {\b ShouldShard()} \'E8 {\b WriteToShardStatusFileIfNeeded()}.}\par
}
{\xe \v CopyArray\:testing::internal}
{\xe \v testing::internal\:CopyArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U > void testing::internal::CopyArray (const T &  {\i from}, U *  {\i to}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1001}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01001 \{ *to = from; \}\par
}
}
{\xe \v CopyArray\:testing::internal}
{\xe \v testing::internal\:CopyArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U > void testing::internal::CopyArray (const T *  {\i from}, size_t  {\i size}, U *  {\i to})}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1013}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01013                                                   \{\par
01014   {\cf19 for} ({\cf18 size_t} i = 0; i != size; i++) \{\par
01015     internal::CopyArray(from[i], to + i);\par
01016   \}\par
01017 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b CopyArray()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CopyArray()}.}\par
}
{\xe \v CopyArray\:testing::internal}
{\xe \v testing::internal\:CopyArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U , size_t N> void testing::internal::CopyArray (const T(&)  {\i from}[N], U(*)  {\i to}[N]){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1005}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01005                                                     \{\par
01006   internal::CopyArray(from, N, *to);\par
01007 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b CopyArray()}.}\par
}
{\xe \v CountIf\:testing::internal}
{\xe \v testing::internal\:CountIf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Container , typename Predicate > int testing::internal::CountIf (const Container &  {\i c}, Predicate  {\i predicate}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 283}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00283                                                             \{\par
00284   {\cf20 // Implemented as an explicit loop since std::count_if() in libCstd on}\par
00285   {\cf20 // Solaris has a non-standard signature.}\par
00286   {\cf18 int} count = 0;\par
00287   {\cf19 for} ({\cf17 typename} Container::const_iterator it = c.begin(); it != c.end(); ++it) \{\par
00288     {\cf19 if} (predicate(*it))\par
00289       ++count;\par
00290   \}\par
00291   {\cf19 return} count;\par
00292 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::TestCase::disabled_test_count()}, {\b testing::internal::UnitTestImpl::failed_test_case_count()}, {\b testing::TestCase::failed_test_count()}, {\b testing::TestResult::HasFatalFailure()}, {\b testing::TestResult::HasNonfatalFailure()}, {\b testing::TestCase::reportable_disabled_test_count()}, {\b testing::TestCase::reportable_test_count()}, {\b testing::internal::UnitTestImpl::successful_test_case_count()}, {\b testing::TestCase::successful_test_count()}, {\b testing::internal::UnitTestImpl::test_case_to_run_count()} \'E8 {\b testing::TestCase::test_to_run_count()}.}\par
}
{\xe \v CreateCodePointFromUtf16SurrogatePair\:testing::internal}
{\xe \v testing::internal\:CreateCodePointFromUtf16SurrogatePair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt32} testing::internal::CreateCodePointFromUtf16SurrogatePair (wchar_t  {\i first}, wchar_t  {\i second}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1797}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01798                                                                     \{\par
01799   {\cf17 const} UInt32 mask = (1 << 10) - 1;\par
01800   {\cf19 return} ({\cf17 sizeof}({\cf18 wchar_t}) == 2) ?\par
01801       (((first & mask) << 10) | (second & mask)) + 0x10000 :\par
01802       {\cf20 // This function should not be called when the condition is}\par
01803       {\cf20 // false, but we provide a sensible default in case it is.}\par
01804       {\cf17 static_cast<}UInt32{\cf17 >}(first);\par
01805 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b WideStringToUtf8()}.}\par
}
{\xe \v DefaultPrintTo\:testing::internal}
{\xe \v testing::internal\:DefaultPrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C > void testing::internal::DefaultPrintTo ({\b WrapPrinterType}< {\b kPrintContainer} > , const C &  {\i container}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 378}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00379                                                         \{\par
00380   {\cf17 const} {\cf18 size_t} kMaxCount = 32;  {\cf20 // The maximum number of elements to print.}\par
00381   *os << {\cf23 '\{'};\par
00382   {\cf18 size_t} count = 0;\par
00383   {\cf19 for} ({\cf17 typename} C::const_iterator it = container.begin();\par
00384        it != container.end(); ++it, ++count) \{\par
00385     {\cf19 if} (count > 0) \{\par
00386       *os << {\cf23 ','};\par
00387       {\cf19 if} (count == kMaxCount) \{  {\cf20 // Enough has been printed.}\par
00388         *os << {\cf22 " ..."};\par
00389         {\cf19 break};\par
00390       \}\par
00391     \}\par
00392     *os << {\cf23 ' '};\par
00393     {\cf20 // We cannot call PrintTo(*it, os) here as PrintTo() doesn't}\par
00394     {\cf20 // handle *it being a native array.}\par
00395     internal::UniversalPrint(*it, os);\par
00396   \}\par
00397 \par
00398   {\cf19 if} (count > 0) \{\par
00399     *os << {\cf23 ' '};\par
00400   \}\par
00401   *os << {\cf23 '\}'};\par
00402 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b UniversalPrint()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b PrintTo()}.}\par
}
{\xe \v DefaultPrintTo\:testing::internal}
{\xe \v testing::internal\:DefaultPrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::DefaultPrintTo ({\b WrapPrinterType}< {\b kPrintFunctionPointer} > , T *  {\i p}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 423}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00424                                           \{\par
00425   {\cf19 if} (p == NULL) \{\par
00426     *os << {\cf22 "NULL"};\par
00427   \} {\cf19 else} \{\par
00428     {\cf20 // T is a function type, so '*os << p' doesn't do what we want}\par
00429     {\cf20 // (it just prints p as bool).  We want to print p as a const}\par
00430     {\cf20 // void*.  However, we cannot cast it to const void* directly,}\par
00431     {\cf20 // even using reinterpret_cast, as earlier versions of gcc}\par
00432     {\cf20 // (e.g. 3.4.5) cannot compile the cast when p is a function}\par
00433     {\cf20 // pointer.  Casting to UInt64 first solves the problem.}\par
00434     *os << reinterpret_cast<const void*>(\par
00435         {\cf17 reinterpret_cast<}internal::UInt64{\cf17 >}(p));\par
00436   \}\par
00437 \}\par
}
}
{\xe \v DefaultPrintTo\:testing::internal}
{\xe \v testing::internal\:DefaultPrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::DefaultPrintTo ({\b WrapPrinterType}< {\b kPrintOther} > , const T &  {\i value}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 442}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00443                                                     \{\par
00444   ::testing_internal::DefaultPrintNonContainerTo(value, os);\par
00445 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing_internal::DefaultPrintNonContainerTo()}.}\par
}
{\xe \v DefaultPrintTo\:testing::internal}
{\xe \v testing::internal\:DefaultPrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::DefaultPrintTo ({\b WrapPrinterType}< {\b kPrintPointer} > , T *  {\i p}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 411}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00412                                           \{\par
00413   {\cf19 if} (p == NULL) \{\par
00414     *os << {\cf22 "NULL"};\par
00415   \} {\cf19 else} \{\par
00416     {\cf20 // T is not a function type.  We just call << to print p,}\par
00417     {\cf20 // relying on ADL to pick up user-defined << for their pointer}\par
00418     {\cf20 // types, if any.}\par
00419     *os << p;\par
00420   \}\par
00421 \}\par
}
}
{\xe \v DiffStrings\:testing::internal}
{\xe \v testing::internal\:DiffStrings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} std::string testing::internal::DiffStrings (const std::string &  {\i left}, const std::string &  {\i right}, size_t *  {\i total_line_count})}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DoubleNearPredFormat\:testing::internal}
{\xe \v testing::internal\:DoubleNearPredFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::internal::DoubleNearPredFormat (const char *  {\i expr1}, const char *  {\i expr2}, const char *  {\i abs_error_expr}, double  {\i val1}, double  {\i val2}, double  {\i abs_error})}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1359}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01364                                                        \{\par
01365   {\cf17 const} {\cf18 double} diff = fabs(val1 - val2);\par
01366   {\cf19 if} (diff <= abs_error) {\cf19 return} AssertionSuccess();\par
01367 \par
01368   {\cf20 // TODO(wan): do not print the value of an expression if it's}\par
01369   {\cf20 // already a literal.}\par
01370   {\cf19 return} AssertionFailure()\par
01371       << {\cf22 "The difference between "} << expr1 << {\cf22 " and "} << expr2\par
01372       << {\cf22 " is "} << diff << {\cf22 ", which exceeds "} << abs_error_expr << {\cf22 ", where\\n"}\par
01373       << expr1 << {\cf22 " evaluates to "} << val1 << {\cf22 ",\\n"}\par
01374       << expr2 << {\cf22 " evaluates to "} << val2 << {\cf22 ", and\\n"}\par
01375       << abs_error_expr << {\cf22 " evaluates to "} << abs_error << {\cf22 "."};\par
01376 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionFailure()} \'E8 {\b testing::AssertionSuccess()}.}\par
}
{\xe \v DownCast_\:testing::internal}
{\xe \v testing::internal\:DownCast_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename To , typename From > To testing::internal::DownCast_ (From *  {\i f}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1402}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01402                              \{  {\cf20 // so we only accept pointers}\par
01403   {\cf20 // Ensures that To is a sub-type of From *.  This test is here only}\par
01404   {\cf20 // for compile-time type checking, and has no overhead in an}\par
01405   {\cf20 // optimized build at run-time, as it will be optimized away}\par
01406   {\cf20 // completely.}\par
01407   GTEST_INTENTIONAL_CONST_COND_PUSH_()\par
01408   if (false) \{\par
01409   GTEST_INTENTIONAL_CONST_COND_POP_()\par
01410     const To to = NULL;\par
01411     ::testing::internal::ImplicitCast_<From*>(to);\par
01412   \}\par
01413 \par
01414 {\cf21 #if GTEST_HAS_RTTI}\par
01415   {\cf20 // RTTI: debug mode only!}\par
01416   GTEST_CHECK_(f == NULL || {\cf17 dynamic_cast<}To{\cf17 >}(f) != NULL);\par
01417 {\cf21 #endif}\par
01418   {\cf19 return} {\cf17 static_cast<}To{\cf17 >}(f);\par
01419 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GTEST_CHECK_}, {\b GTEST_INTENTIONAL_CONST_COND_POP_} \'E8 {\b GTEST_INTENTIONAL_CONST_COND_PUSH_}.}\par
}
{\xe \v EqFailure\:testing::internal}
{\xe \v testing::internal\:EqFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::internal::EqFailure (const char *  {\i expected_expression}, const char *  {\i actual_expression}, const std::string &  {\i expected_value}, const std::string &  {\i actual_value}, bool  {\i ignoring_case})}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1309}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01313                                               \{\par
01314   Message msg;\par
01315   msg << {\cf22 "      Expected: "} << lhs_expression;\par
01316   {\cf19 if} (lhs_value != lhs_expression) \{\par
01317     msg << {\cf22 "\\n      Which is: "} << lhs_value;\par
01318   \}\par
01319   msg << {\cf22 "\\nTo be equal to: "} << rhs_expression;\par
01320   {\cf19 if} (rhs_value != rhs_expression) \{\par
01321     msg << {\cf22 "\\n      Which is: "} << rhs_value;\par
01322   \}\par
01323 \par
01324   {\cf19 if} (ignoring_case) \{\par
01325     msg << {\cf22 "\\nIgnoring case"};\par
01326   \}\par
01327 \par
01328   {\cf19 if} (!lhs_value.empty() && !rhs_value.empty()) \{\par
01329     {\cf17 const} std::vector<std::string> lhs_lines =\par
01330         SplitEscapedString(lhs_value);\par
01331     {\cf17 const} std::vector<std::string> rhs_lines =\par
01332         SplitEscapedString(rhs_value);\par
01333     {\cf19 if} (lhs_lines.size() > 1 || rhs_lines.size() > 1) \{\par
01334       msg << {\cf22 "\\nWith diff:\\n"}\par
01335           << edit_distance::CreateUnifiedDiff(lhs_lines, rhs_lines);\par
01336     \}\par
01337   \}\par
01338 \par
01339   {\cf19 return} AssertionFailure() << msg;\par
01340 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionFailure()} \'E8 {\b testing::internal::edit_distance::CreateUnifiedDiff()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CmpHelperEQ()}, {\b CmpHelperEQFailure()}, {\b CmpHelperFloatingPointEQ()}, {\b CmpHelperSTRCASEEQ()} \'E8 {\b CmpHelperSTREQ()}.}\par
}
{\xe \v FloatingPointLE\:testing::internal}
{\xe \v testing::internal\:FloatingPointLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > {\b AssertionResult} testing::internal::FloatingPointLE (const char *  {\i expr1}, const char *  {\i expr2}, RawType  {\i val1}, RawType  {\i val2})}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1381}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01384                                               \{\par
01385   {\cf20 // Returns success if val1 is less than val2,}\par
01386   {\cf19 if} (val1 < val2) \{\par
01387     {\cf19 return} AssertionSuccess();\par
01388   \}\par
01389 \par
01390   {\cf20 // or if val1 is almost equal to val2.}\par
01391   {\cf17 const} FloatingPoint<RawType> lhs(val1), rhs(val2);\par
01392   {\cf19 if} (lhs.AlmostEquals(rhs)) \{\par
01393     {\cf19 return} AssertionSuccess();\par
01394   \}\par
01395 \par
01396   {\cf20 // Note that the above two checks will both fail if either val1 or}\par
01397   {\cf20 // val2 is NaN, as the IEEE floating-point standard requires that}\par
01398   {\cf20 // any predicate involving a NaN must return false.}\par
01399 \par
01400   ::std::stringstream val1_ss;\par
01401   val1_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\par
01402           << val1;\par
01403 \par
01404   ::std::stringstream val2_ss;\par
01405   val2_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\par
01406           << val2;\par
01407 \par
01408   {\cf19 return} AssertionFailure()\par
01409       << {\cf22 "Expected: ("} << expr1 << {\cf22 ") <= ("} << expr2 << {\cf22 ")\\n"}\par
01410       << {\cf22 "  Actual: "} << StringStreamToString(&val1_ss) << {\cf22 " vs "}\par
01411       << StringStreamToString(&val2_ss);\par
01412 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionFailure()}, {\b testing::AssertionSuccess()} \'E8 {\b StringStreamToString()}.}\par
}
{\xe \v FlushInfoLog\:testing::internal}
{\xe \v testing::internal\:FlushInfoLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::FlushInfoLog (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1311}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01311 \{ fflush(NULL); \}\par
}
}
{\xe \v ForEach\:testing::internal}
{\xe \v testing::internal\:ForEach}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Container , typename Functor > void testing::internal::ForEach (const Container &  {\i c}, Functor  {\i functor})}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 296}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00296                                                   \{\par
00297   std::for_each(c.begin(), c.end(), functor);\par
00298 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::ClearNonAdHocTestResult()}, {\b testing::internal::UnitTestImpl::RunAllTests()}, {\b testing::TestCase::~TestCase()}, {\b testing::internal::TestEventRepeater::~TestEventRepeater()} \'E8 {\b testing::internal::UnitTestImpl::~UnitTestImpl()}.}\par
}
{\xe \v FormatCompilerIndependentFileLocation\:testing::internal}
{\xe \v testing::internal\:FormatCompilerIndependentFileLocation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GTEST_API_::std::string testing::internal::FormatCompilerIndependentFileLocation (const char *  {\i file}, int  {\i line})}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 898}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00899                                 \{\par
00900   {\cf17 const} std::string file_name(file == NULL ? kUnknownFile : file);\par
00901 \par
00902   {\cf19 if} (line < 0)\par
00903     {\cf19 return} file_name;\par
00904   {\cf19 else}\par
00905     {\cf19 return} file_name + {\cf22 ":"} + StreamableToString(line);\par
00906 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b kUnknownFile} \'E8 {\b StreamableToString()}.}\par
}
{\xe \v FormatEpochTimeInMillisAsIso8601\:testing::internal}
{\xe \v testing::internal\:FormatEpochTimeInMillisAsIso8601}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::FormatEpochTimeInMillisAsIso8601 ({\b TimeInMillis}  {\i ms})}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3572}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03572                                                             \{\par
03573   {\cf17 struct }tm time_struct;\par
03574   {\cf19 if} (!PortableLocaltime({\cf17 static_cast<}time_t{\cf17 >}(ms / 1000), &time_struct))\par
03575     {\cf19 return} {\cf22 ""};\par
03576   {\cf20 // YYYY-MM-DDThh:mm:ss}\par
03577   {\cf19 return} StreamableToString(time_struct.tm_year + 1900) + {\cf22 "-"} +\par
03578       String::FormatIntWidth2(time_struct.tm_mon + 1) + {\cf22 "-"} +\par
03579       String::FormatIntWidth2(time_struct.tm_mday) + {\cf22 "T"} +\par
03580       String::FormatIntWidth2(time_struct.tm_hour) + {\cf22 ":"} +\par
03581       String::FormatIntWidth2(time_struct.tm_min) + {\cf22 ":"} +\par
03582       String::FormatIntWidth2(time_struct.tm_sec);\par
03583 \}\par
}
}
{\xe \v FormatFileLocation\:testing::internal}
{\xe \v testing::internal\:FormatFileLocation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GTEST_API_::std::string testing::internal::FormatFileLocation (const char *  {\i file}, int  {\i line})}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 880}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00880                                                                     \{\par
00881   {\cf17 const} std::string file_name(file == NULL ? kUnknownFile : file);\par
00882 \par
00883   {\cf19 if} (line < 0) \{\par
00884     {\cf19 return} file_name + {\cf22 ":"};\par
00885   \}\par
00886 {\cf21 #ifdef _MSC_VER}\par
00887   {\cf19 return} file_name + {\cf22 "("} + StreamableToString(line) + {\cf22 "):"};\par
00888 {\cf21 #else}\par
00889   {\cf19 return} file_name + {\cf22 ":"} + StreamableToString(line) + {\cf22 ":"};\par
00890 {\cf21 #endif  }{\cf20 // _MSC_VER}\par
00891 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b kUnknownFile} \'E8 {\b StreamableToString()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::GTestLog::GTestLog()}.}\par
}
{\xe \v FormatForComparisonFailureMessage\:testing::internal}
{\xe \v testing::internal\:FormatForComparisonFailureMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T1 , typename T2 > std::string testing::internal::FormatForComparisonFailureMessage (const T1 &  {\i value}, const T2 & )}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 349}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00350                                   \{\par
00351   {\cf19 return} FormatForComparison<T1, T2>::Format(value);\par
00352 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::FormatForComparison< ToPrint, OtherOperand >::Format()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CmpHelperEQ()}, {\b CmpHelperEQFailure()} \'E8 {\b CmpHelperOpFailure()}.}\par
}
{\xe \v FormatTimeInMillisAsSeconds\:testing::internal}
{\xe \v testing::internal\:FormatTimeInMillisAsSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::FormatTimeInMillisAsSeconds ({\b TimeInMillis}  {\i ms})}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3548}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03548                                                        \{\par
03549   ::std::stringstream ss;\par
03550   ss << (static_cast<double>(ms) * 1e-3);\par
03551   {\cf19 return} ss.str();\par
03552 \}\par
}
}
{\xe \v GetAnsiColorCode\:testing::internal}
{\xe \v testing::internal\:GetAnsiColorCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::internal::GetAnsiColorCode ({\b GTestColor}  {\i color})}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2901}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02901                                                \{\par
02902   {\cf19 switch} (color) \{\par
02903     {\cf19 case} COLOR_RED:     {\cf19 return} {\cf22 "1"};\par
02904     {\cf19 case} COLOR_GREEN:   {\cf19 return} {\cf22 "2"};\par
02905     {\cf19 case} COLOR_YELLOW:  {\cf19 return} {\cf22 "3"};\par
02906     {\cf19 default}:            {\cf19 return} NULL;\par
02907   \};\par
02908 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b COLOR_GREEN}, {\b COLOR_RED} \'E8 {\b COLOR_YELLOW}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ColoredPrintf()}.}\par
}
{\xe \v GetArgvs\:testing::internal}
{\xe \v testing::internal\:GetArgvs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const ::std::vector< {\b testing::internal::string} > & testing::internal::GetArgvs ()}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 389}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00389                                                    \{\par
00390 {\cf21 #if defined(GTEST_CUSTOM_GET_ARGVS_)}\par
00391   {\cf19 return} GTEST_CUSTOM_GET_ARGVS_();\par
00392 {\cf21 #else  }{\cf20 // defined(GTEST_CUSTOM_GET_ARGVS_)}\par
00393   {\cf19 return} g_argvs;\par
00394 {\cf21 #endif  }{\cf20 // defined(GTEST_CUSTOM_GET_ARGVS_)}\par
00395 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b g_argvs}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b GetCurrentExecutableName()}.}\par
}
{\xe \v GetBoolAssertionFailureMessage\:testing::internal}
{\xe \v testing::internal\:GetBoolAssertionFailureMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::GetBoolAssertionFailureMessage (const {\b AssertionResult} &  {\i assertion_result}, const char *  {\i expression_text}, const char *  {\i actual_predicate_value}, const char *  {\i expected_predicate_value})}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1343}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01347                                           \{\par
01348   {\cf17 const} {\cf18 char}* actual_message = assertion_result.message();\par
01349   Message msg;\par
01350   msg << {\cf22 "Value of: "} << expression_text\par
01351       << {\cf22 "\\n  Actual: "} << actual_predicate_value;\par
01352   {\cf19 if} (actual_message[0] != {\cf23 '\\0'})\par
01353     msg << {\cf22 " ("} << actual_message << {\cf22 ")"};\par
01354   msg << {\cf22 "\\nExpected: "} << expected_predicate_value;\par
01355   {\cf19 return} msg.GetString();\par
01356 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::Message::GetString()} \'E8 {\b testing::AssertionResult::message()}.}\par
}
{\xe \v GetCapturedStderr\:testing::internal}
{\xe \v testing::internal\:GetCapturedStderr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} std::string testing::internal::GetCapturedStderr ()}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GetCapturedStdout\:testing::internal}
{\xe \v testing::internal\:GetCapturedStdout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} std::string testing::internal::GetCapturedStdout ()}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GetCurrentExecutableName\:testing::internal}
{\xe \v testing::internal\:GetCurrentExecutableName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FilePath} testing::internal::GetCurrentExecutableName ()}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 399}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00399                                     \{\par
00400   FilePath result;\par
00401 \par
00402 {\cf21 #if GTEST_OS_WINDOWS}\par
00403   result.Set(FilePath(GetArgvs()[0]).RemoveExtension({\cf22 "exe"}));\par
00404 {\cf21 #else}\par
00405   result.Set(FilePath(GetArgvs()[0]));\par
00406 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
00407 \par
00408   {\cf19 return} result.RemoveDirectoryName();\par
00409 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GetArgvs()}, {\b testing::internal::FilePath::RemoveDirectoryName()} \'E8 {\b testing::internal::FilePath::Set()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestOptions::GetAbsolutePathToOutputFile()}.}\par
}
{\xe \v GetCurrentOsStackTraceExceptTop\:testing::internal}
{\xe \v testing::internal\:GetCurrentOsStackTraceExceptTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::GetCurrentOsStackTraceExceptTop ({\b UnitTest} *  {\i unit_test}, int  {\i skip_count})}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4972}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04973                                                             \{\par
04974   {\cf20 // We pass skip_count + 1 to skip this wrapper function in addition}\par
04975   {\cf20 // to what the user really wants to skip.}\par
04976   {\cf19 return} GetUnitTestImpl()->CurrentOsStackTraceExceptTop(skip_count + 1);\par
04977 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UnitTestImpl::CurrentOsStackTraceExceptTop()} \'E8 {\b GetUnitTestImpl()}.}\par
}
{\xe \v GetElementOr\:testing::internal}
{\xe \v testing::internal\:GetElementOr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename E > E testing::internal::GetElementOr (const std::vector< E > &  {\i v}, int  {\i i}, E  {\i default_value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 303}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00303                                                                      \{\par
00304   {\cf19 return} (i < 0 || i >= {\cf17 static_cast<}{\cf18 int}{\cf17 >}(v.size())) ? default_value : v[i];\par
00305 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::GetMutableTestCase()}, {\b testing::internal::UnitTestImpl::GetTestCase()} \'E8 {\b testing::TestCase::GetTestInfo()}.}\par
}
{\xe \v GetFileSize\:testing::internal}
{\xe \v testing::internal\:GetFileSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t testing::internal::GetFileSize (FILE *  {\i file})}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1058}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01058                                \{\par
01059   fseek(file, 0, SEEK_END);\par
01060   {\cf19 return} {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(ftell(file));\par
01061 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ReadEntireFile()}.}\par
}
{\xe \v GetNextRandomSeed\:testing::internal}
{\xe \v testing::internal\:GetNextRandomSeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::GetNextRandomSeed (int  {\i seed}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 152}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00152                                        \{\par
00153   GTEST_CHECK_(1 <= seed && seed <= kMaxRandomSeed)\par
00154       << {\cf22 "Invalid random seed "} << seed << {\cf22 " - must be in [1, "}\par
00155       << kMaxRandomSeed << {\cf22 "]."};\par
00156   {\cf17 const} {\cf18 int} next_seed = seed + 1;\par
00157   {\cf19 return} (next_seed > kMaxRandomSeed) ? 1 : next_seed;\par
00158 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GTEST_CHECK_} \'E8 {\b kMaxRandomSeed}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v GetRandomSeedFromFlag\:testing::internal}
{\xe \v testing::internal\:GetRandomSeedFromFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::GetRandomSeedFromFlag ({\b Int32}  {\i random_seed_flag}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 136}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00136                                                          \{\par
00137   {\cf17 const} {\cf18 unsigned} {\cf18 int} raw_seed = (random_seed_flag == 0) ?\par
00138       {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(GetTimeInMillis()) :\par
00139       {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(random_seed_flag);\par
00140 \par
00141   {\cf20 // Normalizes the actual seed to range [1, kMaxRandomSeed] such that}\par
00142   {\cf20 // it's easy to type.}\par
00143   {\cf17 const} {\cf18 int} normalized_seed =\par
00144       {\cf17 static_cast<}{\cf18 int}{\cf17 >}((raw_seed - 1U) %\par
00145                        {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(kMaxRandomSeed)) + 1;\par
00146   {\cf19 return} normalized_seed;\par
00147 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GetTimeInMillis()} \'E8 {\b kMaxRandomSeed}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v GetTestTypeId\:testing::internal}
{\xe \v testing::internal\:GetTestTypeId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TypeId} testing::internal::GetTestTypeId ()}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 620}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00620                        \{\par
00621   {\cf19 return} GetTypeId<Test>();\par
00622 \}\par
}
}
{\xe \v GetThreadCount\:testing::internal}
{\xe \v testing::internal\:GetThreadCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t testing::internal::GetThreadCount ()}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 169}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00169                         \{\par
00170   {\cf20 // There's no portable way to detect the number of threads, so we just}\par
00171   {\cf20 // return 0 to indicate that we cannot detect it.}\par
00172   {\cf19 return} 0;\par
00173 \}\par
}
}
{\xe \v GetTimeInMillis\:testing::internal}
{\xe \v testing::internal\:GetTimeInMillis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TimeInMillis} testing::internal::GetTimeInMillis ()}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 803}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00803                                \{\par
00804 {\cf21 #if GTEST_OS_WINDOWS_MOBILE || defined(__BORLANDC__)}\par
00805   {\cf20 // Difference between 1970-01-01 and 1601-01-01 in milliseconds.}\par
00806   {\cf20 // http://analogous.blogspot.com/2005/04/epoch.html}\par
00807   {\cf17 const} TimeInMillis kJavaEpochToWinFileTimeDelta =\par
00808     {\cf17 static_cast<}TimeInMillis{\cf17 >}(116444736UL) * 100000UL;\par
00809   {\cf17 const} DWORD kTenthMicrosInMilliSecond = 10000;\par
00810 \par
00811   SYSTEMTIME now_systime;\par
00812   FILETIME now_filetime;\par
00813   ULARGE_INTEGER now_int64;\par
00814   {\cf20 // TODO(kenton@google.com): Shouldn't this just use}\par
00815   {\cf20 //   GetSystemTimeAsFileTime()?}\par
00816   GetSystemTime(&now_systime);\par
00817   {\cf19 if} (SystemTimeToFileTime(&now_systime, &now_filetime)) \{\par
00818     now_int64.LowPart = now_filetime.dwLowDateTime;\par
00819     now_int64.HighPart = now_filetime.dwHighDateTime;\par
00820     now_int64.QuadPart = (now_int64.QuadPart / kTenthMicrosInMilliSecond) -\par
00821       kJavaEpochToWinFileTimeDelta;\par
00822     {\cf19 return} now_int64.QuadPart;\par
00823   \}\par
00824   {\cf19 return} 0;\par
00825 {\cf21 #elif GTEST_OS_WINDOWS && !GTEST_HAS_GETTIMEOFDAY_}\par
00826   __timeb64 now;\par
00827 \par
00828   {\cf20 // MSVC 8 deprecates _ftime64(), so we want to suppress warning 4996}\par
00829   {\cf20 // (deprecated function) there.}\par
00830   {\cf20 // TODO(kenton@google.com): Use GetTickCount()?  Or use}\par
00831   {\cf20 //   SystemTimeToFileTime()}\par
00832   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4996)\par
00833   _ftime64(&now);\par
00834   GTEST_DISABLE_MSC_WARNINGS_POP_()\par
00835 \par
00836   return static_cast<TimeInMillis>(now.time) * 1000 + now.millitm;\par
00837 {\cf21 #elif GTEST_HAS_GETTIMEOFDAY_}\par
00838   {\cf17 struct }timeval now;\par
00839   gettimeofday(&now, NULL);\par
00840   {\cf19 return} {\cf17 static_cast<}TimeInMillis{\cf17 >}(now.tv_sec) * 1000 + now.tv_usec / 1000;\par
00841 #{\cf19 else}\par
00842 # error {\cf22 "Don't know how to get the current time on your system."}\par
00843 #endif\par
00844 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GTEST_DISABLE_MSC_WARNINGS_POP_}, {\b GTEST_DISABLE_MSC_WARNINGS_PUSH_} \'E8 {\b GTEST_HAS_GETTIMEOFDAY_}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b GetRandomSeedFromFlag()} \'E8 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v GetTypeId\:testing::internal}
{\xe \v testing::internal\:GetTypeId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b TypeId} testing::internal::GetTypeId ()}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 447}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00447                    \{\par
00448   {\cf20 // The compiler is required to allocate a different}\par
00449   {\cf20 // TypeIdHelper<T>::dummy_ variable for each T used to instantiate}\par
00450   {\cf20 // the template.  Therefore, the address of dummy_ is guaranteed to}\par
00451   {\cf20 // be unique.}\par
00452   {\cf19 return} &(TypeIdHelper<T>::dummy_);\par
00453 \}\par
}
}
{\xe \v GetTypeName\:testing::internal}
{\xe \v testing::internal\:GetTypeName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::string testing::internal::GetTypeName ()}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-type-util.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 64}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00064                         \{\par
00065 {\cf21 # if GTEST_HAS_RTTI}\par
00066 \par
00067   {\cf17 const} {\cf18 char}* {\cf17 const} name = {\cf17 typeid}(T).name();\par
00068 {\cf21 #  if GTEST_HAS_CXXABI_H_ || defined(__HP_aCC)}\par
00069   {\cf18 int} status = 0;\par
00070   {\cf20 // gcc's implementation of typeid(T).name() mangles the type name,}\par
00071   {\cf20 // so we have to demangle it.}\par
00072 {\cf21 #   if GTEST_HAS_CXXABI_H_}\par
00073   {\cf17 using} abi::__cxa_demangle;\par
00074 {\cf21 #   endif  }{\cf20 // GTEST_HAS_CXXABI_H_}\par
00075   {\cf18 char}* {\cf17 const} readable_name = __cxa_demangle(name, 0, 0, &status);\par
00076   {\cf17 const} std::string name_str(status == 0 ? readable_name : name);\par
00077   free(readable_name);\par
00078   {\cf19 return} name_str;\par
00079 {\cf21 #  else}\par
00080   {\cf19 return} name;\par
00081 {\cf21 #  endif  }{\cf20 // GTEST_HAS_CXXABI_H_ || __HP_aCC}\par
00082 \par
00083 {\cf21 # else}\par
00084 \par
00085   {\cf19 return} {\cf22 "<type>"};\par
00086 \par
00087 {\cf21 # endif  }{\cf20 // GTEST_HAS_RTTI}\par
00088 \}\par
}
}
{\xe \v GetUnitTestImpl\:testing::internal}
{\xe \v testing::internal\:GetUnitTestImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UnitTestImpl} * testing::internal::GetUnitTestImpl (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 927}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00927                                        \{\par
00928   {\cf19 return} UnitTest::GetInstance()->impl();\par
00929 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::UnitTest::GetInstance()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b GetCurrentOsStackTraceExceptTop()}, {\b HandleExceptionsInMethodIfSupported()}, {\b testing::Test::HasFatalFailure()}, {\b testing::internal::HasNewFatalFailureHelper::HasNewFatalFailureHelper()}, {\b testing::Test::HasNonfatalFailure()}, {\b InitGoogleTestImpl()}, {\b MakeAndRegisterTestInfo()}, {\b testing::internal::HasNewFatalFailureHelper::~HasNewFatalFailureHelper()} \'E8 {\b testing::ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter()}.}\par
}
{\xe \v GTEST_DECLARE_STATIC_MUTEX_\:testing::internal}
{\xe \v testing::internal\:GTEST_DECLARE_STATIC_MUTEX_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} testing::internal::GTEST_DECLARE_STATIC_MUTEX_ (g_linked_ptr_mutex )}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DECLARE_string_\:testing::internal}
{\xe \v testing::internal\:GTEST_DECLARE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_DECLARE_string_ (internal_run_death_test )}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_STATIC_MUTEX_\:testing::internal}
{\xe \v testing::internal\:GTEST_DEFINE_STATIC_MUTEX_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} testing::internal::GTEST_DEFINE_STATIC_MUTEX_ (g_linked_ptr_mutex )}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_DEFINE_string_\:testing::internal}
{\xe \v testing::internal\:GTEST_DEFINE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_DEFINE_string_ (internal_run_death_test , "" , "Indicates the  {\i file}, line  {\i number}, temporal index of " "the single death test to  {\i run}, and a file descriptor to " "which a success code may be  {\i sent}, all separated by " "the '|' characters. This flag is specified if and only if the current " "process is a sub-process launched for running a thread-safe " "death test. FOR INTERNAL USE ONLY." )}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_CMP_HELPER_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_CMP_HELPER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_CMP_HELPER_ (GE , >= )}}
\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_CMP_HELPER_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_CMP_HELPER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_CMP_HELPER_ (GT )}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_CMP_HELPER_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_CMP_HELPER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_CMP_HELPER_ (LE , <= )}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_CMP_HELPER_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_CMP_HELPER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_CMP_HELPER_ (LT )}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_CMP_HELPER_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_CMP_HELPER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_CMP_HELPER_ (NE , ! )}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_ (char )}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_ (wchar_t )}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GTEST_IMPL_FORMAT_C_STRING_AS_STRING_\:testing::internal}
{\xe \v testing::internal\:GTEST_IMPL_FORMAT_C_STRING_AS_STRING_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTEST_IMPL_FORMAT_C_STRING_AS_STRING_ (char , ::std::string )}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HandleExceptionsInMethodIfSupported\:testing::internal}
{\xe \v testing::internal\:HandleExceptionsInMethodIfSupported}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T , typename Result > Result testing::internal::HandleExceptionsInMethodIfSupported (T *  {\i object}, Result(T::*)()  {\i method}, const char *  {\i location})}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2407}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02408                                                           \{\par
02409   {\cf20 // NOTE: The user code can affect the way in which Google Test handles}\par
02410   {\cf20 // exceptions by setting GTEST_FLAG(catch_exceptions), but only before}\par
02411   {\cf20 // RUN_ALL_TESTS() starts. It is technically possible to check the flag}\par
02412   {\cf20 // after the exception is caught and either report or re-throw the}\par
02413   {\cf20 // exception based on the flag's value:}\par
02414   {\cf20 //}\par
02415   {\cf20 // try \{}\par
02416   {\cf20 //   // Perform the test method.}\par
02417   {\cf20 // \} catch (...) \{}\par
02418   {\cf20 //   if (GTEST_FLAG(catch_exceptions))}\par
02419   {\cf20 //     // Report the exception as failure.}\par
02420   {\cf20 //   else}\par
02421   {\cf20 //     throw;  // Re-throws the original exception.}\par
02422   {\cf20 // \}}\par
02423   {\cf20 //}\par
02424   {\cf20 // However, the purpose of this flag is to allow the program to drop into}\par
02425   {\cf20 // the debugger when the exception is thrown. On most platforms, once the}\par
02426   {\cf20 // control enters the catch block, the exception origin information is}\par
02427   {\cf20 // lost and the debugger will stop the program at the point of the}\par
02428   {\cf20 // re-throw in this function -- instead of at the point of the original}\par
02429   {\cf20 // throw statement in the code under test.  For this reason, we perform}\par
02430   {\cf20 // the check early, sacrificing the ability to affect Google Test's}\par
02431   {\cf20 // exception handling in the method where the exception is thrown.}\par
02432   {\cf19 if} (internal::GetUnitTestImpl()->catch_exceptions()) \{\par
02433 {\cf21 #if GTEST_HAS_EXCEPTIONS}\par
02434     {\cf19 try} \{\par
02435       {\cf19 return} HandleSehExceptionsInMethodIfSupported({\cf18 object}, method, location);\par
02436     \} {\cf19 catch} ({\cf17 const} internal::GoogleTestFailureException&) \{  {\cf20 // NOLINT}\par
02437       {\cf20 // This exception type can only be thrown by a failed Google}\par
02438       {\cf20 // Test assertion with the intention of letting another testing}\par
02439       {\cf20 // framework catch it.  Therefore we just re-throw it.}\par
02440       {\cf19 throw};\par
02441     \} {\cf19 catch} ({\cf17 const} std::exception& e) \{  {\cf20 // NOLINT}\par
02442       internal::ReportFailureInUnknownLocation(\par
02443           TestPartResult::kFatalFailure,\par
02444           FormatCxxExceptionMessage(e.what(), location));\par
02445     \} {\cf19 catch} (...) \{  {\cf20 // NOLINT}\par
02446       internal::ReportFailureInUnknownLocation(\par
02447           TestPartResult::kFatalFailure,\par
02448           FormatCxxExceptionMessage(NULL, location));\par
02449     \}\par
02450     {\cf19 return} {\cf17 static_cast<}Result{\cf17 >}(0);\par
02451 {\cf21 #else}\par
02452     {\cf19 return} HandleSehExceptionsInMethodIfSupported({\cf18 object}, method, location);\par
02453 {\cf21 #endif  }{\cf20 // GTEST_HAS_EXCEPTIONS}\par
02454   \} {\cf19 else} \{\par
02455     {\cf19 return} (object->*method)();\par
02456   \}\par
02457 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GetUnitTestImpl()}, {\b HandleSehExceptionsInMethodIfSupported()}, {\b testing::TestPartResult::kFatalFailure} \'E8 {\b ReportFailureInUnknownLocation()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::UnitTest::Run()}.}\par
}
{\xe \v HandleSehExceptionsInMethodIfSupported\:testing::internal}
{\xe \v testing::internal\:HandleSehExceptionsInMethodIfSupported}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T , typename Result > Result testing::internal::HandleSehExceptionsInMethodIfSupported (T *  {\i object}, Result(T::*)()  {\i method}, const char *  {\i location})}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2380}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02381                                                           \{\par
02382 {\cf21 #if GTEST_HAS_SEH}\par
02383   __try \{\par
02384     {\cf19 return} (object->*method)();\par
02385   \} __except (internal::UnitTestOptions::GTestShouldProcessSEH(  {\cf20 // NOLINT}\par
02386       GetExceptionCode())) \{\par
02387     {\cf20 // We create the exception message on the heap because VC++ prohibits}\par
02388     {\cf20 // creation of objects with destructors on stack in functions using __try}\par
02389     {\cf20 // (see error C2712).}\par
02390     std::string* exception_message = FormatSehExceptionMessage(\par
02391         GetExceptionCode(), location);\par
02392     internal::ReportFailureInUnknownLocation(TestPartResult::kFatalFailure,\par
02393                                              *exception_message);\par
02394     {\cf17 delete} exception_message;\par
02395     {\cf19 return} {\cf17 static_cast<}Result{\cf17 >}(0);\par
02396   \}\par
02397 {\cf21 #else}\par
02398   (void)location;\par
02399   {\cf19 return} (object->*method)();\par
02400 {\cf21 #endif  }{\cf20 // GTEST_HAS_SEH}\par
02401 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestPartResult::kFatalFailure} \'E8 {\b ReportFailureInUnknownLocation()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b HandleExceptionsInMethodIfSupported()}.}\par
}
{\xe \v HasOneFailure\:testing::internal}
{\xe \v testing::internal\:HasOneFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::internal::HasOneFailure (const char * , const char * , const char * , const {\b TestPartResultArray} &  {\i results}, {\b TestPartResult::Type}  {\i type}, const std::string &  {\i substr})}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 631}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00636                                                        \{\par
00637   {\cf17 const} std::string expected(type == TestPartResult::kFatalFailure ?\par
00638                         {\cf22 "1 fatal failure"} :\par
00639                         {\cf22 "1 non-fatal failure"});\par
00640   Message msg;\par
00641   {\cf19 if} (results.size() != 1) \{\par
00642     msg << {\cf22 "Expected: "} << expected << {\cf22 "\\n"}\par
00643         << {\cf22 "  Actual: "} << results.size() << {\cf22 " failures"};\par
00644     {\cf19 for} ({\cf18 int} i = 0; i < results.size(); i++) \{\par
00645       msg << {\cf22 "\\n"} << results.GetTestPartResult(i);\par
00646     \}\par
00647     {\cf19 return} AssertionFailure() << msg;\par
00648   \}\par
00649 \par
00650   {\cf17 const} TestPartResult& r = results.GetTestPartResult(0);\par
00651   {\cf19 if} (r.type() != type) \{\par
00652     {\cf19 return} AssertionFailure() << {\cf22 "Expected: "} << expected << {\cf22 "\\n"}\par
00653                               << {\cf22 "  Actual:\\n"}\par
00654                               << r;\par
00655   \}\par
00656 \par
00657   {\cf19 if} (strstr(r.message(), substr.c_str()) == NULL) \{\par
00658     {\cf19 return} AssertionFailure() << {\cf22 "Expected: "} << expected << {\cf22 " containing \\""}\par
00659                               << substr << {\cf22 "\\"\\n"}\par
00660                               << {\cf22 "  Actual:\\n"}\par
00661                               << r;\par
00662   \}\par
00663 \par
00664   {\cf19 return} AssertionSuccess();\par
00665 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionFailure()}, {\b testing::AssertionSuccess()}, {\b testing::TestPartResultArray::GetTestPartResult()}, {\b testing::TestPartResult::kFatalFailure}, {\b testing::TestPartResult::message()}, {\b testing::TestPartResultArray::size()} \'E8 {\b testing::TestPartResult::type()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::SingleFailureChecker::~SingleFailureChecker()}.}\par
}
{\xe \v ImplicitCast_\:testing::internal}
{\xe \v testing::internal\:ImplicitCast_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename To > To testing::internal::ImplicitCast_ (To  {\i x}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1378}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01378 \{ {\cf19 return} x; \}\par
}
}
{\xe \v InitGoogleTestImpl\:testing::internal}
{\xe \v testing::internal\:InitGoogleTestImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > void testing::internal::InitGoogleTestImpl (int *  {\i argc}, CharType **  {\i argv})}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 5343}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 05343                                                     \{\par
05344   {\cf20 // We don't want to run the initialization code twice.}\par
05345   {\cf19 if} (GTestIsInitialized()) {\cf19 return};\par
05346 \par
05347   {\cf19 if} (*argc <= 0) {\cf19 return};\par
05348 \par
05349   g_argvs.clear();\par
05350   {\cf19 for} ({\cf18 int} i = 0; i != *argc; i++) \{\par
05351     g_argvs.push_back(StreamableToString(argv[i]));\par
05352   \}\par
05353 \par
05354   ParseGoogleTestFlagsOnly(argc, argv);\par
05355   GetUnitTestImpl()->PostFlagParsingInit();\par
05356 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b g_argvs}, {\b GetUnitTestImpl()}, {\b ParseGoogleTestFlagsOnly()}, {\b testing::internal::UnitTestImpl::PostFlagParsingInit()} \'E8 {\b StreamableToString()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::InitGoogleTest()}.}\par
}
{\xe \v Int32FromEnvOrDie\:testing::internal}
{\xe \v testing::internal\:Int32FromEnvOrDie}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int32} testing::internal::Int32FromEnvOrDie (const char *  {\i env_var}, {\b Int32}  {\i default_val})}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4759}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04759                                                             \{\par
04760   {\cf17 const} {\cf18 char}* str_val = posix::GetEnv(var);\par
04761   {\cf19 if} (str_val == NULL) \{\par
04762     {\cf19 return} default_val;\par
04763   \}\par
04764 \par
04765   Int32 result;\par
04766   {\cf19 if} (!ParseInt32(Message() << {\cf22 "The value of environment variable "} << var,\par
04767                   str_val, &result)) \{\par
04768     exit(EXIT_FAILURE);\par
04769   \}\par
04770   {\cf19 return} result;\par
04771 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::posix::GetEnv()} \'E8 {\b ParseInt32()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::FilterTests()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart()} \'E8 {\b ShouldShard()}.}\par
}
{\xe \v Int32FromGTestEnv\:testing::internal}
{\xe \v testing::internal\:Int32FromGTestEnv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int32} testing::internal::Int32FromGTestEnv (const char *  {\i flag}, {\b Int32}  {\i default_val})}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1186}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01186                                                                \{\par
01187 {\cf21 #if defined(GTEST_GET_INT32_FROM_ENV_)}\par
01188   {\cf19 return} GTEST_GET_INT32_FROM_ENV_(flag, default_value);\par
01189 {\cf21 #endif  }{\cf20 // defined(GTEST_GET_INT32_FROM_ENV_)}\par
01190   {\cf17 const} std::string env_var = FlagToEnvVar(flag);\par
01191   {\cf17 const} {\cf18 char}* {\cf17 const} string_value = posix::GetEnv(env_var.c_str());\par
01192   {\cf19 if} (string_value == NULL) \{\par
01193     {\cf20 // The environment variable is not set.}\par
01194     {\cf19 return} default_value;\par
01195   \}\par
01196 \par
01197   Int32 result = default_value;\par
01198   {\cf19 if} (!ParseInt32(Message() << {\cf22 "Environment variable "} << env_var,\par
01199                   string_value, &result)) \{\par
01200     printf({\cf22 "The default value %s is used.\\n"},\par
01201            (Message() << default_value).GetString().c_str());\par
01202     fflush(stdout);\par
01203     {\cf19 return} default_value;\par
01204   \}\par
01205 \par
01206   {\cf19 return} result;\par
01207 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::posix::GetEnv()} \'E8 {\b ParseInt32()}.}\par
}
{\xe \v IsAlNum\:testing::internal}
{\xe \v testing::internal\:IsAlNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsAlNum (char  {\i ch}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2286}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02286                              \{\par
02287   {\cf19 return} isalnum({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
02288 \}\par
}
}
{\xe \v IsAlpha\:testing::internal}
{\xe \v testing::internal\:IsAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsAlpha (char  {\i ch}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2283}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02283                              \{\par
02284   {\cf19 return} isalpha({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
02285 \}\par
}
}
{\xe \v IsContainerTest\:testing::internal}
{\xe \v testing::internal\:IsContainerTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class C > {\b IsContainer} testing::internal::IsContainerTest (int , typename C::iterator *  = {\f2 NULL}, typename C::const_iterator *  = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 933}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00935                                                                 \{\par
00936   {\cf19 return} 0;\par
00937 \}\par
}
}
{\xe \v IsContainerTest\:testing::internal}
{\xe \v testing::internal\:IsContainerTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class C > {\b IsNotContainer} testing::internal::IsContainerTest (long )}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 941}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00941 \{ {\cf19 return} {\cf23 '\\0'}; \}\par
}
}
{\xe \v IsDigit\:testing::internal}
{\xe \v testing::internal\:IsDigit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsDigit (char  {\i ch}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2289}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02289                              \{\par
02290   {\cf19 return} isdigit({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
02291 \}\par
}
}
{\xe \v IsLower\:testing::internal}
{\xe \v testing::internal\:IsLower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsLower (char  {\i ch}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2292}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02292                              \{\par
02293   {\cf19 return} islower({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
02294 \}\par
}
}
{\xe \v IsNullLiteralHelper\:testing::internal}
{\xe \v testing::internal\:IsNullLiteralHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char(& testing::internal::IsNullLiteralHelper (  {\i ...}))[2]}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IsNullLiteralHelper\:testing::internal}
{\xe \v testing::internal\:IsNullLiteralHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char testing::internal::IsNullLiteralHelper (Secret *  {\i p})}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IsPrintableAscii\:testing::internal}
{\xe \v testing::internal\:IsPrintableAscii}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsPrintableAscii (wchar_t  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 137}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00137                                         \{\par
00138   {\cf19 return} 0x20 <= c && c <= 0x7E;\par
00139 \}\par
}
}
{\xe \v IsSpace\:testing::internal}
{\xe \v testing::internal\:IsSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsSpace (char  {\i ch}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2295}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02295                              \{\par
02296   {\cf19 return} isspace({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
02297 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b StripTrailingSpaces()}.}\par
}
{\xe \v IsTrue\:testing::internal}
{\xe \v testing::internal\:IsTrue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsTrue (bool  {\i condition})}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4985}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04985 \{ {\cf19 return} condition; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b AlwaysTrue()} \'E8 {\b testing::internal::scoped_ptr< T >::reset()}.}\par
}
{\xe \v IsUpper\:testing::internal}
{\xe \v testing::internal\:IsUpper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsUpper (char  {\i ch}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2298}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02298                              \{\par
02299   {\cf19 return} isupper({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
02300 \}\par
}
}
{\xe \v IsUtf16SurrogatePair\:testing::internal}
{\xe \v testing::internal\:IsUtf16SurrogatePair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsUtf16SurrogatePair (wchar_t  {\i first}, wchar_t  {\i second}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1791}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01791                                                                 \{\par
01792   {\cf19 return} {\cf17 sizeof}(wchar_t) == 2 &&\par
01793       (first & 0xFC00) == 0xD800 && (second & 0xFC00) == 0xDC00;\par
01794 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b WideStringToUtf8()}.}\par
}
{\xe \v IsXDigit\:testing::internal}
{\xe \v testing::internal\:IsXDigit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsXDigit (char  {\i ch}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2301}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02301                               \{\par
02302   {\cf19 return} isxdigit({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
02303 \}\par
}
}
{\xe \v IsXDigit\:testing::internal}
{\xe \v testing::internal\:IsXDigit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::IsXDigit (wchar_t  {\i ch}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2304}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02304                                  \{\par
02305   {\cf17 const} {\cf18 unsigned} {\cf18 char} low_byte = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch);\par
02306   {\cf19 return} ch == low_byte && isxdigit(low_byte) != 0;\par
02307 \}\par
}
}
{\xe \v LogToStderr\:testing::internal}
{\xe \v testing::internal\:LogToStderr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::LogToStderr (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1310}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01310 \{\}\par
}
}
{\xe \v make_linked_ptr\:testing::internal}
{\xe \v testing::internal\:make_linked_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b linked_ptr}< T > testing::internal::make_linked_ptr (T *  {\i ptr})}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 236}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00236                                       \{\par
00237   {\cf19 return} linked_ptr<T>(ptr);\par
00238 \}\par
}
}
{\xe \v MakeAndRegisterTestInfo\:testing::internal}
{\xe \v testing::internal\:MakeAndRegisterTestInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestInfo} * testing::internal::MakeAndRegisterTestInfo (const char *  {\i test_case_name}, const char *  {\i name}, const char *  {\i type_param}, const char *  {\i value_param}, {\b CodeLocation}  {\i code_location}, {\b TypeId}  {\i fixture_class_id}, {\b SetUpTestCaseFunc}  {\i set_up_tc}, {\b TearDownTestCaseFunc}  {\i tear_down_tc}, {\b TestFactoryBase} *  {\i factory})}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2540}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02549                               \{\par
02550   TestInfo* {\cf17 const} test_info =\par
02551       {\cf17 new} TestInfo(test_case_name, name, type_param, value_param,\par
02552                    code_location, fixture_class_id, factory);\par
02553   GetUnitTestImpl()->AddTestInfo(set_up_tc, tear_down_tc, test_info);\par
02554   {\cf19 return} test_info;\par
02555 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UnitTestImpl::AddTestInfo()} \'E8 {\b GetUnitTestImpl()}.}\par
}
{\xe \v move\:testing::internal}
{\xe \v testing::internal\:move}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > const T & testing::internal::move (const T &  {\i t})}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1352}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01352                           \{\par
01353   {\cf19 return} t;\par
01354 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::edit_distance::CalculateOptimalEdits()}.}\par
}
{\xe \v operator!=\:testing::internal}
{\xe \v testing::internal\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool testing::internal::operator!= (T *  {\i ptr}, const {\b linked_ptr}< T > &  {\i x}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 228}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00228                                                 \{\par
00229   {\cf19 return} ptr != x.get();\par
00230 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::linked_ptr< T >::get()}.}\par
}
{\xe \v operator==\:testing::internal}
{\xe \v testing::internal\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool testing::internal::operator== (T *  {\i ptr}, const {\b linked_ptr}< T > &  {\i x}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 223}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00223                                                 \{\par
00224   {\cf19 return} ptr == x.get();\par
00225 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::linked_ptr< T >::get()}.}\par
}
{\xe \v ParseBoolFlag\:testing::internal}
{\xe \v testing::internal\:ParseBoolFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ParseBoolFlag (const char *  {\i str}, const char *  {\i flag}, bool *  {\i value})}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 5052}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 05052                                                                    \{\par
05053   {\cf20 // Gets the value of the flag as a string.}\par
05054   {\cf17 const} {\cf18 char}* {\cf17 const} value_str = ParseFlagValue(str, flag, {\cf17 true});\par
05055 \par
05056   {\cf20 // Aborts if the parsing failed.}\par
05057   {\cf19 if} (value_str == NULL) {\cf19 return} {\cf17 false};\par
05058 \par
05059   {\cf20 // Converts the string value to a bool.}\par
05060   *value = !(*value_str == {\cf23 '0'} || *value_str == {\cf23 'f'} || *value_str == {\cf23 'F'});\par
05061   {\cf19 return} {\cf17 true};\par
05062 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ParseFlagValue()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()} \'E8 {\b ParseGoogleTestFlagsOnlyImpl()}.}\par
}
{\xe \v ParseFlagValue\:testing::internal}
{\xe \v testing::internal\:ParseFlagValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::internal::ParseFlagValue (const char *  {\i str}, const char *  {\i flag}, bool  {\i def_optional})}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 5014}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 05016                                               \{\par
05017   {\cf20 // str and flag must not be NULL.}\par
05018   {\cf19 if} (str == NULL || flag == NULL) {\cf19 return} NULL;\par
05019 \par
05020   {\cf20 // The flag must start with "--" followed by GTEST_FLAG_PREFIX_.}\par
05021   {\cf17 const} std::string flag_str = std::string({\cf22 "--"}) + GTEST_FLAG_PREFIX_ + flag;\par
05022   {\cf17 const} {\cf18 size_t} flag_len = flag_str.length();\par
05023   {\cf19 if} (strncmp(str, flag_str.c_str(), flag_len) != 0) {\cf19 return} NULL;\par
05024 \par
05025   {\cf20 // Skips the flag name.}\par
05026   {\cf17 const} {\cf18 char}* flag_end = str + flag_len;\par
05027 \par
05028   {\cf20 // When def_optional is true, it's OK to not have a "=value" part.}\par
05029   {\cf19 if} (def_optional && (flag_end[0] == {\cf23 '\\0'})) \{\par
05030     {\cf19 return} flag_end;\par
05031   \}\par
05032 \par
05033   {\cf20 // If def_optional is true and there are more characters after the}\par
05034   {\cf20 // flag name, or if def_optional is false, there must be a '=' after}\par
05035   {\cf20 // the flag name.}\par
05036   {\cf19 if} (flag_end[0] != {\cf23 '='}) {\cf19 return} NULL;\par
05037 \par
05038   {\cf20 // Returns the string after "=".}\par
05039   {\cf19 return} flag_end + 1;\par
05040 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GTEST_FLAG_PREFIX_}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseBoolFlag()}, {\b ParseInt32Flag()} \'E8 {\b ParseStringFlag()}.}\par
}
{\xe \v ParseGoogleTestFlag\:testing::internal}
{\xe \v testing::internal\:ParseGoogleTestFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ParseGoogleTestFlag (const char *const  {\i arg})}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 5222}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 05222                                                 \{\par
05223   {\cf19 return} ParseBoolFlag(arg, kAlsoRunDisabledTestsFlag,\par
05224                        &GTEST_FLAG(also_run_disabled_tests)) ||\par
05225       ParseBoolFlag(arg, kBreakOnFailureFlag,\par
05226                     &GTEST_FLAG(break_on_failure)) ||\par
05227       ParseBoolFlag(arg, kCatchExceptionsFlag,\par
05228                     &GTEST_FLAG(catch_exceptions)) ||\par
05229       ParseStringFlag(arg, kColorFlag, &GTEST_FLAG(color)) ||\par
05230       ParseStringFlag(arg, kDeathTestStyleFlag,\par
05231                       &GTEST_FLAG(death_test_style)) ||\par
05232       ParseBoolFlag(arg, kDeathTestUseFork,\par
05233                     &GTEST_FLAG(death_test_use_fork)) ||\par
05234       ParseStringFlag(arg, kFilterFlag, &GTEST_FLAG(filter)) ||\par
05235       ParseStringFlag(arg, kInternalRunDeathTestFlag,\par
05236                       &GTEST_FLAG(internal_run_death_test)) ||\par
05237       ParseBoolFlag(arg, kListTestsFlag, &GTEST_FLAG(list_tests)) ||\par
05238       ParseStringFlag(arg, kOutputFlag, &GTEST_FLAG(output)) ||\par
05239       ParseBoolFlag(arg, kPrintTimeFlag, &GTEST_FLAG(print_time)) ||\par
05240       ParseInt32Flag(arg, kRandomSeedFlag, &GTEST_FLAG(random_seed)) ||\par
05241       ParseInt32Flag(arg, kRepeatFlag, &GTEST_FLAG(repeat)) ||\par
05242       ParseBoolFlag(arg, kShuffleFlag, &GTEST_FLAG(shuffle)) ||\par
05243       ParseInt32Flag(arg, kStackTraceDepthFlag,\par
05244                      &GTEST_FLAG(stack_trace_depth)) ||\par
05245       ParseStringFlag(arg, kStreamResultToFlag,\par
05246                       &GTEST_FLAG(stream_result_to)) ||\par
05247       ParseBoolFlag(arg, kThrowOnFailureFlag,\par
05248                     &GTEST_FLAG(throw_on_failure));\par
05249 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GTEST_FLAG}, {\b kAlsoRunDisabledTestsFlag}, {\b kBreakOnFailureFlag}, {\b kCatchExceptionsFlag}, {\b kColorFlag}, {\b kDeathTestStyleFlag}, {\b kDeathTestUseFork}, {\b kFilterFlag}, {\b kInternalRunDeathTestFlag}, {\b kListTestsFlag}, {\b kOutputFlag}, {\b kPrintTimeFlag}, {\b kRandomSeedFlag}, {\b kRepeatFlag}, {\b kShuffleFlag}, {\b kStackTraceDepthFlag}, {\b kStreamResultToFlag}, {\b kThrowOnFailureFlag}, {\b ParseBoolFlag()}, {\b ParseInt32Flag()} \'E8 {\b ParseStringFlag()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlagsOnlyImpl()}.}\par
}
{\xe \v ParseGoogleTestFlagsOnly\:testing::internal}
{\xe \v testing::internal\:ParseGoogleTestFlagsOnly}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::ParseGoogleTestFlagsOnly (int *  {\i argc}, char **  {\i argv})}}
\par
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 5331}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 05331                                                       \{\par
05332   ParseGoogleTestFlagsOnlyImpl(argc, argv);\par
05333 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ParseGoogleTestFlagsOnlyImpl()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b InitGoogleTestImpl()}.}\par
}
{\xe \v ParseGoogleTestFlagsOnly\:testing::internal}
{\xe \v testing::internal\:ParseGoogleTestFlagsOnly}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::ParseGoogleTestFlagsOnly (int *  {\i argc}, wchar_t **  {\i argv})}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 5334}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 05334                                                          \{\par
05335   ParseGoogleTestFlagsOnlyImpl(argc, argv);\par
05336 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ParseGoogleTestFlagsOnlyImpl()}.}\par
}
{\xe \v ParseGoogleTestFlagsOnlyImpl\:testing::internal}
{\xe \v testing::internal\:ParseGoogleTestFlagsOnlyImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > void testing::internal::ParseGoogleTestFlagsOnlyImpl (int *  {\i argc}, CharType **  {\i argv})}}
\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 5278}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 05278                                                               \{\par
05279   {\cf19 for} ({\cf18 int} i = 1; i < *argc; i++) \{\par
05280     {\cf17 const} std::string arg_string = StreamableToString(argv[i]);\par
05281     {\cf17 const} {\cf18 char}* {\cf17 const} arg = arg_string.c_str();\par
05282 \par
05283     {\cf17 using} internal::ParseBoolFlag;\par
05284     {\cf17 using} internal::ParseInt32Flag;\par
05285     {\cf17 using} internal::ParseStringFlag;\par
05286 \par
05287     {\cf18 bool} remove_flag = {\cf17 false};\par
05288     {\cf19 if} (ParseGoogleTestFlag(arg)) \{\par
05289       remove_flag = {\cf17 true};\par
05290 {\cf21 #if GTEST_USE_OWN_FLAGFILE_FLAG_}\par
05291     \} {\cf19 else} {\cf19 if} (ParseStringFlag(arg, kFlagfileFlag, &GTEST_FLAG(flagfile))) \{\par
05292       LoadFlagsFromFile(GTEST_FLAG(flagfile));\par
05293       remove_flag = {\cf17 true};\par
05294 {\cf21 #endif  }{\cf20 // GTEST_USE_OWN_FLAGFILE_FLAG_}\par
05295     \} {\cf19 else} {\cf19 if} (arg_string == {\cf22 "--help"} || arg_string == {\cf22 "-h"} ||\par
05296                arg_string == {\cf22 "-?"} || arg_string == {\cf22 "/?"} ||\par
05297                HasGoogleTestFlagPrefix(arg)) \{\par
05298       {\cf20 // Both help flag and unrecognized Google Test flags (excluding}\par
05299       {\cf20 // internal ones) trigger help display.}\par
05300       g_help_flag = {\cf17 true};\par
05301     \}\par
05302 \par
05303     {\cf19 if} (remove_flag) \{\par
05304       {\cf20 // Shift the remainder of the argv list left by one.  Note}\par
05305       {\cf20 // that argv has (*argc + 1) elements, the last one always being}\par
05306       {\cf20 // NULL.  The following loop moves the trailing NULL element as}\par
05307       {\cf20 // well.}\par
05308       {\cf19 for} ({\cf18 int} j = i; j != *argc; j++) \{\par
05309         argv[j] = argv[j + 1];\par
05310       \}\par
05311 \par
05312       {\cf20 // Decrements the argument count.}\par
05313       (*argc)--;\par
05314 \par
05315       {\cf20 // We also need to decrement the iterator as we just removed}\par
05316       {\cf20 // an element.}\par
05317       i--;\par
05318     \}\par
05319   \}\par
05320 \par
05321   {\cf19 if} (g_help_flag) \{\par
05322     {\cf20 // We print the help here instead of in RUN_ALL_TESTS(), as the}\par
05323     {\cf20 // latter may not be called at all if the user is using Google}\par
05324     {\cf20 // Test with another testing framework.}\par
05325     PrintColorEncoded(kColorEncodedHelpMessage);\par
05326   \}\par
05327 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b g_help_flag}, {\b GTEST_FLAG}, {\b kFlagfileFlag}, {\b ParseBoolFlag()}, {\b ParseGoogleTestFlag()}, {\b ParseInt32Flag()}, {\b ParseStringFlag()} \'E8 {\b StreamableToString()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlagsOnly()}.}\par
}
{\xe \v ParseInt32\:testing::internal}
{\xe \v testing::internal\:ParseInt32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ParseInt32 (const {\b Message} &  {\i src_text}, const char *  {\i str}, {\b Int32} *  {\i value})}}
\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1131}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01131                                                                         \{\par
01132   {\cf20 // Parses the environment variable as a decimal integer.}\par
01133   {\cf18 char}* end = NULL;\par
01134   {\cf17 const} {\cf18 long} long_value = strtol(str, &end, 10);  {\cf20 // NOLINT}\par
01135 \par
01136   {\cf20 // Has strtol() consumed all characters in the string?}\par
01137   {\cf19 if} (*end != {\cf23 '\\0'}) \{\par
01138     {\cf20 // No - an invalid character was encountered.}\par
01139     Message msg;\par
01140     msg << {\cf22 "WARNING: "} << src_text\par
01141         << {\cf22 " is expected to be a 32-bit integer, but actually"}\par
01142         << {\cf22 " has value \\""} << str << {\cf22 "\\".\\n"};\par
01143     printf({\cf22 "%s"}, msg.GetString().c_str());\par
01144     fflush(stdout);\par
01145     {\cf19 return} {\cf17 false};\par
01146   \}\par
01147 \par
01148   {\cf20 // Is the parsed value in the range of an Int32?}\par
01149   {\cf17 const} Int32 result = {\cf17 static_cast<}Int32{\cf17 >}(long_value);\par
01150   {\cf19 if} (long_value == LONG_MAX || long_value == LONG_MIN ||\par
01151       {\cf20 // The parsed value overflows as a long.  (strtol() returns}\par
01152       {\cf20 // LONG_MAX or LONG_MIN when the input overflows.)}\par
01153       result != long_value\par
01154       {\cf20 // The parsed value overflows as an Int32.}\par
01155       ) \{\par
01156     Message msg;\par
01157     msg << {\cf22 "WARNING: "} << src_text\par
01158         << {\cf22 " is expected to be a 32-bit integer, but actually"}\par
01159         << {\cf22 " has value "} << str << {\cf22 ", which overflows.\\n"};\par
01160     printf({\cf22 "%s"}, msg.GetString().c_str());\par
01161     fflush(stdout);\par
01162     {\cf19 return} {\cf17 false};\par
01163   \}\par
01164 \par
01165   *value = result;\par
01166   {\cf19 return} {\cf17 true};\par
01167 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::Message::GetString()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b Int32FromEnvOrDie()}, {\b Int32FromGTestEnv()} \'E8 {\b ParseInt32Flag()}.}\par
}
{\xe \v ParseInt32Flag\:testing::internal}
{\xe \v testing::internal\:ParseInt32Flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ParseInt32Flag (const char *  {\i str}, const char *  {\i flag}, {\b Int32} *  {\i value})}}
\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 5069}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 05069                                                                      \{\par
05070   {\cf20 // Gets the value of the flag as a string.}\par
05071   {\cf17 const} {\cf18 char}* {\cf17 const} value_str = ParseFlagValue(str, flag, {\cf17 false});\par
05072 \par
05073   {\cf20 // Aborts if the parsing failed.}\par
05074   {\cf19 if} (value_str == NULL) {\cf19 return} {\cf17 false};\par
05075 \par
05076   {\cf20 // Sets *value to the value of the flag.}\par
05077   {\cf19 return} ParseInt32(Message() << {\cf22 "The value of flag --"} << flag,\par
05078                     value_str, value);\par
05079 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ParseFlagValue()} \'E8 {\b ParseInt32()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()} \'E8 {\b ParseGoogleTestFlagsOnlyImpl()}.}\par
}
{\xe \v ParseStringFlag\:testing::internal}
{\xe \v testing::internal\:ParseStringFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ParseStringFlag (const char *  {\i str}, const char *  {\i flag}, std::string *  {\i value})}}
\par
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 5086}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 05086                                                                           \{\par
05087   {\cf20 // Gets the value of the flag as a string.}\par
05088   {\cf17 const} {\cf18 char}* {\cf17 const} value_str = ParseFlagValue(str, flag, {\cf17 false});\par
05089 \par
05090   {\cf20 // Aborts if the parsing failed.}\par
05091   {\cf19 if} (value_str == NULL) {\cf19 return} {\cf17 false};\par
05092 \par
05093   {\cf20 // Sets *value to the value of the flag.}\par
05094   *value = value_str;\par
05095   {\cf19 return} {\cf17 true};\par
05096 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ParseFlagValue()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()} \'E8 {\b ParseGoogleTestFlagsOnlyImpl()}.}\par
}
{\xe \v PrintCharAndCodeTo\:testing::internal}
{\xe \v testing::internal\:PrintCharAndCodeTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UnsignedChar , typename Char > void testing::internal::PrintCharAndCodeTo (Char  {\i c}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 217}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00217                                              \{\par
00218   {\cf20 // First, print c as a literal in the most readable form we can find.}\par
00219   *os << (({\cf17 sizeof}(c) > 1) ? {\cf22 "L'"} : {\cf22 "'"});\par
00220   {\cf17 const} CharFormat format = PrintAsCharLiteralTo<UnsignedChar>(c, os);\par
00221   *os << {\cf22 "'"};\par
00222 \par
00223   {\cf20 // To aid user debugging, we also print c's code in decimal, unless}\par
00224   {\cf20 // it's 0 (in which case c was printed as '\\\\0', making the code}\par
00225   {\cf20 // obvious).}\par
00226   {\cf19 if} (c == 0)\par
00227     {\cf19 return};\par
00228   *os << {\cf22 " ("} << {\cf17 static_cast<}{\cf18 int}{\cf17 >}(c);\par
00229 \par
00230   {\cf20 // For more convenience, we print c's code again in hexidecimal,}\par
00231   {\cf20 // unless c was already printed in the form '\\x##' or the code is in}\par
00232   {\cf20 // [1, 9].}\par
00233   {\cf19 if} (format == kHexEscape || (1 <= c && c <= 9)) \{\par
00234     {\cf20 // Do nothing.}\par
00235   \} {\cf19 else} \{\par
00236     *os << {\cf22 ", 0x"} << String::FormatHexInt({\cf17 static_cast<}UnsignedChar{\cf17 >}(c));\par
00237   \}\par
00238   *os << {\cf22 ")"};\par
00239 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::String::FormatHexInt()} \'E8 {\b kHexEscape}.}\par
}
{\xe \v PrintFullTestCommentIfPresent\:testing::internal}
{\xe \v testing::internal\:PrintFullTestCommentIfPresent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintFullTestCommentIfPresent (const {\b TestInfo} &  {\i test_info})}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3007}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03007                                                               \{\par
03008   {\cf17 const} {\cf18 char}* {\cf17 const} type_param = test_info.type_param();\par
03009   {\cf17 const} {\cf18 char}* {\cf17 const} value_param = test_info.value_param();\par
03010 \par
03011   {\cf19 if} (type_param != NULL || value_param != NULL) \{\par
03012     printf({\cf22 ", where "});\par
03013     {\cf19 if} (type_param != NULL) \{\par
03014       printf({\cf22 "%s = %s"}, kTypeParamLabel, type_param);\par
03015       {\cf19 if} (value_param != NULL)\par
03016         printf({\cf22 " and "});\par
03017     \}\par
03018     {\cf19 if} (value_param != NULL) \{\par
03019       printf({\cf22 "%s = %s"}, kValueParamLabel, value_param);\par
03020     \}\par
03021   \}\par
03022 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestInfo::type_param()} \'E8 {\b testing::TestInfo::value_param()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestEnd()}.}\par
}
{\xe \v PrintRawArrayTo\:testing::internal}
{\xe \v testing::internal\:PrintRawArrayTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::PrintRawArrayTo (const T  {\i a}[], size_t  {\i count}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 561}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00561                                                                 \{\par
00562   UniversalPrint(a[0], os);\par
00563   {\cf19 for} ({\cf18 size_t} i = 1; i != count; i++) \{\par
00564     *os << {\cf22 ", "};\par
00565     UniversalPrint(a[i], os);\par
00566   \}\par
00567 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b UniversalPrint()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b UniversalPrintArray()}.}\par
}
{\xe \v PrintStringTo\:testing::internal}
{\xe \v testing::internal\:PrintStringTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::PrintStringTo (const ::std::string &  {\i s}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b PrintTo()}.}\par
}
{\xe \v PrintStringTo\:testing::internal}
{\xe \v testing::internal\:PrintStringTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintStringTo (const ::std::string &  {\i s}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 354}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00354                                                     \{\par
00355   PrintCharsAsStringTo(s.data(), s.size(), os);\par
00356 \}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (bool  {\i x}, ::std::ostream *  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 508}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00508                                             \{\par
00509   *os << (x ? {\cf22 "true"} : {\cf22 "false"});\par
00510 \}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (char *  {\i s}, ::std::ostream *  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 523}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00523                                              \{\par
00524   PrintTo(ImplicitCast_<const char*>(s), os);\par
00525 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b PrintTo()}.}\par
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (char  {\i c}, ::std::ostream *  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 500}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00500                                             \{\par
00501   {\cf20 // When printing a plain char, we always treat it as unsigned.  This}\par
00502   {\cf20 // way, the output won't be affected by whether the compiler thinks}\par
00503   {\cf20 // char is signed or not.}\par
00504   PrintTo({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(c), os);\par
00505 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b PrintTo()}.}\par
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T1 , typename T2 > void testing::internal::PrintTo (const ::std::pair< T1, T2 > &  {\i value}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 689}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00689                                                            \{\par
00690   *os << {\cf23 '('};\par
00691   {\cf20 // We cannot use UniversalPrint(value.first, os) here, as T1 may be}\par
00692   {\cf20 // a reference type.  The same for printing value.second.}\par
00693   UniversalPrinter<T1>::Print(value.first, os);\par
00694   *os << {\cf22 ", "};\par
00695   UniversalPrinter<T2>::Print(value.second, os);\par
00696   *os << {\cf23 ')'};\par
00697 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UniversalPrinter< T >::Print()}.}\par
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (const ::std::string &  {\i s}, ::std::ostream *  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 578}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00578                                                         \{\par
00579   PrintStringTo(s, os);\par
00580 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b PrintStringTo()}.}\par
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::PrintTo (const char *  {\i s}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (const char *  {\i s}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 320}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00320                                          \{\par
00321   {\cf19 if} (s == NULL) \{\par
00322     *os << {\cf22 "NULL"};\par
00323   \} {\cf19 else} \{\par
00324     *os << ImplicitCast_<const void*>(s) << {\cf22 " pointing to "};\par
00325     PrintCharsAsStringTo(s, strlen(s), os);\par
00326   \}\par
00327 \}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (const signed char *  {\i s}, ::std::ostream *  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 529}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00529                                                           \{\par
00530   PrintTo(ImplicitCast_<const void*>(s), os);\par
00531 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b PrintTo()}.}\par
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::PrintTo (const T &  {\i value}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 459}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00459                                              \{\par
00460   {\cf20 // DefaultPrintTo() is overloaded.  The type of its first argument}\par
00461   {\cf20 // determines which version will be picked.}\par
00462   {\cf20 //}\par
00463   {\cf20 // Note that we check for container types here, prior to we check}\par
00464   {\cf20 // for protocol message types in our operator<<.  The rationale is:}\par
00465   {\cf20 //}\par
00466   {\cf20 // For protocol messages, we want to give people a chance to}\par
00467   {\cf20 // override Google Mock's format by defining a PrintTo() or}\par
00468   {\cf20 // operator<<.  For STL containers, other formats can be}\par
00469   {\cf20 // incompatible with Google Mock's format for the container}\par
00470   {\cf20 // elements; therefore we check for container types here to ensure}\par
00471   {\cf20 // that our format is used.}\par
00472   {\cf20 //}\par
00473   {\cf20 // Note that MSVC and clang-cl do allow an implicit conversion from}\par
00474   {\cf20 // pointer-to-function to pointer-to-object, but clang-cl warns on it.}\par
00475   {\cf20 // So don't use ImplicitlyConvertible if it can be helped since it will}\par
00476   {\cf20 // cause this warning, and use a separate overload of DefaultPrintTo for}\par
00477   {\cf20 // function pointers so that the `*os << p` in the object pointer overload}\par
00478   {\cf20 // doesn't cause that warning either.}\par
00479   DefaultPrintTo(\par
00480       WrapPrinterType<{\cf17 sizeof}(IsContainerTest<T>(0)) == {\cf17 sizeof}(IsContainer)\par
00481           ? kPrintContainer : !is_pointer<T>::value\par
00482                 ? kPrintOther\par
00483 #{\cf19 if} GTEST_LANG_CXX11\par
00484                 : std::is_function<{\cf17 typename} std::remove_pointer<T>::type>::value\par
00485 #{\cf19 else}\par
00486                 : !internal::ImplicitlyConvertible<T, const void*>::value\par
00487 #endif\par
00488                       ? kPrintFunctionPointer\par
00489                       : kPrintPointer>(),\par
00490       value, os);\par
00491 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b DefaultPrintTo()}, {\b GTEST_LANG_CXX11}, {\b kPrintContainer}, {\b kPrintFunctionPointer}, {\b kPrintOther} \'E8 {\b kPrintPointer}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UniversalPrinter< T >::Print()} \'E8 {\b PrintTo()}.}\par
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (const unsigned char *  {\i s}, ::std::ostream *  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 535}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00535                                                             \{\par
00536   PrintTo(ImplicitCast_<const void*>(s), os);\par
00537 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b PrintTo()}.}\par
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::PrintTo (const wchar_t *  {\i s}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (const wchar_t *  {\i s}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 337}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00337                                             \{\par
00338   {\cf19 if} (s == NULL) \{\par
00339     *os << {\cf22 "NULL"};\par
00340   \} {\cf19 else} \{\par
00341     *os << ImplicitCast_<const void*>(s) << {\cf22 " pointing to "};\par
00342     PrintCharsAsStringTo(s, std::wcslen(s), os);\par
00343   \}\par
00344 \}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (signed char *  {\i s}, ::std::ostream *  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 532}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00532                                                     \{\par
00533   PrintTo(ImplicitCast_<const void*>(s), os);\par
00534 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b PrintTo()}.}\par
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (signed char  {\i c}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 244}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00244                                             \{\par
00245   PrintCharAndCodeTo<unsigned char>(c, os);\par
00246 \}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (unsigned char *  {\i s}, ::std::ostream *  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 538}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00538                                                       \{\par
00539   PrintTo(ImplicitCast_<const void*>(s), os);\par
00540 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b PrintTo()}.}\par
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (unsigned char  {\i c}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 241}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00241                                               \{\par
00242   PrintCharAndCodeTo<unsigned char>(c, os);\par
00243 \}\par
}
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (wchar_t *  {\i s}, ::std::ostream *  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 550}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00550                                                 \{\par
00551   PrintTo(ImplicitCast_<const wchar_t*>(s), os);\par
00552 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b PrintTo()}.}\par
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::PrintTo (wchar_t  {\i wc}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PrintTo\:testing::internal}
{\xe \v testing::internal\:PrintTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrintTo (wchar_t  {\i wc}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 250}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00250                                       \{\par
00251   PrintCharAndCodeTo<wchar_t>(wc, os);\par
00252 \}\par
}
}
{\xe \v ReadEntireFile\:testing::internal}
{\xe \v testing::internal\:ReadEntireFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::ReadEntireFile (FILE *  {\i file})}}
\par
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1063}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01063                                      \{\par
01064   {\cf17 const} {\cf18 size_t} file_size = GetFileSize(file);\par
01065   {\cf18 char}* {\cf17 const} buffer = {\cf17 new} {\cf18 char}[file_size];\par
01066 \par
01067   {\cf18 size_t} bytes_last_read = 0;  {\cf20 // # of bytes read in the last fread()}\par
01068   {\cf18 size_t} bytes_read = 0;       {\cf20 // # of bytes read so far}\par
01069 \par
01070   fseek(file, 0, SEEK_SET);\par
01071 \par
01072   {\cf20 // Keeps reading the file until we cannot read further or the}\par
01073   {\cf20 // pre-determined file size is reached.}\par
01074   {\cf19 do} \{\par
01075     bytes_last_read = fread(buffer+bytes_read, 1, file_size-bytes_read, file);\par
01076     bytes_read += bytes_last_read;\par
01077   \} {\cf19 while} (bytes_last_read > 0 && bytes_read < file_size);\par
01078 \par
01079   {\cf17 const} std::string content(buffer, bytes_read);\par
01080   {\cf17 delete}[] buffer;\par
01081 \par
01082   {\cf19 return} content;\par
01083 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GetFileSize()}.}\par
}
{\xe \v ReportFailureInUnknownLocation\:testing::internal}
{\xe \v testing::internal\:ReportFailureInUnknownLocation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::ReportFailureInUnknownLocation ({\b TestPartResult::Type}  {\i result_type}, const std::string &  {\i message})}}
\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2247}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02248                                                               \{\par
02249   {\cf20 // This function is a friend of UnitTest and as such has access to}\par
02250   {\cf20 // AddTestPartResult.}\par
02251   UnitTest::GetInstance()->AddTestPartResult(\par
02252       result_type,\par
02253       NULL,  {\cf20 // No info about the source file where the exception occurred.}\par
02254       -1,    {\cf20 // We have no info on which line caused the exception.}\par
02255       message,\par
02256       {\cf22 ""});   {\cf20 // No stack trace, either.}\par
02257 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::UnitTest::GetInstance()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b HandleExceptionsInMethodIfSupported()} \'E8 {\b HandleSehExceptionsInMethodIfSupported()}.}\par
}
{\xe \v ShouldRunTestOnShard\:testing::internal}
{\xe \v testing::internal\:ShouldRunTestOnShard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ShouldRunTestOnShard (int  {\i total_shards}, int  {\i shard_index}, int  {\i test_id})}}
\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4777}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04777                                                                           \{\par
04778   {\cf19 return} (test_id % total_shards) == shard_index;\par
04779 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::FilterTests()}.}\par
}
{\xe \v ShouldShard\:testing::internal}
{\xe \v testing::internal\:ShouldShard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ShouldShard (const char *  {\i total_shards_str}, const char *  {\i shard_index_str}, bool  {\i in_subprocess_for_death_test})}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4714}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04716                                                     \{\par
04717   {\cf19 if} (in_subprocess_for_death_test) \{\par
04718     {\cf19 return} {\cf17 false};\par
04719   \}\par
04720 \par
04721   {\cf17 const} Int32 total_shards = Int32FromEnvOrDie(total_shards_env, -1);\par
04722   {\cf17 const} Int32 shard_index = Int32FromEnvOrDie(shard_index_env, -1);\par
04723 \par
04724   {\cf19 if} (total_shards == -1 && shard_index == -1) \{\par
04725     {\cf19 return} {\cf17 false};\par
04726   \} {\cf19 else} {\cf19 if} (total_shards == -1 && shard_index != -1) \{\par
04727     {\cf17 const} Message msg = Message()\par
04728       << {\cf22 "Invalid environment variables: you have "}\par
04729       << kTestShardIndex << {\cf22 " = "} << shard_index\par
04730       << {\cf22 ", but have left "} << kTestTotalShards << {\cf22 " unset.\\n"};\par
04731     ColoredPrintf(COLOR_RED, {\cf22 "%s"}, msg.GetString().c_str());\par
04732     fflush(stdout);\par
04733     exit(EXIT_FAILURE);\par
04734   \} {\cf19 else} {\cf19 if} (total_shards != -1 && shard_index == -1) \{\par
04735     {\cf17 const} Message msg = Message()\par
04736       << {\cf22 "Invalid environment variables: you have "}\par
04737       << kTestTotalShards << {\cf22 " = "} << total_shards\par
04738       << {\cf22 ", but have left "} << kTestShardIndex << {\cf22 " unset.\\n"};\par
04739     ColoredPrintf(COLOR_RED, {\cf22 "%s"}, msg.GetString().c_str());\par
04740     fflush(stdout);\par
04741     exit(EXIT_FAILURE);\par
04742   \} {\cf19 else} {\cf19 if} (shard_index < 0 || shard_index >= total_shards) \{\par
04743     {\cf17 const} Message msg = Message()\par
04744       << {\cf22 "Invalid environment variables: we require 0 <= "}\par
04745       << kTestShardIndex << {\cf22 " < "} << kTestTotalShards\par
04746       << {\cf22 ", but you have "} << kTestShardIndex << {\cf22 "="} << shard_index\par
04747       << {\cf22 ", "} << kTestTotalShards << {\cf22 "="} << total_shards << {\cf22 ".\\n"};\par
04748     ColoredPrintf(COLOR_RED, {\cf22 "%s"}, msg.GetString().c_str());\par
04749     fflush(stdout);\par
04750     exit(EXIT_FAILURE);\par
04751   \}\par
04752 \par
04753   {\cf19 return} total_shards > 1;\par
04754 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b COLOR_RED}, {\b ColoredPrintf()}, {\b testing::Message::GetString()} \'E8 {\b Int32FromEnvOrDie()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart()} \'E8 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v ShouldUseColor\:testing::internal}
{\xe \v testing::internal\:ShouldUseColor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::ShouldUseColor (bool  {\i stdout_is_tty})}}
\par
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2913}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02913                                         \{\par
02914   {\cf17 const} {\cf18 char}* {\cf17 const} gtest_color = GTEST_FLAG(color).c_str();\par
02915 \par
02916   {\cf19 if} (String::CaseInsensitiveCStringEquals(gtest_color, {\cf22 "auto"})) \{\par
02917 {\cf21 #if GTEST_OS_WINDOWS}\par
02918     {\cf20 // On Windows the TERM variable is usually not set, but the}\par
02919     {\cf20 // console there does support colors.}\par
02920     {\cf19 return} stdout_is_tty;\par
02921 {\cf21 #else}\par
02922     {\cf20 // On non-Windows platforms, we rely on the TERM variable.}\par
02923     {\cf17 const} {\cf18 char}* {\cf17 const} term = posix::GetEnv({\cf22 "TERM"});\par
02924     {\cf17 const} {\cf18 bool} term_supports_color =\par
02925         String::CStringEquals(term, {\cf22 "xterm"}) ||\par
02926         String::CStringEquals(term, {\cf22 "xterm-color"}) ||\par
02927         String::CStringEquals(term, {\cf22 "xterm-256color"}) ||\par
02928         String::CStringEquals(term, {\cf22 "screen"}) ||\par
02929         String::CStringEquals(term, {\cf22 "screen-256color"}) ||\par
02930         String::CStringEquals(term, {\cf22 "tmux"}) ||\par
02931         String::CStringEquals(term, {\cf22 "tmux-256color"}) ||\par
02932         String::CStringEquals(term, {\cf22 "rxvt-unicode"}) ||\par
02933         String::CStringEquals(term, {\cf22 "rxvt-unicode-256color"}) ||\par
02934         String::CStringEquals(term, {\cf22 "linux"}) ||\par
02935         String::CStringEquals(term, {\cf22 "cygwin"});\par
02936     {\cf19 return} stdout_is_tty && term_supports_color;\par
02937 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
02938   \}\par
02939 \par
02940   {\cf19 return} String::CaseInsensitiveCStringEquals(gtest_color, {\cf22 "yes"}) ||\par
02941       String::CaseInsensitiveCStringEquals(gtest_color, {\cf22 "true"}) ||\par
02942       String::CaseInsensitiveCStringEquals(gtest_color, {\cf22 "t"}) ||\par
02943       String::CStringEquals(gtest_color, {\cf22 "1"});\par
02944   {\cf20 // We take "yes", "true", "t", and "1" as meaning "yes".  If the}\par
02945   {\cf20 // value is neither one of these nor "auto", we treat it as "no" to}\par
02946   {\cf20 // be conservative.}\par
02947 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::String::CaseInsensitiveCStringEquals()}, {\b testing::internal::String::CStringEquals()}, {\b testing::internal::posix::GetEnv()} \'E8 {\b GTEST_FLAG}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ColoredPrintf()}.}\par
}
{\xe \v Shuffle\:testing::internal}
{\xe \v testing::internal\:Shuffle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename E > void testing::internal::Shuffle ({\b internal::Random} *  {\i random}, std::vector< E > *  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 333}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00333                                                              \{\par
00334   ShuffleRange(random, 0, {\cf17 static_cast<}{\cf18 int}{\cf17 >}(v->size()), v);\par
00335 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ShuffleRange()}.}\par
}
{\xe \v ShuffleRange\:testing::internal}
{\xe \v testing::internal\:ShuffleRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename E > void testing::internal::ShuffleRange ({\b internal::Random} *  {\i random}, int  {\i begin}, int  {\i end}, std::vector< E > *  {\i v})}}
\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 312}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00313                                    \{\par
00314   {\cf17 const} {\cf18 int} size = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(v->size());\par
00315   GTEST_CHECK_(0 <= begin && begin <= size)\par
00316       << {\cf22 "Invalid shuffle range start "} << begin << {\cf22 ": must be in range [0, "}\par
00317       << size << {\cf22 "]."};\par
00318   GTEST_CHECK_(begin <= end && end <= size)\par
00319       << {\cf22 "Invalid shuffle range finish "} << end << {\cf22 ": must be in range ["}\par
00320       << begin << {\cf22 ", "} << size << {\cf22 "]."};\par
00321 \par
00322   {\cf20 // Fisher-Yates shuffle, from}\par
00323   {\cf20 // http://en.wikipedia.org/wiki/Fisher-Yates_shuffle}\par
00324   {\cf19 for} ({\cf18 int} range_width = end - begin; range_width >= 2; range_width--) \{\par
00325     {\cf17 const} {\cf18 int} last_in_range = begin + range_width - 1;\par
00326     {\cf17 const} {\cf18 int} selected = begin + random->Generate(range_width);\par
00327     std::swap((*v)[selected], (*v)[last_in_range]);\par
00328   \}\par
00329 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::Random::Generate()} \'E8 {\b GTEST_CHECK_}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b Shuffle()} \'E8 {\b testing::internal::UnitTestImpl::ShuffleTests()}.}\par
}
{\xe \v SkipPrefix\:testing::internal}
{\xe \v testing::internal\:SkipPrefix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::SkipPrefix (const char *  {\i prefix}, const char **  {\i pstr})}}
\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 5000}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 05000                                                        \{\par
05001   {\cf17 const} {\cf18 size_t} prefix_len = strlen(prefix);\par
05002   {\cf19 if} (strncmp(*pstr, prefix, prefix_len) == 0) \{\par
05003     *pstr += prefix_len;\par
05004     {\cf19 return} {\cf17 true};\par
05005   \}\par
05006   {\cf19 return} {\cf17 false};\par
05007 \}\par
}
}
{\xe \v SplitString\:testing::internal}
{\xe \v testing::internal\:SplitString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::SplitString (const ::std::string &  {\i str}, char  {\i delimiter}, ::std::vector< ::std::string > *  {\i dest})}}
\par
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 919}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00920                                               \{\par
00921   ::std::vector< ::std::string> parsed;\par
00922   ::std::string::size_type pos = 0;\par
00923   {\cf19 while} (::testing::internal::AlwaysTrue()) \{\par
00924     const ::std::string::size_type colon = str.find(delimiter, pos);\par
00925     {\cf19 if} (colon == ::std::string::npos) \{\par
00926       parsed.push_back(str.substr(pos));\par
00927       {\cf19 break};\par
00928     \} {\cf19 else} \{\par
00929       parsed.push_back(str.substr(pos, colon - pos));\par
00930       pos = colon + 1;\par
00931     \}\par
00932   \}\par
00933   dest->swap(parsed);\par
00934 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b AlwaysTrue()}.}\par
}
{\xe \v StreamableToString\:testing::internal}
{\xe \v testing::internal\:StreamableToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::string testing::internal::StreamableToString (const T &  {\i streamable})}}
\par
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-message.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 243}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00243                                                   \{\par
00244   {\cf19 return} (Message() << streamable).GetString();\par
00245 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b FormatCompilerIndependentFileLocation()}, {\b FormatFileLocation()}, {\b InitGoogleTestImpl()}, {\b testing::internal::FilePath::MakeFileName()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestCaseEnd()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestEnd()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd()} \'E8 {\b ParseGoogleTestFlagsOnlyImpl()}.}\par
}
{\xe \v StringFromGTestEnv\:testing::internal}
{\xe \v testing::internal\:StringFromGTestEnv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::StringFromGTestEnv (const char *  {\i flag}, const char *  {\i default_val})}}
\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1211}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01211                                                                           \{\par
01212 {\cf21 #if defined(GTEST_GET_STRING_FROM_ENV_)}\par
01213   {\cf19 return} GTEST_GET_STRING_FROM_ENV_(flag, default_value);\par
01214 {\cf21 #endif  }{\cf20 // defined(GTEST_GET_STRING_FROM_ENV_)}\par
01215   {\cf17 const} std::string env_var = FlagToEnvVar(flag);\par
01216   {\cf17 const} {\cf18 char}* value = posix::GetEnv(env_var.c_str());\par
01217   {\cf19 if} (value != NULL) \{\par
01218     {\cf19 return} value;\par
01219   \}\par
01220 \par
01221   {\cf20 // As a special case for the 'output' flag, if GTEST_OUTPUT is not}\par
01222   {\cf20 // set, we look for XML_OUTPUT_FILE, which is set by the Bazel build}\par
01223   {\cf20 // system.  The value of XML_OUTPUT_FILE is a filename without the}\par
01224   {\cf20 // "xml:" prefix of GTEST_OUTPUT.}\par
01225   {\cf20 //}\par
01226   {\cf20 // The net priority order after flag processing is thus:}\par
01227   {\cf20 //   --gtest_output command line flag}\par
01228   {\cf20 //   GTEST_OUTPUT environment variable}\par
01229   {\cf20 //   XML_OUTPUT_FILE environment variable}\par
01230   {\cf20 //   'default_value'}\par
01231   {\cf19 if} (strcmp(flag, {\cf22 "output"}) == 0) \{\par
01232     value = posix::GetEnv({\cf22 "XML_OUTPUT_FILE"});\par
01233     {\cf19 if} (value != NULL) \{\par
01234       {\cf19 return} std::string({\cf22 "xml:"}) + value;\par
01235     \}\par
01236   \}\par
01237   {\cf19 return} default_value;\par
01238 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::posix::GetEnv()}.}\par
}
{\xe \v StringStreamToString\:testing::internal}
{\xe \v testing::internal\:StringStreamToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::StringStreamToString (::std::stringstream *  {\i stream})}}
\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1979}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01979                                                     \{\par
01980   const ::std::string& str = ss->str();\par
01981   {\cf17 const} {\cf18 char}* {\cf17 const} start = str.c_str();\par
01982   {\cf17 const} {\cf18 char}* {\cf17 const} end = start + str.length();\par
01983 \par
01984   std::string result;\par
01985   result.reserve(2 * (end - start));\par
01986   {\cf19 for} ({\cf17 const} {\cf18 char}* ch = start; ch != end; ++ch) \{\par
01987     {\cf19 if} (*ch == {\cf23 '\\0'}) \{\par
01988       result += {\cf22 "\\\\0"};  {\cf20 // Replaces NUL with "\\\\0";}\par
01989     \} {\cf19 else} \{\par
01990       result += *ch;\par
01991     \}\par
01992   \}\par
01993 \par
01994   {\cf19 return} result;\par
01995 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CmpHelperFloatingPointEQ()}, {\b FloatingPointLE()}, {\b testing::Message::GetString()}, {\b testing::internal::XmlUnitTestResultPrinter::OnTestIterationEnd()} \'E8 {\b WideStringToUtf8()}.}\par
}
{\xe \v StripTrailingSpaces\:testing::internal}
{\xe \v testing::internal\:StripTrailingSpaces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::StripTrailingSpaces (std::string  {\i str}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2316}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02316                                                     \{\par
02317   std::string::iterator it = str.end();\par
02318   {\cf19 while} (it != str.begin() && IsSpace(*--it))\par
02319     it = str.erase(it);\par
02320   {\cf19 return} str;\par
02321 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b IsSpace()}.}\par
}
{\xe \v ToLower\:testing::internal}
{\xe \v testing::internal\:ToLower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char testing::internal::ToLower (char  {\i ch}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2309}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02309                              \{\par
02310   {\cf19 return} {\cf17 static_cast<}{\cf18 char}{\cf17 >}(tolower({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)));\par
02311 \}\par
}
}
{\xe \v ToUpper\:testing::internal}
{\xe \v testing::internal\:ToUpper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char testing::internal::ToUpper (char  {\i ch}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2312}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02312                              \{\par
02313   {\cf19 return} {\cf17 static_cast<}{\cf18 char}{\cf17 >}(toupper({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)));\par
02314 \}\par
}
}
{\xe \v UniversalPrint\:testing::internal}
{\xe \v testing::internal\:UniversalPrint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::UniversalPrint (const T &  {\i value}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 865}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00865                                                     \{\par
00866   {\cf20 // A workarond for the bug in VC++ 7.1 that prevents us from instantiating}\par
00867   {\cf20 // UniversalPrinter with T directly.}\par
00868   {\cf17 typedef} T T1;\par
00869   UniversalPrinter<T1>::Print(value, os);\par
00870 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UniversalPrinter< T >::Print()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b DefaultPrintTo()}, {\b testing::internal::UniversalTersePrinter< const char * >::Print()}, {\b testing::internal::UniversalPrinter< T & >::Print()}, {\b testing::internal::UniversalTersePrinter< T >::Print()}, {\b testing::internal::UniversalTersePrinter< T & >::Print()} \'E8 {\b PrintRawArrayTo()}.}\par
}
{\xe \v UniversalPrintArray\:testing::internal}
{\xe \v testing::internal\:UniversalPrintArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::UniversalPrintArray (const char *  {\i begin}, size_t  {\i len}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v UniversalPrintArray\:testing::internal}
{\xe \v testing::internal\:UniversalPrintArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UniversalPrintArray (const char *  {\i begin}, size_t  {\i len}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 309}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00309                                                                      \{\par
00310   UniversalPrintCharArray(begin, len, os);\par
00311 \}\par
}
}
{\xe \v UniversalPrintArray\:testing::internal}
{\xe \v testing::internal\:UniversalPrintArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::UniversalPrintArray (const T *  {\i begin}, size_t  {\i len}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 729}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00729                                                                      \{\par
00730   {\cf19 if} (len == 0) \{\par
00731     *os << {\cf22 "\{\}"};\par
00732   \} {\cf19 else} \{\par
00733     *os << {\cf22 "\{ "};\par
00734     {\cf17 const} {\cf18 size_t} kThreshold = 18;\par
00735     {\cf17 const} {\cf18 size_t} kChunkSize = 8;\par
00736     {\cf20 // If the array has more than kThreshold elements, we'll have to}\par
00737     {\cf20 // omit some details by printing only the first and the last}\par
00738     {\cf20 // kChunkSize elements.}\par
00739     {\cf20 // TODO(wan@google.com): let the user control the threshold using a flag.}\par
00740     {\cf19 if} (len <= kThreshold) \{\par
00741       PrintRawArrayTo(begin, len, os);\par
00742     \} {\cf19 else} \{\par
00743       PrintRawArrayTo(begin, kChunkSize, os);\par
00744       *os << {\cf22 ", ..., "};\par
00745       PrintRawArrayTo(begin + len - kChunkSize, kChunkSize, os);\par
00746     \}\par
00747     *os << {\cf22 " \}"};\par
00748   \}\par
00749 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b PrintRawArrayTo()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UniversalPrinter< T[N]>::Print()}.}\par
}
{\xe \v UniversalPrintArray\:testing::internal}
{\xe \v testing::internal\:UniversalPrintArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal::UniversalPrintArray (const wchar_t *  {\i begin}, size_t  {\i len}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v UniversalPrintArray\:testing::internal}
{\xe \v testing::internal\:UniversalPrintArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UniversalPrintArray (const wchar_t *  {\i begin}, size_t  {\i len}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 315}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00315                                                                         \{\par
00316   UniversalPrintCharArray(begin, len, os);\par
00317 \}\par
}
}
{\xe \v UniversalTersePrint\:testing::internal}
{\xe \v testing::internal\:UniversalTersePrint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing::internal::UniversalTersePrint (const T &  {\i value}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 856}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00856                                                          \{\par
00857   UniversalTersePrinter<T>::Print(value, os);\par
00858 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UniversalTersePrinter< T >::Print()}.}\par
}
{\xe \v WideStringToUtf8\:testing::internal}
{\xe \v testing::internal\:WideStringToUtf8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::WideStringToUtf8 (const wchar_t *  {\i str}, int  {\i num_chars})}}
\par
{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1820}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01820                                                               \{\par
01821   {\cf19 if} (num_chars == -1)\par
01822     num_chars = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(wcslen(str));\par
01823 \par
01824   ::std::stringstream stream;\par
01825   {\cf19 for} ({\cf18 int} i = 0; i < num_chars; ++i) \{\par
01826     UInt32 unicode_code_point;\par
01827 \par
01828     {\cf19 if} (str[i] == L{\cf23 '\\0'}) \{\par
01829       {\cf19 break};\par
01830     \} {\cf19 else} {\cf19 if} (i + 1 < num_chars && IsUtf16SurrogatePair(str[i], str[i + 1])) \{\par
01831       unicode_code_point = CreateCodePointFromUtf16SurrogatePair(str[i],\par
01832                                                                  str[i + 1]);\par
01833       i++;\par
01834     \} {\cf19 else} \{\par
01835       unicode_code_point = {\cf17 static_cast<}UInt32{\cf17 >}(str[i]);\par
01836     \}\par
01837 \par
01838     stream << CodePointToUtf8(unicode_code_point);\par
01839   \}\par
01840   {\cf19 return} StringStreamToString(&stream);\par
01841 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b CodePointToUtf8()}, {\b CreateCodePointFromUtf16SurrogatePair()}, {\b IsUtf16SurrogatePair()} \'E8 {\b StringStreamToString()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::String::ShowWideCString()}.}\par
}
{\xe \v WriteToShardStatusFileIfNeeded\:testing::internal}
{\xe \v testing::internal\:WriteToShardStatusFileIfNeeded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::WriteToShardStatusFileIfNeeded ()}}
\par
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4692}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04692                                       \{\par
04693   {\cf17 const} {\cf18 char}* {\cf17 const} test_shard_file = posix::GetEnv(kTestShardStatusFile);\par
04694   {\cf19 if} (test_shard_file != NULL) \{\par
04695     FILE* {\cf17 const} file = posix::FOpen(test_shard_file, {\cf22 "w"});\par
04696     {\cf19 if} (file == NULL) \{\par
04697       ColoredPrintf(COLOR_RED,\par
04698                     {\cf22 "Could not write to the test shard status file \\"%s\\" "}\par
04699                     {\cf22 "specified by the %s environment variable.\\n"},\par
04700                     test_shard_file, kTestShardStatusFile);\par
04701       fflush(stdout);\par
04702       exit(EXIT_FAILURE);\par
04703     \}\par
04704     fclose(file);\par
04705   \}\par
04706 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b COLOR_RED}, {\b ColoredPrintf()}, {\b testing::internal::posix::FOpen()} \'E8 {\b testing::internal::posix::GetEnv()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 
{\xe \v g_argvs\:testing::internal}
{\xe \v testing::internal\:g_argvs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
::std::vector<{\b testing::internal::string}> testing::internal::g_argvs}}
\par
{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 387}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b GetArgvs()} \'E8 {\b InitGoogleTestImpl()}.}\par
}
{\xe \v g_help_flag\:testing::internal}
{\xe \v testing::internal\:g_help_flag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::g_help_flag = false}}
\par
{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 188}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlagsOnlyImpl()} \'E8 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v GTEST_ATTRIBUTE_UNUSED_\:testing::internal}
{\xe \v testing::internal\:GTEST_ATTRIBUTE_UNUSED_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
class {\b testing::internal::GTestFlagSaver} testing::internal::GTEST_ATTRIBUTE_UNUSED_}}
\par
{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v kAlsoRunDisabledTestsFlag\:testing::internal}
{\xe \v testing::internal\:kAlsoRunDisabledTestsFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kAlsoRunDisabledTestsFlag[] = "also_run_disabled_tests"}}
\par
{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 89}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kBreakOnFailureFlag\:testing::internal}
{\xe \v testing::internal\:kBreakOnFailureFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kBreakOnFailureFlag[] = "break_on_failure"}}
\par
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 90}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kCatchExceptionsFlag\:testing::internal}
{\xe \v testing::internal\:kCatchExceptionsFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kCatchExceptionsFlag[] = "catch_exceptions"}}
\par
{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 91}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kColorFlag\:testing::internal}
{\xe \v testing::internal\:kColorFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kColorFlag[] = "color"}}
\par
{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 92}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kCurrentDirectoryString\:testing::internal}
{\xe \v testing::internal\:kCurrentDirectoryString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kCurrentDirectoryString[] = "./"}}
\par
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 86}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FilePath::GetCurrentDir()} \'E8 {\b testing::internal::FilePath::RemoveFileName()}.}\par
}
{\xe \v kDeathTestStyleFlag\:testing::internal}
{\xe \v testing::internal\:kDeathTestStyleFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kDeathTestStyleFlag[] = "death_test_style"}}
\par
{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-death-test-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 50}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kDeathTestUseFork\:testing::internal}
{\xe \v testing::internal\:kDeathTestUseFork}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kDeathTestUseFork[] = "death_test_use_fork"}}
\par
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-death-test-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 51}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kFilterFlag\:testing::internal}
{\xe \v testing::internal\:kFilterFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kFilterFlag[] = "filter"}}
\par
{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 93}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kFlagfileFlag\:testing::internal}
{\xe \v testing::internal\:kFlagfileFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kFlagfileFlag[] = "flagfile"}}
\par
{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 103}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlagsOnlyImpl()}.}\par
}
{\xe \v kInternalRunDeathTestFlag\:testing::internal}
{\xe \v testing::internal\:kInternalRunDeathTestFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kInternalRunDeathTestFlag[] = "internal_run_death_test"}}
\par
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-death-test-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 52}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kListTestsFlag\:testing::internal}
{\xe \v testing::internal\:kListTestsFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kListTestsFlag[] = "list_tests"}}
\par
{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 94}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kMaxBiggestInt\:testing::internal}
{\xe \v testing::internal\:kMaxBiggestInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b BiggestInt} testing::internal::kMaxBiggestInt}}
\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'C8\'ED\'E8\'F6\'E8\'E0\'EB\'E8\'E7\'E0\'F2\'EE\'F0}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
    ~({\cf17 static_cast<}BiggestInt{\cf17 >}(1) << (8*{\cf17 sizeof}(BiggestInt) - 1))\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2471}}\par
}
{\xe \v kMaxCodePoint1\:testing::internal}
{\xe \v testing::internal\:kMaxCodePoint1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt32} testing::internal::kMaxCodePoint1 = (static_cast<{\b UInt32}>(1) << 7) - 1}}
\par
{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1730}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CodePointToUtf8()}.}\par
}
{\xe \v kMaxCodePoint2\:testing::internal}
{\xe \v testing::internal\:kMaxCodePoint2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt32} testing::internal::kMaxCodePoint2 = (static_cast<{\b UInt32}>(1) << (5 + 6)) - 1}}
\par
{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1733}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CodePointToUtf8()}.}\par
}
{\xe \v kMaxCodePoint3\:testing::internal}
{\xe \v testing::internal\:kMaxCodePoint3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt32} testing::internal::kMaxCodePoint3 = (static_cast<{\b UInt32}>(1) << (4 + 2*6)) - 1}}
\par
{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1736}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CodePointToUtf8()}.}\par
}
{\xe \v kMaxCodePoint4\:testing::internal}
{\xe \v testing::internal\:kMaxCodePoint4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt32} testing::internal::kMaxCodePoint4 = (static_cast<{\b UInt32}>(1) << (3 + 3*6)) - 1}}
\par
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1739}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CodePointToUtf8()}.}\par
}
{\xe \v kMaxRandomSeed\:testing::internal}
{\xe \v testing::internal\:kMaxRandomSeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int testing::internal::kMaxRandomSeed = 99999}}
\par
{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 106}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b GetNextRandomSeed()} \'E8 {\b GetRandomSeedFromFlag()}.}\par
}
{\xe \v kOutputFlag\:testing::internal}
{\xe \v testing::internal\:kOutputFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kOutputFlag[] = "output"}}
\par
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 95}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kPathSeparator\:testing::internal}
{\xe \v testing::internal\:kPathSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kPathSeparator = '/'}}
\par
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 85}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FilePath::ConcatPaths()}.}\par
}
{\xe \v kPrintTimeFlag\:testing::internal}
{\xe \v testing::internal\:kPrintTimeFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kPrintTimeFlag[] = "print_time"}}
\par
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 96}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kRandomSeedFlag\:testing::internal}
{\xe \v testing::internal\:kRandomSeedFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kRandomSeedFlag[] = "random_seed"}}
\par
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 97}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kRepeatFlag\:testing::internal}
{\xe \v testing::internal\:kRepeatFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kRepeatFlag[] = "repeat"}}
\par
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 98}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kShuffleFlag\:testing::internal}
{\xe \v testing::internal\:kShuffleFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kShuffleFlag[] = "shuffle"}}
\par
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 99}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kStackTraceDepthFlag\:testing::internal}
{\xe \v testing::internal\:kStackTraceDepthFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kStackTraceDepthFlag[] = "stack_trace_depth"}}
\par
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 100}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kStackTraceMarker\:testing::internal}
{\xe \v testing::internal\:kStackTraceMarker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kStackTraceMarker = "\\nStack trace:\\n"}}
\par
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 184}}\par
}
{\xe \v kStdErrFileno\:testing::internal}
{\xe \v testing::internal\:kStdErrFileno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int testing::internal::kStdErrFileno = STDERR_FILENO}}
\par
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 89}}\par
}
{\xe \v kStdOutFileno\:testing::internal}
{\xe \v testing::internal\:kStdOutFileno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int testing::internal::kStdOutFileno = STDOUT_FILENO}}
\par
{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 88}}\par
}
{\xe \v kStreamResultToFlag\:testing::internal}
{\xe \v testing::internal\:kStreamResultToFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kStreamResultToFlag[] = "stream_result_to"}}
\par
{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 101}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kTestTypeIdInGoogleTest\:testing::internal}
{\xe \v testing::internal\:kTestTypeIdInGoogleTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TypeId} testing::internal::kTestTypeIdInGoogleTest = {\b GetTestTypeId}(){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 626}}\par
}
{\xe \v kThrowOnFailureFlag\:testing::internal}
{\xe \v testing::internal\:kThrowOnFailureFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kThrowOnFailureFlag[] = "throw_on_failure"}}
\par
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 102}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ParseGoogleTestFlag()}.}\par
}
{\xe \v kUnknownFile\:testing::internal}
{\xe \v testing::internal\:kUnknownFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char testing::internal::kUnknownFile[] = "unknown file"}}
\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 876}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b FormatCompilerIndependentFileLocation()} \'E8 {\b FormatFileLocation()}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'EE \'E8\'EC\'E5\'ED testing::internal2\par \pard\plain 
{\tc\tcl2 \v testing::internal2}
{\xe \v testing::internal2}
{\bkmkstart AAAAAAABZD}
{\bkmkend AAAAAAABZD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TypeWithoutFormatter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TypeWithoutFormatter< T, kConvertibleToInteger >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TypeWithoutFormatter< T, kProtobuf >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b TypeKind} \{ {\b kProtobuf}
, {\b kConvertibleToInteger}
, {\b kOtherType}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b PrintBytesInObjectTo} (const unsigned char *obj_bytes, size_t count, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Char , typename CharTraits , typename T > ::std::basic_ostream< Char, CharTraits > & {\b operator<<} (::std::basic_ostream< Char, CharTraits > &os, const T &x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintBytesInObjectTo} (const unsigned char *obj_bytes, size_t count, ostream *os)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const size_t {\b kProtobufOneLinerMaxLength} = 50\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 
{\xe \v TypeKind\:testing::internal2}
{\xe \v testing::internal2\:TypeKind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b testing::internal2::TypeKind}}}
\par
{\bkmkstart AAAAAAABZE}
{\bkmkend AAAAAAABZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'DD\'EB\'E5\'EC\'E5\'ED\'F2\'FB \'EF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'E9:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v kProtobuf\:testing::internal2}
{\xe \v testing::internal2\:kProtobuf}
{\qr kProtobuf{\bkmkstart AAAAAAABZF}
{\bkmkend AAAAAAABZF}
\cell }{\cell }{\row }
{\xe \v kConvertibleToInteger\:testing::internal2}
{\xe \v testing::internal2\:kConvertibleToInteger}
{\qr kConvertibleToInteger{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
\cell }{\cell }{\row }
{\xe \v kOtherType\:testing::internal2}
{\xe \v testing::internal2\:kOtherType}
{\qr kOtherType{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
\cell }{\cell }{\row }
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 124}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00124               \{\par
00125   kProtobuf,              {\cf20 // a protobuf type}\par
00126   kConvertibleToInteger,  {\cf20 // a type implicitly convertible to BiggestInt}\par
00127                           {\cf20 // (e.g. a named or unnamed enum type)}\par
00128   kOtherType              {\cf20 // anything else}\par
00129 \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 
{\xe \v operator<<\:testing::internal2}
{\xe \v testing::internal2\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Char , typename CharTraits , typename T > ::std::basic_ostream< Char, CharTraits > & testing::internal2::operator<< (::std::basic_ostream< Char, CharTraits > &  {\i os}, const T &  {\i x})}}
\par
{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 148}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00204                                                         \{\par
00205   TypeWithoutFormatter<T,\par
00206       (internal::IsAProtocolMessage<T>::value ? kProtobuf :\par
00207        internal::ImplicitlyConvertible<const T&, internal::BiggestInt>::value ?\par
00208        kConvertibleToInteger : kOtherType)>::PrintValue(x, &os);\par
00209   {\cf19 return} os;\par
00210 \}\par
}
}
{\xe \v PrintBytesInObjectTo\:testing::internal2}
{\xe \v testing::internal2\:PrintBytesInObjectTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} void testing::internal2::PrintBytesInObjectTo (const unsigned char *  {\i obj_bytes}, size_t  {\i count}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal2::TypeWithoutFormatter< T, kTypeKind >::PrintValue()}.}\par
}
{\xe \v PrintBytesInObjectTo\:testing::internal2}
{\xe \v testing::internal2\:PrintBytesInObjectTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal2::PrintBytesInObjectTo (const unsigned char *  {\i obj_bytes}, size_t  {\i count}, ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 114}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00115                                        \{\par
00116   PrintBytesInObjectToImpl(obj_bytes, count, os);\par
00117 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 
{\xe \v kProtobufOneLinerMaxLength\:testing::internal2}
{\xe \v testing::internal2\:kProtobufOneLinerMaxLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t testing::internal2::kProtobufOneLinerMaxLength = 50}}
\par
{\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 148}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal2::TypeWithoutFormatter< T, kProtobuf >::PrintValue()}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'EE \'E8\'EC\'E5\'ED testing::internal::edit_distance\par \pard\plain 
{\tc\tcl2 \v testing::internal::edit_distance}
{\xe \v testing::internal::edit_distance}
{\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b EditType} \{ {\b kMatch}
, {\b kAdd}
, {\b kRemove}
, {\b kReplace}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::vector< {\b EditType} > {\b CalculateOptimalEdits} (const std::vector< size_t > &left, const std::vector< size_t > &right)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::vector< {\b EditType} > {\b CalculateOptimalEdits} (const std::vector< std::string > &left, const std::vector< std::string > &right)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b CreateUnifiedDiff} (const std::vector< std::string > &left, const std::vector< std::string > &right, size_t context=2)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 
{\xe \v EditType\:testing::internal::edit_distance}
{\xe \v testing::internal::edit_distance\:EditType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b testing::internal::edit_distance::EditType}}}
\par
{\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'DD\'EB\'E5\'EC\'E5\'ED\'F2\'FB \'EF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'E9:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v kMatch\:testing::internal::edit_distance}
{\xe \v testing::internal::edit_distance\:kMatch}
{\qr kMatch{\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
\cell }{\cell }{\row }
{\xe \v kAdd\:testing::internal::edit_distance}
{\xe \v testing::internal::edit_distance\:kAdd}
{\qr kAdd{\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
\cell }{\cell }{\row }
{\xe \v kRemove\:testing::internal::edit_distance}
{\xe \v testing::internal::edit_distance\:kRemove}
{\qr kRemove{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
\cell }{\cell }{\row }
{\xe \v kReplace\:testing::internal::edit_distance}
{\xe \v testing::internal::edit_distance\:kReplace}
{\qr kReplace{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
\cell }{\cell }{\row }
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 180}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00180 \{ kMatch, kAdd, kRemove, kReplace \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 
{\xe \v CalculateOptimalEdits\:testing::internal::edit_distance}
{\xe \v testing::internal::edit_distance\:CalculateOptimalEdits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b EditType} > testing::internal::edit_distance::CalculateOptimalEdits (const std::vector< size_t > &  {\i left}, const std::vector< size_t > &  {\i right})}}
\par
{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1025}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01026                                                                             \{\par
01027   std::vector<std::vector<double> > costs(\par
01028       left.size() + 1, std::vector<double>(right.size() + 1));\par
01029   std::vector<std::vector<EditType> > best_move(\par
01030       left.size() + 1, std::vector<EditType>(right.size() + 1));\par
01031 \par
01032   {\cf20 // Populate for empty right.}\par
01033   {\cf19 for} ({\cf18 size_t} l_i = 0; l_i < costs.size(); ++l_i) \{\par
01034     costs[l_i][0] = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(l_i);\par
01035     best_move[l_i][0] = kRemove;\par
01036   \}\par
01037   {\cf20 // Populate for empty left.}\par
01038   {\cf19 for} ({\cf18 size_t} r_i = 1; r_i < costs[0].size(); ++r_i) \{\par
01039     costs[0][r_i] = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(r_i);\par
01040     best_move[0][r_i] = kAdd;\par
01041   \}\par
01042 \par
01043   {\cf19 for} ({\cf18 size_t} l_i = 0; l_i < left.size(); ++l_i) \{\par
01044     {\cf19 for} ({\cf18 size_t} r_i = 0; r_i < right.size(); ++r_i) \{\par
01045       {\cf19 if} (left[l_i] == right[r_i]) \{\par
01046         {\cf20 // Found a match. Consume it.}\par
01047         costs[l_i + 1][r_i + 1] = costs[l_i][r_i];\par
01048         best_move[l_i + 1][r_i + 1] = kMatch;\par
01049         {\cf19 continue};\par
01050       \}\par
01051 \par
01052       {\cf17 const} {\cf18 double} add = costs[l_i + 1][r_i];\par
01053       {\cf17 const} {\cf18 double} remove = costs[l_i][r_i + 1];\par
01054       {\cf17 const} {\cf18 double} replace = costs[l_i][r_i];\par
01055       {\cf19 if} (add < remove && add < replace) \{\par
01056         costs[l_i + 1][r_i + 1] = add + 1;\par
01057         best_move[l_i + 1][r_i + 1] = kAdd;\par
01058       \} {\cf19 else} {\cf19 if} (remove < add && remove < replace) \{\par
01059         costs[l_i + 1][r_i + 1] = remove + 1;\par
01060         best_move[l_i + 1][r_i + 1] = kRemove;\par
01061       \} {\cf19 else} \{\par
01062         {\cf20 // We make replace a little more expensive than add/remove to lower}\par
01063         {\cf20 // their priority.}\par
01064         costs[l_i + 1][r_i + 1] = replace + 1.00001;\par
01065         best_move[l_i + 1][r_i + 1] = kReplace;\par
01066       \}\par
01067     \}\par
01068   \}\par
01069 \par
01070   {\cf20 // Reconstruct the best path. We do it in reverse order.}\par
01071   std::vector<EditType> best_path;\par
01072   {\cf19 for} ({\cf18 size_t} l_i = left.size(), r_i = right.size(); l_i > 0 || r_i > 0;) \{\par
01073     EditType move = best_move[l_i][r_i];\par
01074     best_path.push_back(move);\par
01075     l_i -= move != kAdd;\par
01076     r_i -= move != kRemove;\par
01077   \}\par
01078   std::reverse(best_path.begin(), best_path.end());\par
01079   {\cf19 return} best_path;\par
01080 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b kAdd}, {\b kMatch}, {\b kRemove}, {\b kReplace} \'E8 {\b testing::internal::move()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CalculateOptimalEdits()} \'E8 {\b CreateUnifiedDiff()}.}\par
}
{\xe \v CalculateOptimalEdits\:testing::internal::edit_distance}
{\xe \v testing::internal::edit_distance\:CalculateOptimalEdits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b EditType} > testing::internal::edit_distance::CalculateOptimalEdits (const std::vector< std::string > &  {\i left}, const std::vector< std::string > &  {\i right})}}
\par
{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1101}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01103                                        \{\par
01104   std::vector<size_t> left_ids, right_ids;\par
01105   \{\par
01106     InternalStrings intern_table;\par
01107     {\cf19 for} ({\cf18 size_t} i = 0; i < left.size(); ++i) \{\par
01108       left_ids.push_back(intern_table.GetId(left[i]));\par
01109     \}\par
01110     {\cf19 for} ({\cf18 size_t} i = 0; i < right.size(); ++i) \{\par
01111       right_ids.push_back(intern_table.GetId(right[i]));\par
01112     \}\par
01113   \}\par
01114   {\cf19 return} CalculateOptimalEdits(left_ids, right_ids);\par
01115 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b CalculateOptimalEdits()}.}\par
}
{\xe \v CreateUnifiedDiff\:testing::internal::edit_distance}
{\xe \v testing::internal::edit_distance\:CreateUnifiedDiff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::edit_distance::CreateUnifiedDiff (const std::vector< std::string > &  {\i left}, const std::vector< std::string > &  {\i right}, size_t  {\i context} = {\f2 2})}}
\par
{\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1200}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01202                                               \{\par
01203   {\cf17 const} std::vector<EditType> edits = CalculateOptimalEdits(left, right);\par
01204 \par
01205   {\cf18 size_t} l_i = 0, r_i = 0, edit_i = 0;\par
01206   std::stringstream ss;\par
01207   {\cf19 while} (edit_i < edits.size()) \{\par
01208     {\cf20 // Find first edit.}\par
01209     {\cf19 while} (edit_i < edits.size() && edits[edit_i] == kMatch) \{\par
01210       ++l_i;\par
01211       ++r_i;\par
01212       ++edit_i;\par
01213     \}\par
01214 \par
01215     {\cf20 // Find the first line to include in the hunk.}\par
01216     {\cf17 const} {\cf18 size_t} prefix_context = std::min(l_i, context);\par
01217     Hunk hunk(l_i - prefix_context + 1, r_i - prefix_context + 1);\par
01218     {\cf19 for} ({\cf18 size_t} i = prefix_context; i > 0; --i) \{\par
01219       hunk.PushLine({\cf23 ' '}, left[l_i - i].c_str());\par
01220     \}\par
01221 \par
01222     {\cf20 // Iterate the edits until we found enough suffix for the hunk or the input}\par
01223     {\cf20 // is over.}\par
01224     {\cf18 size_t} n_suffix = 0;\par
01225     {\cf19 for} (; edit_i < edits.size(); ++edit_i) \{\par
01226       {\cf19 if} (n_suffix >= context) \{\par
01227         {\cf20 // Continue only if the next hunk is very close.}\par
01228         std::vector<EditType>::const_iterator it = edits.begin() + edit_i;\par
01229         {\cf19 while} (it != edits.end() && *it == kMatch) ++it;\par
01230         {\cf19 if} (it == edits.end() || (it - edits.begin()) - edit_i >= context) \{\par
01231           {\cf20 // There is no next edit or it is too far away.}\par
01232           {\cf19 break};\par
01233         \}\par
01234       \}\par
01235 \par
01236       EditType edit = edits[edit_i];\par
01237       {\cf20 // Reset count when a non match is found.}\par
01238       n_suffix = edit == kMatch ? n_suffix + 1 : 0;\par
01239 \par
01240       {\cf19 if} (edit == kMatch || edit == kRemove || edit == kReplace) \{\par
01241         hunk.PushLine(edit == kMatch ? {\cf23 ' '} : {\cf23 '-'}, left[l_i].c_str());\par
01242       \}\par
01243       {\cf19 if} (edit == kAdd || edit == kReplace) \{\par
01244         hunk.PushLine({\cf23 '+'}, right[r_i].c_str());\par
01245       \}\par
01246 \par
01247       {\cf20 // Advance indices, depending on edit type.}\par
01248       l_i += edit != kAdd;\par
01249       r_i += edit != kRemove;\par
01250     \}\par
01251 \par
01252     {\cf19 if} (!hunk.has_edits()) \{\par
01253       {\cf20 // We are done. We don't want this hunk.}\par
01254       {\cf19 break};\par
01255     \}\par
01256 \par
01257     hunk.PrintTo(&ss);\par
01258   \}\par
01259   {\cf19 return} ss.str();\par
01260 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b CalculateOptimalEdits()}, {\b kAdd}, {\b kMatch}, {\b kRemove} \'E8 {\b kReplace}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::EqFailure()}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'EE \'E8\'EC\'E5\'ED testing::internal::posix\par \pard\plain 
{\tc\tcl2 \v testing::internal::posix}
{\xe \v testing::internal::posix}
{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct stat {\b StatStruct}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b FileNo} (FILE *file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsATTY} (int fd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Stat} (const char *path, {\b StatStruct} *buf)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b StrCaseCmp} (const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b StrDup} (const char *src)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b RmDir} (const char *dir)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsDir} (const {\b StatStruct} &st)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b StrNCpy} (char *dest, const char *src, size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ChDir} (const char *dir)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FILE * {\b FOpen} (const char *path, const char *mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FILE * {\b FReopen} (const char *path, const char *mode, FILE *stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FILE * {\b FDOpen} (int fd, const char *mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b FClose} (FILE *fp)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Read} (int fd, void *buf, unsigned int count)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Write} (int fd, const void *buf, unsigned int count)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Close} (int fd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b StrError} (int errnum)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b GetEnv} (const char *name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Abort} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D2\'E8\'EF\'FB\par
\pard\plain 
{\xe \v StatStruct\:testing::internal::posix}
{\xe \v testing::internal::posix\:StatStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct stat {\b testing::internal::posix::StatStruct}}}
\par
{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2370}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 
{\xe \v Abort\:testing::internal::posix}
{\xe \v testing::internal::posix\:Abort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::posix::Abort (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2442}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02442 \{ abort(); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::TestResult::GetTestPartResult()}, {\b testing::TestPartResultArray::GetTestPartResult()}, {\b testing::TestResult::GetTestProperty()} \'E8 {\b testing::internal::GTestLog::~GTestLog()}.}\par
}
{\xe \v ChDir\:testing::internal::posix}
{\xe \v testing::internal::posix\:ChDir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::posix::ChDir (const char *  {\i dir}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2397}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02397 \{ {\cf19 return} chdir(dir); \}\par
}
}
{\xe \v Close\:testing::internal::posix}
{\xe \v testing::internal::posix\:Close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::posix::Close (int  {\i fd}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2416}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02416 \{ {\cf19 return} close(fd); \}\par
}
}
{\xe \v FClose\:testing::internal::posix}
{\xe \v testing::internal::posix\:FClose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::posix::FClose (FILE *  {\i fp}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2408}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02408 \{ {\cf19 return} fclose(fp); \}\par
}
}
{\xe \v FDOpen\:testing::internal::posix}
{\xe \v testing::internal::posix\:FDOpen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FILE * testing::internal::posix::FDOpen (int  {\i fd}, const char *  {\i mode}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2406}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02406 \{ {\cf19 return} fdopen(fd, mode); \}\par
}
}
{\xe \v FileNo\:testing::internal::posix}
{\xe \v testing::internal::posix\:FileNo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::posix::FileNo (FILE *  {\i file}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2372}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02372 \{ {\cf19 return} fileno(file); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::ColoredPrintf()}.}\par
}
{\xe \v FOpen\:testing::internal::posix}
{\xe \v testing::internal::posix\:FOpen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FILE * testing::internal::posix::FOpen (const char *  {\i path}, const char *  {\i mode}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2399}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02399                                                        \{\par
02400   {\cf19 return} fopen(path, mode);\par
02401 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::XmlUnitTestResultPrinter::OnTestIterationEnd()}, {\b testing::internal::ScopedPrematureExitFile::ScopedPrematureExitFile()} \'E8 {\b testing::internal::WriteToShardStatusFileIfNeeded()}.}\par
}
{\xe \v FReopen\:testing::internal::posix}
{\xe \v testing::internal::posix\:FReopen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FILE * testing::internal::posix::FReopen (const char *  {\i path}, const char *  {\i mode}, FILE *  {\i stream}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2403}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02403                                                                        \{\par
02404   {\cf19 return} freopen(path, mode, stream);\par
02405 \}\par
}
}
{\xe \v GetEnv\:testing::internal::posix}
{\xe \v testing::internal::posix\:GetEnv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::internal::posix::GetEnv (const char *  {\i name}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2419}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02419                                             \{\par
02420 {\cf21 #if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE | GTEST_OS_WINDOWS_RT}\par
02421   {\cf20 // We are on Windows CE, which has no environment variables.}\par
02422   {\cf17 static_cast<}{\cf18 void}{\cf17 >}(name);  {\cf20 // To prevent 'unused argument' warning.}\par
02423   {\cf19 return} NULL;\par
02424 {\cf21 #elif defined(__BORLANDC__) || defined(__SunOS_5_8) || defined(__SunOS_5_9)}\par
02425   {\cf20 // Environment variables which we programmatically clear will be set to the}\par
02426   {\cf20 // empty string rather than unset (NULL).  Handle that case.}\par
02427   {\cf17 const} {\cf18 char}* {\cf17 const} env = getenv(name);\par
02428   {\cf19 return} (env != NULL && env[0] != {\cf23 '\\0'}) ? env : NULL;\par
02429 {\cf21 #else}\par
02430   {\cf19 return} getenv(name);\par
02431 {\cf21 #endif}\par
02432 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::BoolFromGTestEnv()}, {\b testing::internal::Int32FromEnvOrDie()}, {\b testing::internal::Int32FromGTestEnv()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart()}, {\b testing::UnitTest::Run()}, {\b testing::internal::ShouldUseColor()}, {\b testing::internal::StringFromGTestEnv()}, {\b testing::TempDir()} \'E8 {\b testing::internal::WriteToShardStatusFileIfNeeded()}.}\par
}
{\xe \v IsATTY\:testing::internal::posix}
{\xe \v testing::internal::posix\:IsATTY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::posix::IsATTY (int  {\i fd}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2373}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02373 \{ {\cf19 return} isatty(fd); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::ColoredPrintf()}.}\par
}
{\xe \v IsDir\:testing::internal::posix}
{\xe \v testing::internal::posix\:IsDir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::posix::IsDir (const {\b StatStruct} &  {\i st}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2380}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02380 \{ {\cf19 return} S_ISDIR(st.st_mode); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FilePath::DirectoryExists()}.}\par
}
{\xe \v Read\:testing::internal::posix}
{\xe \v testing::internal::posix\:Read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::posix::Read (int  {\i fd}, void *  {\i buf}, unsigned int  {\i count}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2410}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02410                                                        \{\par
02411   {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(read(fd, buf, count));\par
02412 \}\par
}
}
{\xe \v RmDir\:testing::internal::posix}
{\xe \v testing::internal::posix\:RmDir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::posix::RmDir (const char *  {\i dir}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAP}
{\bkmkend AAAAAAACAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2379}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02379 \{ {\cf19 return} rmdir(dir); \}\par
}
}
{\xe \v Stat\:testing::internal::posix}
{\xe \v testing::internal::posix\:Stat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::posix::Stat (const char *  {\i path}, {\b StatStruct} *  {\i buf}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAQ}
{\bkmkend AAAAAAACAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2374}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02374 \{ {\cf19 return} stat(path, buf); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FilePath::DirectoryExists()} \'E8 {\b testing::internal::FilePath::FileOrDirectoryExists()}.}\par
}
{\xe \v StrCaseCmp\:testing::internal::posix}
{\xe \v testing::internal::posix\:StrCaseCmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::posix::StrCaseCmp (const char *  {\i s1}, const char *  {\i s2}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAR}
{\bkmkend AAAAAAACAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2375}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02375                                                       \{\par
02376   {\cf19 return} strcasecmp(s1, s2);\par
02377 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::String::CaseInsensitiveCStringEquals()}.}\par
}
{\xe \v StrDup\:testing::internal::posix}
{\xe \v testing::internal::posix\:StrDup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * testing::internal::posix::StrDup (const char *  {\i src}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAS}
{\bkmkend AAAAAAACAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2378}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02378 \{ {\cf19 return} strdup(src); \}\par
}
}
{\xe \v StrError\:testing::internal::posix}
{\xe \v testing::internal::posix\:StrError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::internal::posix::StrError (int  {\i errnum}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAT}
{\bkmkend AAAAAAACAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2417}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02417 \{ {\cf19 return} strerror(errnum); \}\par
}
}
{\xe \v StrNCpy\:testing::internal::posix}
{\xe \v testing::internal::posix\:StrNCpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::internal::posix::StrNCpy (char *  {\i dest}, const char *  {\i src}, size_t  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAU}
{\bkmkend AAAAAAACAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2388}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02388                                                                   \{\par
02389   {\cf19 return} strncpy(dest, src, n);\par
02390 \}\par
}
}
{\xe \v Write\:testing::internal::posix}
{\xe \v testing::internal::posix\:Write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::posix::Write (int  {\i fd}, const void *  {\i buf}, unsigned int  {\i count}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAV}
{\bkmkend AAAAAAACAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2413}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02413                                                               \{\par
02414   {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(write(fd, buf, count));\par
02415 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'EE \'E8\'EC\'E5\'ED testing_internal\par \pard\plain 
{\tc\tcl2 \v testing_internal}
{\xe \v testing_internal}
{\bkmkstart AAAAAAACAW}
{\bkmkend AAAAAAACAW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b DefaultPrintNonContainerTo} (const T &value, ::std::ostream *os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 
{\xe \v DefaultPrintNonContainerTo\:testing_internal}
{\xe \v testing_internal\:DefaultPrintNonContainerTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void testing_internal::DefaultPrintNonContainerTo (const T &  {\i value}, ::std::ostream *  {\i os})}}
\par
{\bkmkstart AAAAAAACAX}
{\bkmkend AAAAAAACAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 222}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00222                                                                 \{\par
00223   {\cf20 // With the following statement, during unqualified name lookup,}\par
00224   {\cf20 // testing::internal2::operator<< appears as if it was declared in}\par
00225   {\cf20 // the nearest enclosing namespace that contains both}\par
00226   {\cf20 // ::testing_internal and ::testing::internal2, i.e. the global}\par
00227   {\cf20 // namespace.  For more details, refer to the C++ Standard section}\par
00228   {\cf20 // 7.3.4-1 [namespace.udir].  This allows us to fall back onto}\par
00229   {\cf20 // testing::internal2::operator<< in case T doesn't come with a <<}\par
00230   {\cf20 // operator.}\par
00231   {\cf20 //}\par
00232   {\cf20 // We cannot write 'using ::testing::internal2::operator<<;', which}\par
00233   {\cf20 // gcc 3.3 fails to compile due to a compiler bug.}\par
00234   {\cf17 using namespace }::testing::internal2;  {\cf20 // NOLINT}\par
00235 \par
00236   {\cf20 // Assuming T is defined in namespace foo, in the next statement,}\par
00237   {\cf20 // the compiler will consider all of:}\par
00238   {\cf20 //}\par
00239   {\cf20 //   1. foo::operator<< (thanks to Koenig look-up),}\par
00240   {\cf20 //   2. ::operator<< (as the current namespace is enclosed in ::),}\par
00241   {\cf20 //   3. testing::internal2::operator<< (thanks to the using statement above).}\par
00242   {\cf20 //}\par
00243   {\cf20 // The operator<< whose type matches T best will be picked.}\par
00244   {\cf20 //}\par
00245   {\cf20 // We deliberately allow #2 to be a candidate, as sometimes it's}\par
00246   {\cf20 // impossible to define #1 (e.g. when foo is ::std, defining}\par
00247   {\cf20 // anything in it is undefined behavior unless you are a compiler}\par
00248   {\cf20 // vendor.).}\par
00249   *os << value;\par
00250 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::DefaultPrintTo()}.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5{\tc \v \'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::AddRef< T >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::AddRef< T >}
{\xe \v std::tr1::gtest_internal::AddRef< T >}
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T & {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct std::tr1::gtest_internal::AddRef< T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 137}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:std::tr1::gtest_internal::AddRef< T >}
{\xe \v std::tr1::gtest_internal::AddRef< T >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > typedef T& {\b std::tr1::gtest_internal::AddRef}< T >::type}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 137}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::AddRef< T & >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::AddRef< T & >}
{\xe \v std::tr1::gtest_internal::AddRef< T & >}
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T & {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct std::tr1::gtest_internal::AddRef< T & >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 139}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:std::tr1::gtest_internal::AddRef< T & >}
{\xe \v std::tr1::gtest_internal::AddRef< T & >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > typedef T& {\b std::tr1::gtest_internal::AddRef}< T & >::type}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 139}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::AddReference< T >\par \pard\plain 
{\tc\tcl2 \v testing::internal::AddReference< T >}
{\xe \v testing::internal::AddReference< T >}
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T & {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct testing::internal::AddReference< T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 831}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:testing::internal::AddReference< T >}
{\xe \v testing::internal::AddReference< T >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > typedef T& {\b testing::internal::AddReference}< T >::type}}
\par
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 831}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::AddReference< T & >\par \pard\plain 
{\tc\tcl2 \v testing::internal::AddReference< T & >}
{\xe \v testing::internal::AddReference< T & >}
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T & {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct testing::internal::AddReference< T & >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 833}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:testing::internal::AddReference< T & >}
{\xe \v testing::internal::AddReference< T & >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > typedef T& {\b testing::internal::AddReference}< T & >::type}}
\par
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 833}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::AssertHelper\par \pard\plain 
{\tc\tcl2 \v testing::internal::AssertHelper}
{\xe \v testing::internal::AssertHelper}
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
\par
{
{\f2 #include <gtest.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertHelper} ({\b TestPartResult::Type} type, const char *file, int line, const char *message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~AssertHelper} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator=} (const {\b Message} &message) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1668}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v AssertHelper\:testing::internal::AssertHelper}
{\xe \v testing::internal::AssertHelper\:AssertHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::AssertHelper::AssertHelper ({\b TestPartResult::Type}  {\i type}, const char *  {\i file}, int  {\i line}, const char *  {\i message})}}
\par
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 361}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00365     : data_({\cf17 new} AssertHelperData(type, file, line, message)) \{\par
00366 \}\par
}
}
{\xe \v ~AssertHelper\:testing::internal::AssertHelper}
{\xe \v testing::internal::AssertHelper\:~AssertHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::AssertHelper::~AssertHelper ()}}
\par
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 368}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00368                             \{\par
00369   {\cf17 delete} data_;\par
00370 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v operator=\:testing::internal::AssertHelper}
{\xe \v testing::internal::AssertHelper\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::AssertHelper::operator= (const {\b Message} &  {\i message}) const}}
\par
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 373}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00373                                                          \{\par
00374   UnitTest::GetInstance()->\par
00375     AddTestPartResult(data_->type, data_->file, data_->line,\par
00376                       AppendUserMessage(data_->message, message),\par
00377                       UnitTest::GetInstance()->impl()\par
00378                       ->CurrentOsStackTraceExceptTop(1)\par
00379                       {\cf20 // Skips the stack frame for this function itself.}\par
00380                       );  {\cf20 // NOLINT}\par
00381 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::AppendUserMessage()}, {\b testing::internal::UnitTestImpl::CurrentOsStackTraceExceptTop()} \'E8 {\b testing::UnitTest::GetInstance()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::AssertionResult\par \pard\plain 
{\tc\tcl2 \v testing::AssertionResult}
{\xe \v testing::AssertionResult}
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
\par
{
{\f2 #include <gtest.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} (const {\b AssertionResult} &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b AssertionResult} (const T &success, typename {\b internal::EnableIf}< !{\b internal::ImplicitlyConvertible}< T, {\b AssertionResult} >::value >::type *=NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} & {\b operator=} ({\b AssertionResult} other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator bool} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} {\b operator!} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b message} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b failure_message} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b AssertionResult} & {\b operator<<} (const T &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} & {\b operator<<} (::std::ostream &(*basic_manipulator)(::std::ostream &stream))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 256}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v AssertionResult\:testing::AssertionResult}
{\xe \v testing::AssertionResult\:AssertionResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::AssertionResult::AssertionResult (const {\b AssertionResult} &  {\i other})}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 984}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00985     : success_(other.success_),\par
00986       message_(other.message_.get() != NULL ?\par
00987                new ::std::string(*other.message_) :\par
00988                {\cf17 static_cast<} ::std::string*{\cf17 >}(NULL)) \{\par
00989 \}\par
}
}
{\xe \v AssertionResult\:testing::AssertionResult}
{\xe \v testing::AssertionResult\:AssertionResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > testing::AssertionResult::AssertionResult (const T &  {\i success}, typename {\b internal::EnableIf}< !{\b internal::ImplicitlyConvertible}< T, {\b AssertionResult} >::value >::type *  = {\f2 NULL}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 272}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00277       : success_(success) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v failure_message\:testing::AssertionResult}
{\xe \v testing::AssertionResult\:failure_message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::AssertionResult::failure_message () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 302}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00302 \{ {\cf19 return} message(); \}\par
}
}
{\xe \v message\:testing::AssertionResult}
{\xe \v testing::AssertionResult\:message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::AssertionResult::message () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 297}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00297                               \{\par
00298     {\cf19 return} message_.get() != NULL ?  message_->c_str() : {\cf22 ""};\par
00299   \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::GetBoolAssertionFailureMessage()}.}\par
}
{\xe \v operator bool\:testing::AssertionResult}
{\xe \v testing::AssertionResult\:operator bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::AssertionResult::operator bool () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 288}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00288 \{ {\cf19 return} success_; \}  {\cf20 // NOLINT}\par
}
}
{\xe \v operator!\:testing::AssertionResult}
{\xe \v testing::AssertionResult\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} testing::AssertionResult::operator! () const}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 999}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00999                                                  \{\par
01000   AssertionResult negation(!success_);\par
01001   {\cf19 if} (message_.get() != NULL)\par
01002     negation << *message_;\par
01003   {\cf19 return} negation;\par
01004 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::scoped_ptr< T >::get()}.}\par
}
{\xe \v operator<<\:testing::AssertionResult}
{\xe \v testing::AssertionResult\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} & testing::AssertionResult::operator<< (::std::ostream &(*)(::std::ostream &stream)  {\i basic_manipulator}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 312}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00313                                                             \{\par
00314     AppendMessage(Message() << basic_manipulator);\par
00315     {\cf19 return} *{\cf17 this};\par
00316   \}\par
}
}
{\xe \v operator<<\:testing::AssertionResult}
{\xe \v testing::AssertionResult\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b AssertionResult} & testing::AssertionResult::operator<< (const T &  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 305}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00305                                                                     \{\par
00306     AppendMessage(Message() << value);\par
00307     {\cf19 return} *{\cf17 this};\par
00308   \}\par
}
}
{\xe \v operator=\:testing::AssertionResult}
{\xe \v testing::AssertionResult\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResult} & testing::AssertionResult::operator= ({\b AssertionResult}  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 282}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00282                                                     \{\par
00283     swap(other);\par
00284     {\cf19 return} *{\cf17 this};\par
00285   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::bool_constant< bool_value >\par \pard\plain 
{\tc\tcl2 \v testing::internal::bool_constant< bool_value >}
{\xe \v testing::internal::bool_constant< bool_value >}
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
\par
{
{\f2 #include <gtest-port.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::internal::bool_constant< bool_value >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtesting_1_1internal_1_1bool__constant.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b bool_constant}< bool_value > {\b type}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const bool {\b value} = bool_value\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<bool bool_value>\par
struct testing::internal::bool_constant< bool_value >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2235}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:testing::internal::bool_constant< bool_value >}
{\xe \v testing::internal::bool_constant< bool_value >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<bool bool_value> typedef {\b bool_constant}<bool_value> {\b testing::internal::bool_constant}< bool_value >::type}}
\par
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2236}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v value\:testing::internal::bool_constant< bool_value >}
{\xe \v testing::internal::bool_constant< bool_value >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<bool bool_value> const bool {\b testing::internal::bool_constant}< bool_value >::value = bool_value{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2237}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::ByRef< T >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::ByRef< T >}
{\xe \v std::tr1::gtest_internal::ByRef< T >}
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef const T & {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct std::tr1::gtest_internal::ByRef< T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 127}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:std::tr1::gtest_internal::ByRef< T >}
{\xe \v std::tr1::gtest_internal::ByRef< T >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > typedef const T& {\b std::tr1::gtest_internal::ByRef}< T >::type}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 127}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::ByRef< T & >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::ByRef< T & >}
{\xe \v std::tr1::gtest_internal::ByRef< T & >}
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T & {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct std::tr1::gtest_internal::ByRef< T & >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 129}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:std::tr1::gtest_internal::ByRef< T & >}
{\xe \v std::tr1::gtest_internal::ByRef< T & >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > typedef T& {\b std::tr1::gtest_internal::ByRef}< T & >::type}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 129}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'E0 testing::internal::CodeLocation\par \pard\plain 
{\tc\tcl2 \v testing::internal::CodeLocation}
{\xe \v testing::internal::CodeLocation}
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CodeLocation} (const std::string &a_file, int a_line)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b file}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b line}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 504}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v CodeLocation\:testing::internal::CodeLocation}
{\xe \v testing::internal::CodeLocation\:CodeLocation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::CodeLocation::CodeLocation (const std::string &  {\i a_file}, int  {\i a_line}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 505}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00506       : file(a_file), line(a_line) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v file\:testing::internal::CodeLocation}
{\xe \v testing::internal::CodeLocation\:file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::CodeLocation::file}}
\par
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 508}}\par
}
{\xe \v line\:testing::internal::CodeLocation}
{\xe \v testing::internal::CodeLocation\:line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::CodeLocation::line}}
\par
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 509}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::CompileAssert< bool >\par \pard\plain 
{\tc\tcl2 \v testing::internal::CompileAssert< bool >}
{\xe \v testing::internal::CompileAssert< bool >}
{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
\par
{
{\f2 #include <gtest-port.h>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<bool>\par
struct testing::internal::CompileAssert< bool >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1064}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::CompileAssertTypesEqual< T1, T2 >\par \pard\plain 
{\tc\tcl2 \v testing::internal::CompileAssertTypesEqual< T1, T2 >}
{\xe \v testing::internal::CompileAssertTypesEqual< T1, T2 >}
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T1, typename T2>\par
struct testing::internal::CompileAssertTypesEqual< T1, T2 >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 773}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::CompileAssertTypesEqual< T, T >\par \pard\plain 
{\tc\tcl2 \v testing::internal::CompileAssertTypesEqual< T, T >}
{\xe \v testing::internal::CompileAssertTypesEqual< T, T >}
{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
\par
{
{\f2 #include <gtest-internal.h>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct testing::internal::CompileAssertTypesEqual< T, T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 776}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'E0 testing::internal::ConstCharPtr\par \pard\plain 
{\tc\tcl2 \v testing::internal::ConstCharPtr}
{\xe \v testing::internal::ConstCharPtr}
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ConstCharPtr} (const char *str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator bool} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 742}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v ConstCharPtr\:testing::internal::ConstCharPtr}
{\xe \v testing::internal::ConstCharPtr\:ConstCharPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::ConstCharPtr::ConstCharPtr (const char *  {\i str}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 743}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00743 : value(str) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v operator bool\:testing::internal::ConstCharPtr}
{\xe \v testing::internal::ConstCharPtr\:operator bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::ConstCharPtr::operator bool () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 744}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00744 \{ {\cf19 return} {\cf17 true}; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v value\:testing::internal::ConstCharPtr}
{\xe \v testing::internal::ConstCharPtr\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* testing::internal::ConstCharPtr::value}}
\par
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 745}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::DefaultGlobalTestPartResultReporter\par \pard\plain 
{\tc\tcl2 \v testing::internal::DefaultGlobalTestPartResultReporter}
{\xe \v testing::internal::DefaultGlobalTestPartResultReporter}
{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
\par
{
{\f2 #include <gtest-internal-inl.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::internal::DefaultGlobalTestPartResultReporter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtesting_1_1internal_1_1_default_global_test_part_result_reporter.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DefaultGlobalTestPartResultReporter} ({\b UnitTestImpl} *unit_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ReportTestPartResult} (const {\b TestPartResult} &result)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 465}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v DefaultGlobalTestPartResultReporter\:testing::internal::DefaultGlobalTestPartResultReporter}
{\xe \v testing::internal::DefaultGlobalTestPartResultReporter\:DefaultGlobalTestPartResultReporter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::DefaultGlobalTestPartResultReporter::DefaultGlobalTestPartResultReporter ({\b UnitTestImpl} *  {\i unit_test}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 683}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00684                              : unit_test_(unit_test) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v ReportTestPartResult\:testing::internal::DefaultGlobalTestPartResultReporter}
{\xe \v testing::internal::DefaultGlobalTestPartResultReporter\:ReportTestPartResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::DefaultGlobalTestPartResultReporter::ReportTestPartResult (const {\b TestPartResult} &  {\i result}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestPartResultReporterInterface} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 686}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00687                                   \{\par
00688   unit_test_->current_test_result()->AddTestPartResult(result);\par
00689   unit_test_->listeners()->repeater()->OnTestPartResult(result);\par
00690 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UnitTestImpl::current_test_result()}, {\b testing::internal::UnitTestImpl::listeners()} \'E8 {\b testing::TestEventListener::OnTestPartResult()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-internal-inl.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::DefaultPerThreadTestPartResultReporter\par \pard\plain 
{\tc\tcl2 \v testing::internal::DefaultPerThreadTestPartResultReporter}
{\xe \v testing::internal::DefaultPerThreadTestPartResultReporter}
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
\par
{
{\f2 #include <gtest-internal-inl.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::internal::DefaultPerThreadTestPartResultReporter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtesting_1_1internal_1_1_default_per_thread_test_part_result_reporter.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DefaultPerThreadTestPartResultReporter} ({\b UnitTestImpl} *unit_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ReportTestPartResult} (const {\b TestPartResult} &result)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 481}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v DefaultPerThreadTestPartResultReporter\:testing::internal::DefaultPerThreadTestPartResultReporter}
{\xe \v testing::internal::DefaultPerThreadTestPartResultReporter\:DefaultPerThreadTestPartResultReporter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::DefaultPerThreadTestPartResultReporter::DefaultPerThreadTestPartResultReporter ({\b UnitTestImpl} *  {\i unit_test}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 692}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00693                              : unit_test_(unit_test) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v ReportTestPartResult\:testing::internal::DefaultPerThreadTestPartResultReporter}
{\xe \v testing::internal::DefaultPerThreadTestPartResultReporter\:ReportTestPartResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::DefaultPerThreadTestPartResultReporter::ReportTestPartResult (const {\b TestPartResult} &  {\i result}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestPartResultReporterInterface} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 695}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00696                                   \{\par
00697   unit_test_->GetGlobalTestPartResultReporter()->ReportTestPartResult(result);\par
00698 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UnitTestImpl::GetGlobalTestPartResultReporter()} \'E8 {\b testing::TestPartResultReporterInterface::ReportTestPartResult()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-internal-inl.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::EmptyTestEventListener\par \pard\plain 
{\tc\tcl2 \v testing::EmptyTestEventListener}
{\xe \v testing::EmptyTestEventListener}
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
\par
{
{\f2 #include <gtest.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::EmptyTestEventListener:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtesting_1_1_empty_test_event_listener.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestProgramStart} (const {\b UnitTest} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestIterationStart} (const {\b UnitTest} &, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsSetUpStart} (const {\b UnitTest} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsSetUpEnd} (const {\b UnitTest} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestCaseStart} (const {\b TestCase} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestStart} (const {\b TestInfo} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestPartResult} (const {\b TestPartResult} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestEnd} (const {\b TestInfo} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestCaseEnd} (const {\b TestCase} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsTearDownStart} (const {\b UnitTest} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsTearDownEnd} (const {\b UnitTest} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestIterationEnd} (const {\b UnitTest} &, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestProgramEnd} (const {\b UnitTest} &)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1044}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v OnEnvironmentsSetUpEnd\:testing::EmptyTestEventListener}
{\xe \v testing::EmptyTestEventListener\:OnEnvironmentsSetUpEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::EmptyTestEventListener::OnEnvironmentsSetUpEnd (const {\b UnitTest} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1050}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01050 \{\}\par
}
}
{\xe \v OnEnvironmentsSetUpStart\:testing::EmptyTestEventListener}
{\xe \v testing::EmptyTestEventListener\:OnEnvironmentsSetUpStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::EmptyTestEventListener::OnEnvironmentsSetUpStart (const {\b UnitTest} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1049}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01049 \{\}\par
}
}
{\xe \v OnEnvironmentsTearDownEnd\:testing::EmptyTestEventListener}
{\xe \v testing::EmptyTestEventListener\:OnEnvironmentsTearDownEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::EmptyTestEventListener::OnEnvironmentsTearDownEnd (const {\b UnitTest} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1057}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01057 \{\}\par
}
}
{\xe \v OnEnvironmentsTearDownStart\:testing::EmptyTestEventListener}
{\xe \v testing::EmptyTestEventListener\:OnEnvironmentsTearDownStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::EmptyTestEventListener::OnEnvironmentsTearDownStart (const {\b UnitTest} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1056}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01056 \{\}\par
}
}
{\xe \v OnTestCaseEnd\:testing::EmptyTestEventListener}
{\xe \v testing::EmptyTestEventListener\:OnTestCaseEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::EmptyTestEventListener::OnTestCaseEnd (const {\b TestCase} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1055}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01055 \{\}\par
}
}
{\xe \v OnTestCaseStart\:testing::EmptyTestEventListener}
{\xe \v testing::EmptyTestEventListener\:OnTestCaseStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::EmptyTestEventListener::OnTestCaseStart (const {\b TestCase} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1051}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01051 \{\}\par
}
}
{\xe \v OnTestEnd\:testing::EmptyTestEventListener}
{\xe \v testing::EmptyTestEventListener\:OnTestEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::EmptyTestEventListener::OnTestEnd (const {\b TestInfo} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1054}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01054 \{\}\par
}
}
{\xe \v OnTestIterationEnd\:testing::EmptyTestEventListener}
{\xe \v testing::EmptyTestEventListener\:OnTestIterationEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::EmptyTestEventListener::OnTestIterationEnd (const {\b UnitTest} & , int ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'CF\'E5\'F0\'E5\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'FF\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::XmlUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1058}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01059                                          \{\}\par
}
}
{\xe \v OnTestIterationStart\:testing::EmptyTestEventListener}
{\xe \v testing::EmptyTestEventListener\:OnTestIterationStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::EmptyTestEventListener::OnTestIterationStart (const {\b UnitTest} & , int ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1047}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01048                                            \{\}\par
}
}
{\xe \v OnTestPartResult\:testing::EmptyTestEventListener}
{\xe \v testing::EmptyTestEventListener\:OnTestPartResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::EmptyTestEventListener::OnTestPartResult (const {\b TestPartResult} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1053}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01053 \{\}\par
}
}
{\xe \v OnTestProgramEnd\:testing::EmptyTestEventListener}
{\xe \v testing::EmptyTestEventListener\:OnTestProgramEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::EmptyTestEventListener::OnTestProgramEnd (const {\b UnitTest} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1060}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01060 \{\}\par
}
}
{\xe \v OnTestProgramStart\:testing::EmptyTestEventListener}
{\xe \v testing::EmptyTestEventListener\:OnTestProgramStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::EmptyTestEventListener::OnTestProgramStart (const {\b UnitTest} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1046}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01046 \{\}\par
}
}
{\xe \v OnTestStart\:testing::EmptyTestEventListener}
{\xe \v testing::EmptyTestEventListener\:OnTestStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::EmptyTestEventListener::OnTestStart (const {\b TestInfo} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1052}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01052 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::EnableIf< bool >\par \pard\plain 
{\tc\tcl2 \v testing::internal::EnableIf< bool >}
{\xe \v testing::internal::EnableIf< bool >}
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<bool>\par
struct testing::internal::EnableIf< bool >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 947}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'E0 testing::internal::EnableIf< true >\par \pard\plain 
{\tc\tcl2 \v testing::internal::EnableIf< true >}
{\xe \v testing::internal::EnableIf< true >}
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 948}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:testing::internal::EnableIf< true >}
{\xe \v testing::internal::EnableIf< true >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void {\b testing::internal::EnableIf}< true >::type}}
\par
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 948}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::Environment\par \pard\plain 
{\tc\tcl2 \v testing::Environment}
{\xe \v testing::Environment}
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
\par
{
{\f2 #include <gtest.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Environment} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b SetUp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b TearDown} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 972}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v ~Environment\:testing::Environment}
{\xe \v testing::Environment\:~Environment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual testing::Environment::~Environment (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 975}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00975 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v SetUp\:testing::Environment}
{\xe \v testing::Environment\:SetUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::Environment::SetUp (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 978}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00978 \{\}\par
}
}
{\xe \v TearDown\:testing::Environment}
{\xe \v testing::Environment\:TearDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::Environment::TearDown (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 981}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00981 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::EqHelper< lhs_is_null_literal >\par \pard\plain 
{\tc\tcl2 \v testing::internal::EqHelper< lhs_is_null_literal >}
{\xe \v testing::internal::EqHelper< lhs_is_null_literal >}
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
\par
{
{\f2 #include <gtest.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > static {\b AssertionResult} {\b Compare} (const char *lhs_expression, const char *rhs_expression, const T1 &lhs, const T2 &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b AssertionResult} {\b Compare} (const char *lhs_expression, const char *rhs_expression, {\b BiggestInt} lhs, {\b BiggestInt} rhs)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<bool lhs_is_null_literal>\par
class testing::internal::EqHelper< lhs_is_null_literal >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1413}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Compare\:testing::internal::EqHelper< lhs_is_null_literal >}
{\xe \v testing::internal::EqHelper< lhs_is_null_literal >\:Compare}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<bool lhs_is_null_literal> static {\b AssertionResult} {\b testing::internal::EqHelper}< lhs_is_null_literal >::Compare (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, {\b BiggestInt}  {\i lhs}, {\b BiggestInt}  {\i rhs}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1430}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01433                                                  \{\par
01434     {\cf19 return} CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\par
01435   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CmpHelperEQ()}.}\par
}
{\xe \v Compare\:testing::internal::EqHelper< lhs_is_null_literal >}
{\xe \v testing::internal::EqHelper< lhs_is_null_literal >\:Compare}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<bool lhs_is_null_literal> template<typename T1 , typename T2 > static {\b AssertionResult} {\b testing::internal::EqHelper}< lhs_is_null_literal >::Compare (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, const T1 &  {\i lhs}, const T2 &  {\i rhs}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1417}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01420                                                 \{\par
01421     {\cf19 return} CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\par
01422   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CmpHelperEQ()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::EqHelper< true >\par \pard\plain 
{\tc\tcl2 \v testing::internal::EqHelper< true >}
{\xe \v testing::internal::EqHelper< true >}
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
\par
{
{\f2 #include <gtest.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > static {\b AssertionResult} {\b Compare} (const char *lhs_expression, const char *rhs_expression, const T1 &lhs, const T2 &rhs, typename {\b EnableIf}<!{\b is_pointer}< T2 >::value >::type *=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static {\b AssertionResult} {\b Compare} (const char *lhs_expression, const char *rhs_expression, Secret *, T *rhs)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1441}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Compare\:testing::internal::EqHelper< true >}
{\xe \v testing::internal::EqHelper< true >\:Compare}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T1 , typename T2 > static {\b AssertionResult} {\b testing::internal::EqHelper}< true >::Compare (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, const T1 &  {\i lhs}, const T2 &  {\i rhs}, typename {\b EnableIf}<!{\b is_pointer}< T2 >::value >::type *  = {\f2 0}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1448}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01458                                                         \{\par
01459     {\cf19 return} CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\par
01460   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CmpHelperEQ()}.}\par
}
{\xe \v Compare\:testing::internal::EqHelper< true >}
{\xe \v testing::internal::EqHelper< true >\:Compare}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static {\b AssertionResult} {\b testing::internal::EqHelper}< true >::Compare (const char *  {\i lhs_expression}, const char *  {\i rhs_expression}, Secret * , T *  {\i rhs}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1465}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01475               \{\par
01476     {\cf20 // We already know that 'lhs' is a null pointer.}\par
01477     {\cf19 return} CmpHelperEQ(lhs_expression, rhs_expression,\par
01478                        {\cf17 static_cast<}T*{\cf17 >}(NULL), rhs);\par
01479   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CmpHelperEQ()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::FilePath\par \pard\plain 
{\tc\tcl2 \v testing::internal::FilePath}
{\xe \v testing::internal::FilePath}
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
\par
{
{\f2 #include <gtest-filepath.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FilePath} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FilePath} (const {\b FilePath} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FilePath} (const std::string &pathname)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FilePath} & {\b operator=} (const {\b FilePath} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Set} (const {\b FilePath} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b string} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b c_str} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsEmpty} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FilePath} {\b RemoveTrailingPathSeparator} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FilePath} {\b RemoveDirectoryName} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FilePath} {\b RemoveFileName} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FilePath} {\b RemoveExtension} (const char *extension) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b CreateDirectoriesRecursively} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b CreateFolder} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b FileOrDirectoryExists} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b DirectoryExists} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsDirectory} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsRootDirectory} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsAbsolutePath} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b FilePath} {\b GetCurrentDir} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b FilePath} {\b MakeFileName} (const {\b FilePath} &directory, const {\b FilePath} &base_name, int number, const char *extension)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b FilePath} {\b ConcatPaths} (const {\b FilePath} &directory, const {\b FilePath} &relative_path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b FilePath} {\b GenerateUniqueFileName} (const {\b FilePath} &directory, const {\b FilePath} &base_name, const char *extension)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 59}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v FilePath\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:FilePath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::FilePath::FilePath (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 61}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00061 : pathname_({\cf22 ""}) \{ \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ConcatPaths()}, {\b GetCurrentDir()}, {\b MakeFileName()}, {\b RemoveDirectoryName()}, {\b RemoveExtension()}, {\b RemoveFileName()} \'E8 {\b RemoveTrailingPathSeparator()}.}\par
}
{\xe \v FilePath\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:FilePath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::FilePath::FilePath (const {\b FilePath} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 62}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00062 : pathname_(rhs.pathname_) \{ \}\par
}
}
{\xe \v FilePath\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:FilePath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::FilePath::FilePath (const std::string &  {\i pathname}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 64}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00064                                                : pathname_(pathname) \{\par
00065     Normalize();\par
00066   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v c_str\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:c_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::internal::FilePath::c_str () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 78}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00078 \{ {\cf19 return} pathname_.c_str(); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CreateFolder()}, {\b DirectoryExists()}, {\b testing::UnitTest::original_working_dir()} \'E8 {\b RemoveFileName()}.}\par
}
{\xe \v ConcatPaths\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:ConcatPaths}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FilePath} testing::internal::FilePath::ConcatPaths (const {\b FilePath} &  {\i directory}, const {\b FilePath} &  {\i relative_path}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 199}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00200                                                               \{\par
00201   {\cf19 if} (directory.IsEmpty())\par
00202     {\cf19 return} relative_path;\par
00203   {\cf17 const} FilePath dir(directory.RemoveTrailingPathSeparator());\par
00204   {\cf19 return} FilePath(dir.string() + kPathSeparator + relative_path.string());\par
00205 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b FilePath()}, {\b IsEmpty()}, {\b testing::internal::kPathSeparator}, {\b RemoveTrailingPathSeparator()} \'E8 {\b string()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestOptions::GetAbsolutePathToOutputFile()} \'E8 {\b MakeFileName()}.}\par
}
{\xe \v CreateDirectoriesRecursively\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:CreateDirectoriesRecursively}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::FilePath::CreateDirectoriesRecursively () const}}
\par
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 308}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00308                                                   \{\par
00309   {\cf19 if} (!this->IsDirectory()) \{\par
00310     {\cf19 return} {\cf17 false};\par
00311   \}\par
00312 \par
00313   {\cf19 if} (pathname_.length() == 0 || this->DirectoryExists()) \{\par
00314     {\cf19 return} {\cf17 true};\par
00315   \}\par
00316 \par
00317   {\cf17 const} FilePath parent(this->RemoveTrailingPathSeparator().RemoveFileName());\par
00318   {\cf19 return} parent.CreateDirectoriesRecursively() && this->CreateFolder();\par
00319 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b CreateDirectoriesRecursively()}, {\b CreateFolder()}, {\b IsDirectory()}, {\b RemoveFileName()} \'E8 {\b RemoveTrailingPathSeparator()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CreateDirectoriesRecursively()} \'E8 {\b testing::internal::XmlUnitTestResultPrinter::OnTestIterationEnd()}.}\par
}
{\xe \v CreateFolder\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:CreateFolder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::FilePath::CreateFolder () const}}
\par
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 325}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00325                                   \{\par
00326 {\cf21 #if GTEST_OS_WINDOWS_MOBILE}\par
00327   FilePath removed_sep(this->RemoveTrailingPathSeparator());\par
00328   LPCWSTR unicode = String::AnsiToUtf16(removed_sep.c_str());\par
00329   {\cf18 int} result = CreateDirectory(unicode, NULL) ? 0 : -1;\par
00330   {\cf17 delete} [] unicode;\par
00331 {\cf21 #elif GTEST_OS_WINDOWS}\par
00332   {\cf18 int} result = _mkdir(pathname_.c_str());\par
00333 {\cf21 #else}\par
00334   {\cf18 int} result = mkdir(pathname_.c_str(), 0777);\par
00335 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
00336 \par
00337   {\cf19 if} (result == -1) \{\par
00338     {\cf19 return} this->DirectoryExists();  {\cf20 // An error is OK if the directory exists.}\par
00339   \}\par
00340   {\cf19 return} {\cf17 true};  {\cf20 // No error.}\par
00341 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b c_str()}, {\b DirectoryExists()} \'E8 {\b RemoveTrailingPathSeparator()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CreateDirectoriesRecursively()}.}\par
}
{\xe \v DirectoryExists\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:DirectoryExists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::FilePath::DirectoryExists () const}}
\par
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 223}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00223                                      \{\par
00224   {\cf18 bool} result = {\cf17 false};\par
00225 {\cf21 #if GTEST_OS_WINDOWS}\par
00226   {\cf20 // Don't strip off trailing separator if path is a root directory on}\par
00227   {\cf20 // Windows (like "C:\\\\").}\par
00228   {\cf17 const} FilePath& path(IsRootDirectory() ? *{\cf17 this} :\par
00229                                            RemoveTrailingPathSeparator());\par
00230 {\cf21 #else}\par
00231   {\cf17 const} FilePath& path(*{\cf17 this});\par
00232 {\cf21 #endif}\par
00233 \par
00234 {\cf21 #if GTEST_OS_WINDOWS_MOBILE}\par
00235   LPCWSTR unicode = String::AnsiToUtf16(path.c_str());\par
00236   {\cf17 const} DWORD attributes = GetFileAttributes(unicode);\par
00237   {\cf17 delete} [] unicode;\par
00238   {\cf19 if} ((attributes != kInvalidFileAttributes) &&\par
00239       (attributes & FILE_ATTRIBUTE_DIRECTORY)) \{\par
00240     result = {\cf17 true};\par
00241   \}\par
00242 {\cf21 #else}\par
00243   posix::StatStruct file_stat;\par
00244   result = posix::Stat(path.c_str(), &file_stat) == 0 &&\par
00245       posix::IsDir(file_stat);\par
00246 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
00247 \par
00248   {\cf19 return} result;\par
00249 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b c_str()}, {\b testing::internal::posix::IsDir()}, {\b IsRootDirectory()}, {\b RemoveTrailingPathSeparator()} \'E8 {\b testing::internal::posix::Stat()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CreateFolder()}.}\par
}
{\xe \v FileOrDirectoryExists\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:FileOrDirectoryExists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::FilePath::FileOrDirectoryExists () const}}
\par
{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 209}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00209                                            \{\par
00210 {\cf21 #if GTEST_OS_WINDOWS_MOBILE}\par
00211   LPCWSTR unicode = String::AnsiToUtf16(pathname_.c_str());\par
00212   {\cf17 const} DWORD attributes = GetFileAttributes(unicode);\par
00213   {\cf17 delete} [] unicode;\par
00214   {\cf19 return} attributes != kInvalidFileAttributes;\par
00215 {\cf21 #else}\par
00216   posix::StatStruct file_stat;\par
00217   {\cf19 return} posix::Stat(pathname_.c_str(), &file_stat) == 0;\par
00218 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
00219 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::posix::Stat()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b GenerateUniqueFileName()}.}\par
}
{\xe \v GenerateUniqueFileName\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:GenerateUniqueFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FilePath} testing::internal::FilePath::GenerateUniqueFileName (const {\b FilePath} &  {\i directory}, const {\b FilePath} &  {\i base_name}, const char *  {\i extension}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 286}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00288                                                                  \{\par
00289   FilePath full_pathname;\par
00290   {\cf18 int} number = 0;\par
00291   {\cf19 do} \{\par
00292     full_pathname.Set(MakeFileName(directory, base_name, number++, extension));\par
00293   \} {\cf19 while} (full_pathname.FileOrDirectoryExists());\par
00294   {\cf19 return} full_pathname;\par
00295 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b FileOrDirectoryExists()}, {\b MakeFileName()} \'E8 {\b Set()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestOptions::GetAbsolutePathToOutputFile()}.}\par
}
{\xe \v GetCurrentDir\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:GetCurrentDir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FilePath} testing::internal::FilePath::GetCurrentDir (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 99}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00099                                  \{\par
00100 {\cf21 #if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT}\par
00101   {\cf20 // Windows CE doesn't have a current directory, so we just return}\par
00102   {\cf20 // something reasonable.}\par
00103   {\cf19 return} FilePath(kCurrentDirectoryString);\par
00104 {\cf21 #elif GTEST_OS_WINDOWS}\par
00105   {\cf18 char} cwd[GTEST_PATH_MAX_ + 1] = \{ {\cf23 '\\0'} \};\par
00106   {\cf19 return} FilePath(_getcwd(cwd, {\cf17 sizeof}(cwd)) == NULL ? {\cf22 ""} : cwd);\par
00107 {\cf21 #else}\par
00108   {\cf18 char} cwd[GTEST_PATH_MAX_ + 1] = \{ {\cf23 '\\0'} \};\par
00109   {\cf18 char}* result = getcwd(cwd, {\cf17 sizeof}(cwd));\par
00110 {\cf21 # if GTEST_OS_NACL}\par
00111   {\cf20 // getcwd will likely fail in NaCl due to the sandbox, so return something}\par
00112   {\cf20 // reasonable. The user may have provided a shim implementation for getcwd,}\par
00113   {\cf20 // however, so fallback only when failure is detected.}\par
00114   {\cf19 return} FilePath(result == NULL ? kCurrentDirectoryString : cwd);\par
00115 {\cf21 # endif  }{\cf20 // GTEST_OS_NACL}\par
00116   {\cf19 return} FilePath(result == NULL ? {\cf22 ""} : cwd);\par
00117 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
00118 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b FilePath()}, {\b GTEST_PATH_MAX_} \'E8 {\b testing::internal::kCurrentDirectoryString}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::AddTestInfo()}.}\par
}
{\xe \v IsAbsolutePath\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:IsAbsolutePath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::FilePath::IsAbsolutePath () const}}
\par
{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 265}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00265                                     \{\par
00266   {\cf17 const} {\cf18 char}* {\cf17 const} name = pathname_.c_str();\par
00267 {\cf21 #if GTEST_OS_WINDOWS}\par
00268   {\cf19 return} pathname_.length() >= 3 &&\par
00269      ((name[0] >= {\cf23 'a'} && name[0] <= {\cf23 'z'}) ||\par
00270       (name[0] >= {\cf23 'A'} && name[0] <= {\cf23 'Z'})) &&\par
00271      name[1] == {\cf23 ':'} &&\par
00272      IsPathSeparator(name[2]);\par
00273 {\cf21 #else}\par
00274   {\cf19 return} IsPathSeparator(name[0]);\par
00275 {\cf21 #endif}\par
00276 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestOptions::GetAbsolutePathToOutputFile()} \'E8 {\b IsRootDirectory()}.}\par
}
{\xe \v IsDirectory\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:IsDirectory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::FilePath::IsDirectory () const}}
\par
{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 300}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00300                                  \{\par
00301   {\cf19 return} !pathname_.empty() &&\par
00302          IsPathSeparator(pathname_.c_str()[pathname_.length() - 1]);\par
00303 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CreateDirectoriesRecursively()}, {\b testing::internal::UnitTestOptions::GetAbsolutePathToOutputFile()} \'E8 {\b RemoveTrailingPathSeparator()}.}\par
}
{\xe \v IsEmpty\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:IsEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::FilePath::IsEmpty () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 111}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00111 \{ {\cf19 return} pathname_.empty(); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ConcatPaths()}.}\par
}
{\xe \v IsRootDirectory\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:IsRootDirectory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::FilePath::IsRootDirectory () const}}
\par
{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 253}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00253                                      \{\par
00254 {\cf21 #if GTEST_OS_WINDOWS}\par
00255   {\cf20 // TODO(wan@google.com): on Windows a network share like}\par
00256   {\cf20 // \\\\server\\share can be a root directory, although it cannot be the}\par
00257   {\cf20 // current directory.  Handle this properly.}\par
00258   {\cf19 return} pathname_.length() == 3 && IsAbsolutePath();\par
00259 {\cf21 #else}\par
00260   {\cf19 return} pathname_.length() == 1 && IsPathSeparator(pathname_.c_str()[0]);\par
00261 {\cf21 #endif}\par
00262 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b IsAbsolutePath()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b DirectoryExists()}.}\par
}
{\xe \v MakeFileName\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:MakeFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FilePath} testing::internal::FilePath::MakeFileName (const {\b FilePath} &  {\i directory}, const {\b FilePath} &  {\i base_name}, int  {\i number}, const char *  {\i extension}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 183}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00186                                                        \{\par
00187   std::string file;\par
00188   {\cf19 if} (number == 0) \{\par
00189     file = base_name.string() + {\cf22 "."} + extension;\par
00190   \} {\cf19 else} \{\par
00191     file = base_name.string() + {\cf22 "_"} + StreamableToString(number)\par
00192         + {\cf22 "."} + extension;\par
00193   \}\par
00194   {\cf19 return} ConcatPaths(directory, FilePath(file));\par
00195 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ConcatPaths()}, {\b FilePath()}, {\b testing::internal::StreamableToString()} \'E8 {\b string()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b GenerateUniqueFileName()}.}\par
}
{\xe \v operator=\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FilePath} & testing::internal::FilePath::operator= (const {\b FilePath} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 68}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00068                                            \{\par
00069     Set(rhs);\par
00070     {\cf19 return} *{\cf17 this};\par
00071   \}\par
}
}
{\xe \v RemoveDirectoryName\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:RemoveDirectoryName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FilePath} testing::internal::FilePath::RemoveDirectoryName () const}}
\par
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 155}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00155                                              \{\par
00156   {\cf17 const} {\cf18 char}* {\cf17 const} last_sep = FindLastPathSeparator();\par
00157   {\cf19 return} last_sep ? FilePath(last_sep + 1) : *this;\par
00158 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b FilePath()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::GetCurrentExecutableName()}.}\par
}
{\xe \v RemoveExtension\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:RemoveExtension}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FilePath} testing::internal::FilePath::RemoveExtension (const char *  {\i extension}) const}}
\par
{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 124}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00124                                                               \{\par
00125   {\cf17 const} std::string dot_extension = std::string({\cf22 "."}) + extension;\par
00126   {\cf19 if} (String::EndsWithCaseInsensitive(pathname_, dot_extension)) \{\par
00127     {\cf19 return} FilePath(pathname_.substr(\par
00128         0, pathname_.length() - dot_extension.length()));\par
00129   \}\par
00130   {\cf19 return} *{\cf17 this};\par
00131 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::String::EndsWithCaseInsensitive()} \'E8 {\b FilePath()}.}\par
}
{\xe \v RemoveFileName\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:RemoveFileName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FilePath} testing::internal::FilePath::RemoveFileName () const}}
\par
{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 166}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00166                                         \{\par
00167   {\cf17 const} {\cf18 char}* {\cf17 const} last_sep = FindLastPathSeparator();\par
00168   std::string dir;\par
00169   {\cf19 if} (last_sep) \{\par
00170     dir = std::string(c_str(), last_sep + 1 - c_str());\par
00171   \} {\cf19 else} \{\par
00172     dir = kCurrentDirectoryString;\par
00173   \}\par
00174   {\cf19 return} FilePath(dir);\par
00175 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b c_str()}, {\b FilePath()} \'E8 {\b testing::internal::kCurrentDirectoryString}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CreateDirectoriesRecursively()} \'E8 {\b testing::internal::XmlUnitTestResultPrinter::OnTestIterationEnd()}.}\par
}
{\xe \v RemoveTrailingPathSeparator\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:RemoveTrailingPathSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FilePath} testing::internal::FilePath::RemoveTrailingPathSeparator () const}}
\par
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 346}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00346                                                      \{\par
00347   {\cf19 return} IsDirectory()\par
00348       ? FilePath(pathname_.substr(0, pathname_.length() - 1))\par
00349       : *this;\par
00350 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b FilePath()} \'E8 {\b IsDirectory()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ConcatPaths()}, {\b CreateDirectoriesRecursively()}, {\b CreateFolder()} \'E8 {\b DirectoryExists()}.}\par
}
{\xe \v Set\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:Set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::FilePath::Set (const {\b FilePath} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 73}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00073                                 \{\par
00074     pathname_ = rhs.pathname_;\par
00075   \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b GenerateUniqueFileName()} \'E8 {\b testing::internal::GetCurrentExecutableName()}.}\par
}
{\xe \v string\:testing::internal::FilePath}
{\xe \v testing::internal::FilePath\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string & testing::internal::FilePath::string () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 77}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00077 \{ {\cf19 return} pathname_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ConcatPaths()}, {\b testing::internal::UnitTestOptions::GetAbsolutePathToOutputFile()} \'E8 {\b MakeFileName()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-filepath.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-filepath.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::FloatingPoint< RawType >\par \pard\plain 
{\tc\tcl2 \v testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >}
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b TypeWithSize}< sizeof(RawType)>::UInt {\b Bits}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FloatingPoint} (const RawType &x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Bits} & {\b bits} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bits} {\b exponent_bits} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bits} {\b fraction_bits} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bits} {\b sign_bit} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_nan} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b AlmostEquals} (const {\b FloatingPoint} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Max} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Max} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static RawType {\b ReinterpretBits} (const {\b Bits} {\b bits})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static RawType {\b Infinity} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static RawType {\b Max} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b kBitCount} = 8*sizeof(RawType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b kFractionBitCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b kExponentBitCount} = {\b kBitCount} - 1 - {\b kFractionBitCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b Bits} {\b kSignBitMask} = static_cast<{\b Bits}>(1) << ({\b kBitCount} - 1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b Bits} {\b kFractionBitMask}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b Bits} {\b kExponentBitMask} = ~({\b kSignBitMask} | {\b kFractionBitMask})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b kMaxUlps} = 4\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename RawType>\par
class testing::internal::FloatingPoint< RawType >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 262}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v Bits\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:Bits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > typedef {\b TypeWithSize}<sizeof(RawType)>::UInt {\b testing::internal::FloatingPoint}< RawType >::Bits}}
\par
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 266}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v FloatingPoint\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:FloatingPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > {\b testing::internal::FloatingPoint}< RawType >::FloatingPoint (const RawType &  {\i x}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 310}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00310 \{ u_.value_ = x; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v AlmostEquals\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:AlmostEquals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > bool {\b testing::internal::FloatingPoint}< RawType >::AlmostEquals (const {\b FloatingPoint}< RawType > &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 358}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00358                                                     \{\par
00359     {\cf20 // The IEEE standard says that any comparison operation involving}\par
00360     {\cf20 // a NAN must return false.}\par
00361     {\cf19 if} (is_nan() || rhs.is_nan()) {\cf19 return} {\cf17 false};\par
00362 \par
00363     {\cf19 return} DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)\par
00364         <= kMaxUlps;\par
00365   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::FloatingPoint< RawType >::is_nan()} \'E8 {\b testing::internal::FloatingPoint< RawType >::kMaxUlps}.}\par
}
{\xe \v bits\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:bits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > const {\b Bits} & {\b testing::internal::FloatingPoint}< RawType >::bits () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 334}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00334 \{ {\cf19 return} u_.bits_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FloatingPoint< RawType >::ReinterpretBits()}.}\par
}
{\xe \v exponent_bits\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:exponent_bits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > {\b Bits} {\b testing::internal::FloatingPoint}< RawType >::exponent_bits () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 337}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00337 \{ {\cf19 return} kExponentBitMask & u_.bits_; \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::FloatingPoint< RawType >::kExponentBitMask}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FloatingPoint< RawType >::is_nan()}.}\par
}
{\xe \v fraction_bits\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:fraction_bits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > {\b Bits} {\b testing::internal::FloatingPoint}< RawType >::fraction_bits () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 340}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00340 \{ {\cf19 return} kFractionBitMask & u_.bits_; \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::FloatingPoint< RawType >::kFractionBitMask}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FloatingPoint< RawType >::is_nan()}.}\par
}
{\xe \v Infinity\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:Infinity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > static RawType {\b testing::internal::FloatingPoint}< RawType >::Infinity (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 324}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00324                             \{\par
00325     {\cf19 return} ReinterpretBits(kExponentBitMask);\par
00326   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::FloatingPoint< RawType >::kExponentBitMask} \'E8 {\b testing::internal::FloatingPoint< RawType >::ReinterpretBits()}.}\par
}
{\xe \v is_nan\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:is_nan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > bool {\b testing::internal::FloatingPoint}< RawType >::is_nan () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 346}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00346                       \{\par
00347     {\cf20 // It's a NAN if the exponent bits are all ones and the fraction}\par
00348     {\cf20 // bits are not entirely zeros.}\par
00349     {\cf19 return} (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);\par
00350   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::FloatingPoint< RawType >::exponent_bits()}, {\b testing::internal::FloatingPoint< RawType >::fraction_bits()} \'E8 {\b testing::internal::FloatingPoint< RawType >::kExponentBitMask}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FloatingPoint< RawType >::AlmostEquals()}.}\par
}
{\xe \v Max\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:Max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > static RawType {\b testing::internal::FloatingPoint}< RawType >::Max (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Max\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:Max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float {\b testing::internal::FloatingPoint}< float >::Max (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 414}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00414 \{ {\cf19 return} FLT_MAX; \}\par
}
}
{\xe \v Max\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:Max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double {\b testing::internal::FloatingPoint}< double >::Max (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 416}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00416 \{ {\cf19 return} DBL_MAX; \}\par
}
}
{\xe \v ReinterpretBits\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:ReinterpretBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > static RawType {\b testing::internal::FloatingPoint}< RawType >::ReinterpretBits (const {\b Bits}  {\i bits}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 317}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00317                                                   \{\par
00318     FloatingPoint fp(0);\par
00319     fp.u_.bits_ = bits;\par
00320     {\cf19 return} fp.u_.value_;\par
00321   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::FloatingPoint< RawType >::bits()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FloatingPoint< RawType >::Infinity()}.}\par
}
{\xe \v sign_bit\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:sign_bit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > {\b Bits} {\b testing::internal::FloatingPoint}< RawType >::sign_bit () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 343}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00343 \{ {\cf19 return} kSignBitMask & u_.bits_; \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::FloatingPoint< RawType >::kSignBitMask}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v kBitCount\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:kBitCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > const size_t {\b testing::internal::FloatingPoint}< RawType >::kBitCount = 8*sizeof(RawType){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 271}}\par
}
{\xe \v kExponentBitCount\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:kExponentBitCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > const size_t {\b testing::internal::FloatingPoint}< RawType >::kExponentBitCount = {\b kBitCount} - 1 - {\b kFractionBitCount}{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 278}}\par
}
{\xe \v kExponentBitMask\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:kExponentBitMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > const {\b Bits} {\b testing::internal::FloatingPoint}< RawType >::kExponentBitMask = ~({\b kSignBitMask} | {\b kFractionBitMask}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 288}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FloatingPoint< RawType >::exponent_bits()}, {\b testing::internal::FloatingPoint< RawType >::Infinity()} \'E8 {\b testing::internal::FloatingPoint< RawType >::is_nan()}.}\par
}
{\xe \v kFractionBitCount\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:kFractionBitCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > const size_t {\b testing::internal::FloatingPoint}< RawType >::kFractionBitCount{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'C8\'ED\'E8\'F6\'E8\'E0\'EB\'E8\'E7\'E0\'F2\'EE\'F0}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
    std::numeric_limits<RawType>::digits - 1\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 274}}\par
}
{\xe \v kFractionBitMask\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:kFractionBitMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > const {\b Bits} {\b testing::internal::FloatingPoint}< RawType >::kFractionBitMask{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'C8\'ED\'E8\'F6\'E8\'E0\'EB\'E8\'E7\'E0\'F2\'EE\'F0}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
    ~static_cast<Bits>(0) >> (kExponentBitCount + 1)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 284}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FloatingPoint< RawType >::fraction_bits()}.}\par
}
{\xe \v kMaxUlps\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:kMaxUlps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > const size_t {\b testing::internal::FloatingPoint}< RawType >::kMaxUlps = 4{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 302}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FloatingPoint< RawType >::AlmostEquals()}.}\par
}
{\xe \v kSignBitMask\:testing::internal::FloatingPoint< RawType >}
{\xe \v testing::internal::FloatingPoint< RawType >\:kSignBitMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RawType > const {\b Bits} {\b testing::internal::FloatingPoint}< RawType >::kSignBitMask = static_cast<{\b Bits}>(1) << ({\b kBitCount} - 1){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 281}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FloatingPoint< RawType >::sign_bit()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::FormatForComparison< ToPrint, OtherOperand >\par \pard\plain 
{\tc\tcl2 \v testing::internal::FormatForComparison< ToPrint, OtherOperand >}
{\xe \v testing::internal::FormatForComparison< ToPrint, OtherOperand >}
{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
\par
{
{\f2 #include <gtest-printers.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
::std::string {\b Format} (const ToPrint &value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename ToPrint, typename OtherOperand>\par
class testing::internal::FormatForComparison< ToPrint, OtherOperand >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 273}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Format\:testing::internal::FormatForComparison< ToPrint, OtherOperand >}
{\xe \v testing::internal::FormatForComparison< ToPrint, OtherOperand >\:Format}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ToPrint , typename OtherOperand > ::std::string {\b testing::internal::FormatForComparison}< ToPrint, OtherOperand >::Format (const ToPrint &  {\i value}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 275}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00275                                                 \{\par
00276     return ::testing::PrintToString(value);\par
00277   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::PrintToString()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FormatForComparison< ToPrint[N], OtherOperand >::Format()} \'E8 {\b testing::internal::FormatForComparisonFailureMessage()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::FormatForComparison< ToPrint[N], OtherOperand >\par \pard\plain 
{\tc\tcl2 \v testing::internal::FormatForComparison< ToPrint[N], OtherOperand >}
{\xe \v testing::internal::FormatForComparison< ToPrint[N], OtherOperand >}
{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
\par
{
{\f2 #include <gtest-printers.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
::std::string {\b Format} (const ToPrint *value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename ToPrint, size_t N, typename OtherOperand>\par
class testing::internal::FormatForComparison< ToPrint[N], OtherOperand >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 282}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Format\:testing::internal::FormatForComparison< ToPrint[N], OtherOperand >}
{\xe \v testing::internal::FormatForComparison< ToPrint[N], OtherOperand >\:Format}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ToPrint , size_t N, typename OtherOperand > ::std::string {\b testing::internal::FormatForComparison}< ToPrint[N], OtherOperand >::Format (const ToPrint *  {\i value}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 284}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00284                                                 \{\par
00285     {\cf19 return} FormatForComparison<const ToPrint*, OtherOperand>::Format(value);\par
00286   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::FormatForComparison< ToPrint, OtherOperand >::Format()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 std::tr1::gtest_internal::Get< k >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::Get< k >}
{\xe \v std::tr1::gtest_internal::Get< k >}
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<int k>\par
class std::tr1::gtest_internal::Get< k >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 145}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 std::tr1::gtest_internal::Get< 0 >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::Get< 0 >}
{\xe \v std::tr1::gtest_internal::Get< 0 >}
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_ADD_REF_} ({\b GTEST_TUPLE_ELEMENT_}(0, Tuple)) Field(Tuple &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_BY_REF_} ({\b GTEST_TUPLE_ELEMENT_}(0, Tuple)) ConstField(const Tuple &t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 808}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v GTEST_ADD_REF_\:std::tr1::gtest_internal::Get< 0 >}
{\xe \v std::tr1::gtest_internal::Get< 0 >\:GTEST_ADD_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 0 >::GTEST_ADD_REF_ ({\b GTEST_TUPLE_ELEMENT_}(0, Tuple) ) &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 811}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00812                   \{ {\cf19 return} t.f0_; \}  {\cf20 // NOLINT}\par
}
}
{\xe \v GTEST_BY_REF_\:std::tr1::gtest_internal::Get< 0 >}
{\xe \v std::tr1::gtest_internal::Get< 0 >\:GTEST_BY_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 0 >::GTEST_BY_REF_ ({\b GTEST_TUPLE_ELEMENT_}(0, Tuple) ) const &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 815}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00816                              \{ {\cf19 return} t.f0_; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 std::tr1::gtest_internal::Get< 1 >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::Get< 1 >}
{\xe \v std::tr1::gtest_internal::Get< 1 >}
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_ADD_REF_} ({\b GTEST_TUPLE_ELEMENT_}(1, Tuple)) Field(Tuple &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_BY_REF_} ({\b GTEST_TUPLE_ELEMENT_}(1, Tuple)) ConstField(const Tuple &t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 820}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v GTEST_ADD_REF_\:std::tr1::gtest_internal::Get< 1 >}
{\xe \v std::tr1::gtest_internal::Get< 1 >\:GTEST_ADD_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 1 >::GTEST_ADD_REF_ ({\b GTEST_TUPLE_ELEMENT_}(1, Tuple) ) &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 823}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00824                   \{ {\cf19 return} t.f1_; \}  {\cf20 // NOLINT}\par
}
}
{\xe \v GTEST_BY_REF_\:std::tr1::gtest_internal::Get< 1 >}
{\xe \v std::tr1::gtest_internal::Get< 1 >\:GTEST_BY_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 1 >::GTEST_BY_REF_ ({\b GTEST_TUPLE_ELEMENT_}(1, Tuple) ) const &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 827}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00828                              \{ {\cf19 return} t.f1_; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 std::tr1::gtest_internal::Get< 2 >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::Get< 2 >}
{\xe \v std::tr1::gtest_internal::Get< 2 >}
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_ADD_REF_} ({\b GTEST_TUPLE_ELEMENT_}(2, Tuple)) Field(Tuple &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_BY_REF_} ({\b GTEST_TUPLE_ELEMENT_}(2, Tuple)) ConstField(const Tuple &t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 832}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v GTEST_ADD_REF_\:std::tr1::gtest_internal::Get< 2 >}
{\xe \v std::tr1::gtest_internal::Get< 2 >\:GTEST_ADD_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 2 >::GTEST_ADD_REF_ ({\b GTEST_TUPLE_ELEMENT_}(2, Tuple) ) &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 835}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00836                   \{ {\cf19 return} t.f2_; \}  {\cf20 // NOLINT}\par
}
}
{\xe \v GTEST_BY_REF_\:std::tr1::gtest_internal::Get< 2 >}
{\xe \v std::tr1::gtest_internal::Get< 2 >\:GTEST_BY_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 2 >::GTEST_BY_REF_ ({\b GTEST_TUPLE_ELEMENT_}(2, Tuple) ) const &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 839}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00840                              \{ {\cf19 return} t.f2_; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 std::tr1::gtest_internal::Get< 3 >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::Get< 3 >}
{\xe \v std::tr1::gtest_internal::Get< 3 >}
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_ADD_REF_} ({\b GTEST_TUPLE_ELEMENT_}(3, Tuple)) Field(Tuple &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_BY_REF_} ({\b GTEST_TUPLE_ELEMENT_}(3, Tuple)) ConstField(const Tuple &t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 844}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v GTEST_ADD_REF_\:std::tr1::gtest_internal::Get< 3 >}
{\xe \v std::tr1::gtest_internal::Get< 3 >\:GTEST_ADD_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 3 >::GTEST_ADD_REF_ ({\b GTEST_TUPLE_ELEMENT_}(3, Tuple) ) &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 847}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00848                   \{ {\cf19 return} t.f3_; \}  {\cf20 // NOLINT}\par
}
}
{\xe \v GTEST_BY_REF_\:std::tr1::gtest_internal::Get< 3 >}
{\xe \v std::tr1::gtest_internal::Get< 3 >\:GTEST_BY_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 3 >::GTEST_BY_REF_ ({\b GTEST_TUPLE_ELEMENT_}(3, Tuple) ) const &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 851}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00852                              \{ {\cf19 return} t.f3_; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 std::tr1::gtest_internal::Get< 4 >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::Get< 4 >}
{\xe \v std::tr1::gtest_internal::Get< 4 >}
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_ADD_REF_} ({\b GTEST_TUPLE_ELEMENT_}(4, Tuple)) Field(Tuple &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_BY_REF_} ({\b GTEST_TUPLE_ELEMENT_}(4, Tuple)) ConstField(const Tuple &t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 856}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v GTEST_ADD_REF_\:std::tr1::gtest_internal::Get< 4 >}
{\xe \v std::tr1::gtest_internal::Get< 4 >\:GTEST_ADD_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 4 >::GTEST_ADD_REF_ ({\b GTEST_TUPLE_ELEMENT_}(4, Tuple) ) &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 859}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00860                   \{ {\cf19 return} t.f4_; \}  {\cf20 // NOLINT}\par
}
}
{\xe \v GTEST_BY_REF_\:std::tr1::gtest_internal::Get< 4 >}
{\xe \v std::tr1::gtest_internal::Get< 4 >\:GTEST_BY_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 4 >::GTEST_BY_REF_ ({\b GTEST_TUPLE_ELEMENT_}(4, Tuple) ) const &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 863}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00864                              \{ {\cf19 return} t.f4_; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 std::tr1::gtest_internal::Get< 5 >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::Get< 5 >}
{\xe \v std::tr1::gtest_internal::Get< 5 >}
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_ADD_REF_} ({\b GTEST_TUPLE_ELEMENT_}(5, Tuple)) Field(Tuple &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_BY_REF_} ({\b GTEST_TUPLE_ELEMENT_}(5, Tuple)) ConstField(const Tuple &t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 868}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v GTEST_ADD_REF_\:std::tr1::gtest_internal::Get< 5 >}
{\xe \v std::tr1::gtest_internal::Get< 5 >\:GTEST_ADD_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 5 >::GTEST_ADD_REF_ ({\b GTEST_TUPLE_ELEMENT_}(5, Tuple) ) &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 871}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00872                   \{ {\cf19 return} t.f5_; \}  {\cf20 // NOLINT}\par
}
}
{\xe \v GTEST_BY_REF_\:std::tr1::gtest_internal::Get< 5 >}
{\xe \v std::tr1::gtest_internal::Get< 5 >\:GTEST_BY_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 5 >::GTEST_BY_REF_ ({\b GTEST_TUPLE_ELEMENT_}(5, Tuple) ) const &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 875}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00876                              \{ {\cf19 return} t.f5_; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 std::tr1::gtest_internal::Get< 6 >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::Get< 6 >}
{\xe \v std::tr1::gtest_internal::Get< 6 >}
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_ADD_REF_} ({\b GTEST_TUPLE_ELEMENT_}(6, Tuple)) Field(Tuple &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_BY_REF_} ({\b GTEST_TUPLE_ELEMENT_}(6, Tuple)) ConstField(const Tuple &t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 880}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v GTEST_ADD_REF_\:std::tr1::gtest_internal::Get< 6 >}
{\xe \v std::tr1::gtest_internal::Get< 6 >\:GTEST_ADD_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 6 >::GTEST_ADD_REF_ ({\b GTEST_TUPLE_ELEMENT_}(6, Tuple) ) &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 883}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00884                   \{ {\cf19 return} t.f6_; \}  {\cf20 // NOLINT}\par
}
}
{\xe \v GTEST_BY_REF_\:std::tr1::gtest_internal::Get< 6 >}
{\xe \v std::tr1::gtest_internal::Get< 6 >\:GTEST_BY_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 6 >::GTEST_BY_REF_ ({\b GTEST_TUPLE_ELEMENT_}(6, Tuple) ) const &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 887}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00888                              \{ {\cf19 return} t.f6_; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 std::tr1::gtest_internal::Get< 7 >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::Get< 7 >}
{\xe \v std::tr1::gtest_internal::Get< 7 >}
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_ADD_REF_} ({\b GTEST_TUPLE_ELEMENT_}(7, Tuple)) Field(Tuple &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_BY_REF_} ({\b GTEST_TUPLE_ELEMENT_}(7, Tuple)) ConstField(const Tuple &t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 892}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v GTEST_ADD_REF_\:std::tr1::gtest_internal::Get< 7 >}
{\xe \v std::tr1::gtest_internal::Get< 7 >\:GTEST_ADD_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 7 >::GTEST_ADD_REF_ ({\b GTEST_TUPLE_ELEMENT_}(7, Tuple) ) &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 895}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00896                   \{ {\cf19 return} t.f7_; \}  {\cf20 // NOLINT}\par
}
}
{\xe \v GTEST_BY_REF_\:std::tr1::gtest_internal::Get< 7 >}
{\xe \v std::tr1::gtest_internal::Get< 7 >\:GTEST_BY_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 7 >::GTEST_BY_REF_ ({\b GTEST_TUPLE_ELEMENT_}(7, Tuple) ) const &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 899}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00900                              \{ {\cf19 return} t.f7_; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 std::tr1::gtest_internal::Get< 8 >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::Get< 8 >}
{\xe \v std::tr1::gtest_internal::Get< 8 >}
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_ADD_REF_} ({\b GTEST_TUPLE_ELEMENT_}(8, Tuple)) Field(Tuple &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_BY_REF_} ({\b GTEST_TUPLE_ELEMENT_}(8, Tuple)) ConstField(const Tuple &t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 904}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v GTEST_ADD_REF_\:std::tr1::gtest_internal::Get< 8 >}
{\xe \v std::tr1::gtest_internal::Get< 8 >\:GTEST_ADD_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 8 >::GTEST_ADD_REF_ ({\b GTEST_TUPLE_ELEMENT_}(8, Tuple) ) &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 907}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00908                   \{ {\cf19 return} t.f8_; \}  {\cf20 // NOLINT}\par
}
}
{\xe \v GTEST_BY_REF_\:std::tr1::gtest_internal::Get< 8 >}
{\xe \v std::tr1::gtest_internal::Get< 8 >\:GTEST_BY_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 8 >::GTEST_BY_REF_ ({\b GTEST_TUPLE_ELEMENT_}(8, Tuple) ) const &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 911}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00912                              \{ {\cf19 return} t.f8_; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 std::tr1::gtest_internal::Get< 9 >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::Get< 9 >}
{\xe \v std::tr1::gtest_internal::Get< 9 >}
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_ADD_REF_} ({\b GTEST_TUPLE_ELEMENT_}(9, Tuple)) Field(Tuple &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple > static {\b GTEST_BY_REF_} ({\b GTEST_TUPLE_ELEMENT_}(9, Tuple)) ConstField(const Tuple &t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 916}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v GTEST_ADD_REF_\:std::tr1::gtest_internal::Get< 9 >}
{\xe \v std::tr1::gtest_internal::Get< 9 >\:GTEST_ADD_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 9 >::GTEST_ADD_REF_ ({\b GTEST_TUPLE_ELEMENT_}(9, Tuple) ) &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 919}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00920                   \{ {\cf19 return} t.f9_; \}  {\cf20 // NOLINT}\par
}
}
{\xe \v GTEST_BY_REF_\:std::tr1::gtest_internal::Get< 9 >}
{\xe \v std::tr1::gtest_internal::Get< 9 >\:GTEST_BY_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple > static {\b std::tr1::gtest_internal::Get}< 9 >::GTEST_BY_REF_ ({\b GTEST_TUPLE_ELEMENT_}(9, Tuple) ) const &{\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 923}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00924                              \{ {\cf19 return} t.f9_; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::GTestFlagSaver\par \pard\plain 
{\tc\tcl2 \v testing::internal::GTestFlagSaver}
{\xe \v testing::internal::GTestFlagSaver}
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
\par
{
{\f2 #include <gtest-internal-inl.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTestFlagSaver} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~GTestFlagSaver} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 162}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v GTestFlagSaver\:testing::internal::GTestFlagSaver}
{\xe \v testing::internal::GTestFlagSaver\:GTestFlagSaver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTestFlagSaver::GTestFlagSaver (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 165}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00165                    \{\par
00166     also_run_disabled_tests_ = GTEST_FLAG(also_run_disabled_tests);\par
00167     break_on_failure_ = GTEST_FLAG(break_on_failure);\par
00168     catch_exceptions_ = GTEST_FLAG(catch_exceptions);\par
00169     color_ = GTEST_FLAG(color);\par
00170     death_test_style_ = GTEST_FLAG(death_test_style);\par
00171     death_test_use_fork_ = GTEST_FLAG(death_test_use_fork);\par
00172     filter_ = GTEST_FLAG(filter);\par
00173     internal_run_death_test_ = GTEST_FLAG(internal_run_death_test);\par
00174     list_tests_ = GTEST_FLAG(list_tests);\par
00175     output_ = GTEST_FLAG(output);\par
00176     print_time_ = GTEST_FLAG(print_time);\par
00177     random_seed_ = GTEST_FLAG(random_seed);\par
00178     repeat_ = GTEST_FLAG(repeat);\par
00179     shuffle_ = GTEST_FLAG(shuffle);\par
00180     stack_trace_depth_ = GTEST_FLAG(stack_trace_depth);\par
00181     stream_result_to_ = GTEST_FLAG(stream_result_to);\par
00182     throw_on_failure_ = GTEST_FLAG(throw_on_failure);\par
00183   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GTEST_FLAG}.}\par
}
{\xe \v ~GTestFlagSaver\:testing::internal::GTestFlagSaver}
{\xe \v testing::internal::GTestFlagSaver\:~GTestFlagSaver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTestFlagSaver::~GTestFlagSaver (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 186}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00186                     \{\par
00187     GTEST_FLAG(also_run_disabled_tests) = also_run_disabled_tests_;\par
00188     GTEST_FLAG(break_on_failure) = break_on_failure_;\par
00189     GTEST_FLAG(catch_exceptions) = catch_exceptions_;\par
00190     GTEST_FLAG(color) = color_;\par
00191     GTEST_FLAG(death_test_style) = death_test_style_;\par
00192     GTEST_FLAG(death_test_use_fork) = death_test_use_fork_;\par
00193     GTEST_FLAG(filter) = filter_;\par
00194     GTEST_FLAG(internal_run_death_test) = internal_run_death_test_;\par
00195     GTEST_FLAG(list_tests) = list_tests_;\par
00196     GTEST_FLAG(output) = output_;\par
00197     GTEST_FLAG(print_time) = print_time_;\par
00198     GTEST_FLAG(random_seed) = random_seed_;\par
00199     GTEST_FLAG(repeat) = repeat_;\par
00200     GTEST_FLAG(shuffle) = shuffle_;\par
00201     GTEST_FLAG(stack_trace_depth) = stack_trace_depth_;\par
00202     GTEST_FLAG(stream_result_to) = stream_result_to_;\par
00203     GTEST_FLAG(throw_on_failure) = throw_on_failure_;\par
00204   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GTEST_FLAG}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-internal-inl.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::GTestLog\par \pard\plain 
{\tc\tcl2 \v testing::internal::GTestLog}
{\xe \v testing::internal::GTestLog}
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
\par
{
{\f2 #include <gtest-port.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTestLog} ({\b GTestLogSeverity} severity, const char *file, int line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~GTestLog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
::std::ostream & {\b GetStream} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1289}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v GTestLog\:testing::internal::GTestLog}
{\xe \v testing::internal::GTestLog\:GTestLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTestLog::GTestLog ({\b GTestLogSeverity}  {\i severity}, const char *  {\i file}, int  {\i line})}}
\par
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 908}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00909     : severity_(severity) \{\par
00910   {\cf17 const} {\cf18 char}* {\cf17 const} marker =\par
00911       severity == GTEST_INFO ?    {\cf22 "[  INFO ]"} :\par
00912       severity == GTEST_WARNING ? {\cf22 "[WARNING]"} :\par
00913       severity == GTEST_ERROR ?   {\cf22 "[ ERROR ]"} : {\cf22 "[ FATAL ]"};\par
00914   GetStream() << ::std::endl << marker << {\cf22 " "}\par
00915               << FormatFileLocation(file, line).c_str() << {\cf22 ": "};\par
00916 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::FormatFileLocation()}, {\b GetStream()}, {\b testing::internal::GTEST_ERROR}, {\b testing::internal::GTEST_INFO} \'E8 {\b testing::internal::GTEST_WARNING}.}\par
}
{\xe \v ~GTestLog\:testing::internal::GTestLog}
{\xe \v testing::internal::GTestLog\:~GTestLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTestLog::~GTestLog ()}}
\par
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 919}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00919                     \{\par
00920   GetStream() << ::std::endl;\par
00921   {\cf19 if} (severity_ == GTEST_FATAL) \{\par
00922     fflush(stderr);\par
00923     posix::Abort();\par
00924   \}\par
00925 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::posix::Abort()}, {\b GetStream()} \'E8 {\b testing::internal::GTEST_FATAL}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v GetStream\:testing::internal::GTestLog}
{\xe \v testing::internal::GTestLog\:GetStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
::std::ostream & testing::internal::GTestLog::GetStream (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1296}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01296 \{ return ::std::cerr; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b GTestLog()} \'E8 {\b ~GTestLog()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-port.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::GTestMutexLock\par \pard\plain 
{\tc\tcl2 \v testing::internal::GTestMutexLock}
{\xe \v testing::internal::GTestMutexLock}
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
\par
{
{\f2 #include <gtest-port.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTestMutexLock} ({\b Mutex} *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2186}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v GTestMutexLock\:testing::internal::GTestMutexLock}
{\xe \v testing::internal::GTestMutexLock\:GTestMutexLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::GTestMutexLock::GTestMutexLock ({\b Mutex} * ){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2188}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02188 \{\}  {\cf20 // NOLINT}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::HasNewFatalFailureHelper\par \pard\plain 
{\tc\tcl2 \v testing::internal::HasNewFatalFailureHelper}
{\xe \v testing::internal::HasNewFatalFailureHelper}
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
\par
{
{\f2 #include <gtest-test-part.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::internal::HasNewFatalFailureHelper:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtesting_1_1internal_1_1_has_new_fatal_failure_helper.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HasNewFatalFailureHelper} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~HasNewFatalFailureHelper} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ReportTestPartResult} (const {\b TestPartResult} &result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b has_new_fatal_failure} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 161}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v HasNewFatalFailureHelper\:testing::internal::HasNewFatalFailureHelper}
{\xe \v testing::internal::HasNewFatalFailureHelper\:HasNewFatalFailureHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::HasNewFatalFailureHelper::HasNewFatalFailureHelper ()}}
\par
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 89}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00090     : has_new_fatal_failure_({\cf17 false}),\par
00091       original_reporter_(GetUnitTestImpl()->\par
00092                          GetTestPartResultReporterForCurrentThread()) \{\par
00093   GetUnitTestImpl()->SetTestPartResultReporterForCurrentThread({\cf17 this});\par
00094 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::GetUnitTestImpl()} \'E8 {\b testing::internal::UnitTestImpl::SetTestPartResultReporterForCurrentThread()}.}\par
}
{\xe \v ~HasNewFatalFailureHelper\:testing::internal::HasNewFatalFailureHelper}
{\xe \v testing::internal::HasNewFatalFailureHelper\:~HasNewFatalFailureHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::HasNewFatalFailureHelper::~HasNewFatalFailureHelper (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 96}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00096                                                     \{\par
00097   GetUnitTestImpl()->SetTestPartResultReporterForCurrentThread(\par
00098       original_reporter_);\par
00099 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::GetUnitTestImpl()} \'E8 {\b testing::internal::UnitTestImpl::SetTestPartResultReporterForCurrentThread()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v has_new_fatal_failure\:testing::internal::HasNewFatalFailureHelper}
{\xe \v testing::internal::HasNewFatalFailureHelper\:has_new_fatal_failure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::HasNewFatalFailureHelper::has_new_fatal_failure () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 167}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00167 \{ {\cf19 return} has_new_fatal_failure_; \}\par
}
}
{\xe \v ReportTestPartResult\:testing::internal::HasNewFatalFailureHelper}
{\xe \v testing::internal::HasNewFatalFailureHelper\:ReportTestPartResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::HasNewFatalFailureHelper::ReportTestPartResult (const {\b TestPartResult} &  {\i result}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestPartResultReporterInterface} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 101}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00102                                   \{\par
00103   {\cf19 if} (result.fatally_failed())\par
00104     has_new_fatal_failure_ = {\cf17 true};\par
00105   original_reporter_->ReportTestPartResult(result);\par
00106 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestPartResult::fatally_failed()} \'E8 {\b testing::TestPartResultReporterInterface::ReportTestPartResult()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-test-part.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-test-part.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::ImplicitlyConvertible< From, To >\par \pard\plain 
{\tc\tcl2 \v testing::internal::ImplicitlyConvertible< From, To >}
{\xe \v testing::internal::ImplicitlyConvertible< From, To >}
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const bool {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename From, typename To>\par
class testing::internal::ImplicitlyConvertible< From, To >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 856}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v value\:testing::internal::ImplicitlyConvertible< From, To >}
{\xe \v testing::internal::ImplicitlyConvertible< From, To >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename From , typename To > const bool {\b testing::internal::ImplicitlyConvertible}< From, To >::value{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'C8\'ED\'E8\'F6\'E8\'E0\'EB\'E8\'E7\'E0\'F2\'EE\'F0}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
      {\cf17 sizeof}(Helper(ImplicitlyConvertible::MakeFrom())) == 1\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 892}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::is_pointer< T >\par \pard\plain 
{\tc\tcl2 \v testing::internal::is_pointer< T >}
{\xe \v testing::internal::is_pointer< T >}
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
\par
{
{\f2 #include <gtest-port.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::internal::is_pointer< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtesting_1_1internal_1_1is__pointer.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EF\'EE\'EB\'ED\'E8\'F2\'E5\'EB\'FC\'ED\'FB\'E5 \'F3\'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'ED\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct testing::internal::is_pointer< T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2245}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::is_pointer< T * >\par \pard\plain 
{\tc\tcl2 \v testing::internal::is_pointer< T * >}
{\xe \v testing::internal::is_pointer< T * >}
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
\par
{
{\f2 #include <gtest-port.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::internal::is_pointer< T * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtesting_1_1internal_1_1is__pointer_3_01_t_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EF\'EE\'EB\'ED\'E8\'F2\'E5\'EB\'FC\'ED\'FB\'E5 \'F3\'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'ED\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct testing::internal::is_pointer< T * >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2248}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::IsAProtocolMessage< T >\par \pard\plain 
{\tc\tcl2 \v testing::internal::IsAProtocolMessage< T >}
{\xe \v testing::internal::IsAProtocolMessage< T >}
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::internal::IsAProtocolMessage< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtesting_1_1internal_1_1_is_a_protocol_message.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EF\'EE\'EB\'ED\'E8\'F2\'E5\'EB\'FC\'ED\'FB\'E5 \'F3\'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'ED\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct testing::internal::IsAProtocolMessage< T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 904}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::IteratorTraits< Iterator >\par \pard\plain 
{\tc\tcl2 \v testing::internal::IteratorTraits< Iterator >}
{\xe \v testing::internal::IteratorTraits< Iterator >}
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
\par
{
{\f2 #include <gtest-port.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef Iterator::value_type {\b value_type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Iterator>\par
struct testing::internal::IteratorTraits< Iterator >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2251}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v value_type\:testing::internal::IteratorTraits< Iterator >}
{\xe \v testing::internal::IteratorTraits< Iterator >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Iterator > typedef Iterator::value_type {\b testing::internal::IteratorTraits}< Iterator >::value_type}}
\par
{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2252}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::IteratorTraits< const T * >\par \pard\plain 
{\tc\tcl2 \v testing::internal::IteratorTraits< const T * >}
{\xe \v testing::internal::IteratorTraits< const T * >}
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
\par
{
{\f2 #include <gtest-port.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T {\b value_type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct testing::internal::IteratorTraits< const T * >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2261}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v value_type\:testing::internal::IteratorTraits< const T * >}
{\xe \v testing::internal::IteratorTraits< const T * >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > typedef T {\b testing::internal::IteratorTraits}< const T * >::value_type}}
\par
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2262}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::IteratorTraits< T * >\par \pard\plain 
{\tc\tcl2 \v testing::internal::IteratorTraits< T * >}
{\xe \v testing::internal::IteratorTraits< T * >}
{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
\par
{
{\f2 #include <gtest-port.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T {\b value_type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct testing::internal::IteratorTraits< T * >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2256}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v value_type\:testing::internal::IteratorTraits< T * >}
{\xe \v testing::internal::IteratorTraits< T * >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > typedef T {\b testing::internal::IteratorTraits}< T * >::value_type}}
\par
{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2257}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::linked_ptr< T >\par \pard\plain 
{\tc\tcl2 \v testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >}
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
\par
{
{\f2 #include <gtest-linked_ptr.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T {\b element_type}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b linked_ptr} (T *ptr=NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~linked_ptr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b linked_ptr} ({\b linked_ptr}< U > const &ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b linked_ptr} ({\b linked_ptr} const &ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b linked_ptr} & {\b operator=} ({\b linked_ptr}< U > const &ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b linked_ptr} & {\b operator=} ({\b linked_ptr} const &ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} (T *ptr=NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b get} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b operator->} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b operator*} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (T *p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (T *p) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > bool {\b operator==} ({\b linked_ptr}< U > const &ptr) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > bool {\b operator!=} ({\b linked_ptr}< U > const &ptr) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'F0\'F3\'E7\'FC\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > class {\b linked_ptr}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class testing::internal::linked_ptr< T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 146}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v element_type\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:element_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > typedef T {\b testing::internal::linked_ptr}< T >::element_type}}
\par
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 148}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v linked_ptr\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:linked_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b testing::internal::linked_ptr}< T >::linked_ptr (T *  {\i ptr} = {\f2 NULL}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 152}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00152 \{ capture(ptr); \}\par
}
}
{\xe \v ~linked_ptr\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:~linked_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b testing::internal::linked_ptr}< T >::~{\b linked_ptr} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 153}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00153 \{ depart(); \}\par
}
}
{\xe \v linked_ptr\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:linked_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U > {\b testing::internal::linked_ptr}< T >::linked_ptr ({\b linked_ptr}< U > const &  {\i ptr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 156}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00156 \{ copy(&ptr); \}\par
}
}
{\xe \v linked_ptr\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:linked_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b testing::internal::linked_ptr}< T >::linked_ptr ({\b linked_ptr}< T > const &  {\i ptr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 157}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00157                                     \{  {\cf20 // NOLINT}\par
00158     assert(&ptr != {\cf17 this});\par
00159     copy(&ptr);\par
00160   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v get\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T * {\b testing::internal::linked_ptr}< T >::get () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 182}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00182 \{ {\cf19 return} value_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::linked_ptr< T >::operator!=()}, {\b testing::internal::operator!=()}, {\b testing::internal::linked_ptr< T >::operator==()} \'E8 {\b testing::internal::operator==()}.}\par
}
{\xe \v operator!=\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U > bool {\b testing::internal::linked_ptr}< T >::operator!= ({\b linked_ptr}< U > const &  {\i ptr}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 193}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00193                                                   \{\par
00194     {\cf19 return} value_ != ptr.get();\par
00195   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::linked_ptr< T >::get()}.}\par
}
{\xe \v operator!=\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b testing::internal::linked_ptr}< T >::operator!= (T *  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 187}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00187 \{ {\cf19 return} value_ != p; \}\par
}
}
{\xe \v operator*\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T & {\b testing::internal::linked_ptr}< T >::operator* () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 184}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00184 \{ {\cf19 return} *value_; \}\par
}
}
{\xe \v operator->\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T * {\b testing::internal::linked_ptr}< T >::operator-> () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 183}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00183 \{ {\cf19 return} value_; \}\par
}
}
{\xe \v operator=\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b linked_ptr} & {\b testing::internal::linked_ptr}< T >::operator= ({\b linked_ptr}< T > const &  {\i ptr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 169}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00169                                                \{\par
00170     {\cf19 if} (&ptr != {\cf17 this}) \{\par
00171       depart();\par
00172       copy(&ptr);\par
00173     \}\par
00174     {\cf19 return} *{\cf17 this};\par
00175   \}\par
}
}
{\xe \v operator=\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U > {\b linked_ptr} & {\b testing::internal::linked_ptr}< T >::operator= ({\b linked_ptr}< U > const &  {\i ptr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 163}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00163                                                                         \{\par
00164     depart();\par
00165     copy(&ptr);\par
00166     {\cf19 return} *{\cf17 this};\par
00167   \}\par
}
}
{\xe \v operator==\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U > bool {\b testing::internal::linked_ptr}< T >::operator== ({\b linked_ptr}< U > const &  {\i ptr}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 189}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00189                                                   \{\par
00190     {\cf19 return} value_ == ptr.get();\par
00191   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::linked_ptr< T >::get()}.}\par
}
{\xe \v operator==\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b testing::internal::linked_ptr}< T >::operator== (T *  {\i p}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 186}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00186 \{ {\cf19 return} value_ == p; \}\par
}
}
{\xe \v reset\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void {\b testing::internal::linked_ptr}< T >::reset (T *  {\i ptr} = {\f2 NULL}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 178}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00178                             \{\par
00179     depart();\par
00180     capture(ptr);\par
00181   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FF \'EF\'EE \'E4\'F0\'F3\'E7\'FC\'FF\'EC \'EA\'EB\'E0\'F1\'F1\'E0 \'E8 \'F4\'F3\'ED\'EA\'F6\'E8\'FF\'EC, \'EE\'F2\'ED\'EE\'F1\'FF\'F9\'E8\'EC\'F1\'FF \'EA \'EA\'EB\'E0\'F1\'F1\'F3\par
\pard\plain 
{\xe \v linked_ptr\:testing::internal::linked_ptr< T >}
{\xe \v testing::internal::linked_ptr< T >\:linked_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U > friend class {\b linked_ptr}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 199}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-linked_ptr.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::linked_ptr_internal\par \pard\plain 
{\tc\tcl2 \v testing::internal::linked_ptr_internal}
{\xe \v testing::internal::linked_ptr_internal}
{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
\par
{
{\f2 #include <gtest-linked_ptr.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b join_new} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b join} ({\b linked_ptr_internal} const *ptr) {\b GTEST_LOCK_EXCLUDED_}(g_linked_ptr_mutex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b depart} () {\b GTEST_LOCK_EXCLUDED_}(g_linked_ptr_mutex)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 89}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v depart\:testing::internal::linked_ptr_internal}
{\xe \v testing::internal::linked_ptr_internal\:depart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::linked_ptr_internal::depart (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 125}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00126                                                \{\par
00127     MutexLock lock(&g_linked_ptr_mutex);\par
00128 \par
00129     {\cf19 if} (next_ == {\cf17 this}) {\cf19 return} {\cf17 true};\par
00130     linked_ptr_internal {\cf17 const}* p = next_;\par
00131     {\cf19 while} (p->next_ != {\cf17 this}) \{\par
00132       assert(p->next_ != next_ &&\par
00133              {\cf22 "Trying to depart() a linked ring we are not in. "}\par
00134              {\cf22 "Is GMock thread safety enabled?"});\par
00135       p = p->next_;\par
00136     \}\par
00137     p->next_ = next_;\par
00138     {\cf19 return} {\cf17 false};\par
00139   \}\par
}
}
{\xe \v join\:testing::internal::linked_ptr_internal}
{\xe \v testing::internal::linked_ptr_internal\:join}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::linked_ptr_internal::join ({\b linked_ptr_internal} const *  {\i ptr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 108}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00109                                                \{\par
00110     MutexLock lock(&g_linked_ptr_mutex);\par
00111 \par
00112     linked_ptr_internal {\cf17 const}* p = ptr;\par
00113     {\cf19 while} (p->next_ != ptr) \{\par
00114       assert(p->next_ != {\cf17 this} &&\par
00115              {\cf22 "Trying to join() a linked ring we are already in. "}\par
00116              {\cf22 "Is GMock thread safety enabled?"});\par
00117       p = p->next_;\par
00118     \}\par
00119     p->next_ = {\cf17 this};\par
00120     next_ = ptr;\par
00121   \}\par
}
}
{\xe \v join_new\:testing::internal::linked_ptr_internal}
{\xe \v testing::internal::linked_ptr_internal\:join_new}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::linked_ptr_internal::join_new (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-linked_ptr.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 92}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00092                   \{\par
00093     next_ = {\cf17 this};\par
00094   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-linked_ptr.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::Message\par \pard\plain 
{\tc\tcl2 \v testing::Message}
{\xe \v testing::Message}
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
\par
{
{\f2 #include <gtest-message.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Message} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Message} (const {\b Message} &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Message} (const char *str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b Message} & {\b operator<<} (const T &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b Message} & {\b operator<<} (T *const &pointer)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Message} & {\b operator<<} (BasicNarrowIoManip val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Message} & {\b operator<<} (bool b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Message} & {\b operator<<} (const wchar_t *wide_c_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Message} & {\b operator<<} (wchar_t *wide_c_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b GetString} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-message.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 85}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v Message\:testing::Message}
{\xe \v testing::Message\:Message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::Message::Message ()}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 943}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00943                  : ss_(new ::std::stringstream) \{\par
00944   {\cf20 // By default, we want there to be enough precision when printing}\par
00945   {\cf20 // a double to a Message.}\par
00946   *ss_ << std::setprecision(std::numeric_limits<double>::digits10 + 2);\par
00947 \}\par
}
}
{\xe \v Message\:testing::Message}
{\xe \v testing::Message\:Message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::Message::Message (const {\b Message} &  {\i msg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-message.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 96}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00096                               : ss_(new ::std::stringstream) \{  {\cf20 // NOLINT}\par
00097     *ss_ << msg.GetString();\par
00098   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GetString()}.}\par
}
{\xe \v Message\:testing::Message}
{\xe \v testing::Message\:Message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::Message::Message (const char *  {\i str}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-message.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 101}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00101                                     : ss_(new ::std::stringstream) \{\par
00102     *ss_ << str;\par
00103   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v GetString\:testing::Message}
{\xe \v testing::Message\:GetString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::Message::GetString () const}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 978}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00978                                    \{\par
00979   {\cf19 return} internal::StringStreamToString(ss_.get());\par
00980 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::scoped_ptr< T >::get()} \'E8 {\b testing::internal::StringStreamToString()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::AppendUserMessage()}, {\b testing::internal::GetBoolAssertionFailureMessage()}, {\b Message()}, {\b testing::operator<<()}, {\b testing::internal::ParseInt32()}, {\b testing::Test::RecordProperty()} \'E8 {\b testing::internal::ShouldShard()}.}\par
}
{\xe \v operator<<\:testing::Message}
{\xe \v testing::Message\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Message} & testing::Message::operator<< (BasicNarrowIoManip  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-message.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 165}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00165                                                \{\par
00166     *ss_ << val;\par
00167     {\cf19 return} *{\cf17 this};\par
00168   \}\par
}
}
{\xe \v operator<<\:testing::Message}
{\xe \v testing::Message\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Message} & testing::Message::operator<< (bool  {\i b}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-message.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 171}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00171                                \{\par
00172     {\cf19 return} *{\cf17 this} << (b ? {\cf22 "true"} : {\cf22 "false"});\par
00173   \}\par
}
}
{\xe \v operator<<\:testing::Message}
{\xe \v testing::Message\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Message} & testing::Message::operator<< (const T &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-message.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 115}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00115                                             \{\par
00116     {\cf20 // Some libraries overload << for STL containers.  These}\par
00117     {\cf20 // overloads are defined in the global namespace instead of ::std.}\par
00118     {\cf20 //}\par
00119     {\cf20 // C++'s symbol lookup rule (i.e. Koenig lookup) says that these}\par
00120     {\cf20 // overloads are visible in either the std namespace or the global}\par
00121     {\cf20 // namespace, but not other namespaces, including the testing}\par
00122     {\cf20 // namespace which Google Test's Message class is in.}\par
00123     {\cf20 //}\par
00124     {\cf20 // To allow STL containers (and other types that has a << operator}\par
00125     {\cf20 // defined in the global namespace) to be used in Google Test}\par
00126     {\cf20 // assertions, testing::Message must access the custom << operator}\par
00127     {\cf20 // from the global namespace.  With this using declaration,}\par
00128     {\cf20 // overloads of << defined in the global namespace and those}\par
00129     {\cf20 // visible via Koenig lookup are both exposed in this function.}\par
00130     using ::operator <<;\par
00131     *ss_ << val;\par
00132     {\cf19 return} *{\cf17 this};\par
00133   \}\par
}
}
{\xe \v operator<<\:testing::Message}
{\xe \v testing::Message\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Message} & testing::Message::operator<< (const wchar_t *  {\i wide_c_str})}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 951}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00951                                                        \{\par
00952   {\cf19 return} *{\cf17 this} << internal::String::ShowWideCString(wide_c_str);\par
00953 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::String::ShowWideCString()}.}\par
}
{\xe \v operator<<\:testing::Message}
{\xe \v testing::Message\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Message} & testing::Message::operator<< (T *const &  {\i pointer}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-message.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 149}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00149                                                  \{  {\cf20 // NOLINT}\par
00150     {\cf19 if} (pointer == NULL) \{\par
00151       *ss_ << {\cf22 "(null)"};\par
00152     \} {\cf19 else} \{\par
00153       *ss_ << pointer;\par
00154     \}\par
00155     {\cf19 return} *{\cf17 this};\par
00156   \}\par
}
}
{\xe \v operator<<\:testing::Message}
{\xe \v testing::Message\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Message} & testing::Message::operator<< (wchar_t *  {\i wide_c_str})}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 954}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00954                                                  \{\par
00955   {\cf19 return} *{\cf17 this} << internal::String::ShowWideCString(wide_c_str);\par
00956 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::String::ShowWideCString()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-message.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::Mutex\par \pard\plain 
{\tc\tcl2 \v testing::internal::Mutex}
{\xe \v testing::internal::Mutex}
{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
\par
{
{\f2 #include <gtest-port.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Mutex} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Lock} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Unlock} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AssertHeld} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2168}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v Mutex\:testing::internal::Mutex}
{\xe \v testing::internal::Mutex\:Mutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::Mutex::Mutex (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2170}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02170 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v AssertHeld\:testing::internal::Mutex}
{\xe \v testing::internal::Mutex\:AssertHeld}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::Mutex::AssertHeld () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2173}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02173 \{\}\par
}
}
{\xe \v Lock\:testing::internal::Mutex}
{\xe \v testing::internal::Mutex\:Lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::Mutex::Lock (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2171}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02171 \{\}\par
}
}
{\xe \v Unlock\:testing::internal::Mutex}
{\xe \v testing::internal::Mutex\:Unlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::Mutex::Unlock (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2172}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02172 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::NativeArray< Element >\par \pard\plain 
{\tc\tcl2 \v testing::internal::NativeArray< Element >}
{\xe \v testing::internal::NativeArray< Element >}
{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef Element {\b value_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef Element * {\b iterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef const Element * {\b const_iterator}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NativeArray} (const Element *array, size_t count, {\b RelationToSourceReference})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NativeArray} (const Element *array, size_t count, {\b RelationToSourceCopy})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NativeArray} (const {\b NativeArray} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~NativeArray} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b begin} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b end} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b NativeArray} &rhs) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Element>\par
class testing::internal::NativeArray< Element >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1035}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v const_iterator\:testing::internal::NativeArray< Element >}
{\xe \v testing::internal::NativeArray< Element >\:const_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Element > typedef const Element* {\b testing::internal::NativeArray}< Element >::const_iterator}}
\par
{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1040}}\par
}
{\xe \v iterator\:testing::internal::NativeArray< Element >}
{\xe \v testing::internal::NativeArray< Element >\:iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Element > typedef Element* {\b testing::internal::NativeArray}< Element >::iterator}}
\par
{\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1039}}\par
}
{\xe \v value_type\:testing::internal::NativeArray< Element >}
{\xe \v testing::internal::NativeArray< Element >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Element > typedef Element {\b testing::internal::NativeArray}< Element >::value_type}}
\par
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1038}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v NativeArray\:testing::internal::NativeArray< Element >}
{\xe \v testing::internal::NativeArray< Element >\:NativeArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Element > {\b testing::internal::NativeArray}< Element >::NativeArray (const Element *  {\i array}, size_t  {\i count}, {\b RelationToSourceReference} ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1043}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01043                                                                              \{\par
01044     InitRef(array, count);\par
01045   \}\par
}
}
{\xe \v NativeArray\:testing::internal::NativeArray< Element >}
{\xe \v testing::internal::NativeArray< Element >\:NativeArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Element > {\b testing::internal::NativeArray}< Element >::NativeArray (const Element *  {\i array}, size_t  {\i count}, {\b RelationToSourceCopy} ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1048}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01048                                                                         \{\par
01049     InitCopy(array, count);\par
01050   \}\par
}
}
{\xe \v NativeArray\:testing::internal::NativeArray< Element >}
{\xe \v testing::internal::NativeArray< Element >\:NativeArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Element > {\b testing::internal::NativeArray}< Element >::NativeArray (const {\b NativeArray}< Element > &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1053}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01053                                       \{\par
01054     (this->*rhs.clone_)(rhs.array_, rhs.size_);\par
01055   \}\par
}
}
{\xe \v ~NativeArray\:testing::internal::NativeArray< Element >}
{\xe \v testing::internal::NativeArray< Element >\:~NativeArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Element > {\b testing::internal::NativeArray}< Element >::~{\b NativeArray} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1057}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01057                  \{\par
01058     {\cf19 if} (clone_ != &NativeArray::InitRef)\par
01059       {\cf17 delete}[] array_;\par
01060   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v begin\:testing::internal::NativeArray< Element >}
{\xe \v testing::internal::NativeArray< Element >\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Element > {\b const_iterator} {\b testing::internal::NativeArray}< Element >::begin () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1064}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01064 \{ {\cf19 return} array_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::NativeArray< Element >::operator==()}.}\par
}
{\xe \v end\:testing::internal::NativeArray< Element >}
{\xe \v testing::internal::NativeArray< Element >\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Element > {\b const_iterator} {\b testing::internal::NativeArray}< Element >::end () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1065}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01065 \{ {\cf19 return} array_ + size_; \}\par
}
}
{\xe \v operator==\:testing::internal::NativeArray< Element >}
{\xe \v testing::internal::NativeArray< Element >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Element > bool {\b testing::internal::NativeArray}< Element >::operator== (const {\b NativeArray}< Element > &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1066}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01066                                                 \{\par
01067     {\cf19 return} size() == rhs.size() &&\par
01068         ArrayEq(begin(), size(), rhs.begin());\par
01069   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::ArrayEq()}, {\b testing::internal::NativeArray< Element >::begin()} \'E8 {\b testing::internal::NativeArray< Element >::size()}.}\par
}
{\xe \v size\:testing::internal::NativeArray< Element >}
{\xe \v testing::internal::NativeArray< Element >\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Element > size_t {\b testing::internal::NativeArray}< Element >::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1063}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01063 \{ {\cf19 return} size_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::NativeArray< Element >::operator==()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::OsStackTraceGetter\par \pard\plain 
{\tc\tcl2 \v testing::internal::OsStackTraceGetter}
{\xe \v testing::internal::OsStackTraceGetter}
{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
\par
{
{\f2 #include <gtest-internal-inl.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::internal::OsStackTraceGetter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtesting_1_1internal_1_1_os_stack_trace_getter.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OsStackTraceGetter} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b CurrentStackTrace} (int max_depth, int skip_count)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b UponLeavingGTest} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EF\'EE\'EB\'ED\'E8\'F2\'E5\'EB\'FC\'ED\'FB\'E5 \'F3\'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'ED\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 445}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v OsStackTraceGetter\:testing::internal::OsStackTraceGetter}
{\xe \v testing::internal::OsStackTraceGetter\:OsStackTraceGetter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::OsStackTraceGetter::OsStackTraceGetter (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 447}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00447 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v CurrentStackTrace\:testing::internal::OsStackTraceGetter}
{\xe \v testing::internal::OsStackTraceGetter\:CurrentStackTrace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::OsStackTraceGetter::CurrentStackTrace (int  {\i max_depth}, int  {\i skip_count}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::internal::OsStackTraceGetterInterface} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABRK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3849}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03850                                                          \{\par
03851   {\cf19 return} {\cf22 ""};\par
03852 \}\par
}
}
{\xe \v UponLeavingGTest\:testing::internal::OsStackTraceGetter}
{\xe \v testing::internal::OsStackTraceGetter\:UponLeavingGTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::OsStackTraceGetter::UponLeavingGTest (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::internal::OsStackTraceGetterInterface} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABRM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3854}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03854 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-internal-inl.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::OsStackTraceGetterInterface\par \pard\plain 
{\tc\tcl2 \v testing::internal::OsStackTraceGetterInterface}
{\xe \v testing::internal::OsStackTraceGetterInterface}
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
\par
{
{\f2 #include <gtest-internal-inl.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::internal::OsStackTraceGetterInterface:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtesting_1_1internal_1_1_os_stack_trace_getter_interface.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OsStackTraceGetterInterface} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~OsStackTraceGetterInterface} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b CurrentStackTrace} (int max_depth, int skip_count)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b UponLeavingGTest} ()=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char *const {\b kElidedFramesMarker}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 418}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v OsStackTraceGetterInterface\:testing::internal::OsStackTraceGetterInterface}
{\xe \v testing::internal::OsStackTraceGetterInterface\:OsStackTraceGetterInterface}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::OsStackTraceGetterInterface::OsStackTraceGetterInterface (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 420}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00420 \{\}\par
}
}
{\xe \v ~OsStackTraceGetterInterface\:testing::internal::OsStackTraceGetterInterface}
{\xe \v testing::internal::OsStackTraceGetterInterface\:~OsStackTraceGetterInterface}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual testing::internal::OsStackTraceGetterInterface::~OsStackTraceGetterInterface (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 421}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00421 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v CurrentStackTrace\:testing::internal::OsStackTraceGetterInterface}
{\xe \v testing::internal::OsStackTraceGetterInterface\:CurrentStackTrace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::string testing::internal::OsStackTraceGetterInterface::CurrentStackTrace (int  {\i max_depth}, int  {\i skip_count}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::OsStackTraceGetter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABRJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::CurrentOsStackTraceExceptTop()}.}\par
}
{\xe \v UponLeavingGTest\:testing::internal::OsStackTraceGetterInterface}
{\xe \v testing::internal::OsStackTraceGetterInterface\:UponLeavingGTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::OsStackTraceGetterInterface::UponLeavingGTest (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::OsStackTraceGetter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABRL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v kElidedFramesMarker\:testing::internal::OsStackTraceGetterInterface}
{\xe \v testing::internal::OsStackTraceGetterInterface\:kElidedFramesMarker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char *const testing::internal::OsStackTraceGetterInterface::kElidedFramesMarker{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'C8\'ED\'E8\'F6\'E8\'E0\'EB\'E8\'E7\'E0\'F2\'EE\'F0}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
    {\cf22 "... "} GTEST_NAME_ {\cf22 " internal frames ..."}\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 438}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-internal-inl.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::PrettyUnitTestResultPrinter\par \pard\plain 
{\tc\tcl2 \v testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter}
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::internal::PrettyUnitTestResultPrinter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtesting_1_1internal_1_1_pretty_unit_test_result_printer.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PrettyUnitTestResultPrinter} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestProgramStart} (const {\b UnitTest} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestIterationStart} (const {\b UnitTest} &unit_test, int iteration)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsSetUpStart} (const {\b UnitTest} &unit_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsSetUpEnd} (const {\b UnitTest} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestCaseStart} (const {\b TestCase} &test_case)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestStart} (const {\b TestInfo} &test_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestPartResult} (const {\b TestPartResult} &result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestEnd} (const {\b TestInfo} &test_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestCaseEnd} (const {\b TestCase} &test_case)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsTearDownStart} (const {\b UnitTest} &unit_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsTearDownEnd} (const {\b UnitTest} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestIterationEnd} (const {\b UnitTest} &unit_test, int iteration)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestProgramEnd} (const {\b UnitTest} &)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b PrintTestName} (const char *test_case, const char *test)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3027}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v PrettyUnitTestResultPrinter\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:PrettyUnitTestResultPrinter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::PrettyUnitTestResultPrinter::PrettyUnitTestResultPrinter (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3029}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03029 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v OnEnvironmentsSetUpEnd\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:OnEnvironmentsSetUpEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsSetUpEnd (const {\b UnitTest} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3038}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03038 \{\}\par
}
}
{\xe \v OnEnvironmentsSetUpStart\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:OnEnvironmentsSetUpStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart (const {\b UnitTest} &  {\i unit_test}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3089}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03090                        \{\par
03091   ColoredPrintf(COLOR_GREEN,  {\cf22 "[----------] "});\par
03092   printf({\cf22 "Global test environment set-up.\\n"});\par
03093   fflush(stdout);\par
03094 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::COLOR_GREEN} \'E8 {\b testing::internal::ColoredPrintf()}.}\par
}
{\xe \v OnEnvironmentsTearDownEnd\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:OnEnvironmentsTearDownEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsTearDownEnd (const {\b UnitTest} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3045}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03045 \{\}\par
}
}
{\xe \v OnEnvironmentsTearDownStart\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:OnEnvironmentsTearDownStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart (const {\b UnitTest} &  {\i unit_test}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3159}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03160                        \{\par
03161   ColoredPrintf(COLOR_GREEN,  {\cf22 "[----------] "});\par
03162   printf({\cf22 "Global test environment tear-down\\n"});\par
03163   fflush(stdout);\par
03164 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::COLOR_GREEN} \'E8 {\b testing::internal::ColoredPrintf()}.}\par
}
{\xe \v OnTestCaseEnd\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:OnTestCaseEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrettyUnitTestResultPrinter::OnTestCaseEnd (const {\b TestCase} &  {\i test_case}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3147}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03147                                                                          \{\par
03148   {\cf19 if} (!GTEST_FLAG(print_time)) {\cf19 return};\par
03149 \par
03150   {\cf17 const} std::string counts =\par
03151       FormatCountableNoun(test_case.test_to_run_count(), {\cf22 "test"}, {\cf22 "tests"});\par
03152   ColoredPrintf(COLOR_GREEN, {\cf22 "[----------] "});\par
03153   printf({\cf22 "%s from %s (%s ms total)\\n\\n"},\par
03154          counts.c_str(), test_case.name(),\par
03155          internal::StreamableToString(test_case.elapsed_time()).c_str());\par
03156   fflush(stdout);\par
03157 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::COLOR_GREEN}, {\b testing::internal::ColoredPrintf()}, {\b testing::TestCase::elapsed_time()}, {\b GTEST_FLAG}, {\b testing::TestCase::name()}, {\b testing::internal::StreamableToString()} \'E8 {\b testing::TestCase::test_to_run_count()}.}\par
}
{\xe \v OnTestCaseStart\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:OnTestCaseStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrettyUnitTestResultPrinter::OnTestCaseStart (const {\b TestCase} &  {\i test_case}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3096}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03096                                                                            \{\par
03097   {\cf17 const} std::string counts =\par
03098       FormatCountableNoun(test_case.test_to_run_count(), {\cf22 "test"}, {\cf22 "tests"});\par
03099   ColoredPrintf(COLOR_GREEN, {\cf22 "[----------] "});\par
03100   printf({\cf22 "%s from %s"}, counts.c_str(), test_case.name());\par
03101   {\cf19 if} (test_case.type_param() == NULL) \{\par
03102     printf({\cf22 "\\n"});\par
03103   \} {\cf19 else} \{\par
03104     printf({\cf22 ", where %s = %s\\n"}, kTypeParamLabel, test_case.type_param());\par
03105   \}\par
03106   fflush(stdout);\par
03107 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::COLOR_GREEN}, {\b testing::internal::ColoredPrintf()}, {\b testing::TestCase::name()}, {\b testing::TestCase::test_to_run_count()} \'E8 {\b testing::TestCase::type_param()}.}\par
}
{\xe \v OnTestEnd\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:OnTestEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrettyUnitTestResultPrinter::OnTestEnd (const {\b TestInfo} &  {\i test_info}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3128}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03128                                                                      \{\par
03129   {\cf19 if} (test_info.result()->Passed()) \{\par
03130     ColoredPrintf(COLOR_GREEN, {\cf22 "[       OK ] "});\par
03131   \} {\cf19 else} \{\par
03132     ColoredPrintf(COLOR_RED, {\cf22 "[  FAILED  ] "});\par
03133   \}\par
03134   PrintTestName(test_info.test_case_name(), test_info.name());\par
03135   {\cf19 if} (test_info.result()->Failed())\par
03136     PrintFullTestCommentIfPresent(test_info);\par
03137 \par
03138   {\cf19 if} (GTEST_FLAG(print_time)) \{\par
03139     printf({\cf22 " (%s ms)\\n"}, internal::StreamableToString(\par
03140            test_info.result()->elapsed_time()).c_str());\par
03141   \} {\cf19 else} \{\par
03142     printf({\cf22 "\\n"});\par
03143   \}\par
03144   fflush(stdout);\par
03145 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::COLOR_GREEN}, {\b testing::internal::COLOR_RED}, {\b testing::internal::ColoredPrintf()}, {\b testing::TestResult::elapsed_time()}, {\b testing::TestResult::Failed()}, {\b GTEST_FLAG}, {\b testing::TestInfo::name()}, {\b testing::TestResult::Passed()}, {\b testing::internal::PrintFullTestCommentIfPresent()}, {\b PrintTestName()}, {\b testing::TestInfo::result()}, {\b testing::internal::StreamableToString()} \'E8 {\b testing::TestInfo::test_case_name()}.}\par
}
{\xe \v OnTestIterationEnd\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:OnTestIterationEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd (const {\b UnitTest} &  {\i unit_test}, int  {\i iteration}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3191}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03192                                                             \{\par
03193   ColoredPrintf(COLOR_GREEN,  {\cf22 "[==========] "});\par
03194   printf({\cf22 "%s from %s ran."},\par
03195          FormatTestCount(unit_test.test_to_run_count()).c_str(),\par
03196          FormatTestCaseCount(unit_test.test_case_to_run_count()).c_str());\par
03197   {\cf19 if} (GTEST_FLAG(print_time)) \{\par
03198     printf({\cf22 " (%s ms total)"},\par
03199            internal::StreamableToString(unit_test.elapsed_time()).c_str());\par
03200   \}\par
03201   printf({\cf22 "\\n"});\par
03202   ColoredPrintf(COLOR_GREEN,  {\cf22 "[  PASSED  ] "});\par
03203   printf({\cf22 "%s.\\n"}, FormatTestCount(unit_test.successful_test_count()).c_str());\par
03204 \par
03205   {\cf18 int} num_failures = unit_test.failed_test_count();\par
03206   {\cf19 if} (!unit_test.Passed()) \{\par
03207     {\cf17 const} {\cf18 int} failed_test_count = unit_test.failed_test_count();\par
03208     ColoredPrintf(COLOR_RED,  {\cf22 "[  FAILED  ] "});\par
03209     printf({\cf22 "%s, listed below:\\n"}, FormatTestCount(failed_test_count).c_str());\par
03210     PrintFailedTests(unit_test);\par
03211     printf({\cf22 "\\n%2d FAILED %s\\n"}, num_failures,\par
03212                         num_failures == 1 ? {\cf22 "TEST"} : {\cf22 "TESTS"});\par
03213   \}\par
03214 \par
03215   {\cf18 int} num_disabled = unit_test.reportable_disabled_test_count();\par
03216   {\cf19 if} (num_disabled && !GTEST_FLAG(also_run_disabled_tests)) \{\par
03217     {\cf19 if} (!num_failures) \{\par
03218       printf({\cf22 "\\n"});  {\cf20 // Add a spacer if no FAILURE banner is displayed.}\par
03219     \}\par
03220     ColoredPrintf(COLOR_YELLOW,\par
03221                   {\cf22 "  YOU HAVE %d DISABLED %s\\n\\n"},\par
03222                   num_disabled,\par
03223                   num_disabled == 1 ? {\cf22 "TEST"} : {\cf22 "TESTS"});\par
03224   \}\par
03225   {\cf20 // Ensure that Google Test output is printed before, e.g., heapchecker output.}\par
03226   fflush(stdout);\par
03227 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::COLOR_GREEN}, {\b testing::internal::COLOR_RED}, {\b testing::internal::COLOR_YELLOW}, {\b testing::internal::ColoredPrintf()}, {\b testing::UnitTest::elapsed_time()}, {\b testing::UnitTest::failed_test_count()}, {\b GTEST_FLAG}, {\b testing::UnitTest::Passed()}, {\b testing::UnitTest::reportable_disabled_test_count()}, {\b testing::internal::StreamableToString()}, {\b testing::UnitTest::successful_test_count()}, {\b testing::UnitTest::test_case_to_run_count()} \'E8 {\b testing::UnitTest::test_to_run_count()}.}\par
}
{\xe \v OnTestIterationStart\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:OnTestIterationStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart (const {\b UnitTest} &  {\i unit_test}, int  {\i iteration}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3054}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03055                                               \{\par
03056   {\cf19 if} (GTEST_FLAG(repeat) != 1)\par
03057     printf({\cf22 "\\nRepeating all tests (iteration %d) . . .\\n\\n"}, iteration + 1);\par
03058 \par
03059   {\cf17 const} {\cf18 char}* {\cf17 const} filter = GTEST_FLAG(filter).c_str();\par
03060 \par
03061   {\cf20 // Prints the filter if it's not *.  This reminds the user that some}\par
03062   {\cf20 // tests may be skipped.}\par
03063   {\cf19 if} (!String::CStringEquals(filter, kUniversalFilter)) \{\par
03064     ColoredPrintf(COLOR_YELLOW,\par
03065                   {\cf22 "Note: %s filter = %s\\n"}, GTEST_NAME_, filter);\par
03066   \}\par
03067 \par
03068   {\cf19 if} (internal::ShouldShard(kTestTotalShards, kTestShardIndex, {\cf17 false})) \{\par
03069     {\cf17 const} Int32 shard_index = Int32FromEnvOrDie(kTestShardIndex, -1);\par
03070     ColoredPrintf(COLOR_YELLOW,\par
03071                   {\cf22 "Note: This is test shard %d of %s.\\n"},\par
03072                   {\cf17 static_cast<}{\cf18 int}{\cf17 >}(shard_index) + 1,\par
03073                   internal::posix::GetEnv(kTestTotalShards));\par
03074   \}\par
03075 \par
03076   {\cf19 if} (GTEST_FLAG(shuffle)) \{\par
03077     ColoredPrintf(COLOR_YELLOW,\par
03078                   {\cf22 "Note: Randomizing tests' orders with a seed of %d .\\n"},\par
03079                   unit_test.random_seed());\par
03080   \}\par
03081 \par
03082   ColoredPrintf(COLOR_GREEN,  {\cf22 "[==========] "});\par
03083   printf({\cf22 "Running %s from %s.\\n"},\par
03084          FormatTestCount(unit_test.test_to_run_count()).c_str(),\par
03085          FormatTestCaseCount(unit_test.test_case_to_run_count()).c_str());\par
03086   fflush(stdout);\par
03087 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::COLOR_GREEN}, {\b testing::internal::COLOR_YELLOW}, {\b testing::internal::ColoredPrintf()}, {\b testing::internal::String::CStringEquals()}, {\b testing::internal::posix::GetEnv()}, {\b GTEST_FLAG}, {\b GTEST_NAME_}, {\b testing::internal::Int32FromEnvOrDie()}, {\b testing::UnitTest::random_seed()}, {\b testing::internal::ShouldShard()}, {\b testing::UnitTest::test_case_to_run_count()} \'E8 {\b testing::UnitTest::test_to_run_count()}.}\par
}
{\xe \v OnTestPartResult\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:OnTestPartResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrettyUnitTestResultPrinter::OnTestPartResult (const {\b TestPartResult} &  {\i result}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3117}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03118                                   \{\par
03119   {\cf20 // If the test part succeeded, we don't need to do anything.}\par
03120   {\cf19 if} (result.type() == TestPartResult::kSuccess)\par
03121     {\cf19 return};\par
03122 \par
03123   {\cf20 // Print failure message from the assertion (e.g. expected this and got that).}\par
03124   PrintTestPartResult(result);\par
03125   fflush(stdout);\par
03126 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestPartResult::kSuccess} \'E8 {\b testing::TestPartResult::type()}.}\par
}
{\xe \v OnTestProgramEnd\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:OnTestProgramEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::PrettyUnitTestResultPrinter::OnTestProgramEnd (const {\b UnitTest} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3047}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03047 \{\}\par
}
}
{\xe \v OnTestProgramStart\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:OnTestProgramStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::PrettyUnitTestResultPrinter::OnTestProgramStart (const {\b UnitTest} & ){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3035}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03035 \{\}\par
}
}
{\xe \v OnTestStart\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:OnTestStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::PrettyUnitTestResultPrinter::OnTestStart (const {\b TestInfo} &  {\i test_info}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3109}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03109                                                                        \{\par
03110   ColoredPrintf(COLOR_GREEN,  {\cf22 "[ RUN      ] "});\par
03111   PrintTestName(test_info.test_case_name(), test_info.name());\par
03112   printf({\cf22 "\\n"});\par
03113   fflush(stdout);\par
03114 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::COLOR_GREEN}, {\b testing::internal::ColoredPrintf()}, {\b testing::TestInfo::name()}, {\b PrintTestName()} \'E8 {\b testing::TestInfo::test_case_name()}.}\par
}
{\xe \v PrintTestName\:testing::internal::PrettyUnitTestResultPrinter}
{\xe \v testing::internal::PrettyUnitTestResultPrinter\:PrintTestName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void testing::internal::PrettyUnitTestResultPrinter::PrintTestName (const char *  {\i test_case}, const char *  {\i test}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3030}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03030                                                                        \{\par
03031     printf({\cf22 "%s.%s"}, test_case, test);\par
03032   \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b OnTestEnd()} \'E8 {\b OnTestStart()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::Random\par \pard\plain 
{\tc\tcl2 \v testing::internal::Random}
{\xe \v testing::internal::Random}
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Random} ({\b UInt32} seed)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Reseed} ({\b UInt32} seed)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt32} {\b Generate} ({\b UInt32} range)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b UInt32} {\b kMaxRange} = 1u << 31\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 753}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v Random\:testing::internal::Random}
{\xe \v testing::internal::Random\:Random}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::Random::Random ({\b UInt32}  {\i seed}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 757}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00757 : state_(seed) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Generate\:testing::internal::Random}
{\xe \v testing::internal::Random\:Generate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt32} testing::internal::Random::Generate ({\b UInt32}  {\i range})}}
\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 311}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00311                                     \{\par
00312   {\cf20 // These constants are the same as are used in glibc's rand(3).}\par
00313   state_ = (1103515245U*state_ + 12345U) % kMaxRange;\par
00314 \par
00315   GTEST_CHECK_(range > 0)\par
00316       << {\cf22 "Cannot generate a number in the range [0, 0)."};\par
00317   GTEST_CHECK_(range <= kMaxRange)\par
00318       << {\cf22 "Generation of a number in [0, "} << range << {\cf22 ") was requested, "}\par
00319       << {\cf22 "but this can only generate numbers in [0, "} << kMaxRange << {\cf22 ")."};\par
00320 \par
00321   {\cf20 // Converting via modulus introduces a bit of downward bias, but}\par
00322   {\cf20 // it's simple, and a linear congruential generator isn't too good}\par
00323   {\cf20 // to begin with.}\par
00324   {\cf19 return} state_ % range;\par
00325 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GTEST_CHECK_} \'E8 {\b kMaxRange}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::ShuffleRange()}.}\par
}
{\xe \v Reseed\:testing::internal::Random}
{\xe \v testing::internal::Random\:Reseed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::Random::Reseed ({\b UInt32}  {\i seed}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 759}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00759 \{ state_ = seed; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v kMaxRange\:testing::internal::Random}
{\xe \v testing::internal::Random\:kMaxRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt32} testing::internal::Random::kMaxRange = 1u << 31{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 755}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b Generate()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::RE\par \pard\plain 
{\tc\tcl2 \v testing::internal::RE}
{\xe \v testing::internal::RE}
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
\par
{
{\f2 #include <gtest-port.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RE} (const {\b RE} &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RE} (const ::std::string &regex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RE} (const char *regex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~RE} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b pattern} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b FullMatch} (const ::std::string &str, const {\b RE} &re)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b PartialMatch} (const ::std::string &str, const {\b RE} &re)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b FullMatch} (const char *str, const {\b RE} &re)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b PartialMatch} (const char *str, const {\b RE} &re)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1191}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v RE\:testing::internal::RE}
{\xe \v testing::internal::RE\:RE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::RE::RE (const {\b RE} &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1195}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01195 \{ Init(other.pattern()); \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b pattern()}.}\par
}
{\xe \v RE\:testing::internal::RE}
{\xe \v testing::internal::RE\:RE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::RE::RE (const ::std::string &  {\i regex}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1198}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01198 \{ Init(regex.c_str()); \}  {\cf20 // NOLINT}\par
}
}
{\xe \v RE\:testing::internal::RE}
{\xe \v testing::internal::RE\:RE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::RE::RE (const char *  {\i regex}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1206}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01206 \{ Init(regex); \}  {\cf20 // NOLINT}\par
}
}
{\xe \v ~RE\:testing::internal::RE}
{\xe \v testing::internal::RE\:~RE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::RE::~RE ()}}
\par
{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v FullMatch\:testing::internal::RE}
{\xe \v testing::internal::RE\:FullMatch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool testing::internal::RE::FullMatch (const ::std::string &  {\i str}, const {\b RE} &  {\i re}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1219}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01219                                                             \{\par
01220     {\cf19 return} FullMatch(str.c_str(), re);\par
01221   \}\par
}
}
{\xe \v FullMatch\:testing::internal::RE}
{\xe \v testing::internal::RE\:FullMatch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool testing::internal::RE::FullMatch (const char *  {\i str}, const {\b RE} &  {\i re}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PartialMatch\:testing::internal::RE}
{\xe \v testing::internal::RE\:PartialMatch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool testing::internal::RE::PartialMatch (const ::std::string &  {\i str}, const {\b RE} &  {\i re}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1222}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01222                                                                \{\par
01223     {\cf19 return} PartialMatch(str.c_str(), re);\par
01224   \}\par
}
}
{\xe \v PartialMatch\:testing::internal::RE}
{\xe \v testing::internal::RE\:PartialMatch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool testing::internal::RE::PartialMatch (const char *  {\i str}, const {\b RE} &  {\i re}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pattern\:testing::internal::RE}
{\xe \v testing::internal::RE\:pattern}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::internal::RE::pattern () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1210}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01210 \{ {\cf19 return} pattern_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b RE()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'E0 testing::internal::RelationToSourceCopy\par \pard\plain 
{\tc\tcl2 \v testing::internal::RelationToSourceCopy}
{\xe \v testing::internal::RelationToSourceCopy}
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
\par
{
{\f2 #include <gtest-internal.h>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1024}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'E0 testing::internal::RelationToSourceReference\par \pard\plain 
{\tc\tcl2 \v testing::internal::RelationToSourceReference}
{\xe \v testing::internal::RelationToSourceReference}
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
\par
{
{\f2 #include <gtest-internal.h>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1023}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::RemoveConst< T >\par \pard\plain 
{\tc\tcl2 \v testing::internal::RemoveConst< T >}
{\xe \v testing::internal::RemoveConst< T >}
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct testing::internal::RemoveConst< T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 796}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:testing::internal::RemoveConst< T >}
{\xe \v testing::internal::RemoveConst< T >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > typedef T {\b testing::internal::RemoveConst}< T >::type}}
\par
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 796}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::RemoveConst< const T >\par \pard\plain 
{\tc\tcl2 \v testing::internal::RemoveConst< const T >}
{\xe \v testing::internal::RemoveConst< const T >}
{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct testing::internal::RemoveConst< const T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 798}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:testing::internal::RemoveConst< const T >}
{\xe \v testing::internal::RemoveConst< const T >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > typedef T {\b testing::internal::RemoveConst}< const T >::type}}
\par
{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 798}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::RemoveConst< const T[N]>\par \pard\plain 
{\tc\tcl2 \v testing::internal::RemoveConst< const T[N]>}
{\xe \v testing::internal::RemoveConst< const T[N]>}
{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b RemoveConst}< T >::type {\b type}[N]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, size_t N>\par
struct testing::internal::RemoveConst< const T[N]>\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 804}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:testing::internal::RemoveConst< const T[N]>}
{\xe \v testing::internal::RemoveConst< const T[N]>\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , size_t N> typedef {\b RemoveConst}<T>::type {\b testing::internal::RemoveConst}< const T[N]>::type[N]}}
\par
{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 805}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::RemoveReference< T >\par \pard\plain 
{\tc\tcl2 \v testing::internal::RemoveReference< T >}
{\xe \v testing::internal::RemoveReference< T >}
{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct testing::internal::RemoveReference< T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 783}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:testing::internal::RemoveReference< T >}
{\xe \v testing::internal::RemoveReference< T >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > typedef T {\b testing::internal::RemoveReference}< T >::type}}
\par
{\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 783}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::RemoveReference< T & >\par \pard\plain 
{\tc\tcl2 \v testing::internal::RemoveReference< T & >}
{\xe \v testing::internal::RemoveReference< T & >}
{\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct testing::internal::RemoveReference< T & >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 785}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:testing::internal::RemoveReference< T & >}
{\xe \v testing::internal::RemoveReference< T & >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > typedef T {\b testing::internal::RemoveReference}< T & >::type}}
\par
{\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 785}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::SameSizeTuplePrefixComparator< kSize1, kSize2 >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::SameSizeTuplePrefixComparator< kSize1, kSize2 >}
{\xe \v std::tr1::gtest_internal::SameSizeTuplePrefixComparator< kSize1, kSize2 >}
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<int kSize1, int kSize2>\par
struct std::tr1::gtest_internal::SameSizeTuplePrefixComparator< kSize1, kSize2 >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 952}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'E0 std::tr1::gtest_internal::SameSizeTuplePrefixComparator< 0, 0 >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::SameSizeTuplePrefixComparator< 0, 0 >}
{\xe \v std::tr1::gtest_internal::SameSizeTuplePrefixComparator< 0, 0 >}
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple1 , class Tuple2 > static bool {\b Eq} (const Tuple1 &, const Tuple2 &)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 955}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Eq\:std::tr1::gtest_internal::SameSizeTuplePrefixComparator< 0, 0 >}
{\xe \v std::tr1::gtest_internal::SameSizeTuplePrefixComparator< 0, 0 >\:Eq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Tuple1 , class Tuple2 > static bool {\b std::tr1::gtest_internal::SameSizeTuplePrefixComparator}< 0, 0 >::Eq (const Tuple1 & , const Tuple2 & ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 957}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00957                                                    \{\par
00958     {\cf19 return} {\cf17 true};\par
00959   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::SameSizeTuplePrefixComparator< k, k >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::SameSizeTuplePrefixComparator< k, k >}
{\xe \v std::tr1::gtest_internal::SameSizeTuplePrefixComparator< k, k >}
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Tuple1 , class Tuple2 > static bool {\b Eq} (const Tuple1 &t1, const Tuple2 &t2)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<int k>\par
struct std::tr1::gtest_internal::SameSizeTuplePrefixComparator< k, k >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 963}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Eq\:std::tr1::gtest_internal::SameSizeTuplePrefixComparator< k, k >}
{\xe \v std::tr1::gtest_internal::SameSizeTuplePrefixComparator< k, k >\:Eq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<int k> template<class Tuple1 , class Tuple2 > static bool {\b std::tr1::gtest_internal::SameSizeTuplePrefixComparator}< k, k >::Eq (const Tuple1 &  {\i t1}, const Tuple2 &  {\i t2}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 965}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00965                                                      \{\par
00966     {\cf19 return} SameSizeTuplePrefixComparator<k - 1, k - 1>::Eq(t1, t2) &&\par
00967         ::std::tr1::get<k - 1>(t1) == ::std::tr1::get<k - 1>(t2);\par
00968   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::scoped_ptr< T >\par \pard\plain 
{\tc\tcl2 \v testing::internal::scoped_ptr< T >}
{\xe \v testing::internal::scoped_ptr< T >}
{\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
\par
{
{\f2 #include <gtest-port.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T {\b element_type}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b scoped_ptr} (T *p=NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~scoped_ptr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b operator*} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b operator->} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b get} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b release} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} (T *p=NULL)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'F0\'F3\'E7\'FC\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b scoped_ptr} &a, {\b scoped_ptr} &b)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class testing::internal::scoped_ptr< T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1150}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v element_type\:testing::internal::scoped_ptr< T >}
{\xe \v testing::internal::scoped_ptr< T >\:element_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > typedef T {\b testing::internal::scoped_ptr}< T >::element_type}}
\par
{\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1152}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v scoped_ptr\:testing::internal::scoped_ptr< T >}
{\xe \v testing::internal::scoped_ptr< T >\:scoped_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b testing::internal::scoped_ptr}< T >::scoped_ptr (T *  {\i p} = {\f2 NULL}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1154}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01154 : ptr_(p) \{\}\par
}
}
{\xe \v ~scoped_ptr\:testing::internal::scoped_ptr< T >}
{\xe \v testing::internal::scoped_ptr< T >\:~scoped_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b testing::internal::scoped_ptr}< T >::~{\b scoped_ptr} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1155}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01155 \{ reset(); \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::scoped_ptr< T >::reset()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v get\:testing::internal::scoped_ptr< T >}
{\xe \v testing::internal::scoped_ptr< T >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T * {\b testing::internal::scoped_ptr}< T >::get () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1159}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01159 \{ {\cf19 return} ptr_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::Message::GetString()} \'E8 {\b testing::AssertionResult::operator!()}.}\par
}
{\xe \v operator*\:testing::internal::scoped_ptr< T >}
{\xe \v testing::internal::scoped_ptr< T >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T & {\b testing::internal::scoped_ptr}< T >::operator* () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTA}
{\bkmkend AAAAAAABTA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1157}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01157 \{ {\cf19 return} *ptr_; \}\par
}
}
{\xe \v operator->\:testing::internal::scoped_ptr< T >}
{\xe \v testing::internal::scoped_ptr< T >\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T * {\b testing::internal::scoped_ptr}< T >::operator-> () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTB}
{\bkmkend AAAAAAABTB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1158}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01158 \{ {\cf19 return} ptr_; \}\par
}
}
{\xe \v release\:testing::internal::scoped_ptr< T >}
{\xe \v testing::internal::scoped_ptr< T >\:release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T * {\b testing::internal::scoped_ptr}< T >::release (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTC}
{\bkmkend AAAAAAABTC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1161}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01161                \{\par
01162     T* {\cf17 const} ptr = ptr_;\par
01163     ptr_ = NULL;\par
01164     {\cf19 return} ptr;\par
01165   \}\par
}
}
{\xe \v reset\:testing::internal::scoped_ptr< T >}
{\xe \v testing::internal::scoped_ptr< T >\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void {\b testing::internal::scoped_ptr}< T >::reset (T *  {\i p} = {\f2 NULL}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTD}
{\bkmkend AAAAAAABTD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1167}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01167                           \{\par
01168     {\cf19 if} (p != ptr_) \{\par
01169       {\cf19 if} (IsTrue({\cf17 sizeof}(T) > 0)) \{  {\cf20 // Makes sure T is a complete type.}\par
01170         {\cf17 delete} ptr_;\par
01171       \}\par
01172       ptr_ = p;\par
01173     \}\par
01174   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::IsTrue()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::scoped_ptr< T >::~scoped_ptr()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FF \'EF\'EE \'E4\'F0\'F3\'E7\'FC\'FF\'EC \'EA\'EB\'E0\'F1\'F1\'E0 \'E8 \'F4\'F3\'ED\'EA\'F6\'E8\'FF\'EC, \'EE\'F2\'ED\'EE\'F1\'FF\'F9\'E8\'EC\'F1\'FF \'EA \'EA\'EB\'E0\'F1\'F1\'F3\par
\pard\plain 
{\xe \v swap\:testing::internal::scoped_ptr< T >}
{\xe \v testing::internal::scoped_ptr< T >\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void swap ({\b scoped_ptr}< T > &  {\i a}, {\b scoped_ptr}< T > &  {\i b}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABTE}
{\bkmkend AAAAAAABTE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1176}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01176                                                  \{\par
01177     {\cf17 using} std::swap;\par
01178     swap(a.ptr_, b.ptr_);\par
01179   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::ScopedFakeTestPartResultReporter\par \pard\plain 
{\tc\tcl2 \v testing::ScopedFakeTestPartResultReporter}
{\xe \v testing::ScopedFakeTestPartResultReporter}
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
\par
{
{\f2 #include <gtest-spi.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::ScopedFakeTestPartResultReporter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtesting_1_1_scoped_fake_test_part_result_reporter.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b InterceptMode} \{ {\b INTERCEPT_ONLY_CURRENT_THREAD}
, {\b INTERCEPT_ALL_THREADS}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScopedFakeTestPartResultReporter} ({\b TestPartResultArray} *result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScopedFakeTestPartResultReporter} ({\b InterceptMode} intercept_mode, {\b TestPartResultArray} *result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ScopedFakeTestPartResultReporter} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ReportTestPartResult} (const {\b TestPartResult} &result)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-spi.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 51}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 
{\xe \v InterceptMode\:testing::ScopedFakeTestPartResultReporter}
{\xe \v testing::ScopedFakeTestPartResultReporter\:InterceptMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b testing::ScopedFakeTestPartResultReporter::InterceptMode}}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'DD\'EB\'E5\'EC\'E5\'ED\'F2\'FB \'EF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'E9:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v INTERCEPT_ONLY_CURRENT_THREAD\:testing::ScopedFakeTestPartResultReporter}
{\xe \v testing::ScopedFakeTestPartResultReporter\:INTERCEPT_ONLY_CURRENT_THREAD}
{\qr INTERCEPT_ONLY_CURRENT_THREAD{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
\cell }{\cell }{\row }
{\xe \v INTERCEPT_ALL_THREADS\:testing::ScopedFakeTestPartResultReporter}
{\xe \v testing::ScopedFakeTestPartResultReporter\:INTERCEPT_ALL_THREADS}
{\qr INTERCEPT_ALL_THREADS{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
\cell }{\cell }{\row }
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-spi.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 55}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00055                      \{\par
00056     INTERCEPT_ONLY_CURRENT_THREAD,  {\cf20 // Intercepts only thread local failures.}\par
00057     INTERCEPT_ALL_THREADS           {\cf20 // Intercepts all failures.}\par
00058   \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v ScopedFakeTestPartResultReporter\:testing::ScopedFakeTestPartResultReporter}
{\xe \v testing::ScopedFakeTestPartResultReporter\:ScopedFakeTestPartResultReporter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter ({\b TestPartResultArray} *  {\i result}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 563}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00565     : intercept_mode_(INTERCEPT_ONLY_CURRENT_THREAD),\par
00566       result_(result) \{\par
00567   Init();\par
00568 \}\par
}
}
{\xe \v ScopedFakeTestPartResultReporter\:testing::ScopedFakeTestPartResultReporter}
{\xe \v testing::ScopedFakeTestPartResultReporter\:ScopedFakeTestPartResultReporter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter ({\b InterceptMode}  {\i intercept_mode}, {\b TestPartResultArray} *  {\i result})}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 573}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00575     : intercept_mode_(intercept_mode),\par
00576       result_(result) \{\par
00577   Init();\par
00578 \}\par
}
}
{\xe \v ~ScopedFakeTestPartResultReporter\:testing::ScopedFakeTestPartResultReporter}
{\xe \v testing::ScopedFakeTestPartResultReporter\:~ScopedFakeTestPartResultReporter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 593}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00593                                                                     \{\par
00594   internal::UnitTestImpl* {\cf17 const} impl = internal::GetUnitTestImpl();\par
00595   {\cf19 if} (intercept_mode_ == INTERCEPT_ALL_THREADS) \{\par
00596     impl->SetGlobalTestPartResultReporter(old_reporter_);\par
00597   \} {\cf19 else} \{\par
00598     impl->SetTestPartResultReporterForCurrentThread(old_reporter_);\par
00599   \}\par
00600 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::GetUnitTestImpl()}, {\b INTERCEPT_ALL_THREADS}, {\b testing::internal::UnitTestImpl::SetGlobalTestPartResultReporter()} \'E8 {\b testing::internal::UnitTestImpl::SetTestPartResultReporterForCurrentThread()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v ReportTestPartResult\:testing::ScopedFakeTestPartResultReporter}
{\xe \v testing::ScopedFakeTestPartResultReporter\:ReportTestPartResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::ScopedFakeTestPartResultReporter::ReportTestPartResult (const {\b TestPartResult} &  {\i result}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestPartResultReporterInterface} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 604}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00605                                   \{\par
00606   result_->Append(result);\par
00607 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestPartResultArray::Append()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-spi.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::ScopedPrematureExitFile\par \pard\plain 
{\tc\tcl2 \v testing::internal::ScopedPrematureExitFile}
{\xe \v testing::internal::ScopedPrematureExitFile}
{\bkmkstart AAAAAAABTF}
{\bkmkend AAAAAAABTF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScopedPrematureExitFile} (const char *premature_exit_filepath)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ScopedPrematureExitFile} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3858}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v ScopedPrematureExitFile\:testing::internal::ScopedPrematureExitFile}
{\xe \v testing::internal::ScopedPrematureExitFile\:ScopedPrematureExitFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::ScopedPrematureExitFile::ScopedPrematureExitFile (const char *  {\i premature_exit_filepath}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABTG}
{\bkmkend AAAAAAABTG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3860}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03861       : premature_exit_filepath_(premature_exit_filepath) \{\par
03862     {\cf20 // If a path to the premature-exit file is specified...}\par
03863     {\cf19 if} (premature_exit_filepath != NULL && *premature_exit_filepath != {\cf23 '\\0'}) \{\par
03864       {\cf20 // create the file with a single "0" character in it.  I/O}\par
03865       {\cf20 // errors are ignored as there's nothing better we can do and we}\par
03866       {\cf20 // don't want to fail the test because of this.}\par
03867       FILE* pfile = posix::FOpen(premature_exit_filepath, {\cf22 "w"});\par
03868       fwrite({\cf22 "0"}, 1, 1, pfile);\par
03869       fclose(pfile);\par
03870     \}\par
03871   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::posix::FOpen()}.}\par
}
{\xe \v ~ScopedPrematureExitFile\:testing::internal::ScopedPrematureExitFile}
{\xe \v testing::internal::ScopedPrematureExitFile\:~ScopedPrematureExitFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::ScopedPrematureExitFile::~ScopedPrematureExitFile (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTH}
{\bkmkend AAAAAAABTH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3873}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03873                              \{\par
03874     {\cf19 if} (premature_exit_filepath_ != NULL && *premature_exit_filepath_ != {\cf23 '\\0'}) \{\par
03875       remove(premature_exit_filepath_);\par
03876     \}\par
03877   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::ScopedTrace\par \pard\plain 
{\tc\tcl2 \v testing::internal::ScopedTrace}
{\xe \v testing::internal::ScopedTrace}
{\bkmkstart AAAAAAABTI}
{\bkmkend AAAAAAABTI}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScopedTrace} (const char *file, int line, const {\b Message} &message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ScopedTrace} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 156}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v ScopedTrace\:testing::internal::ScopedTrace}
{\xe \v testing::internal::ScopedTrace\:ScopedTrace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::ScopedTrace::ScopedTrace (const char *  {\i file}, int  {\i line}, const {\b Message} &  {\i message})}}
\par
{\bkmkstart AAAAAAABTJ}
{\bkmkend AAAAAAABTJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3827}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03828                                           \{\par
03829   TraceInfo trace;\par
03830   trace.file = file;\par
03831   trace.line = line;\par
03832   trace.message = message.GetString();\par
03833 \par
03834   UnitTest::GetInstance()->PushGTestTrace(trace);\par
03835 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::TraceInfo::file}, {\b testing::UnitTest::GetInstance()}, {\b testing::internal::TraceInfo::line} \'E8 {\b testing::internal::TraceInfo::message}.}\par
}
{\xe \v ~ScopedTrace\:testing::internal::ScopedTrace}
{\xe \v testing::internal::ScopedTrace\:~ScopedTrace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::ScopedTrace::~ScopedTrace ()}}
\par
{\bkmkstart AAAAAAABTK}
{\bkmkend AAAAAAABTK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3838}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03839                                           \{\par
03840   UnitTest::GetInstance()->PopGTestTrace();\par
03841 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::UnitTest::GetInstance()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::SingleFailureChecker\par \pard\plain 
{\tc\tcl2 \v testing::internal::SingleFailureChecker}
{\xe \v testing::internal::SingleFailureChecker}
{\bkmkstart AAAAAAABTL}
{\bkmkend AAAAAAABTL}
\par
{
{\f2 #include <gtest-spi.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SingleFailureChecker} (const {\b TestPartResultArray} *results, {\b TestPartResult::Type} type, const std::string &substr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~SingleFailureChecker} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-spi.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 96}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v SingleFailureChecker\:testing::internal::SingleFailureChecker}
{\xe \v testing::internal::SingleFailureChecker\:SingleFailureChecker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::SingleFailureChecker::SingleFailureChecker (const {\b TestPartResultArray} *  {\i results}, {\b TestPartResult::Type}  {\i type}, const std::string &  {\i substr})}}
\par
{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 670}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00673     : results_(results), type_(type), substr_(substr) \{\}\par
}
}
{\xe \v ~SingleFailureChecker\:testing::internal::SingleFailureChecker}
{\xe \v testing::internal::SingleFailureChecker\:~SingleFailureChecker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::SingleFailureChecker::~SingleFailureChecker ()}}
\par
{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 679}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00679                                             \{\par
00680   EXPECT_PRED_FORMAT3(HasOneFailure, *results_, type_, substr_);\par
00681 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b EXPECT_PRED_FORMAT3} \'E8 {\b testing::internal::HasOneFailure()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-spi.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::StaticAssertTypeEqHelper< T1, T2 >\par \pard\plain 
{\tc\tcl2 \v testing::internal::StaticAssertTypeEqHelper< T1, T2 >}
{\xe \v testing::internal::StaticAssertTypeEqHelper< T1, T2 >}
{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T1, typename T2>\par
struct testing::internal::StaticAssertTypeEqHelper< T1, T2 >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1119}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::StaticAssertTypeEqHelper< T, T >\par \pard\plain 
{\tc\tcl2 \v testing::internal::StaticAssertTypeEqHelper< T, T >}
{\xe \v testing::internal::StaticAssertTypeEqHelper< T, T >}
{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
\par
{
{\f2 #include <gtest-port.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b value} = true
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct testing::internal::StaticAssertTypeEqHelper< T, T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1122}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > anonymous enum}}
\par
{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'DD\'EB\'E5\'EC\'E5\'ED\'F2\'FB \'EF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'E9:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v value\:testing::internal::StaticAssertTypeEqHelper< T, T >}
{\xe \v testing::internal::StaticAssertTypeEqHelper< T, T >\:value}
{\qr value{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
\cell }{\cell }{\row }
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1123}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01123 \{ value = {\cf17 true} \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::String\par \pard\plain 
{\tc\tcl2 \v testing::internal::String}
{\xe \v testing::internal::String}
{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
\par
{
{\f2 #include <gtest-string.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b CloneCString} (const char *c_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b CStringEquals} (const char *lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b ShowWideCString} (const wchar_t *wide_c_str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b WideCStringEquals} (const wchar_t *lhs, const wchar_t *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b CaseInsensitiveCStringEquals} (const char *lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b CaseInsensitiveWideCStringEquals} (const wchar_t *lhs, const wchar_t *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b EndsWithCaseInsensitive} (const std::string &str, const std::string &suffix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b FormatIntWidth2} (int value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b FormatHexInt} (int value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b FormatByte} (unsigned char value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-string.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 58}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v CaseInsensitiveCStringEquals\:testing::internal::String}
{\xe \v testing::internal::String\:CaseInsensitiveCStringEquals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::String::CaseInsensitiveCStringEquals (const char *  {\i lhs}, const char *  {\i rhs}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1902}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01902                                                                             \{\par
01903   {\cf19 if} (lhs == NULL)\par
01904     {\cf19 return} rhs == NULL;\par
01905   {\cf19 if} (rhs == NULL)\par
01906     {\cf19 return} {\cf17 false};\par
01907   {\cf19 return} posix::StrCaseCmp(lhs, rhs) == 0;\par
01908 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::posix::StrCaseCmp()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::CmpHelperSTRCASEEQ()}, {\b testing::internal::CmpHelperSTRCASENE()}, {\b EndsWithCaseInsensitive()} \'E8 {\b testing::internal::ShouldUseColor()}.}\par
}
{\xe \v CaseInsensitiveWideCStringEquals\:testing::internal::String}
{\xe \v testing::internal::String\:CaseInsensitiveWideCStringEquals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::String::CaseInsensitiveWideCStringEquals (const wchar_t *  {\i lhs}, const wchar_t *  {\i rhs}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1922}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01923                                                                   \{\par
01924   {\cf19 if} (lhs == NULL) {\cf19 return} rhs == NULL;\par
01925 \par
01926   {\cf19 if} (rhs == NULL) {\cf19 return} {\cf17 false};\par
01927 \par
01928 {\cf21 #if GTEST_OS_WINDOWS}\par
01929   {\cf19 return} _wcsicmp(lhs, rhs) == 0;\par
01930 {\cf21 #elif GTEST_OS_LINUX && !GTEST_OS_LINUX_ANDROID}\par
01931   {\cf19 return} wcscasecmp(lhs, rhs) == 0;\par
01932 {\cf21 #else}\par
01933   {\cf20 // Android, Mac OS X and Cygwin don't define wcscasecmp.}\par
01934   {\cf20 // Other unknown OSes may not define it either.}\par
01935   wint_t left, right;\par
01936   {\cf19 do} \{\par
01937     left = towlower(*lhs++);\par
01938     right = towlower(*rhs++);\par
01939   \} {\cf19 while} (left && left == right);\par
01940   {\cf19 return} left == right;\par
01941 {\cf21 #endif  }{\cf20 // OS selector}\par
01942 \}\par
}
}
{\xe \v CloneCString\:testing::internal::String}
{\xe \v testing::internal::String\:CloneCString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char * testing::internal::String::CloneCString (const char *  {\i c_str}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CStringEquals\:testing::internal::String}
{\xe \v testing::internal::String\:CStringEquals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::String::CStringEquals (const char *  {\i lhs}, const char *  {\i rhs}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 891}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00891                                                              \{\par
00892   {\cf19 if} ( lhs == NULL ) {\cf19 return} rhs == NULL;\par
00893 \par
00894   {\cf19 if} ( rhs == NULL ) {\cf19 return} {\cf17 false};\par
00895 \par
00896   {\cf19 return} strcmp(lhs, rhs) == 0;\par
00897 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::CmpHelperSTREQ()}, {\b testing::internal::CmpHelperSTRNE()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart()} \'E8 {\b testing::internal::ShouldUseColor()}.}\par
}
{\xe \v EndsWithCaseInsensitive\:testing::internal::String}
{\xe \v testing::internal::String\:EndsWithCaseInsensitive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::String::EndsWithCaseInsensitive (const std::string &  {\i str}, const std::string &  {\i suffix}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1946}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01947                                                    \{\par
01948   {\cf17 const} {\cf18 size_t} str_len = str.length();\par
01949   {\cf17 const} {\cf18 size_t} suffix_len = suffix.length();\par
01950   {\cf19 return} (str_len >= suffix_len) &&\par
01951          CaseInsensitiveCStringEquals(str.c_str() + str_len - suffix_len,\par
01952                                       suffix.c_str());\par
01953 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b CaseInsensitiveCStringEquals()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::FilePath::RemoveExtension()}.}\par
}
{\xe \v FormatByte\:testing::internal::String}
{\xe \v testing::internal::String\:FormatByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::String::FormatByte (unsigned char  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1970}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01970                                                 \{\par
01971   std::stringstream ss;\par
01972   ss << std::setfill({\cf23 '0'}) << std::setw(2) << std::hex << std::uppercase\par
01973      << {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(value);\par
01974   {\cf19 return} ss.str();\par
01975 \}\par
}
}
{\xe \v FormatHexInt\:testing::internal::String}
{\xe \v testing::internal::String\:FormatHexInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::String::FormatHexInt (int  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1963}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01963                                         \{\par
01964   std::stringstream ss;\par
01965   ss << std::hex << std::uppercase << value;\par
01966   {\cf19 return} ss.str();\par
01967 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::CodePointToUtf8()} \'E8 {\b testing::internal::PrintCharAndCodeTo()}.}\par
}
{\xe \v FormatIntWidth2\:testing::internal::String}
{\xe \v testing::internal::String\:FormatIntWidth2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::String::FormatIntWidth2 (int  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1956}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01956                                            \{\par
01957   std::stringstream ss;\par
01958   ss << std::setfill({\cf23 '0'}) << std::setw(2) << value;\par
01959   {\cf19 return} ss.str();\par
01960 \}\par
}
}
{\xe \v ShowWideCString\:testing::internal::String}
{\xe \v testing::internal::String\:ShowWideCString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::String::ShowWideCString (const wchar_t *  {\i wide_c_str}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1845}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01845                                                             \{\par
01846   {\cf19 if} (wide_c_str == NULL)  {\cf19 return} {\cf22 "(null)"};\par
01847 \par
01848   {\cf19 return} internal::WideStringToUtf8(wide_c_str, -1);\par
01849 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::WideStringToUtf8()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::Message::operator<<()}.}\par
}
{\xe \v WideCStringEquals\:testing::internal::String}
{\xe \v testing::internal::String\:WideCStringEquals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::String::WideCStringEquals (const wchar_t *  {\i lhs}, const wchar_t *  {\i rhs}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1857}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01857                                                                        \{\par
01858   {\cf19 if} (lhs == NULL) {\cf19 return} rhs == NULL;\par
01859 \par
01860   {\cf19 if} (rhs == NULL) {\cf19 return} {\cf17 false};\par
01861 \par
01862   {\cf19 return} wcscmp(lhs, rhs) == 0;\par
01863 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::CmpHelperSTREQ()} \'E8 {\b testing::internal::CmpHelperSTRNE()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-string.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::Test\par \pard\plain 
{\tc\tcl2 \v testing::Test}
{\xe \v testing::Test}
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
\par
{
{\f2 #include <gtest.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef internal::SetUpTestCaseFunc {\b SetUpTestCaseFunc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef internal::TearDownTestCaseFunc {\b TearDownTestCaseFunc}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Test} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b SetUpTestCase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b TearDownTestCase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b HasFatalFailure} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b HasNonfatalFailure} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b HasFailure} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b RecordProperty} (const std::string &key, const std::string &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b RecordProperty} (const std::string &key, int value)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C7\'E0\'F9\'E8\'F9\'E5\'ED\'ED\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Test} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b SetUp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b TearDown} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'F0\'F3\'E7\'FC\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestInfo}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 371}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v SetUpTestCaseFunc\:testing::Test}
{\xe \v testing::Test\:SetUpTestCaseFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef internal::SetUpTestCaseFunc {\b testing::Test::SetUpTestCaseFunc}}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 377}}\par
}
{\xe \v TearDownTestCaseFunc\:testing::Test}
{\xe \v testing::Test\:TearDownTestCaseFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef internal::TearDownTestCaseFunc {\b testing::Test::TearDownTestCaseFunc}}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 378}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v ~Test\:testing::Test}
{\xe \v testing::Test\:~Test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::Test::~Test (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2218}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02218             \{\par
02219 \}\par
}
}
{\xe \v Test\:testing::Test}
{\xe \v testing::Test\:Test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::Test::Test (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2211}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02212     : gtest_flag_saver_({\cf17 new} GTEST_FLAG_SAVER_) \{\par
02213 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v HasFailure\:testing::Test}
{\xe \v testing::Test\:HasFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool testing::Test::HasFailure (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 407}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00407 \{ {\cf19 return} HasFatalFailure() || HasNonfatalFailure(); \}\par
}
}
{\xe \v HasFatalFailure\:testing::Test}
{\xe \v testing::Test\:HasFatalFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::Test::HasFatalFailure (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2484}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02484                            \{\par
02485   {\cf19 return} internal::GetUnitTestImpl()->current_test_result()->HasFatalFailure();\par
02486 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UnitTestImpl::current_test_result()}, {\b testing::internal::GetUnitTestImpl()} \'E8 {\b testing::TestResult::HasFatalFailure()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v HasNonfatalFailure\:testing::Test}
{\xe \v testing::Test\:HasNonfatalFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::Test::HasNonfatalFailure (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2489}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02489                               \{\par
02490   {\cf19 return} internal::GetUnitTestImpl()->current_test_result()->\par
02491       HasNonfatalFailure();\par
02492 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UnitTestImpl::current_test_result()} \'E8 {\b testing::internal::GetUnitTestImpl()}.}\par
}
{\xe \v RecordProperty\:testing::Test}
{\xe \v testing::Test\:RecordProperty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::Test::RecordProperty (const std::string &  {\i key}, const std::string &  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2234}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02234                                                                       \{\par
02235   UnitTest::GetInstance()->RecordProperty(key, value);\par
02236 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::UnitTest::GetInstance()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b RecordProperty()}.}\par
}
{\xe \v RecordProperty\:testing::Test}
{\xe \v testing::Test\:RecordProperty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::Test::RecordProperty (const std::string &  {\i key}, int  {\i value}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2239}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02239                                                          \{\par
02240   Message value_message;\par
02241   value_message << value;\par
02242   RecordProperty(key, value_message.GetString().c_str());\par
02243 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::Message::GetString()} \'E8 {\b RecordProperty()}.}\par
}
{\xe \v SetUp\:testing::Test}
{\xe \v testing::Test\:SetUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::Test::SetUp (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2224}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02224                  \{\par
02225 \}\par
}
}
{\xe \v SetUpTestCase\:testing::Test}
{\xe \v testing::Test\:SetUpTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void testing::Test::SetUpTestCase (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 389}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00389 \{\}\par
}
}
{\xe \v TearDown\:testing::Test}
{\xe \v testing::Test\:TearDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::Test::TearDown (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2230}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02230                     \{\par
02231 \}\par
}
}
{\xe \v TearDownTestCase\:testing::Test}
{\xe \v testing::Test\:TearDownTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void testing::Test::TearDownTestCase (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 397}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00397 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FF \'EF\'EE \'E4\'F0\'F3\'E7\'FC\'FF\'EC \'EA\'EB\'E0\'F1\'F1\'E0 \'E8 \'F4\'F3\'ED\'EA\'F6\'E8\'FF\'EC, \'EE\'F2\'ED\'EE\'F1\'FF\'F9\'E8\'EC\'F1\'FF \'EA \'EA\'EB\'E0\'F1\'F1\'F3\par
\pard\plain 
{\xe \v TestInfo\:testing::Test}
{\xe \v testing::Test\:TestInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b TestInfo}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 373}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::TestCase\par \pard\plain 
{\tc\tcl2 \v testing::TestCase}
{\xe \v testing::TestCase}
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
\par
{
{\f2 #include <gtest.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCase} (const char *{\b name}, const char *a_type_param, {\b Test::SetUpTestCaseFunc} set_up_tc, {\b Test::TearDownTestCaseFunc} tear_down_tc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~TestCase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b name} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b type_param} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b should_run} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b successful_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b failed_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b reportable_disabled_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b disabled_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b reportable_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b test_to_run_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b total_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Passed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Failed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TimeInMillis} {\b elapsed_time} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b TestInfo} * {\b GetTestInfo} (int i) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b TestResult} & {\b ad_hoc_test_result} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'F0\'F3\'E7\'FC\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Test}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::UnitTestImpl}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 778}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v TestCase\:testing::TestCase}
{\xe \v testing::TestCase\:TestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::TestCase::TestCase (const char *  {\i name}, const char *  {\i a_type_param}, {\b Test::SetUpTestCaseFunc}  {\i set_up_tc}, {\b Test::TearDownTestCaseFunc}  {\i tear_down_tc})}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2717}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02720     : name_(a_name),\par
02721       type_param_(a_type_param ? {\cf17 new} std::string(a_type_param) : NULL),\par
02722       set_up_tc_(set_up_tc),\par
02723       tear_down_tc_(tear_down_tc),\par
02724       should_run_({\cf17 false}),\par
02725       elapsed_time_(0) \{\par
02726 \}\par
}
}
{\xe \v ~TestCase\:testing::TestCase}
{\xe \v testing::TestCase\:~TestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::TestCase::~TestCase (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2729}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02729                     \{\par
02730   {\cf20 // Deletes every Test in the collection.}\par
02731   ForEach(test_info_list_, internal::Delete<TestInfo>);\par
02732 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::ForEach()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v ad_hoc_test_result\:testing::TestCase}
{\xe \v testing::TestCase\:ad_hoc_test_result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestResult} & testing::TestCase::ad_hoc_test_result () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 849}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00849 \{ {\cf19 return} ad_hoc_test_result_; \}\par
}
}
{\xe \v disabled_test_count\:testing::TestCase}
{\xe \v testing::TestCase\:disabled_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::TestCase::disabled_test_count () const}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2689}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02689                                         \{\par
02690   {\cf19 return} CountIf(test_info_list_, TestDisabled);\par
02691 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CountIf()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::disabled_test_count()}.}\par
}
{\xe \v elapsed_time\:testing::TestCase}
{\xe \v testing::TestCase\:elapsed_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TimeInMillis} testing::TestCase::elapsed_time () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 841}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00841 \{ {\cf19 return} elapsed_time_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestCaseEnd()}.}\par
}
{\xe \v Failed\:testing::TestCase}
{\xe \v testing::TestCase\:Failed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::TestCase::Failed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 838}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00838 \{ {\cf19 return} failed_test_count() > 0; \}\par
}
}
{\xe \v failed_test_count\:testing::TestCase}
{\xe \v testing::TestCase\:failed_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::TestCase::failed_test_count () const}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2679}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02679                                       \{\par
02680   {\cf19 return} CountIf(test_info_list_, TestFailed);\par
02681 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CountIf()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::failed_test_count()}.}\par
}
{\xe \v GetTestInfo\:testing::TestCase}
{\xe \v testing::TestCase\:GetTestInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestInfo} * testing::TestCase::GetTestInfo (int  {\i i}) const}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2736}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02736                                                  \{\par
02737   {\cf17 const} {\cf18 int} index = GetElementOr(test_indices_, i, -1);\par
02738   {\cf19 return} index < 0 ? NULL : test_info_list_[index];\par
02739 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::GetElementOr()}.}\par
}
{\xe \v name\:testing::TestCase}
{\xe \v testing::TestCase\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::TestCase::name () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 800}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00800 \{ {\cf19 return} name_.c_str(); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::FilterTests()}, {\b testing::internal::UnitTestImpl::ListTestsMatchingFilter()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestCaseEnd()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestCaseStart()} \'E8 {\b testing::internal::TestCaseNameIs::operator()()}.}\par
}
{\xe \v Passed\:testing::TestCase}
{\xe \v testing::TestCase\:Passed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::TestCase::Passed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 835}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00835 \{ {\cf19 return} !Failed(); \}\par
}
}
{\xe \v reportable_disabled_test_count\:testing::TestCase}
{\xe \v testing::TestCase\:reportable_disabled_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::TestCase::reportable_disabled_test_count () const}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2684}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02684                                                    \{\par
02685   {\cf19 return} CountIf(test_info_list_, TestReportableDisabled);\par
02686 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CountIf()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::reportable_disabled_test_count()}.}\par
}
{\xe \v reportable_test_count\:testing::TestCase}
{\xe \v testing::TestCase\:reportable_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::TestCase::reportable_test_count () const}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2694}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02694                                           \{\par
02695   {\cf19 return} CountIf(test_info_list_, TestReportable);\par
02696 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CountIf()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::reportable_test_count()}.}\par
}
{\xe \v should_run\:testing::TestCase}
{\xe \v testing::TestCase\:should_run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::TestCase::should_run () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 811}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00811 \{ {\cf19 return} should_run_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::FilterTests()}.}\par
}
{\xe \v successful_test_count\:testing::TestCase}
{\xe \v testing::TestCase\:successful_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::TestCase::successful_test_count () const}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2674}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02674                                           \{\par
02675   {\cf19 return} CountIf(test_info_list_, TestPassed);\par
02676 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CountIf()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::successful_test_count()}.}\par
}
{\xe \v test_to_run_count\:testing::TestCase}
{\xe \v testing::TestCase\:test_to_run_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::TestCase::test_to_run_count () const}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2699}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02699                                       \{\par
02700   {\cf19 return} CountIf(test_info_list_, ShouldRunTest);\par
02701 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CountIf()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestCaseEnd()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestCaseStart()} \'E8 {\b testing::internal::UnitTestImpl::test_to_run_count()}.}\par
}
{\xe \v total_test_count\:testing::TestCase}
{\xe \v testing::TestCase\:total_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::TestCase::total_test_count () const}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2704}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02704                                      \{\par
02705   {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(test_info_list_.size());\par
02706 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::total_test_count()}.}\par
}
{\xe \v type_param\:testing::TestCase}
{\xe \v testing::TestCase\:type_param}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::TestCase::type_param () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 804}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00804                                  \{\par
00805     {\cf19 if} (type_param_.get() != NULL)\par
00806       {\cf19 return} type_param_->c_str();\par
00807     {\cf19 return} NULL;\par
00808   \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::ListTestsMatchingFilter()} \'E8 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestCaseStart()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FF \'EF\'EE \'E4\'F0\'F3\'E7\'FC\'FF\'EC \'EA\'EB\'E0\'F1\'F1\'E0 \'E8 \'F4\'F3\'ED\'EA\'F6\'E8\'FF\'EC, \'EE\'F2\'ED\'EE\'F1\'FF\'F9\'E8\'EC\'F1\'FF \'EA \'EA\'EB\'E0\'F1\'F1\'F3\par
\pard\plain 
{\xe \v internal::UnitTestImpl\:testing::TestCase}
{\xe \v testing::TestCase\:internal::UnitTestImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b internal::UnitTestImpl}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 853}}\par
}
{\xe \v Test\:testing::TestCase}
{\xe \v testing::TestCase\:Test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b Test}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 852}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::TestCaseNameIs\par \pard\plain 
{\tc\tcl2 \v testing::internal::TestCaseNameIs}
{\xe \v testing::internal::TestCaseNameIs}
{\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCaseNameIs} (const std::string &name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator()} (const {\b TestCase} *test_case) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4474}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v TestCaseNameIs\:testing::internal::TestCaseNameIs}
{\xe \v testing::internal::TestCaseNameIs\:TestCaseNameIs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::TestCaseNameIs::TestCaseNameIs (const std::string &  {\i name}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4477}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04478       : name_(name) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v operator()\:testing::internal::TestCaseNameIs}
{\xe \v testing::internal::TestCaseNameIs\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::TestCaseNameIs::operator() (const {\b TestCase} *  {\i test_case}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4481}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04481                                                    \{\par
04482     {\cf19 return} test_case != NULL && strcmp(test_case->name(), name_.c_str()) == 0;\par
04483   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestCase::name()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::TestEventListener\par \pard\plain 
{\tc\tcl2 \v testing::TestEventListener}
{\xe \v testing::TestEventListener}
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
\par
{
{\f2 #include <gtest.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::TestEventListener:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtesting_1_1_test_event_listener.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~TestEventListener} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestProgramStart} (const {\b UnitTest} &unit_test)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestIterationStart} (const {\b UnitTest} &unit_test, int iteration)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsSetUpStart} (const {\b UnitTest} &unit_test)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsSetUpEnd} (const {\b UnitTest} &unit_test)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestCaseStart} (const {\b TestCase} &test_case)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestStart} (const {\b TestInfo} &test_info)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestPartResult} (const {\b TestPartResult} &test_part_result)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestEnd} (const {\b TestInfo} &test_info)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestCaseEnd} (const {\b TestCase} &test_case)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsTearDownStart} (const {\b UnitTest} &unit_test)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsTearDownEnd} (const {\b UnitTest} &unit_test)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestIterationEnd} (const {\b UnitTest} &unit_test, int iteration)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestProgramEnd} (const {\b UnitTest} &unit_test)=0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 991}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v ~TestEventListener\:testing::TestEventListener}
{\xe \v testing::TestEventListener\:~TestEventListener}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual testing::TestEventListener::~TestEventListener (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 993}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00993 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v OnEnvironmentsSetUpEnd\:testing::TestEventListener}
{\xe \v testing::TestEventListener\:OnEnvironmentsSetUpEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::TestEventListener::OnEnvironmentsSetUpEnd (const {\b UnitTest} &  {\i unit_test}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::EmptyTestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUA \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::PrettyUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXK \\*MERGEFORMAT}{\fldrslt pagenum}}}) \'E8 {\b testing::internal::TestEventRepeater} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v OnEnvironmentsSetUpStart\:testing::TestEventListener}
{\xe \v testing::TestEventListener\:OnEnvironmentsSetUpStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::TestEventListener::OnEnvironmentsSetUpStart (const {\b UnitTest} &  {\i unit_test}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::EmptyTestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::PrettyUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}}) \'E8 {\b testing::internal::TestEventRepeater} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v OnEnvironmentsTearDownEnd\:testing::TestEventListener}
{\xe \v testing::TestEventListener\:OnEnvironmentsTearDownEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::TestEventListener::OnEnvironmentsTearDownEnd (const {\b UnitTest} &  {\i unit_test}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::EmptyTestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::PrettyUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXO \\*MERGEFORMAT}{\fldrslt pagenum}}}) \'E8 {\b testing::internal::TestEventRepeater} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v OnEnvironmentsTearDownStart\:testing::TestEventListener}
{\xe \v testing::TestEventListener\:OnEnvironmentsTearDownStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::TestEventListener::OnEnvironmentsTearDownStart (const {\b UnitTest} &  {\i unit_test}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::EmptyTestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::PrettyUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXQ \\*MERGEFORMAT}{\fldrslt pagenum}}}) \'E8 {\b testing::internal::TestEventRepeater} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v OnTestCaseEnd\:testing::TestEventListener}
{\xe \v testing::TestEventListener\:OnTestCaseEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::TestEventListener::OnTestCaseEnd (const {\b TestCase} &  {\i test_case}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::EmptyTestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::PrettyUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXS \\*MERGEFORMAT}{\fldrslt pagenum}}}) \'E8 {\b testing::internal::TestEventRepeater} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v OnTestCaseStart\:testing::TestEventListener}
{\xe \v testing::TestEventListener\:OnTestCaseStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::TestEventListener::OnTestCaseStart (const {\b TestCase} &  {\i test_case}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::EmptyTestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::PrettyUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXU \\*MERGEFORMAT}{\fldrslt pagenum}}}) \'E8 {\b testing::internal::TestEventRepeater} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v OnTestEnd\:testing::TestEventListener}
{\xe \v testing::TestEventListener\:OnTestEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::TestEventListener::OnTestEnd (const {\b TestInfo} &  {\i test_info}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::EmptyTestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUM \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::PrettyUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXW \\*MERGEFORMAT}{\fldrslt pagenum}}}) \'E8 {\b testing::internal::TestEventRepeater} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v OnTestIterationEnd\:testing::TestEventListener}
{\xe \v testing::TestEventListener\:OnTestIterationEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::TestEventListener::OnTestIterationEnd (const {\b UnitTest} &  {\i unit_test}, int  {\i iteration}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::EmptyTestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUO \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::PrettyUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXY \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::TestEventRepeater} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXZ \\*MERGEFORMAT}{\fldrslt pagenum}}}) \'E8 {\b testing::internal::XmlUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v OnTestIterationStart\:testing::TestEventListener}
{\xe \v testing::TestEventListener\:OnTestIterationStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::TestEventListener::OnTestIterationStart (const {\b UnitTest} &  {\i unit_test}, int  {\i iteration}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::EmptyTestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUR \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::PrettyUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYA \\*MERGEFORMAT}{\fldrslt pagenum}}}) \'E8 {\b testing::internal::TestEventRepeater} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v OnTestPartResult\:testing::TestEventListener}
{\xe \v testing::TestEventListener\:OnTestPartResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::TestEventListener::OnTestPartResult (const {\b TestPartResult} &  {\i test_part_result}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::EmptyTestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUT \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::PrettyUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYC \\*MERGEFORMAT}{\fldrslt pagenum}}}) \'E8 {\b testing::internal::TestEventRepeater} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::DefaultGlobalTestPartResultReporter::ReportTestPartResult()}.}\par
}
{\xe \v OnTestProgramEnd\:testing::TestEventListener}
{\xe \v testing::TestEventListener\:OnTestProgramEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::TestEventListener::OnTestProgramEnd (const {\b UnitTest} &  {\i unit_test}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::EmptyTestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUV \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::PrettyUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYE \\*MERGEFORMAT}{\fldrslt pagenum}}}) \'E8 {\b testing::internal::TestEventRepeater} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v OnTestProgramStart\:testing::TestEventListener}
{\xe \v testing::TestEventListener\:OnTestProgramStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::TestEventListener::OnTestProgramStart (const {\b UnitTest} &  {\i unit_test}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::EmptyTestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::PrettyUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYG \\*MERGEFORMAT}{\fldrslt pagenum}}}) \'E8 {\b testing::internal::TestEventRepeater} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v OnTestStart\:testing::TestEventListener}
{\xe \v testing::TestEventListener\:OnTestStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::TestEventListener::OnTestStart (const {\b TestInfo} &  {\i test_info}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::EmptyTestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUZ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::PrettyUnitTestResultPrinter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYI \\*MERGEFORMAT}{\fldrslt pagenum}}}) \'E8 {\b testing::internal::TestEventRepeater} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::TestEventListeners\par \pard\plain 
{\tc\tcl2 \v testing::TestEventListeners}
{\xe \v testing::TestEventListeners}
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
\par
{
{\f2 #include <gtest.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestEventListeners} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~TestEventListeners} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Append} ({\b TestEventListener} *listener)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestEventListener} * {\b Release} ({\b TestEventListener} *listener)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestEventListener} * {\b default_result_printer} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestEventListener} * {\b default_xml_generator} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'F0\'F3\'E7\'FC\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestCase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::DefaultGlobalTestPartResultReporter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::NoExecDeathTest}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::TestEventListenersAccessor}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::UnitTestImpl}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1064}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v TestEventListeners\:testing::TestEventListeners}
{\xe \v testing::TestEventListeners\:TestEventListeners}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::TestEventListeners::TestEventListeners ()}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3889}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03890     : repeater_({\cf17 new} internal::TestEventRepeater()),\par
03891       default_result_printer_(NULL),\par
03892       default_xml_generator_(NULL) \{\par
03893 \}\par
}
}
{\xe \v ~TestEventListeners\:testing::TestEventListeners}
{\xe \v testing::TestEventListeners\:~TestEventListeners}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::TestEventListeners::~TestEventListeners ()}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3895}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03895 \{ {\cf17 delete} repeater_; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Append\:testing::TestEventListeners}
{\xe \v testing::TestEventListeners\:Append}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::TestEventListeners::Append ({\b TestEventListener} *  {\i listener})}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3901}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03901                                                            \{\par
03902   repeater_->Append(listener);\par
03903 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::TestEventRepeater::Append()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::PostFlagParsingInit()}.}\par
}
{\xe \v default_result_printer\:testing::TestEventListeners}
{\xe \v testing::TestEventListeners\:default_result_printer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestEventListener} * testing::TestEventListeners::default_result_printer () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1084}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01084                                                     \{\par
01085     {\cf19 return} default_result_printer_;\par
01086   \}\par
}
}
{\xe \v default_xml_generator\:testing::TestEventListeners}
{\xe \v testing::TestEventListeners\:default_xml_generator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestEventListener} * testing::TestEventListeners::default_xml_generator () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1095}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01095                                                    \{\par
01096     {\cf19 return} default_xml_generator_;\par
01097   \}\par
}
}
{\xe \v Release\:testing::TestEventListeners}
{\xe \v testing::TestEventListeners\:Release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestEventListener} * testing::TestEventListeners::Release ({\b TestEventListener} *  {\i listener})}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3908}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03908                                                                           \{\par
03909   {\cf19 if} (listener == default_result_printer_)\par
03910     default_result_printer_ = NULL;\par
03911   {\cf19 else} {\cf19 if} (listener == default_xml_generator_)\par
03912     default_xml_generator_ = NULL;\par
03913   {\cf19 return} repeater_->Release(listener);\par
03914 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::TestEventRepeater::Release()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FF \'EF\'EE \'E4\'F0\'F3\'E7\'FC\'FF\'EC \'EA\'EB\'E0\'F1\'F1\'E0 \'E8 \'F4\'F3\'ED\'EA\'F6\'E8\'FF\'EC, \'EE\'F2\'ED\'EE\'F1\'FF\'F9\'E8\'EC\'F1\'FF \'EA \'EA\'EB\'E0\'F1\'F1\'F3\par
\pard\plain 
{\xe \v internal::DefaultGlobalTestPartResultReporter\:testing::TestEventListeners}
{\xe \v testing::TestEventListeners\:internal::DefaultGlobalTestPartResultReporter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b internal::DefaultGlobalTestPartResultReporter}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1102}}\par
}
{\xe \v internal::NoExecDeathTest\:testing::TestEventListeners}
{\xe \v testing::TestEventListeners\:internal::NoExecDeathTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class internal::NoExecDeathTest{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1103}}\par
}
{\xe \v internal::TestEventListenersAccessor\:testing::TestEventListeners}
{\xe \v testing::TestEventListeners\:internal::TestEventListenersAccessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class internal::TestEventListenersAccessor{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1104}}\par
}
{\xe \v internal::UnitTestImpl\:testing::TestEventListeners}
{\xe \v testing::TestEventListeners\:internal::UnitTestImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b internal::UnitTestImpl}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1105}}\par
}
{\xe \v TestCase\:testing::TestEventListeners}
{\xe \v testing::TestEventListeners\:TestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b TestCase}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1100}}\par
}
{\xe \v TestInfo\:testing::TestEventListeners}
{\xe \v testing::TestEventListeners\:TestInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b TestInfo}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1101}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::TestEventRepeater\par \pard\plain 
{\tc\tcl2 \v testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater}
{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::internal::TestEventRepeater:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtesting_1_1internal_1_1_test_event_repeater.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestEventRepeater} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~TestEventRepeater} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Append} ({\b TestEventListener} *listener)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestEventListener} * {\b Release} ({\b TestEventListener} *listener)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b forwarding_enabled} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_forwarding_enabled} (bool enable)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestProgramStart} (const {\b UnitTest} &unit_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestIterationStart} (const {\b UnitTest} &unit_test, int iteration)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsSetUpStart} (const {\b UnitTest} &unit_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsSetUpEnd} (const {\b UnitTest} &unit_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestCaseStart} (const {\b TestCase} &test_case)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestStart} (const {\b TestInfo} &test_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestPartResult} (const {\b TestPartResult} &result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestEnd} (const {\b TestInfo} &test_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestCaseEnd} (const {\b TestCase} &test_case)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsTearDownStart} (const {\b UnitTest} &unit_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEnvironmentsTearDownEnd} (const {\b UnitTest} &unit_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestIterationEnd} (const {\b UnitTest} &unit_test, int iteration)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestProgramEnd} (const {\b UnitTest} &unit_test)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3234}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v TestEventRepeater\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:TestEventRepeater}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::TestEventRepeater::TestEventRepeater (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3236}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03236 : forwarding_enabled_({\cf17 true}) \{\}\par
}
}
{\xe \v ~TestEventRepeater\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:~TestEventRepeater}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::TestEventRepeater::~TestEventRepeater (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3270}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03270                                       \{\par
03271   ForEach(listeners_, Delete<TestEventListener>);\par
03272 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::ForEach()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Append\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:Append}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::TestEventRepeater::Append ({\b TestEventListener} *  {\i listener})}}
\par
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3274}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03274                                                           \{\par
03275   listeners_.push_back(listener);\par
03276 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::TestEventListeners::Append()}.}\par
}
{\xe \v forwarding_enabled\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:forwarding_enabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::TestEventRepeater::forwarding_enabled () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3243}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03243 \{ {\cf19 return} forwarding_enabled_; \}\par
}
}
{\xe \v OnEnvironmentsSetUpEnd\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:OnEnvironmentsSetUpEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::TestEventRepeater::OnEnvironmentsSetUpEnd (const {\b UnitTest} &  {\i unit_test}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v OnEnvironmentsSetUpStart\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:OnEnvironmentsSetUpStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::TestEventRepeater::OnEnvironmentsSetUpStart (const {\b UnitTest} &  {\i unit_test}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v OnEnvironmentsTearDownEnd\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:OnEnvironmentsTearDownEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::TestEventRepeater::OnEnvironmentsTearDownEnd (const {\b UnitTest} &  {\i unit_test}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v OnEnvironmentsTearDownStart\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:OnEnvironmentsTearDownStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::TestEventRepeater::OnEnvironmentsTearDownStart (const {\b UnitTest} &  {\i unit_test}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v OnTestCaseEnd\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:OnTestCaseEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::TestEventRepeater::OnTestCaseEnd (const {\b TestCase} &  {\i test_case}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v OnTestCaseStart\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:OnTestCaseStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::TestEventRepeater::OnTestCaseStart (const {\b TestCase} &  {\i test_case}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v OnTestEnd\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:OnTestEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::TestEventRepeater::OnTestEnd (const {\b TestInfo} &  {\i test_info}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v OnTestIterationEnd\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:OnTestIterationEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::TestEventRepeater::OnTestIterationEnd (const {\b UnitTest} &  {\i unit_test}, int  {\i iteration}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3335}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03336                                                           \{\par
03337   {\cf19 if} (forwarding_enabled_) \{\par
03338     {\cf19 for} ({\cf18 int} i = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(listeners_.size()) - 1; i >= 0; i--) \{\par
03339       listeners_[i]->OnTestIterationEnd(unit_test, iteration);\par
03340     \}\par
03341   \}\par
03342 \}\par
}
}
{\xe \v OnTestIterationStart\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:OnTestIterationStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::TestEventRepeater::OnTestIterationStart (const {\b UnitTest} &  {\i unit_test}, int  {\i iteration}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3326}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03327                                                             \{\par
03328   {\cf19 if} (forwarding_enabled_) \{\par
03329     {\cf19 for} ({\cf18 size_t} i = 0; i < listeners_.size(); i++) \{\par
03330       listeners_[i]->OnTestIterationStart(unit_test, iteration);\par
03331     \}\par
03332   \}\par
03333 \}\par
}
}
{\xe \v OnTestPartResult\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:OnTestPartResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::TestEventRepeater::OnTestPartResult (const {\b TestPartResult} &  {\i result}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v OnTestProgramEnd\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:OnTestProgramEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::TestEventRepeater::OnTestProgramEnd (const {\b UnitTest} &  {\i unit_test}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v OnTestProgramStart\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:OnTestProgramStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::TestEventRepeater::OnTestProgramStart (const {\b UnitTest} &  {\i unit_test}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v OnTestStart\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:OnTestStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::internal::TestEventRepeater::OnTestStart (const {\b TestInfo} &  {\i test_info}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::TestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v Release\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:Release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestEventListener} * testing::internal::TestEventRepeater::Release ({\b TestEventListener} *  {\i listener})}}
\par
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3279}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03279                                                                          \{\par
03280   {\cf19 for} ({\cf18 size_t} i = 0; i < listeners_.size(); ++i) \{\par
03281     {\cf19 if} (listeners_[i] == listener) \{\par
03282       listeners_.erase(listeners_.begin() + i);\par
03283       {\cf19 return} listener;\par
03284     \}\par
03285   \}\par
03286 \par
03287   {\cf19 return} NULL;\par
03288 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::TestEventListeners::Release()}.}\par
}
{\xe \v set_forwarding_enabled\:testing::internal::TestEventRepeater}
{\xe \v testing::internal::TestEventRepeater\:set_forwarding_enabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::TestEventRepeater::set_forwarding_enabled (bool  {\i enable}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3244}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03244 \{ forwarding_enabled_ = enable; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::TestFactoryBase\par \pard\plain 
{\tc\tcl2 \v testing::internal::TestFactoryBase}
{\xe \v testing::internal::TestFactoryBase}
{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::internal::TestFactoryBase:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtesting_1_1internal_1_1_test_factory_base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~TestFactoryBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Test} * {\b CreateTest} ()=0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C7\'E0\'F9\'E8\'F9\'E5\'ED\'ED\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestFactoryBase} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 464}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v ~TestFactoryBase\:testing::internal::TestFactoryBase}
{\xe \v testing::internal::TestFactoryBase\:~TestFactoryBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual testing::internal::TestFactoryBase::~TestFactoryBase (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 466}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00466 \{\}\par
}
}
{\xe \v TestFactoryBase\:testing::internal::TestFactoryBase}
{\xe \v testing::internal::TestFactoryBase\:TestFactoryBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::TestFactoryBase::TestFactoryBase (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 473}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00473 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v CreateTest\:testing::internal::TestFactoryBase}
{\xe \v testing::internal::TestFactoryBase\:CreateTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b Test} * testing::internal::TestFactoryBase::CreateTest (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::TestFactoryImpl< TestClass >} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABUR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::TestFactoryImpl< TestClass >\par \pard\plain 
{\tc\tcl2 \v testing::internal::TestFactoryImpl< TestClass >}
{\xe \v testing::internal::TestFactoryImpl< TestClass >}
{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::internal::TestFactoryImpl< TestClass >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtesting_1_1internal_1_1_test_factory_impl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Test} * {\b CreateTest} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EF\'EE\'EB\'ED\'E8\'F2\'E5\'EB\'FC\'ED\'FB\'E5 \'F3\'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'ED\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class TestClass>\par
class testing::internal::TestFactoryImpl< TestClass >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 482}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v CreateTest\:testing::internal::TestFactoryImpl< TestClass >}
{\xe \v testing::internal::TestFactoryImpl< TestClass >\:CreateTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class TestClass > virtual {\b Test} * {\b testing::internal::TestFactoryImpl}< TestClass >::CreateTest (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2 {\b testing::internal::TestFactoryBase} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABUQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 484}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00484 \{ {\cf19 return} {\cf17 new} TestClass; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::TestInfo\par \pard\plain 
{\tc\tcl2 \v testing::TestInfo}
{\xe \v testing::TestInfo}
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
\par
{
{\f2 #include <gtest.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~TestInfo} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b test_case_name} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b name} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b type_param} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b value_param} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b file} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b line} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b should_run} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_reportable} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b TestResult} * {\b result} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'F0\'F3\'E7\'FC\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Test}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestCase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::UnitTestImpl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::StreamingListenerTest}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestInfo} * {\b internal::MakeAndRegisterTestInfo} (const char *{\b test_case_name}, const char *{\b name}, const char *{\b type_param}, const char *{\b value_param}, {\b internal::CodeLocation} code_location, {\b internal::TypeId} fixture_class_id, {\b Test::SetUpTestCaseFunc} set_up_tc, {\b Test::TearDownTestCaseFunc} tear_down_tc, {\b internal::TestFactoryBase} *factory)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 644}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v ~TestInfo\:testing::TestInfo}
{\xe \v testing::TestInfo\:~TestInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::TestInfo::~TestInfo ()}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2518}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02518 \{ {\cf17 delete} factory_; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v file\:testing::TestInfo}
{\xe \v testing::TestInfo\:file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::TestInfo::file () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 673}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00673 \{ {\cf19 return} location_.file.c_str(); \}\par
}
}
{\xe \v is_reportable\:testing::TestInfo}
{\xe \v testing::TestInfo\:is_reportable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::TestInfo::is_reportable () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 697}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00697                              \{\par
00698     {\cf20 // For now, the XML report includes all tests matching the filter.}\par
00699     {\cf20 // In the future, we may trim tests that are excluded because of}\par
00700     {\cf20 // sharding.}\par
00701     {\cf19 return} matches_filter_;\par
00702   \}\par
}
}
{\xe \v line\:testing::TestInfo}
{\xe \v testing::TestInfo\:line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::TestInfo::line () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 676}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00676 \{ {\cf19 return} location_.line; \}\par
}
}
{\xe \v name\:testing::TestInfo}
{\xe \v testing::TestInfo\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::TestInfo::name () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 654}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00654 \{ {\cf19 return} name_.c_str(); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::FilterTests()}, {\b testing::internal::UnitTestImpl::ListTestsMatchingFilter()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestEnd()} \'E8 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestStart()}.}\par
}
{\xe \v result\:testing::TestInfo}
{\xe \v testing::TestInfo\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestResult} * testing::TestInfo::result () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 705}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00705 \{ {\cf19 return} &result_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestEnd()}.}\par
}
{\xe \v should_run\:testing::TestInfo}
{\xe \v testing::TestInfo\:should_run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::TestInfo::should_run () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 694}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00694 \{ {\cf19 return} should_run_; \}\par
}
}
{\xe \v test_case_name\:testing::TestInfo}
{\xe \v testing::TestInfo\:test_case_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::TestInfo::test_case_name () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 651}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00651 \{ {\cf19 return} test_case_name_.c_str(); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::AddTestInfo()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestEnd()} \'E8 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestStart()}.}\par
}
{\xe \v type_param\:testing::TestInfo}
{\xe \v testing::TestInfo\:type_param}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::TestInfo::type_param () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 658}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00658                                  \{\par
00659     {\cf19 if} (type_param_.get() != NULL)\par
00660       {\cf19 return} type_param_->c_str();\par
00661     {\cf19 return} NULL;\par
00662   \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::AddTestInfo()} \'E8 {\b testing::internal::PrintFullTestCommentIfPresent()}.}\par
}
{\xe \v value_param\:testing::TestInfo}
{\xe \v testing::TestInfo\:value_param}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::TestInfo::value_param () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 666}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00666                                   \{\par
00667     {\cf19 if} (value_param_.get() != NULL)\par
00668       {\cf19 return} value_param_->c_str();\par
00669     {\cf19 return} NULL;\par
00670   \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::ListTestsMatchingFilter()} \'E8 {\b testing::internal::PrintFullTestCommentIfPresent()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FF \'EF\'EE \'E4\'F0\'F3\'E7\'FC\'FF\'EC \'EA\'EB\'E0\'F1\'F1\'E0 \'E8 \'F4\'F3\'ED\'EA\'F6\'E8\'FF\'EC, \'EE\'F2\'ED\'EE\'F1\'FF\'F9\'E8\'EC\'F1\'FF \'EA \'EA\'EB\'E0\'F1\'F1\'F3\par
\pard\plain 
{\xe \v internal::MakeAndRegisterTestInfo\:testing::TestInfo}
{\xe \v testing::TestInfo\:internal::MakeAndRegisterTestInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestInfo} * {\b internal::MakeAndRegisterTestInfo} (const char *  {\i test_case_name}, const char *  {\i name}, const char *  {\i type_param}, const char *  {\i value_param}, {\b internal::CodeLocation}  {\i code_location}, {\b internal::TypeId}  {\i fixture_class_id}, {\b Test::SetUpTestCaseFunc}  {\i set_up_tc}, {\b Test::TearDownTestCaseFunc}  {\i tear_down_tc}, {\b internal::TestFactoryBase} *  {\i factory}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v internal::StreamingListenerTest\:testing::TestInfo}
{\xe \v testing::TestInfo\:internal::StreamingListenerTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class internal::StreamingListenerTest{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 714}}\par
}
{\xe \v internal::UnitTestImpl\:testing::TestInfo}
{\xe \v testing::TestInfo\:internal::UnitTestImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b internal::UnitTestImpl}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 713}}\par
}
{\xe \v Test\:testing::TestInfo}
{\xe \v testing::TestInfo\:Test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b Test}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 711}}\par
}
{\xe \v TestCase\:testing::TestInfo}
{\xe \v testing::TestInfo\:TestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b TestCase}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 712}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::TestPartResult\par \pard\plain 
{\tc\tcl2 \v testing::TestPartResult}
{\xe \v testing::TestPartResult}
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
\par
{
{\f2 #include <gtest-test-part.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Type} \{ {\b kSuccess}
, {\b kNonFatalFailure}
, {\b kFatalFailure}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestPartResult} ({\b Type} a_type, const char *a_file_name, int a_line_number, const char *a_message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Type} {\b type} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b file_name} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b line_number} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b summary} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b message} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b passed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b failed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b nonfatally_failed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b fatally_failed} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 47}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 
{\xe \v Type\:testing::TestPartResult}
{\xe \v testing::TestPartResult\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b testing::TestPartResult::Type}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'DD\'EB\'E5\'EC\'E5\'ED\'F2\'FB \'EF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'E9:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v kSuccess\:testing::TestPartResult}
{\xe \v testing::TestPartResult\:kSuccess}
{\qr kSuccess{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
\cell }{\cell }{\row }
{\xe \v kNonFatalFailure\:testing::TestPartResult}
{\xe \v testing::TestPartResult\:kNonFatalFailure}
{\qr kNonFatalFailure{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
\cell }{\cell }{\row }
{\xe \v kFatalFailure\:testing::TestPartResult}
{\xe \v testing::TestPartResult\:kFatalFailure}
{\qr kFatalFailure{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
\cell }{\cell }{\row }
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 51}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00051             \{\par
00052     kSuccess,          {\cf20 // Succeeded.}\par
00053     kNonFatalFailure,  {\cf20 // Failed but the test can continue.}\par
00054     kFatalFailure      {\cf20 // Failed and the test should be terminated.}\par
00055   \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v TestPartResult\:testing::TestPartResult}
{\xe \v testing::TestPartResult\:TestPartResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::TestPartResult::TestPartResult ({\b Type}  {\i a_type}, const char *  {\i a_file_name}, int  {\i a_line_number}, const char *  {\i a_message}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 60}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00064       : type_(a_type),\par
00065         file_name_(a_file_name == NULL ? {\cf22 ""} : a_file_name),\par
00066         line_number_(a_line_number),\par
00067         summary_(ExtractSummary(a_message)),\par
00068         message_(a_message) \{\par
00069   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v failed\:testing::TestPartResult}
{\xe \v testing::TestPartResult\:failed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::TestPartResult::failed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 94}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00094 \{ {\cf19 return} type_ != kSuccess; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::TestResult::Failed()}.}\par
}
{\xe \v fatally_failed\:testing::TestPartResult}
{\xe \v testing::TestPartResult\:fatally_failed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::TestPartResult::fatally_failed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 100}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00100 \{ {\cf19 return} type_ == kFatalFailure; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::HasNewFatalFailureHelper::ReportTestPartResult()}.}\par
}
{\xe \v file_name\:testing::TestPartResult}
{\xe \v testing::TestPartResult\:file_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::TestPartResult::file_name () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 76}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00076                                 \{\par
00077     {\cf19 return} file_name_.empty() ? NULL : file_name_.c_str();\par
00078   \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::operator<<()}.}\par
}
{\xe \v line_number\:testing::TestPartResult}
{\xe \v testing::TestPartResult\:line_number}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::TestPartResult::line_number () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 82}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00082 \{ {\cf19 return} line_number_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::operator<<()}.}\par
}
{\xe \v message\:testing::TestPartResult}
{\xe \v testing::TestPartResult\:message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::TestPartResult::message () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 88}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00088 \{ {\cf19 return} message_.c_str(); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::HasOneFailure()} \'E8 {\b testing::operator<<()}.}\par
}
{\xe \v nonfatally_failed\:testing::TestPartResult}
{\xe \v testing::TestPartResult\:nonfatally_failed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::TestPartResult::nonfatally_failed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 97}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00097 \{ {\cf19 return} type_ == kNonFatalFailure; \}\par
}
}
{\xe \v passed\:testing::TestPartResult}
{\xe \v testing::TestPartResult\:passed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::TestPartResult::passed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 91}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00091 \{ {\cf19 return} type_ == kSuccess; \}\par
}
}
{\xe \v summary\:testing::TestPartResult}
{\xe \v testing::TestPartResult\:summary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::TestPartResult::summary () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 85}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00085 \{ {\cf19 return} summary_.c_str(); \}\par
}
}
{\xe \v type\:testing::TestPartResult}
{\xe \v testing::TestPartResult\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Type} testing::TestPartResult::type () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 72}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00072 \{ {\cf19 return} type_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::HasOneFailure()}, {\b testing::internal::PrettyUnitTestResultPrinter::OnTestPartResult()} \'E8 {\b testing::operator<<()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-test-part.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-test-part.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::TestPartResultArray\par \pard\plain 
{\tc\tcl2 \v testing::TestPartResultArray}
{\xe \v testing::TestPartResultArray}
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
\par
{
{\f2 #include <gtest-test-part.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestPartResultArray} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Append} (const {\b TestPartResult} &result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b TestPartResult} & {\b GetTestPartResult} (int index) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b size} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 126}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v TestPartResultArray\:testing::TestPartResultArray}
{\xe \v testing::TestPartResultArray\:TestPartResultArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::TestPartResultArray::TestPartResultArray (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 128}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00128 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Append\:testing::TestPartResultArray}
{\xe \v testing::TestPartResultArray\:Append}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::TestPartResultArray::Append (const {\b TestPartResult} &  {\i result})}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 68}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00068                                                              \{\par
00069   array_.push_back(result);\par
00070 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::ScopedFakeTestPartResultReporter::ReportTestPartResult()}.}\par
}
{\xe \v GetTestPartResult\:testing::TestPartResultArray}
{\xe \v testing::TestPartResultArray\:GetTestPartResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestPartResult} & testing::TestPartResultArray::GetTestPartResult (int  {\i index}) const}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 73}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00073                                                                             \{\par
00074   {\cf19 if} (index < 0 || index >= size()) \{\par
00075     printf({\cf22 "\\nInvalid index (%d) into TestPartResultArray.\\n"}, index);\par
00076     internal::posix::Abort();\par
00077   \}\par
00078 \par
00079   {\cf19 return} array_[index];\par
00080 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::posix::Abort()} \'E8 {\b size()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::HasOneFailure()}.}\par
}
{\xe \v size\:testing::TestPartResultArray}
{\xe \v testing::TestPartResultArray\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::TestPartResultArray::size () const}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 83}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00083                                     \{\par
00084   {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(array_.size());\par
00085 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b GetTestPartResult()} \'E8 {\b testing::internal::HasOneFailure()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-test-part.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-test-part.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::TestPartResultReporterInterface\par \pard\plain 
{\tc\tcl2 \v testing::TestPartResultReporterInterface}
{\xe \v testing::TestPartResultReporterInterface}
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
\par
{
{\f2 #include <gtest-test-part.h>}}\par
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::TestPartResultReporterInterface:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtesting_1_1_test_part_result_reporter_interface.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~TestPartResultReporterInterface} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ReportTestPartResult} (const {\b TestPartResult} &result)=0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 146}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v ~TestPartResultReporterInterface\:testing::TestPartResultReporterInterface}
{\xe \v testing::TestPartResultReporterInterface\:~TestPartResultReporterInterface}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual testing::TestPartResultReporterInterface::~TestPartResultReporterInterface (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 148}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00148 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v ReportTestPartResult\:testing::TestPartResultReporterInterface}
{\xe \v testing::TestPartResultReporterInterface\:ReportTestPartResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void testing::TestPartResultReporterInterface::ReportTestPartResult (const {\b TestPartResult} &  {\i result}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'C7\'E0\'EC\'E5\'F9\'E0\'E5\'F2\'F1\'FF \'E2 {\b testing::ScopedFakeTestPartResultReporter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::HasNewFatalFailureHelper} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b testing::internal::DefaultGlobalTestPartResultReporter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAK \\*MERGEFORMAT}{\fldrslt pagenum}}}) \'E8 {\b testing::internal::DefaultPerThreadTestPartResultReporter} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::HasNewFatalFailureHelper::ReportTestPartResult()} \'E8 {\b testing::internal::DefaultPerThreadTestPartResultReporter::ReportTestPartResult()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-test-part.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::TestProperty\par \pard\plain 
{\tc\tcl2 \v testing::TestProperty}
{\xe \v testing::TestProperty}
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
\par
{
{\f2 #include <gtest.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestProperty} (const std::string &a_key, const std::string &a_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b key} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b value} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetValue} (const std::string &new_value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 486}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v TestProperty\:testing::TestProperty}
{\xe \v testing::TestProperty\:TestProperty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::TestProperty::TestProperty (const std::string &  {\i a_key}, const std::string &  {\i a_value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 491}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00491                                                                  :\par
00492     key_(a_key), value_(a_value) \{\par
00493   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v key\:testing::TestProperty}
{\xe \v testing::TestProperty\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::TestProperty::key () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 496}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00496                           \{\par
00497     {\cf19 return} key_.c_str();\par
00498   \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::TestPropertyKeyIs::operator()()}.}\par
}
{\xe \v SetValue\:testing::TestProperty}
{\xe \v testing::TestProperty\:SetValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::TestProperty::SetValue (const std::string &  {\i new_value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 506}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00506                                             \{\par
00507     value_ = new_value;\par
00508   \}\par
}
}
{\xe \v value\:testing::TestProperty}
{\xe \v testing::TestProperty\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::TestProperty::value () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 501}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00501                             \{\par
00502     {\cf19 return} value_.c_str();\par
00503   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::TestPropertyKeyIs\par \pard\plain 
{\tc\tcl2 \v testing::internal::TestPropertyKeyIs}
{\xe \v testing::internal::TestPropertyKeyIs}
{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
\par
{
{\f2 #include <gtest-internal-inl.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestPropertyKeyIs} (const std::string &key)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator()} (const {\b TestProperty} &test_property) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 347}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v TestPropertyKeyIs\:testing::internal::TestPropertyKeyIs}
{\xe \v testing::internal::TestPropertyKeyIs\:TestPropertyKeyIs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::TestPropertyKeyIs::TestPropertyKeyIs (const std::string &  {\i key}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 352}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00352 : key_(key) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v operator()\:testing::internal::TestPropertyKeyIs}
{\xe \v testing::internal::TestPropertyKeyIs\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::TestPropertyKeyIs::operator() (const {\b TestProperty} &  {\i test_property}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 355}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00355                                                            \{\par
00356     {\cf19 return} test_property.key() == key_;\par
00357   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestProperty::key()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-internal-inl.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::TestResult\par \pard\plain 
{\tc\tcl2 \v testing::TestResult}
{\xe \v testing::TestResult}
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
\par
{
{\f2 #include <gtest.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestResult} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~TestResult} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b total_part_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b test_property_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Passed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Failed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b HasFatalFailure} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b HasNonfatalFailure} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TimeInMillis} {\b elapsed_time} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b TestPartResult} & {\b GetTestPartResult} (int i) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b TestProperty} & {\b GetTestProperty} (int i) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'F0\'F3\'E7\'FC\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestCase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UnitTest}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::DefaultGlobalTestPartResultReporter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::ExecDeathTest}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::TestResultAccessor}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::UnitTestImpl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::WindowsDeathTest}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 523}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v TestResult\:testing::TestResult}
{\xe \v testing::TestResult\:TestResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::TestResult::TestResult ()}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2014}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02015     : death_test_count_(0),\par
02016       elapsed_time_(0) \{\par
02017 \}\par
}
}
{\xe \v ~TestResult\:testing::TestResult}
{\xe \v testing::TestResult\:~TestResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::TestResult::~TestResult ()}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2020}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02020                         \{\par
02021 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v elapsed_time\:testing::TestResult}
{\xe \v testing::TestResult\:elapsed_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TimeInMillis} testing::TestResult::elapsed_time () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 551}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00551 \{ {\cf19 return} elapsed_time_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestEnd()}.}\par
}
{\xe \v Failed\:testing::TestResult}
{\xe \v testing::TestResult\:Failed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::TestResult::Failed () const}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2167}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02167                               \{\par
02168   {\cf19 for} ({\cf18 int} i = 0; i < total_part_count(); ++i) \{\par
02169     {\cf19 if} (GetTestPartResult(i).failed())\par
02170       {\cf19 return} {\cf17 true};\par
02171   \}\par
02172   {\cf19 return} {\cf17 false};\par
02173 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestPartResult::failed()}, {\b GetTestPartResult()} \'E8 {\b total_part_count()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestEnd()}.}\par
}
{\xe \v GetTestPartResult\:testing::TestResult}
{\xe \v testing::TestResult\:GetTestPartResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestPartResult} & testing::TestResult::GetTestPartResult (int  {\i i}) const}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2026}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02026                                                                \{\par
02027   {\cf19 if} (i < 0 || i >= total_part_count())\par
02028     internal::posix::Abort();\par
02029   {\cf19 return} test_part_results_.at(i);\par
02030 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::posix::Abort()} \'E8 {\b total_part_count()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b Failed()}.}\par
}
{\xe \v GetTestProperty\:testing::TestResult}
{\xe \v testing::TestResult\:GetTestProperty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestProperty} & testing::TestResult::GetTestProperty (int  {\i i}) const}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2035}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02035                                                            \{\par
02036   {\cf19 if} (i < 0 || i >= test_property_count())\par
02037     internal::posix::Abort();\par
02038   {\cf19 return} test_properties_.at(i);\par
02039 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::posix::Abort()} \'E8 {\b test_property_count()}.}\par
}
{\xe \v HasFatalFailure\:testing::TestResult}
{\xe \v testing::TestResult\:HasFatalFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::TestResult::HasFatalFailure () const}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2181}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02181                                        \{\par
02182   {\cf19 return} CountIf(test_part_results_, TestPartFatallyFailed) > 0;\par
02183 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CountIf()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::Test::HasFatalFailure()}.}\par
}
{\xe \v HasNonfatalFailure\:testing::TestResult}
{\xe \v testing::TestResult\:HasNonfatalFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::TestResult::HasNonfatalFailure () const}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2191}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02191                                           \{\par
02192   {\cf19 return} CountIf(test_part_results_, TestPartNonfatallyFailed) > 0;\par
02193 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CountIf()}.}\par
}
{\xe \v Passed\:testing::TestResult}
{\xe \v testing::TestResult\:Passed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::TestResult::Passed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 539}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00539 \{ {\cf19 return} !Failed(); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestEnd()}.}\par
}
{\xe \v test_property_count\:testing::TestResult}
{\xe \v testing::TestResult\:test_property_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::TestResult::test_property_count () const}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2202}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02202                                           \{\par
02203   {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(test_properties_.size());\par
02204 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b GetTestProperty()}.}\par
}
{\xe \v total_part_count\:testing::TestResult}
{\xe \v testing::TestResult\:total_part_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::TestResult::total_part_count () const}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2197}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02197                                        \{\par
02198   {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(test_part_results_.size());\par
02199 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b Failed()} \'E8 {\b GetTestPartResult()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FF \'EF\'EE \'E4\'F0\'F3\'E7\'FC\'FF\'EC \'EA\'EB\'E0\'F1\'F1\'E0 \'E8 \'F4\'F3\'ED\'EA\'F6\'E8\'FF\'EC, \'EE\'F2\'ED\'EE\'F1\'FF\'F9\'E8\'EC\'F1\'FF \'EA \'EA\'EB\'E0\'F1\'F1\'F3\par
\pard\plain 
{\xe \v internal::DefaultGlobalTestPartResultReporter\:testing::TestResult}
{\xe \v testing::TestResult\:internal::DefaultGlobalTestPartResultReporter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b internal::DefaultGlobalTestPartResultReporter}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 567}}\par
}
{\xe \v internal::ExecDeathTest\:testing::TestResult}
{\xe \v testing::TestResult\:internal::ExecDeathTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class internal::ExecDeathTest{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 568}}\par
}
{\xe \v internal::TestResultAccessor\:testing::TestResult}
{\xe \v testing::TestResult\:internal::TestResultAccessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b internal::TestResultAccessor}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 569}}\par
}
{\xe \v internal::UnitTestImpl\:testing::TestResult}
{\xe \v testing::TestResult\:internal::UnitTestImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b internal::UnitTestImpl}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 570}}\par
}
{\xe \v internal::WindowsDeathTest\:testing::TestResult}
{\xe \v testing::TestResult\:internal::WindowsDeathTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class internal::WindowsDeathTest{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 571}}\par
}
{\xe \v TestCase\:testing::TestResult}
{\xe \v testing::TestResult\:TestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b TestCase}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 565}}\par
}
{\xe \v TestInfo\:testing::TestResult}
{\xe \v testing::TestResult\:TestInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b TestInfo}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 564}}\par
}
{\xe \v UnitTest\:testing::TestResult}
{\xe \v testing::TestResult\:UnitTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b UnitTest}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 566}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::TestResultAccessor\par \pard\plain 
{\tc\tcl2 \v testing::internal::TestResultAccessor}
{\xe \v testing::internal::TestResultAccessor}
{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
\par
{
{\f2 #include <gtest-internal-inl.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b RecordProperty} ({\b TestResult} *test_result, const std::string &xml_element, const {\b TestProperty} &property)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ClearTestPartResults} ({\b TestResult} *test_result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const std::vector< {\b testing::TestPartResult} > & {\b test_part_results} (const {\b TestResult} &test_result)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1014}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v ClearTestPartResults\:testing::internal::TestResultAccessor}
{\xe \v testing::internal::TestResultAccessor\:ClearTestPartResults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void testing::internal::TestResultAccessor::ClearTestPartResults ({\b TestResult} *  {\i test_result}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1022}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01022                                                             \{\par
01023     test_result->ClearTestPartResults();\par
01024   \}\par
}
}
{\xe \v RecordProperty\:testing::internal::TestResultAccessor}
{\xe \v testing::internal::TestResultAccessor\:RecordProperty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void testing::internal::TestResultAccessor::RecordProperty ({\b TestResult} *  {\i test_result}, const std::string &  {\i xml_element}, const {\b TestProperty} &  {\i property}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1016}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01018                                                            \{\par
01019     test_result->RecordProperty(xml_element, property);\par
01020   \}\par
}
}
{\xe \v test_part_results\:testing::internal::TestResultAccessor}
{\xe \v testing::internal::TestResultAccessor\:test_part_results}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const std::vector< {\b testing::TestPartResult} > & testing::internal::TestResultAccessor::test_part_results (const {\b TestResult} &  {\i test_result}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1026}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01027                                      \{\par
01028     {\cf19 return} test_result.test_part_results();\par
01029   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-internal-inl.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::ThreadLocal< T >\par \pard\plain 
{\tc\tcl2 \v testing::internal::ThreadLocal< T >}
{\xe \v testing::internal::ThreadLocal< T >}
{\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
\par
{
{\f2 #include <gtest-port.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ThreadLocal} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ThreadLocal} (const T &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b pointer} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T * {\b pointer} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T & {\b get} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (const T &value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class testing::internal::ThreadLocal< T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2194}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v ThreadLocal\:testing::internal::ThreadLocal< T >}
{\xe \v testing::internal::ThreadLocal< T >\:ThreadLocal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b testing::internal::ThreadLocal}< T >::ThreadLocal (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2196}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02196 : value_() \{\}\par
}
}
{\xe \v ThreadLocal\:testing::internal::ThreadLocal< T >}
{\xe \v testing::internal::ThreadLocal< T >\:ThreadLocal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b testing::internal::ThreadLocal}< T >::ThreadLocal (const T &  {\i value}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2197}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02197 : value_(value) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v get\:testing::internal::ThreadLocal< T >}
{\xe \v testing::internal::ThreadLocal< T >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > const T & {\b testing::internal::ThreadLocal}< T >::get () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2200}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02200 \{ {\cf19 return} value_; \}\par
}
}
{\xe \v pointer\:testing::internal::ThreadLocal< T >}
{\xe \v testing::internal::ThreadLocal< T >\:pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T * {\b testing::internal::ThreadLocal}< T >::pointer (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2198}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02198 \{ {\cf19 return} &value_; \}\par
}
}
{\xe \v pointer\:testing::internal::ThreadLocal< T >}
{\xe \v testing::internal::ThreadLocal< T >\:pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > const T * {\b testing::internal::ThreadLocal}< T >::pointer () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2199}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02199 \{ {\cf19 return} &value_; \}\par
}
}
{\xe \v set\:testing::internal::ThreadLocal< T >}
{\xe \v testing::internal::ThreadLocal< T >\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void {\b testing::internal::ThreadLocal}< T >::set (const T &  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2201}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02201 \{ value_ = value; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'E0 testing::internal::TraceInfo\par \pard\plain 
{\tc\tcl2 \v testing::internal::TraceInfo}
{\xe \v testing::internal::TraceInfo}
{\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
\par
{
{\f2 #include <gtest-internal-inl.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b file}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b line}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b message}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 457}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v file\:testing::internal::TraceInfo}
{\xe \v testing::internal::TraceInfo\:file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* testing::internal::TraceInfo::file}}
\par
{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 458}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::ScopedTrace::ScopedTrace()}.}\par
}
{\xe \v line\:testing::internal::TraceInfo}
{\xe \v testing::internal::TraceInfo\:line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::TraceInfo::line}}
\par
{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 459}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::ScopedTrace::ScopedTrace()}.}\par
}
{\xe \v message\:testing::internal::TraceInfo}
{\xe \v testing::internal::TraceInfo\:message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::TraceInfo::message}}
\par
{\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 460}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::ScopedTrace::ScopedTrace()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-internal-inl.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 std::tr1::tuple<>\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>}
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b tuple} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b tuple} ({\b GTEST_BY_REF_}(T0) f0, {\b GTEST_BY_REF_}(T1) {\b f1}, {\b GTEST_BY_REF_}(T2) {\b f2}, {\b GTEST_BY_REF_}(T3) {\b f3}, {\b GTEST_BY_REF_}(T4) {\b f4}, {\b GTEST_BY_REF_}(T5) {\b f5}, {\b GTEST_BY_REF_}(T6) {\b f6}, {\b GTEST_BY_REF_}(T7) {\b f7}, {\b GTEST_BY_REF_}(T8) {\b f8}, {\b GTEST_BY_REF_}(T9) {\b f9})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b tuple} (const {\b tuple} &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(U) > {\b tuple} (const {\b GTEST_10_TUPLE_}(U)&t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b tuple} & {\b operator=} (const {\b tuple} &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(U) > {\b tuple} & {\b operator=} (const {\b GTEST_10_TUPLE_}(U)&t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(U) > {\b GTEST_DECLARE_TUPLE_AS_FRIEND_} {\b tuple} & {\b CopyFrom} (const {\b GTEST_10_TUPLE_}(U)&t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T0 {\b f0_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T1 {\b f1_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T2 {\b f2_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T3 {\b f3_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T4 {\b f4_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T5 {\b f5_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T6 {\b f6_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T7 {\b f7_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T8 {\b f8_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T9 {\b f9_}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'F0\'F3\'E7\'FC\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<int k> class {\b gtest_internal::Get}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T)>\par
class std::tr1::tuple<>\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 612}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v tuple\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:tuple}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > {\b std::tr1::tuple}<>::tuple (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 616}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00616           : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_(), f7_(), f8_(),\par
00617       f9_() \{\}\par
}
}
{\xe \v tuple\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:tuple}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > {\b std::tr1::tuple}<>::tuple ({\b GTEST_BY_REF_}(T0)  {\i f0}, {\b GTEST_BY_REF_}(T1)  {\i f1}, {\b GTEST_BY_REF_}(T2)  {\i f2}, {\b GTEST_BY_REF_}(T3)  {\i f3}, {\b GTEST_BY_REF_}(T4)  {\i f4}, {\b GTEST_BY_REF_}(T5)  {\i f5}, {\b GTEST_BY_REF_}(T6)  {\i f6}, {\b GTEST_BY_REF_}(T7)  {\i f7}, {\b GTEST_BY_REF_}(T8)  {\i f8}, {\b GTEST_BY_REF_}(T9)  {\i f9}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 619}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00622                                                   : f0_(f0), f1_(f1), f2_(f2),\par
00623       f3_(f3), f4_(f4), f5_(f5), f6_(f6), f7_(f7), f8_(f8), f9_(f9) \{\}\par
}
}
{\xe \v tuple\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:tuple}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > {\b std::tr1::tuple}<>::tuple (const {\b tuple}<> &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 625}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00625                         : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),\par
00626       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_), f9_(t.f9_) \{\}\par
}
}
{\xe \v tuple\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:tuple}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > template<{\b GTEST_10_TYPENAMES_}(U) > {\b std::tr1::tuple}<>::tuple (const {\b GTEST_10_TUPLE_}(U)&  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 629}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00629                                      : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),\par
00630       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_),\par
00631       f9_(t.f9_) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v CopyFrom\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:CopyFrom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > template<{\b GTEST_10_TYPENAMES_}(U) > {\b GTEST_DECLARE_TUPLE_AS_FRIEND_} {\b tuple} & {\b std::tr1::tuple}<>::CopyFrom (const {\b GTEST_10_TUPLE_}(U)&  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 643}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00643                                                \{\par
00644     f0_ = t.f0_;\par
00645     f1_ = t.f1_;\par
00646     f2_ = t.f2_;\par
00647     f3_ = t.f3_;\par
00648     f4_ = t.f4_;\par
00649     f5_ = t.f5_;\par
00650     f6_ = t.f6_;\par
00651     f7_ = t.f7_;\par
00652     f8_ = t.f8_;\par
00653     f9_ = t.f9_;\par
00654     {\cf19 return} *{\cf17 this};\par
00655   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b std::tr1::tuple<>::f0_}.}\par
}
{\xe \v operator=\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > template<{\b GTEST_10_TYPENAMES_}(U) > {\b tuple} & {\b std::tr1::tuple}<>::operator= (const {\b GTEST_10_TUPLE_}(U)&  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 636}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00636                                                 \{\par
00637     {\cf19 return} CopyFrom(t);\par
00638   \}\par
}
}
{\xe \v operator=\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > {\b tuple} & {\b std::tr1::tuple}<>::operator= (const {\b tuple}<> &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 633}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00633 \{ {\cf19 return} CopyFrom(t); \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FF \'EF\'EE \'E4\'F0\'F3\'E7\'FC\'FF\'EC \'EA\'EB\'E0\'F1\'F1\'E0 \'E8 \'F4\'F3\'ED\'EA\'F6\'E8\'FF\'EC, \'EE\'F2\'ED\'EE\'F1\'FF\'F9\'E8\'EC\'F1\'FF \'EA \'EA\'EB\'E0\'F1\'F1\'F3\par
\pard\plain 
{\xe \v gtest_internal::Get\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:gtest_internal::Get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > template<int k> friend class {\b gtest_internal::Get}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 614}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v f0_\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:f0_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > T0 {\b std::tr1::tuple}<>::f0_}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 657}}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b std::tr1::tuple<>::CopyFrom()}.}\par
}
{\xe \v f1_\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:f1_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > T1 {\b std::tr1::tuple}<>::f1_}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 658}}\par
}
{\xe \v f2_\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:f2_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > T2 {\b std::tr1::tuple}<>::f2_}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 659}}\par
}
{\xe \v f3_\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:f3_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > T3 {\b std::tr1::tuple}<>::f3_}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 660}}\par
}
{\xe \v f4_\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:f4_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > T4 {\b std::tr1::tuple}<>::f4_}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 661}}\par
}
{\xe \v f5_\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:f5_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > T5 {\b std::tr1::tuple}<>::f5_}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 662}}\par
}
{\xe \v f6_\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:f6_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > T6 {\b std::tr1::tuple}<>::f6_}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 663}}\par
}
{\xe \v f7_\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:f7_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > T7 {\b std::tr1::tuple}<>::f7_}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 664}}\par
}
{\xe \v f8_\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:f8_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > T8 {\b std::tr1::tuple}<>::f8_}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 665}}\par
}
{\xe \v f9_\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:f9_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > T9 {\b std::tr1::tuple}<>::f9_}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 666}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 std::tr1::tuple<>\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>}
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b tuple} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b tuple} (const {\b tuple} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b tuple} & {\b operator=} (const {\b tuple} &)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 205}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v tuple\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:tuple}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::tr1::tuple}<>::tuple (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 207}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00207 \{\}\par
}
}
{\xe \v tuple\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:tuple}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::tr1::tuple}<>::tuple (const {\b tuple}<> & ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 208}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00208 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v operator=\:std::tr1::tuple<>}
{\xe \v std::tr1::tuple<>\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b tuple} & {\b std::tr1::tuple}<>::operator= (const {\b tuple}<> & ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 209}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00209 \{ {\cf19 return} *{\cf17 this}; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::tuple_element< k, Tuple >\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple_element< k, Tuple >}
{\xe \v std::tr1::tuple_element< k, Tuple >}
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<int k, class Tuple>\par
struct std::tr1::tuple_element< k, Tuple >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 796}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::tuple_size< Tuple >\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple_size< Tuple >}
{\xe \v std::tr1::tuple_size< Tuple >}
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Tuple>\par
struct std::tr1::tuple_size< Tuple >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 738}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::tuple_size< GTEST_0_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple_size< GTEST_0_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_0_TUPLE_(T) >}
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b value} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_0_TYPENAMES_}(T)>\par
struct std::tr1::tuple_size< GTEST_0_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 741}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v value\:std::tr1::tuple_size< GTEST_0_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_0_TUPLE_(T) >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_0_TYPENAMES_}(T) > const int {\b std::tr1::tuple_size}< {\b GTEST_0_TUPLE_}(T) >::value = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 742}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::tuple_size< GTEST_10_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple_size< GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_10_TUPLE_(T) >}
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b value} = 10\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T)>\par
struct std::tr1::tuple_size< GTEST_10_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 791}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v value\:std::tr1::tuple_size< GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_10_TUPLE_(T) >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > const int {\b std::tr1::tuple_size}< {\b GTEST_10_TUPLE_}(T) >::value = 10{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 792}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::tuple_size< GTEST_1_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple_size< GTEST_1_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_1_TUPLE_(T) >}
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b value} = 1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_1_TYPENAMES_}(T)>\par
struct std::tr1::tuple_size< GTEST_1_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 746}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v value\:std::tr1::tuple_size< GTEST_1_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_1_TUPLE_(T) >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_1_TYPENAMES_}(T) > const int {\b std::tr1::tuple_size}< {\b GTEST_1_TUPLE_}(T) >::value = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 747}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::tuple_size< GTEST_2_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple_size< GTEST_2_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_2_TUPLE_(T) >}
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b value} = 2\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_2_TYPENAMES_}(T)>\par
struct std::tr1::tuple_size< GTEST_2_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 751}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v value\:std::tr1::tuple_size< GTEST_2_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_2_TUPLE_(T) >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_2_TYPENAMES_}(T) > const int {\b std::tr1::tuple_size}< {\b GTEST_2_TUPLE_}(T) >::value = 2{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 752}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::tuple_size< GTEST_3_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple_size< GTEST_3_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_3_TUPLE_(T) >}
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b value} = 3\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_3_TYPENAMES_}(T)>\par
struct std::tr1::tuple_size< GTEST_3_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 756}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v value\:std::tr1::tuple_size< GTEST_3_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_3_TUPLE_(T) >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_3_TYPENAMES_}(T) > const int {\b std::tr1::tuple_size}< {\b GTEST_3_TUPLE_}(T) >::value = 3{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 757}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::tuple_size< GTEST_4_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple_size< GTEST_4_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_4_TUPLE_(T) >}
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b value} = 4\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_4_TYPENAMES_}(T)>\par
struct std::tr1::tuple_size< GTEST_4_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 761}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v value\:std::tr1::tuple_size< GTEST_4_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_4_TUPLE_(T) >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_4_TYPENAMES_}(T) > const int {\b std::tr1::tuple_size}< {\b GTEST_4_TUPLE_}(T) >::value = 4{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 762}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::tuple_size< GTEST_5_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple_size< GTEST_5_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_5_TUPLE_(T) >}
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b value} = 5\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_5_TYPENAMES_}(T)>\par
struct std::tr1::tuple_size< GTEST_5_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 766}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v value\:std::tr1::tuple_size< GTEST_5_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_5_TUPLE_(T) >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_5_TYPENAMES_}(T) > const int {\b std::tr1::tuple_size}< {\b GTEST_5_TUPLE_}(T) >::value = 5{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 767}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::tuple_size< GTEST_6_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple_size< GTEST_6_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_6_TUPLE_(T) >}
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b value} = 6\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_6_TYPENAMES_}(T)>\par
struct std::tr1::tuple_size< GTEST_6_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 771}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v value\:std::tr1::tuple_size< GTEST_6_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_6_TUPLE_(T) >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_6_TYPENAMES_}(T) > const int {\b std::tr1::tuple_size}< {\b GTEST_6_TUPLE_}(T) >::value = 6{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 772}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::tuple_size< GTEST_7_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple_size< GTEST_7_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_7_TUPLE_(T) >}
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b value} = 7\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_7_TYPENAMES_}(T)>\par
struct std::tr1::tuple_size< GTEST_7_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 776}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v value\:std::tr1::tuple_size< GTEST_7_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_7_TUPLE_(T) >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_7_TYPENAMES_}(T) > const int {\b std::tr1::tuple_size}< {\b GTEST_7_TUPLE_}(T) >::value = 7{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 777}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::tuple_size< GTEST_8_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple_size< GTEST_8_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_8_TUPLE_(T) >}
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b value} = 8\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_8_TYPENAMES_}(T)>\par
struct std::tr1::tuple_size< GTEST_8_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 781}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v value\:std::tr1::tuple_size< GTEST_8_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_8_TUPLE_(T) >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_8_TYPENAMES_}(T) > const int {\b std::tr1::tuple_size}< {\b GTEST_8_TUPLE_}(T) >::value = 8{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 782}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::tuple_size< GTEST_9_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::tuple_size< GTEST_9_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_9_TUPLE_(T) >}
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b value} = 9\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_9_TYPENAMES_}(T)>\par
struct std::tr1::tuple_size< GTEST_9_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 786}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v value\:std::tr1::tuple_size< GTEST_9_TUPLE_(T) >}
{\xe \v std::tr1::tuple_size< GTEST_9_TUPLE_(T) >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_9_TYPENAMES_}(T) > const int {\b std::tr1::tuple_size}< {\b GTEST_9_TUPLE_}(T) >::value = 9{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 787}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::TupleElement< kIndexValid, kIndex, Tuple >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::TupleElement< kIndexValid, kIndex, Tuple >}
{\xe \v std::tr1::gtest_internal::TupleElement< kIndexValid, kIndex, Tuple >}
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<bool kIndexValid, int kIndex, class Tuple>\par
struct std::tr1::gtest_internal::TupleElement< kIndexValid, kIndex, Tuple >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 150}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::TupleElement< true, 0, GTEST_10_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::TupleElement< true, 0, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 0, GTEST_10_TUPLE_(T) >}
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T0 {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T)>\par
struct std::tr1::gtest_internal::TupleElement< true, 0, GTEST_10_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 153}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:std::tr1::gtest_internal::TupleElement< true, 0, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 0, GTEST_10_TUPLE_(T) >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > typedef T0 {\b std::tr1::gtest_internal::TupleElement}< true, 0, {\b GTEST_10_TUPLE_}(T) >::type}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 154}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::TupleElement< true, 1, GTEST_10_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::TupleElement< true, 1, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 1, GTEST_10_TUPLE_(T) >}
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T1 {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T)>\par
struct std::tr1::gtest_internal::TupleElement< true, 1, GTEST_10_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 158}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:std::tr1::gtest_internal::TupleElement< true, 1, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 1, GTEST_10_TUPLE_(T) >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > typedef T1 {\b std::tr1::gtest_internal::TupleElement}< true, 1, {\b GTEST_10_TUPLE_}(T) >::type}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 159}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::TupleElement< true, 2, GTEST_10_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::TupleElement< true, 2, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 2, GTEST_10_TUPLE_(T) >}
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T2 {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T)>\par
struct std::tr1::gtest_internal::TupleElement< true, 2, GTEST_10_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 163}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:std::tr1::gtest_internal::TupleElement< true, 2, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 2, GTEST_10_TUPLE_(T) >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > typedef T2 {\b std::tr1::gtest_internal::TupleElement}< true, 2, {\b GTEST_10_TUPLE_}(T) >::type}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 164}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::TupleElement< true, 3, GTEST_10_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::TupleElement< true, 3, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 3, GTEST_10_TUPLE_(T) >}
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T3 {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T)>\par
struct std::tr1::gtest_internal::TupleElement< true, 3, GTEST_10_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 168}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:std::tr1::gtest_internal::TupleElement< true, 3, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 3, GTEST_10_TUPLE_(T) >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > typedef T3 {\b std::tr1::gtest_internal::TupleElement}< true, 3, {\b GTEST_10_TUPLE_}(T) >::type}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 169}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::TupleElement< true, 4, GTEST_10_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::TupleElement< true, 4, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 4, GTEST_10_TUPLE_(T) >}
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T4 {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T)>\par
struct std::tr1::gtest_internal::TupleElement< true, 4, GTEST_10_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 173}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:std::tr1::gtest_internal::TupleElement< true, 4, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 4, GTEST_10_TUPLE_(T) >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > typedef T4 {\b std::tr1::gtest_internal::TupleElement}< true, 4, {\b GTEST_10_TUPLE_}(T) >::type}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 174}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::TupleElement< true, 5, GTEST_10_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::TupleElement< true, 5, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 5, GTEST_10_TUPLE_(T) >}
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T5 {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T)>\par
struct std::tr1::gtest_internal::TupleElement< true, 5, GTEST_10_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 178}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:std::tr1::gtest_internal::TupleElement< true, 5, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 5, GTEST_10_TUPLE_(T) >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > typedef T5 {\b std::tr1::gtest_internal::TupleElement}< true, 5, {\b GTEST_10_TUPLE_}(T) >::type}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 179}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::TupleElement< true, 6, GTEST_10_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::TupleElement< true, 6, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 6, GTEST_10_TUPLE_(T) >}
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T6 {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T)>\par
struct std::tr1::gtest_internal::TupleElement< true, 6, GTEST_10_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 183}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:std::tr1::gtest_internal::TupleElement< true, 6, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 6, GTEST_10_TUPLE_(T) >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > typedef T6 {\b std::tr1::gtest_internal::TupleElement}< true, 6, {\b GTEST_10_TUPLE_}(T) >::type}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 184}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::TupleElement< true, 7, GTEST_10_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::TupleElement< true, 7, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 7, GTEST_10_TUPLE_(T) >}
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T7 {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T)>\par
struct std::tr1::gtest_internal::TupleElement< true, 7, GTEST_10_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 188}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:std::tr1::gtest_internal::TupleElement< true, 7, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 7, GTEST_10_TUPLE_(T) >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > typedef T7 {\b std::tr1::gtest_internal::TupleElement}< true, 7, {\b GTEST_10_TUPLE_}(T) >::type}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 189}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::TupleElement< true, 8, GTEST_10_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::TupleElement< true, 8, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 8, GTEST_10_TUPLE_(T) >}
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T8 {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T)>\par
struct std::tr1::gtest_internal::TupleElement< true, 8, GTEST_10_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 193}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:std::tr1::gtest_internal::TupleElement< true, 8, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 8, GTEST_10_TUPLE_(T) >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > typedef T8 {\b std::tr1::gtest_internal::TupleElement}< true, 8, {\b GTEST_10_TUPLE_}(T) >::type}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 194}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB std::tr1::gtest_internal::TupleElement< true, 9, GTEST_10_TUPLE_(T) >\par \pard\plain 
{\tc\tcl2 \v std::tr1::gtest_internal::TupleElement< true, 9, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 9, GTEST_10_TUPLE_(T) >}
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
\par
{
{\f2 #include <gtest-tuple.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef T9 {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T)>\par
struct std::tr1::gtest_internal::TupleElement< true, 9, GTEST_10_TUPLE_(T) >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 198}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v type\:std::tr1::gtest_internal::TupleElement< true, 9, GTEST_10_TUPLE_(T) >}
{\xe \v std::tr1::gtest_internal::TupleElement< true, 9, GTEST_10_TUPLE_(T) >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b GTEST_10_TYPENAMES_}(T) > typedef T9 {\b std::tr1::gtest_internal::TupleElement}< true, 9, {\b GTEST_10_TUPLE_}(T) >::type}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 199}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-tuple.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::TuplePolicy< TupleT >\par \pard\plain 
{\tc\tcl2 \v testing::internal::TuplePolicy< TupleT >}
{\xe \v testing::internal::TuplePolicy< TupleT >}
{\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename TupleT>\par
struct testing::internal::TuplePolicy< TupleT >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 882}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::TypeIdHelper< T >\par \pard\plain 
{\tc\tcl2 \v testing::internal::TypeIdHelper< T >}
{\xe \v testing::internal::TypeIdHelper< T >}
{\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
\par
{
{\f2 #include <gtest-internal.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'EE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'E4\'E0\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b dummy_} = false\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class testing::internal::TypeIdHelper< T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 432}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'EB\'FF\par
\pard\plain 
{\xe \v dummy_\:testing::internal::TypeIdHelper< T >}
{\xe \v testing::internal::TypeIdHelper< T >\:dummy_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b testing::internal::TypeIdHelper}< T >::dummy_ = false{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 437}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-internal.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal2::TypeWithoutFormatter< T, kTypeKind >\par \pard\plain 
{\tc\tcl2 \v testing::internal2::TypeWithoutFormatter< T, kTypeKind >}
{\xe \v testing::internal2::TypeWithoutFormatter< T, kTypeKind >}
{\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
\par
{
{\f2 #include <gtest-printers.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b PrintValue} (const T &value, ::std::ostream *os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, {\b TypeKind} kTypeKind>\par
class testing::internal2::TypeWithoutFormatter< T, kTypeKind >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 136}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v PrintValue\:testing::internal2::TypeWithoutFormatter< T, kTypeKind >}
{\xe \v testing::internal2::TypeWithoutFormatter< T, kTypeKind >\:PrintValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b TypeKind} kTypeKind> static void {\b testing::internal2::TypeWithoutFormatter}< T, kTypeKind >::PrintValue (const T &  {\i value}, ::std::ostream *  {\i os}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 139}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00139                                                          \{\par
00140     PrintBytesInObjectTo({\cf17 reinterpret_cast<}{\cf17 const }{\cf18 unsigned} {\cf18 char}*{\cf17 >}(&value),\par
00141                          {\cf17 sizeof}(value), os);\par
00142   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal2::PrintBytesInObjectTo()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal2::TypeWithoutFormatter< T, kConvertibleToInteger >\par \pard\plain 
{\tc\tcl2 \v testing::internal2::TypeWithoutFormatter< T, kConvertibleToInteger >}
{\xe \v testing::internal2::TypeWithoutFormatter< T, kConvertibleToInteger >}
{\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
\par
{
{\f2 #include <gtest-printers.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b PrintValue} (const T &value, ::std::ostream *os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class testing::internal2::TypeWithoutFormatter< T, kConvertibleToInteger >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 163}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v PrintValue\:testing::internal2::TypeWithoutFormatter< T, kConvertibleToInteger >}
{\xe \v testing::internal2::TypeWithoutFormatter< T, kConvertibleToInteger >\:PrintValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static void {\b testing::internal2::TypeWithoutFormatter}< T, {\b kConvertibleToInteger} >::PrintValue (const T &  {\i value}, ::std::ostream *  {\i os}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 172}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00172                                                          \{\par
00173     {\cf17 const} internal::BiggestInt kBigInt = value;\par
00174     *os << kBigInt;\par
00175   \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal2::TypeWithoutFormatter< T, kProtobuf >\par \pard\plain 
{\tc\tcl2 \v testing::internal2::TypeWithoutFormatter< T, kProtobuf >}
{\xe \v testing::internal2::TypeWithoutFormatter< T, kProtobuf >}
{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
\par
{
{\f2 #include <gtest-printers.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b PrintValue} (const T &value, ::std::ostream *os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class testing::internal2::TypeWithoutFormatter< T, kProtobuf >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 151}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v PrintValue\:testing::internal2::TypeWithoutFormatter< T, kProtobuf >}
{\xe \v testing::internal2::TypeWithoutFormatter< T, kProtobuf >\:PrintValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static void {\b testing::internal2::TypeWithoutFormatter}< T, {\b kProtobuf} >::PrintValue (const T &  {\i value}, ::std::ostream *  {\i os}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 153}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00153                                                          \{\par
00154     std::string pretty_str = value.ShortDebugString();\par
00155     {\cf19 if} (pretty_str.length() > kProtobufOneLinerMaxLength) \{\par
00156       pretty_str = {\cf22 "\\n"} + value.DebugString();\par
00157     \}\par
00158     *os << ({\cf22 "<"} + pretty_str + {\cf22 ">"});\par
00159   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal2::kProtobufOneLinerMaxLength}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::TypeWithSize< size >\par \pard\plain 
{\tc\tcl2 \v testing::internal::TypeWithSize< size >}
{\xe \v testing::internal::TypeWithSize< size >}
{\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
\par
{
{\f2 #include <gtest-port.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void {\b UInt}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<size_t size>\par
class testing::internal::TypeWithSize< size >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2493}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v UInt\:testing::internal::TypeWithSize< size >}
{\xe \v testing::internal::TypeWithSize< size >\:UInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<size_t size> typedef void {\b testing::internal::TypeWithSize}< size >::UInt}}
\par
{\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2497}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::TypeWithSize< 4 >\par \pard\plain 
{\tc\tcl2 \v testing::internal::TypeWithSize< 4 >}
{\xe \v testing::internal::TypeWithSize< 4 >}
{\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
\par
{
{\f2 #include <gtest-port.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef int {\b Int}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned int {\b UInt}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2502}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v Int\:testing::internal::TypeWithSize< 4 >}
{\xe \v testing::internal::TypeWithSize< 4 >\:Int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef int {\b testing::internal::TypeWithSize}< 4 >::Int}}
\par
{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2508}}\par
}
{\xe \v UInt\:testing::internal::TypeWithSize< 4 >}
{\xe \v testing::internal::TypeWithSize< 4 >\:UInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned int {\b testing::internal::TypeWithSize}< 4 >::UInt}}
\par
{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2509}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::TypeWithSize< 8 >\par \pard\plain 
{\tc\tcl2 \v testing::internal::TypeWithSize< 8 >}
{\xe \v testing::internal::TypeWithSize< 8 >}
{\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
\par
{
{\f2 #include <gtest-port.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef long long {\b Int}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned long long {\b UInt}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2514}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 
{\xe \v Int\:testing::internal::TypeWithSize< 8 >}
{\xe \v testing::internal::TypeWithSize< 8 >\:Int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef long long {\b testing::internal::TypeWithSize}< 8 >::Int}}
\par
{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2520}}\par
}
{\xe \v UInt\:testing::internal::TypeWithSize< 8 >}
{\xe \v testing::internal::TypeWithSize< 8 >\:UInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned long long {\b testing::internal::TypeWithSize}< 8 >::UInt}}
\par
{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2521}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/internal/{\b gtest-port.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::UnitTest\par \pard\plain 
{\tc\tcl2 \v testing::UnitTest}
{\xe \v testing::UnitTest}
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
\par
{
{\f2 #include <gtest.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Run} () {\b GTEST_MUST_USE_RESULT_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b original_working_dir} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b TestCase} * {\b current_test_case} () const {\b GTEST_LOCK_EXCLUDED_}(mutex_)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b TestInfo} * {\b current_test_info} () const {\b GTEST_LOCK_EXCLUDED_}(mutex_)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b random_seed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b successful_test_case_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b failed_test_case_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b total_test_case_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b test_case_to_run_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b successful_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b failed_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b reportable_disabled_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b disabled_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b reportable_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b total_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b test_to_run_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TimeInMillis} {\b start_timestamp} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TimeInMillis} {\b elapsed_time} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Passed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Failed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b TestCase} * {\b GetTestCase} (int i) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b TestResult} & {\b ad_hoc_test_result} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestEventListeners} & {\b listeners} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b UnitTest} * {\b GetInstance} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'F0\'F3\'E7\'FC\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Test}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::AssertHelper}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::ScopedTrace}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::StreamingListenerTest}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b internal::UnitTestRecordPropertyTestHelper}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Environment} * {\b AddGlobalTestEnvironment} ({\b Environment} *env)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b internal::UnitTestImpl} * {\b internal::GetUnitTestImpl} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b internal::ReportFailureInUnknownLocation} ({\b TestPartResult::Type} result_type, const std::string &message)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1151}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v ad_hoc_test_result\:testing::UnitTest}
{\xe \v testing::UnitTest\:ad_hoc_test_result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestResult} & testing::UnitTest::ad_hoc_test_result () const}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4068}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04068                                                      \{\par
04069   {\cf19 return} *impl()->ad_hoc_test_result();\par
04070 \}\par
}
}
{\xe \v current_test_case\:testing::UnitTest}
{\xe \v testing::UnitTest\:current_test_case}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestCase} * testing::UnitTest::current_test_case () const}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4270}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04271                                  \{\par
04272   internal::MutexLock lock(&mutex_);\par
04273   {\cf19 return} impl_->current_test_case();\par
04274 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UnitTestImpl::current_test_case()}.}\par
}
{\xe \v current_test_info\:testing::UnitTest}
{\xe \v testing::UnitTest\:current_test_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestInfo} * testing::UnitTest::current_test_info () const}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4278}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04279                                  \{\par
04280   internal::MutexLock lock(&mutex_);\par
04281   {\cf19 return} impl_->current_test_info();\par
04282 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UnitTestImpl::current_test_info()}.}\par
}
{\xe \v disabled_test_count\:testing::UnitTest}
{\xe \v testing::UnitTest\:disabled_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::UnitTest::disabled_test_count () const}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4027}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04027                                         \{\par
04028   {\cf19 return} impl()->disabled_test_count();\par
04029 \}\par
}
}
{\xe \v elapsed_time\:testing::UnitTest}
{\xe \v testing::UnitTest\:elapsed_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b internal::TimeInMillis} testing::UnitTest::elapsed_time () const}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4049}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04049                                                   \{\par
04050   {\cf19 return} impl()->elapsed_time();\par
04051 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd()}.}\par
}
{\xe \v Failed\:testing::UnitTest}
{\xe \v testing::UnitTest\:Failed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::UnitTest::Failed () const}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4058}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04058 \{ {\cf19 return} impl()->Failed(); \}\par
}
}
{\xe \v failed_test_case_count\:testing::UnitTest}
{\xe \v testing::UnitTest\:failed_test_case_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::UnitTest::failed_test_case_count () const}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3998}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03998                                            \{\par
03999   {\cf19 return} impl()->failed_test_case_count();\par
04000 \}\par
}
}
{\xe \v failed_test_count\:testing::UnitTest}
{\xe \v testing::UnitTest\:failed_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::UnitTest::failed_test_count () const}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4019}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04019 \{ {\cf19 return} impl()->failed_test_count(); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd()}.}\par
}
{\xe \v GetInstance\:testing::UnitTest}
{\xe \v testing::UnitTest\:GetInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UnitTest} * testing::UnitTest::GetInstance (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3971}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03971                                 \{\par
03972   {\cf20 // When compiled with MSVC 7.1 in optimized mode, destroying the}\par
03973   {\cf20 // UnitTest object upon exiting the program messes up the exit code,}\par
03974   {\cf20 // causing successful tests to appear failed.  We have to use a}\par
03975   {\cf20 // different implementation in this case to bypass the compiler bug.}\par
03976   {\cf20 // This implementation makes the compiler happy, at the cost of}\par
03977   {\cf20 // leaking the UnitTest object.}\par
03978 \par
03979   {\cf20 // CodeGear C++Builder insists on a public destructor for the}\par
03980   {\cf20 // default implementation.  Use this implementation to keep good OO}\par
03981   {\cf20 // design with private destructor.}\par
03982 \par
03983 {\cf21 #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)}\par
03984   {\cf17 static} UnitTest* {\cf17 const} instance = {\cf17 new} UnitTest;\par
03985   {\cf19 return} instance;\par
03986 {\cf21 #else}\par
03987   {\cf17 static} UnitTest instance;\par
03988   {\cf19 return} &instance;\par
03989 {\cf21 #endif  }{\cf20 // (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)}\par
03990 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestOptions::GetAbsolutePathToOutputFile()}, {\b testing::internal::GetUnitTestImpl()}, {\b testing::internal::AssertHelper::operator=()}, {\b testing::Test::RecordProperty()}, {\b testing::internal::ReportFailureInUnknownLocation()}, {\b testing::internal::ScopedTrace::ScopedTrace()} \'E8 {\b testing::internal::ScopedTrace::~ScopedTrace()}.}\par
}
{\xe \v GetTestCase\:testing::UnitTest}
{\xe \v testing::UnitTest\:GetTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestCase} * testing::UnitTest::GetTestCase (int  {\i i}) const}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4062}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04062                                                  \{\par
04063   {\cf19 return} impl()->GetTestCase(i);\par
04064 \}\par
}
}
{\xe \v listeners\:testing::UnitTest}
{\xe \v testing::UnitTest\:listeners}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestEventListeners} & testing::UnitTest::listeners ()}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4080}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04080                                         \{\par
04081   {\cf19 return} *impl()->listeners();\par
04082 \}\par
}
}
{\xe \v original_working_dir\:testing::UnitTest}
{\xe \v testing::UnitTest\:original_working_dir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * testing::UnitTest::original_working_dir () const}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4264}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04264                                                  \{\par
04265   {\cf19 return} impl_->original_working_dir_.c_str();\par
04266 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::FilePath::c_str()}.}\par
}
{\xe \v Passed\:testing::UnitTest}
{\xe \v testing::UnitTest\:Passed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::UnitTest::Passed () const}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4054}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04054 \{ {\cf19 return} impl()->Passed(); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd()}.}\par
}
{\xe \v random_seed\:testing::UnitTest}
{\xe \v testing::UnitTest\:random_seed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::UnitTest::random_seed () const}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4285}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04285 \{ {\cf19 return} impl_->random_seed(); \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UnitTestImpl::random_seed()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart()}.}\par
}
{\xe \v reportable_disabled_test_count\:testing::UnitTest}
{\xe \v testing::UnitTest\:reportable_disabled_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::UnitTest::reportable_disabled_test_count () const}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4022}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04022                                                    \{\par
04023   {\cf19 return} impl()->reportable_disabled_test_count();\par
04024 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd()}.}\par
}
{\xe \v reportable_test_count\:testing::UnitTest}
{\xe \v testing::UnitTest\:reportable_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::UnitTest::reportable_test_count () const}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4032}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04032                                           \{\par
04033   {\cf19 return} impl()->reportable_test_count();\par
04034 \}\par
}
}
{\xe \v Run\:testing::UnitTest}
{\xe \v testing::UnitTest\:Run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::UnitTest::Run ()}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4184}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04184                   \{\par
04185   {\cf17 const} {\cf18 bool} in_death_test_child_process =\par
04186       internal::GTEST_FLAG(internal_run_death_test).length() > 0;\par
04187 \par
04188   {\cf20 // Google Test implements this protocol for catching that a test}\par
04189   {\cf20 // program exits before returning control to Google Test:}\par
04190   {\cf20 //}\par
04191   {\cf20 //   1. Upon start, Google Test creates a file whose absolute path}\par
04192   {\cf20 //      is specified by the environment variable}\par
04193   {\cf20 //      TEST_PREMATURE_EXIT_FILE.}\par
04194   {\cf20 //   2. When Google Test has finished its work, it deletes the file.}\par
04195   {\cf20 //}\par
04196   {\cf20 // This allows a test runner to set TEST_PREMATURE_EXIT_FILE before}\par
04197   {\cf20 // running a Google-Test-based test program and check the existence}\par
04198   {\cf20 // of the file at the end of the test execution to see if it has}\par
04199   {\cf20 // exited prematurely.}\par
04200 \par
04201   {\cf20 // If we are in the child process of a death test, don't}\par
04202   {\cf20 // create/delete the premature exit file, as doing so is unnecessary}\par
04203   {\cf20 // and will confuse the parent process.  Otherwise, create/delete}\par
04204   {\cf20 // the file upon entering/leaving this function.  If the program}\par
04205   {\cf20 // somehow exits before this function has a chance to return, the}\par
04206   {\cf20 // premature-exit file will be left undeleted, causing a test runner}\par
04207   {\cf20 // that understands the premature-exit-file protocol to report the}\par
04208   {\cf20 // test as having failed.}\par
04209   {\cf17 const} internal::ScopedPrematureExitFile premature_exit_file(\par
04210       in_death_test_child_process ?\par
04211       NULL : internal::posix::GetEnv({\cf22 "TEST_PREMATURE_EXIT_FILE"}));\par
04212 \par
04213   {\cf20 // Captures the value of GTEST_FLAG(catch_exceptions).  This value will be}\par
04214   {\cf20 // used for the duration of the program.}\par
04215   impl()->set_catch_exceptions(GTEST_FLAG(catch_exceptions));\par
04216 \par
04217 {\cf21 #if GTEST_HAS_SEH}\par
04218   {\cf20 // Either the user wants Google Test to catch exceptions thrown by the}\par
04219   {\cf20 // tests or this is executing in the context of death test child}\par
04220   {\cf20 // process. In either case the user does not want to see pop-up dialogs}\par
04221   {\cf20 // about crashes - they are expected.}\par
04222   {\cf19 if} (impl()->catch_exceptions() || in_death_test_child_process) \{\par
04223 {\cf21 # if !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT}\par
04224     {\cf20 // SetErrorMode doesn't exist on CE.}\par
04225     SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOALIGNMENTFAULTEXCEPT |\par
04226                  SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);\par
04227 {\cf21 # endif  }{\cf20 // !GTEST_OS_WINDOWS_MOBILE}\par
04228 \par
04229 {\cf21 # if (defined(_MSC_VER) || GTEST_OS_WINDOWS_MINGW) && !GTEST_OS_WINDOWS_MOBILE}\par
04230     {\cf20 // Death test children can be terminated with _abort().  On Windows,}\par
04231     {\cf20 // _abort() can show a dialog with a warning message.  This forces the}\par
04232     {\cf20 // abort message to go to stderr instead.}\par
04233     _set_error_mode(_OUT_TO_STDERR);\par
04234 {\cf21 # endif}\par
04235 \par
04236 {\cf21 # if _MSC_VER >= 1400 && !GTEST_OS_WINDOWS_MOBILE}\par
04237     {\cf20 // In the debug version, Visual Studio pops up a separate dialog}\par
04238     {\cf20 // offering a choice to debug the aborted program. We need to suppress}\par
04239     {\cf20 // this dialog or it will pop up for every EXPECT/ASSERT_DEATH statement}\par
04240     {\cf20 // executed. Google Test will notify the user of any unexpected}\par
04241     {\cf20 // failure via stderr.}\par
04242     {\cf20 //}\par
04243     {\cf20 // VC++ doesn't define _set_abort_behavior() prior to the version 8.0.}\par
04244     {\cf20 // Users of prior VC versions shall suffer the agony and pain of}\par
04245     {\cf20 // clicking through the countless debug dialogs.}\par
04246     {\cf20 // TODO(vladl@google.com): find a way to suppress the abort dialog() in the}\par
04247     {\cf20 // debug mode when compiled with VC 7.1 or lower.}\par
04248     {\cf19 if} (!GTEST_FLAG(break_on_failure))\par
04249       _set_abort_behavior(\par
04250           0x0,                                    {\cf20 // Clear the following flags:}\par
04251           _WRITE_ABORT_MSG | _CALL_REPORTFAULT);  {\cf20 // pop-up window, core dump.}\par
04252 {\cf21 # endif}\par
04253   \}\par
04254 {\cf21 #endif  }{\cf20 // GTEST_HAS_SEH}\par
04255 \par
04256   {\cf19 return} internal::HandleExceptionsInMethodIfSupported(\par
04257       impl(),\par
04258       &internal::UnitTestImpl::RunAllTests,\par
04259       {\cf22 "auxiliary test code (environments or event listeners)"}) ? 0 : 1;\par
04260 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::posix::GetEnv()}, {\b GTEST_FLAG}, {\b testing::internal::HandleExceptionsInMethodIfSupported()} \'E8 {\b testing::internal::UnitTestImpl::RunAllTests()}.}\par
}
{\xe \v start_timestamp\:testing::UnitTest}
{\xe \v testing::UnitTest\:start_timestamp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b internal::TimeInMillis} testing::UnitTest::start_timestamp () const}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4044}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04044                                                      \{\par
04045     {\cf19 return} impl()->start_timestamp();\par
04046 \}\par
}
}
{\xe \v successful_test_case_count\:testing::UnitTest}
{\xe \v testing::UnitTest\:successful_test_case_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::UnitTest::successful_test_case_count () const}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3993}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03993                                                \{\par
03994   {\cf19 return} impl()->successful_test_case_count();\par
03995 \}\par
}
}
{\xe \v successful_test_count\:testing::UnitTest}
{\xe \v testing::UnitTest\:successful_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::UnitTest::successful_test_count () const}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4014}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04014                                           \{\par
04015   {\cf19 return} impl()->successful_test_count();\par
04016 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd()}.}\par
}
{\xe \v test_case_to_run_count\:testing::UnitTest}
{\xe \v testing::UnitTest\:test_case_to_run_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::UnitTest::test_case_to_run_count () const}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4009}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04009                                            \{\par
04010   {\cf19 return} impl()->test_case_to_run_count();\par
04011 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd()} \'E8 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart()}.}\par
}
{\xe \v test_to_run_count\:testing::UnitTest}
{\xe \v testing::UnitTest\:test_to_run_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::UnitTest::test_to_run_count () const}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4040}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04040 \{ {\cf19 return} impl()->test_to_run_count(); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd()} \'E8 {\b testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart()}.}\par
}
{\xe \v total_test_case_count\:testing::UnitTest}
{\xe \v testing::UnitTest\:total_test_case_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::UnitTest::total_test_case_count () const}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4003}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04003                                           \{\par
04004   {\cf19 return} impl()->total_test_case_count();\par
04005 \}\par
}
}
{\xe \v total_test_count\:testing::UnitTest}
{\xe \v testing::UnitTest\:total_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::UnitTest::total_test_count () const}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4037}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04037 \{ {\cf19 return} impl()->total_test_count(); \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FF \'EF\'EE \'E4\'F0\'F3\'E7\'FC\'FF\'EC \'EA\'EB\'E0\'F1\'F1\'E0 \'E8 \'F4\'F3\'ED\'EA\'F6\'E8\'FF\'EC, \'EE\'F2\'ED\'EE\'F1\'FF\'F9\'E8\'EC\'F1\'FF \'EA \'EA\'EB\'E0\'F1\'F1\'F3\par
\pard\plain 
{\xe \v AddGlobalTestEnvironment\:testing::UnitTest}
{\xe \v testing::UnitTest\:AddGlobalTestEnvironment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Environment} * AddGlobalTestEnvironment ({\b Environment} *  {\i env}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1350}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 01350                                                                \{\par
01351   {\cf19 return} UnitTest::GetInstance()->AddEnvironment(env);\par
01352 \}\par
}
}
{\xe \v internal::AssertHelper\:testing::UnitTest}
{\xe \v testing::UnitTest\:internal::AssertHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b internal::AssertHelper}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1293}}\par
}
{\xe \v internal::GetUnitTestImpl\:testing::UnitTest}
{\xe \v testing::UnitTest\:internal::GetUnitTestImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b internal::UnitTestImpl} * {\b internal::GetUnitTestImpl} (){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v internal::ReportFailureInUnknownLocation\:testing::UnitTest}
{\xe \v testing::UnitTest\:internal::ReportFailureInUnknownLocation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b internal::ReportFailureInUnknownLocation} ({\b TestPartResult::Type}  {\i result_type}, const std::string &  {\i message}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v internal::ScopedTrace\:testing::UnitTest}
{\xe \v testing::UnitTest\:internal::ScopedTrace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b internal::ScopedTrace}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1294}}\par
}
{\xe \v internal::StreamingListenerTest\:testing::UnitTest}
{\xe \v testing::UnitTest\:internal::StreamingListenerTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class internal::StreamingListenerTest{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1295}}\par
}
{\xe \v internal::UnitTestRecordPropertyTestHelper\:testing::UnitTest}
{\xe \v testing::UnitTest\:internal::UnitTestRecordPropertyTestHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class internal::UnitTestRecordPropertyTestHelper{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1296}}\par
}
{\xe \v Test\:testing::UnitTest}
{\xe \v testing::UnitTest\:Test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b Test}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1292}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::UnitTestImpl\par \pard\plain 
{\tc\tcl2 \v testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl}
{\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
\par
{
{\f2 #include <gtest-internal-inl.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F2\'E8\'EF\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ReactionToSharding} \{ {\b HONOR_SHARDING_PROTOCOL}
, {\b IGNORE_SHARDING_PROTOCOL}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UnitTestImpl} ({\b UnitTest} *parent)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~UnitTestImpl} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestPartResultReporterInterface} * {\b GetGlobalTestPartResultReporter} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetGlobalTestPartResultReporter} ({\b TestPartResultReporterInterface} *reporter)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestPartResultReporterInterface} * {\b GetTestPartResultReporterForCurrentThread} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTestPartResultReporterForCurrentThread} ({\b TestPartResultReporterInterface} *reporter)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b successful_test_case_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b failed_test_case_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b total_test_case_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b test_case_to_run_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b successful_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b failed_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b reportable_disabled_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b disabled_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b reportable_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b total_test_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b test_to_run_count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TimeInMillis} {\b start_timestamp} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TimeInMillis} {\b elapsed_time} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Passed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Failed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b TestCase} * {\b GetTestCase} (int i) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCase} * {\b GetMutableTestCase} (int i)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestEventListeners} * {\b listeners} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestResult} * {\b current_test_result} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b TestResult} * {\b ad_hoc_test_result} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_os_stack_trace_getter} ({\b OsStackTraceGetterInterface} *getter)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OsStackTraceGetterInterface} * {\b os_stack_trace_getter} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b CurrentOsStackTraceExceptTop} (int skip_count) {\b GTEST_NO_INLINE_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCase} * {\b GetTestCase} (const char *test_case_name, const char *type_param, {\b Test::SetUpTestCaseFunc} set_up_tc, {\b Test::TearDownTestCaseFunc} tear_down_tc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddTestInfo} ({\b Test::SetUpTestCaseFunc} set_up_tc, {\b Test::TearDownTestCaseFunc} tear_down_tc, {\b TestInfo} *test_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_current_test_case} ({\b TestCase} *a_current_test_case)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_current_test_info} ({\b TestInfo} *a_current_test_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RegisterParameterizedTests} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b RunAllTests} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearNonAdHocTestResult} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearAdHocTestResult} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RecordProperty} (const {\b TestProperty} &test_property)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b FilterTests} ({\b ReactionToSharding} shard_tests)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ListTestsMatchingFilter} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b TestCase} * {\b current_test_case} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestInfo} * {\b current_test_info} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b TestInfo} * {\b current_test_info} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Environment} * > & {\b environments} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TraceInfo} > & {\b gtest_trace_stack} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::vector< {\b TraceInfo} > & {\b gtest_trace_stack} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ConfigureXmlOutput} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PostFlagParsingInit} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b random_seed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b internal::Random} * {\b random} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ShuffleTests} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnshuffleTests} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b catch_exceptions} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'F0\'F3\'E7\'FC\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ::testing::UnitTest}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 499}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 
{\xe \v ReactionToSharding\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:ReactionToSharding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b testing::internal::UnitTestImpl::ReactionToSharding}}}
\par
{\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'DD\'EB\'E5\'EC\'E5\'ED\'F2\'FB \'EF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'E9:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v HONOR_SHARDING_PROTOCOL\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:HONOR_SHARDING_PROTOCOL}
{\qr HONOR_SHARDING_PROTOCOL{\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
\cell }{\cell }{\row }
{\xe \v IGNORE_SHARDING_PROTOCOL\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:IGNORE_SHARDING_PROTOCOL}
{\qr IGNORE_SHARDING_PROTOCOL{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
\cell }{\cell }{\row }
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 717}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00717                           \{\par
00718     HONOR_SHARDING_PROTOCOL,\par
00719     IGNORE_SHARDING_PROTOCOL\par
00720   \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v UnitTestImpl\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:UnitTestImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::UnitTestImpl::UnitTestImpl ({\b UnitTest} *  {\i parent}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4324}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04325     : parent_(parent),\par
04326       GTEST_DISABLE_MSC_WARNINGS_PUSH_(4355 {\cf20 /* using this in initializer */})\par
04327       default_global_test_part_result_reporter_(this),\par
04328       default_per_thread_test_part_result_reporter_(this),\par
04329       GTEST_DISABLE_MSC_WARNINGS_POP_()\par
04330       global_test_part_result_repoter_(\par
04331           &default_global_test_part_result_reporter_),\par
04332       per_thread_test_part_result_reporter_(\par
04333           &default_per_thread_test_part_result_reporter_),\par
04334 {\cf21 #if GTEST_HAS_PARAM_TEST}\par
04335       parameterized_test_registry_(),\par
04336       parameterized_tests_registered_({\cf17 false}),\par
04337 {\cf21 #endif  }{\cf20 // GTEST_HAS_PARAM_TEST}\par
04338       last_death_test_case_(-1),\par
04339       current_test_case_(NULL),\par
04340       current_test_info_(NULL),\par
04341       ad_hoc_test_result_(),\par
04342       os_stack_trace_getter_(NULL),\par
04343       post_flag_parse_init_performed_({\cf17 false}),\par
04344       random_seed_(0),  {\cf20 // Will be overridden by the flag before first use.}\par
04345       random_(0),  {\cf20 // Will be reseeded before first use.}\par
04346       start_timestamp_(0),\par
04347       elapsed_time_(0),\par
04348 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
04349       death_test_factory_({\cf17 new} DefaultDeathTestFactory),\par
04350 {\cf21 #endif}\par
04351       {\cf20 // Will be overridden by the flag before first use.}\par
04352       catch_exceptions_({\cf17 false}) \{\par
04353   listeners()->SetDefaultResultPrinter({\cf17 new} PrettyUnitTestResultPrinter);\par
04354 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b listeners()}.}\par
}
{\xe \v ~UnitTestImpl\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:~UnitTestImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::UnitTestImpl::~UnitTestImpl (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4356}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04356                             \{\par
04357   {\cf20 // Deletes every TestCase.}\par
04358   ForEach(test_cases_, internal::Delete<TestCase>);\par
04359 \par
04360   {\cf20 // Deletes every Environment.}\par
04361   ForEach(environments_, internal::Delete<Environment>);\par
04362 \par
04363   {\cf17 delete} os_stack_trace_getter_;\par
04364 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::ForEach()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v ad_hoc_test_result\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:ad_hoc_test_result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestResult} * testing::internal::UnitTestImpl::ad_hoc_test_result () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 597}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00597 \{ {\cf19 return} &ad_hoc_test_result_; \}\par
}
}
{\xe \v AddTestInfo\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:AddTestInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::AddTestInfo ({\b Test::SetUpTestCaseFunc}  {\i set_up_tc}, {\b Test::TearDownTestCaseFunc}  {\i tear_down_tc}, {\b TestInfo} *  {\i test_info}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 645}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00647                                         \{\par
00648     {\cf20 // In order to support thread-safe death tests, we need to}\par
00649     {\cf20 // remember the original working directory when the test program}\par
00650     {\cf20 // was first invoked.  We cannot do this in RUN_ALL_TESTS(), as}\par
00651     {\cf20 // the user may have changed the current directory before calling}\par
00652     {\cf20 // RUN_ALL_TESTS().  Therefore we capture the current directory in}\par
00653     {\cf20 // AddTestInfo(), which is called to register a TEST or TEST_F}\par
00654     {\cf20 // before main() is reached.}\par
00655     {\cf19 if} (original_working_dir_.IsEmpty()) \{\par
00656       original_working_dir_.Set(FilePath::GetCurrentDir());\par
00657       GTEST_CHECK_(!original_working_dir_.IsEmpty())\par
00658           << {\cf22 "Failed to get the current working directory."};\par
00659     \}\par
00660 \par
00661     GetTestCase(test_info->test_case_name(),\par
00662                 test_info->type_param(),\par
00663                 set_up_tc,\par
00664                 tear_down_tc)->AddTestInfo(test_info);\par
00665   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::FilePath::GetCurrentDir()}, {\b GTEST_CHECK_}, {\b testing::TestInfo::test_case_name()} \'E8 {\b testing::TestInfo::type_param()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::MakeAndRegisterTestInfo()}.}\par
}
{\xe \v catch_exceptions\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:catch_exceptions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::UnitTestImpl::catch_exceptions () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 803}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00803 \{ {\cf19 return} catch_exceptions_; \}\par
}
}
{\xe \v ClearAdHocTestResult\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:ClearAdHocTestResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::ClearAdHocTestResult (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 707}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00707                               \{\par
00708     ad_hoc_test_result_.Clear();\par
00709   \}\par
}
}
{\xe \v ClearNonAdHocTestResult\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:ClearNonAdHocTestResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::ClearNonAdHocTestResult (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 702}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00702                                  \{\par
00703     ForEach(test_cases_, TestCase::ClearTestCaseResult);\par
00704   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::ForEach()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b RunAllTests()}.}\par
}
{\xe \v ConfigureXmlOutput\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:ConfigureXmlOutput}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::ConfigureXmlOutput ()}}
\par
{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4399}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04399                                       \{\par
04400   {\cf17 const} std::string& output_format = UnitTestOptions::GetOutputFormat();\par
04401   {\cf19 if} (output_format == {\cf22 "xml"}) \{\par
04402     listeners()->SetDefaultXmlGenerator({\cf17 new} XmlUnitTestResultPrinter(\par
04403         UnitTestOptions::GetAbsolutePathToOutputFile().c_str()));\par
04404   \} {\cf19 else} {\cf19 if} (output_format != {\cf22 ""}) \{\par
04405     printf({\cf22 "WARNING: unrecognized output format \\"%s\\" ignored.\\n"},\par
04406            output_format.c_str());\par
04407     fflush(stdout);\par
04408   \}\par
04409 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UnitTestOptions::GetAbsolutePathToOutputFile()}, {\b testing::internal::UnitTestOptions::GetOutputFormat()} \'E8 {\b listeners()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b PostFlagParsingInit()}.}\par
}
{\xe \v current_test_case\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:current_test_case}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestCase} * testing::internal::UnitTestImpl::current_test_case () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 733}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00733 \{ {\cf19 return} current_test_case_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::UnitTest::current_test_case()}.}\par
}
{\xe \v current_test_info\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:current_test_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestInfo} * testing::internal::UnitTestImpl::current_test_info (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 734}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00734 \{ {\cf19 return} current_test_info_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::UnitTest::current_test_info()}.}\par
}
{\xe \v current_test_info\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:current_test_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestInfo} * testing::internal::UnitTestImpl::current_test_info () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 735}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00735 \{ {\cf19 return} current_test_info_; \}\par
}
}
{\xe \v current_test_result\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:current_test_result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestResult} * testing::internal::UnitTestImpl::current_test_result ()}}
\par
{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4931}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04931                                               \{\par
04932   {\cf19 return} current_test_info_ ?\par
04933       &(current_test_info_->result_) : &ad_hoc_test_result_;\par
04934 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::Test::HasFatalFailure()}, {\b testing::Test::HasNonfatalFailure()} \'E8 {\b testing::internal::DefaultGlobalTestPartResultReporter::ReportTestPartResult()}.}\par
}
{\xe \v CurrentOsStackTraceExceptTop\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:CurrentOsStackTraceExceptTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::UnitTestImpl::CurrentOsStackTraceExceptTop (int  {\i skip_count})}}
\par
{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 793}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00793                                                                    \{\par
00794   {\cf19 return} os_stack_trace_getter()->CurrentStackTrace(\par
00795       {\cf17 static_cast<}{\cf18 int}{\cf17 >}(GTEST_FLAG(stack_trace_depth)),\par
00796       skip_count + 1\par
00797       {\cf20 // Skips the user-specified number of frames plus this function}\par
00798       {\cf20 // itself.}\par
00799       );  {\cf20 // NOLINT}\par
00800 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::OsStackTraceGetterInterface::CurrentStackTrace()}, {\b GTEST_FLAG} \'E8 {\b os_stack_trace_getter()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::GetCurrentOsStackTraceExceptTop()} \'E8 {\b testing::internal::AssertHelper::operator=()}.}\par
}
{\xe \v disabled_test_count\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:disabled_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::UnitTestImpl::disabled_test_count () const}}
\par
{\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 764}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00764                                             \{\par
00765   {\cf19 return} SumOverTestCaseList(test_cases_, &TestCase::disabled_test_count);\par
00766 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestCase::disabled_test_count()}.}\par
}
{\xe \v elapsed_time\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:elapsed_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TimeInMillis} testing::internal::UnitTestImpl::elapsed_time () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 564}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00564 \{ {\cf19 return} elapsed_time_; \}\par
}
}
{\xe \v environments\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:environments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b Environment} * > & testing::internal::UnitTestImpl::environments (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 739}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00739 \{ {\cf19 return} environments_; \}\par
}
}
{\xe \v Failed\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:Failed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::UnitTestImpl::Failed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 571}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00571                       \{\par
00572     {\cf19 return} failed_test_case_count() > 0 || ad_hoc_test_result()->Failed();\par
00573   \}\par
}
}
{\xe \v failed_test_case_count\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:failed_test_case_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::UnitTestImpl::failed_test_case_count () const}}
\par
{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 732}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00732                                                \{\par
00733   {\cf19 return} CountIf(test_cases_, TestCaseFailed);\par
00734 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CountIf()}.}\par
}
{\xe \v failed_test_count\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:failed_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::UnitTestImpl::failed_test_count () const}}
\par
{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 753}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00753                                           \{\par
00754   {\cf19 return} SumOverTestCaseList(test_cases_, &TestCase::failed_test_count);\par
00755 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestCase::failed_test_count()}.}\par
}
{\xe \v FilterTests\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:FilterTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::UnitTestImpl::FilterTests ({\b ReactionToSharding}  {\i shard_tests})}}
\par
{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4788}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04788                                                             \{\par
04789   {\cf17 const} Int32 total_shards = shard_tests == HONOR_SHARDING_PROTOCOL ?\par
04790       Int32FromEnvOrDie(kTestTotalShards, -1) : -1;\par
04791   {\cf17 const} Int32 shard_index = shard_tests == HONOR_SHARDING_PROTOCOL ?\par
04792       Int32FromEnvOrDie(kTestShardIndex, -1) : -1;\par
04793 \par
04794   {\cf20 // num_runnable_tests are the number of tests that will}\par
04795   {\cf20 // run across all shards (i.e., match filter and are not disabled).}\par
04796   {\cf20 // num_selected_tests are the number of tests to be run on}\par
04797   {\cf20 // this shard.}\par
04798   {\cf18 int} num_runnable_tests = 0;\par
04799   {\cf18 int} num_selected_tests = 0;\par
04800   {\cf19 for} ({\cf18 size_t} i = 0; i < test_cases_.size(); i++) \{\par
04801     TestCase* {\cf17 const} test_case = test_cases_[i];\par
04802     {\cf17 const} std::string &test_case_name = test_case->name();\par
04803     test_case->set_should_run({\cf17 false});\par
04804 \par
04805     {\cf19 for} ({\cf18 size_t} j = 0; j < test_case->test_info_list().size(); j++) \{\par
04806       TestInfo* {\cf17 const} test_info = test_case->test_info_list()[j];\par
04807       {\cf17 const} std::string test_name(test_info->name());\par
04808       {\cf20 // A test is disabled if test case name or test name matches}\par
04809       {\cf20 // kDisableTestFilter.}\par
04810       {\cf17 const} {\cf18 bool} is_disabled =\par
04811           internal::UnitTestOptions::MatchesFilter(test_case_name,\par
04812                                                    kDisableTestFilter) ||\par
04813           internal::UnitTestOptions::MatchesFilter(test_name,\par
04814                                                    kDisableTestFilter);\par
04815       test_info->is_disabled_ = is_disabled;\par
04816 \par
04817       {\cf17 const} {\cf18 bool} matches_filter =\par
04818           internal::UnitTestOptions::FilterMatchesTest(test_case_name,\par
04819                                                        test_name);\par
04820       test_info->matches_filter_ = matches_filter;\par
04821 \par
04822       {\cf17 const} {\cf18 bool} is_runnable =\par
04823           (GTEST_FLAG(also_run_disabled_tests) || !is_disabled) &&\par
04824           matches_filter;\par
04825 \par
04826       {\cf17 const} {\cf18 bool} is_selected = is_runnable &&\par
04827           (shard_tests == IGNORE_SHARDING_PROTOCOL ||\par
04828            ShouldRunTestOnShard(total_shards, shard_index,\par
04829                                 num_runnable_tests));\par
04830 \par
04831       num_runnable_tests += is_runnable;\par
04832       num_selected_tests += is_selected;\par
04833 \par
04834       test_info->should_run_ = is_selected;\par
04835       test_case->set_should_run(test_case->should_run() || is_selected);\par
04836     \}\par
04837   \}\par
04838   {\cf19 return} num_selected_tests;\par
04839 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UnitTestOptions::FilterMatchesTest()}, {\b GTEST_FLAG}, {\b HONOR_SHARDING_PROTOCOL}, {\b IGNORE_SHARDING_PROTOCOL}, {\b testing::internal::Int32FromEnvOrDie()}, {\b testing::internal::UnitTestOptions::MatchesFilter()}, {\b testing::TestInfo::name()}, {\b testing::TestCase::name()}, {\b testing::TestCase::should_run()} \'E8 {\b testing::internal::ShouldRunTestOnShard()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b RunAllTests()}.}\par
}
{\xe \v GetGlobalTestPartResultReporter\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:GetGlobalTestPartResultReporter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestPartResultReporterInterface} * testing::internal::UnitTestImpl::GetGlobalTestPartResultReporter ()}}
\par
{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 702}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00702                                               \{\par
00703   internal::MutexLock lock(&global_test_part_result_reporter_mutex_);\par
00704   {\cf19 return} global_test_part_result_repoter_;\par
00705 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::DefaultPerThreadTestPartResultReporter::ReportTestPartResult()}.}\par
}
{\xe \v GetMutableTestCase\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:GetMutableTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestCase} * testing::internal::UnitTestImpl::GetMutableTestCase (int  {\i i}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 584}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00584                                       \{\par
00585     {\cf17 const} {\cf18 int} index = GetElementOr(test_case_indices_, i, -1);\par
00586     {\cf19 return} index < 0 ? NULL : test_cases_[index];\par
00587   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::GetElementOr()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b RunAllTests()}.}\par
}
{\xe \v GetTestCase\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:GetTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestCase} * testing::internal::UnitTestImpl::GetTestCase (const char *  {\i test_case_name}, const char *  {\i type_param}, {\b Test::SetUpTestCaseFunc}  {\i set_up_tc}, {\b Test::TearDownTestCaseFunc}  {\i tear_down_tc})}}
\par
{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4501}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04504                                                                            \{\par
04505   {\cf20 // Can we find a TestCase with the given name?}\par
04506   {\cf17 const} std::vector<TestCase*>::const_iterator test_case =\par
04507       std::find_if(test_cases_.begin(), test_cases_.end(),\par
04508                    TestCaseNameIs(test_case_name));\par
04509 \par
04510   {\cf19 if} (test_case != test_cases_.end())\par
04511     {\cf19 return} *test_case;\par
04512 \par
04513   {\cf20 // No.  Let's create one.}\par
04514   TestCase* {\cf17 const} new_test_case =\par
04515       {\cf17 new} TestCase(test_case_name, type_param, set_up_tc, tear_down_tc);\par
04516 \par
04517   {\cf20 // Is this a death test case?}\par
04518   {\cf19 if} (internal::UnitTestOptions::MatchesFilter(test_case_name,\par
04519                                                kDeathTestCaseFilter)) \{\par
04520     {\cf20 // Yes.  Inserts the test case after the last death test case}\par
04521     {\cf20 // defined so far.  This only works when the test cases haven't}\par
04522     {\cf20 // been shuffled.  Otherwise we may end up running a death test}\par
04523     {\cf20 // after a non-death test.}\par
04524     ++last_death_test_case_;\par
04525     test_cases_.insert(test_cases_.begin() + last_death_test_case_,\par
04526                        new_test_case);\par
04527   \} {\cf19 else} \{\par
04528     {\cf20 // No.  Appends to the end of the list.}\par
04529     test_cases_.push_back(new_test_case);\par
04530   \}\par
04531 \par
04532   test_case_indices_.push_back({\cf17 static_cast<}{\cf18 int}{\cf17 >}(test_case_indices_.size()));\par
04533   {\cf19 return} new_test_case;\par
04534 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UnitTestOptions::MatchesFilter()}.}\par
}
{\xe \v GetTestCase\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:GetTestCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestCase} * testing::internal::UnitTestImpl::GetTestCase (int  {\i i}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 577}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00577                                            \{\par
00578     {\cf17 const} {\cf18 int} index = GetElementOr(test_case_indices_, i, -1);\par
00579     {\cf19 return} index < 0 ? NULL : test_cases_[i];\par
00580   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::GetElementOr()}.}\par
}
{\xe \v GetTestPartResultReporterForCurrentThread\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:GetTestPartResultReporterForCurrentThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestPartResultReporterInterface} * testing::internal::UnitTestImpl::GetTestPartResultReporterForCurrentThread ()}}
\par
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 716}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00716                                                         \{\par
00717   {\cf19 return} per_thread_test_part_result_reporter_.get();\par
00718 \}\par
}
}
{\xe \v gtest_trace_stack\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:gtest_trace_stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b TraceInfo} > & testing::internal::UnitTestImpl::gtest_trace_stack (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 742}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00742                                             \{\par
00743     {\cf19 return} *(gtest_trace_stack_.pointer());\par
00744   \}\par
}
}
{\xe \v gtest_trace_stack\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:gtest_trace_stack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::vector< {\b TraceInfo} > & testing::internal::UnitTestImpl::gtest_trace_stack () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 745}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00745                                                         \{\par
00746     {\cf19 return} gtest_trace_stack_.get();\par
00747   \}\par
}
}
{\xe \v listeners\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:listeners}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestEventListeners} * testing::internal::UnitTestImpl::listeners (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 590}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00590 \{ {\cf19 return} &listeners_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b ConfigureXmlOutput()}, {\b PostFlagParsingInit()}, {\b testing::internal::DefaultGlobalTestPartResultReporter::ReportTestPartResult()}, {\b RunAllTests()} \'E8 {\b UnitTestImpl()}.}\par
}
{\xe \v ListTestsMatchingFilter\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:ListTestsMatchingFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::ListTestsMatchingFilter ()}}
\par
{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4864}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04864                                            \{\par
04865   {\cf20 // Print at most this many characters for each type/value parameter.}\par
04866   {\cf17 const} {\cf18 int} kMaxParamLength = 250;\par
04867 \par
04868   {\cf19 for} ({\cf18 size_t} i = 0; i < test_cases_.size(); i++) \{\par
04869     {\cf17 const} TestCase* {\cf17 const} test_case = test_cases_[i];\par
04870     {\cf18 bool} printed_test_case_name = {\cf17 false};\par
04871 \par
04872     {\cf19 for} ({\cf18 size_t} j = 0; j < test_case->test_info_list().size(); j++) \{\par
04873       {\cf17 const} TestInfo* {\cf17 const} test_info =\par
04874           test_case->test_info_list()[j];\par
04875       {\cf19 if} (test_info->matches_filter_) \{\par
04876         {\cf19 if} (!printed_test_case_name) \{\par
04877           printed_test_case_name = {\cf17 true};\par
04878           printf({\cf22 "%s."}, test_case->name());\par
04879           {\cf19 if} (test_case->type_param() != NULL) \{\par
04880             printf({\cf22 "  # %s = "}, kTypeParamLabel);\par
04881             {\cf20 // We print the type parameter on a single line to make}\par
04882             {\cf20 // the output easy to parse by a program.}\par
04883             PrintOnOneLine(test_case->type_param(), kMaxParamLength);\par
04884           \}\par
04885           printf({\cf22 "\\n"});\par
04886         \}\par
04887         printf({\cf22 "  %s"}, test_info->name());\par
04888         {\cf19 if} (test_info->value_param() != NULL) \{\par
04889           printf({\cf22 "  # %s = "}, kValueParamLabel);\par
04890           {\cf20 // We print the value parameter on a single line to make the}\par
04891           {\cf20 // output easy to parse by a program.}\par
04892           PrintOnOneLine(test_info->value_param(), kMaxParamLength);\par
04893         \}\par
04894         printf({\cf22 "\\n"});\par
04895       \}\par
04896     \}\par
04897   \}\par
04898   fflush(stdout);\par
04899 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestInfo::name()}, {\b testing::TestCase::name()}, {\b testing::TestCase::type_param()} \'E8 {\b testing::TestInfo::value_param()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b RunAllTests()}.}\par
}
{\xe \v os_stack_trace_getter\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:os_stack_trace_getter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b OsStackTraceGetterInterface} * testing::internal::UnitTestImpl::os_stack_trace_getter ()}}
\par
{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4917}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04917                                                                  \{\par
04918   {\cf19 if} (os_stack_trace_getter_ == NULL) \{\par
04919 {\cf21 #ifdef GTEST_OS_STACK_TRACE_GETTER_}\par
04920     os_stack_trace_getter_ = {\cf17 new} GTEST_OS_STACK_TRACE_GETTER_;\par
04921 {\cf21 #else}\par
04922     os_stack_trace_getter_ = {\cf17 new} OsStackTraceGetter;\par
04923 {\cf21 #endif  }{\cf20 // GTEST_OS_STACK_TRACE_GETTER_}\par
04924   \}\par
04925 \par
04926   {\cf19 return} os_stack_trace_getter_;\par
04927 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b CurrentOsStackTraceExceptTop()}.}\par
}
{\xe \v Passed\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:Passed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::UnitTestImpl::Passed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 567}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00567 \{ {\cf19 return} !Failed(); \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b RunAllTests()}.}\par
}
{\xe \v PostFlagParsingInit\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:PostFlagParsingInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::PostFlagParsingInit ()}}
\par
{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4435}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04435                                        \{\par
04436   {\cf20 // Ensures that this function does not execute more than once.}\par
04437   {\cf19 if} (!post_flag_parse_init_performed_) \{\par
04438     post_flag_parse_init_performed_ = {\cf17 true};\par
04439 \par
04440 {\cf21 #if defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)}\par
04441     {\cf20 // Register to send notifications about key process state changes.}\par
04442     listeners()->Append({\cf17 new} GTEST_CUSTOM_TEST_EVENT_LISTENER_());\par
04443 {\cf21 #endif  }{\cf20 // defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)}\par
04444 \par
04445 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
04446     InitDeathTestSubprocessControlInfo();\par
04447     SuppressTestEventsIfInSubprocess();\par
04448 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
04449 \par
04450     {\cf20 // Registers parameterized tests. This makes parameterized tests}\par
04451     {\cf20 // available to the UnitTest reflection API without running}\par
04452     {\cf20 // RUN_ALL_TESTS.}\par
04453     RegisterParameterizedTests();\par
04454 \par
04455     {\cf20 // Configures listeners for XML output. This makes it possible for users}\par
04456     {\cf20 // to shut down the default XML output before invoking RUN_ALL_TESTS.}\par
04457     ConfigureXmlOutput();\par
04458 \par
04459 {\cf21 #if GTEST_CAN_STREAM_RESULTS_}\par
04460     {\cf20 // Configures listeners for streaming test results to the specified server.}\par
04461     ConfigureStreamingOutput();\par
04462 {\cf21 #endif  }{\cf20 // GTEST_CAN_STREAM_RESULTS_}\par
04463   \}\par
04464 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestEventListeners::Append()}, {\b ConfigureXmlOutput()}, {\b listeners()} \'E8 {\b RegisterParameterizedTests()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::InitGoogleTestImpl()} \'E8 {\b RunAllTests()}.}\par
}
{\xe \v random\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:random}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b internal::Random} * testing::internal::UnitTestImpl::random (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 792}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00792 \{ {\cf19 return} &random_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b RunAllTests()} \'E8 {\b ShuffleTests()}.}\par
}
{\xe \v random_seed\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:random_seed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::UnitTestImpl::random_seed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 789}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00789 \{ {\cf19 return} random_seed_; \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::UnitTest::random_seed()} \'E8 {\b RunAllTests()}.}\par
}
{\xe \v RecordProperty\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:RecordProperty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::RecordProperty (const {\b TestProperty} &  {\i test_property})}}
\par
{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4371}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04371                                                                    \{\par
04372   std::string xml_element;\par
04373   TestResult* test_result;  {\cf20 // TestResult appropriate for property recording.}\par
04374 \par
04375   {\cf19 if} (current_test_info_ != NULL) \{\par
04376     xml_element = {\cf22 "testcase"};\par
04377     test_result = &(current_test_info_->result_);\par
04378   \} {\cf19 else} {\cf19 if} (current_test_case_ != NULL) \{\par
04379     xml_element = {\cf22 "testsuite"};\par
04380     test_result = &(current_test_case_->ad_hoc_test_result_);\par
04381   \} {\cf19 else} \{\par
04382     xml_element = {\cf22 "testsuites"};\par
04383     test_result = &ad_hoc_test_result_;\par
04384   \}\par
04385   test_result->RecordProperty(xml_element, test_property);\par
04386 \}\par
}
}
{\xe \v RegisterParameterizedTests\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:RegisterParameterizedTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::RegisterParameterizedTests ()}}
\par
{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2614}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02614                                               \{\par
02615 {\cf21 #if GTEST_HAS_PARAM_TEST}\par
02616   {\cf19 if} (!parameterized_tests_registered_) \{\par
02617     parameterized_test_registry_.RegisterTests();\par
02618     parameterized_tests_registered_ = {\cf17 true};\par
02619   \}\par
02620 {\cf21 #endif}\par
02621 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b PostFlagParsingInit()}.}\par
}
{\xe \v reportable_disabled_test_count\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:reportable_disabled_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::UnitTestImpl::reportable_disabled_test_count () const}}
\par
{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 758}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00758                                                        \{\par
00759   {\cf19 return} SumOverTestCaseList(test_cases_,\par
00760                              &TestCase::reportable_disabled_test_count);\par
00761 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestCase::reportable_disabled_test_count()}.}\par
}
{\xe \v reportable_test_count\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:reportable_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::UnitTestImpl::reportable_test_count () const}}
\par
{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 769}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00769                                               \{\par
00770   {\cf19 return} SumOverTestCaseList(test_cases_, &TestCase::reportable_test_count);\par
00771 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestCase::reportable_test_count()}.}\par
}
{\xe \v RunAllTests\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:RunAllTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::UnitTestImpl::RunAllTests ()}}
\par
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4550}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04550                                \{\par
04551   {\cf20 // Makes sure InitGoogleTest() was called.}\par
04552   {\cf19 if} (!GTestIsInitialized()) \{\par
04553     printf({\cf22 "%s"},\par
04554            {\cf22 "\\nThis test program did NOT call ::testing::InitGoogleTest "}\par
04555            {\cf22 "before calling RUN_ALL_TESTS().  Please fix it.\\n"});\par
04556     {\cf19 return} {\cf17 false};\par
04557   \}\par
04558 \par
04559   {\cf20 // Do not run any test if the --help flag was specified.}\par
04560   {\cf19 if} (g_help_flag)\par
04561     {\cf19 return} {\cf17 true};\par
04562 \par
04563   {\cf20 // Repeats the call to the post-flag parsing initialization in case the}\par
04564   {\cf20 // user didn't call InitGoogleTest.}\par
04565   PostFlagParsingInit();\par
04566 \par
04567   {\cf20 // Even if sharding is not on, test runners may want to use the}\par
04568   {\cf20 // GTEST_SHARD_STATUS_FILE to query whether the test supports the sharding}\par
04569   {\cf20 // protocol.}\par
04570   internal::WriteToShardStatusFileIfNeeded();\par
04571 \par
04572   {\cf20 // True iff we are in a subprocess for running a thread-safe-style}\par
04573   {\cf20 // death test.}\par
04574   {\cf18 bool} in_subprocess_for_death_test = {\cf17 false};\par
04575 \par
04576 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
04577   in_subprocess_for_death_test = (internal_run_death_test_flag_.get() != NULL);\par
04578 {\cf21 # if defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)}\par
04579   {\cf19 if} (in_subprocess_for_death_test) \{\par
04580     GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_();\par
04581   \}\par
04582 {\cf21 # endif  }{\cf20 // defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)}\par
04583 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
04584 \par
04585   {\cf17 const} {\cf18 bool} should_shard = ShouldShard(kTestTotalShards, kTestShardIndex,\par
04586                                         in_subprocess_for_death_test);\par
04587 \par
04588   {\cf20 // Compares the full test names with the filter to decide which}\par
04589   {\cf20 // tests to run.}\par
04590   {\cf17 const} {\cf18 bool} has_tests_to_run = FilterTests(should_shard\par
04591                                               ? HONOR_SHARDING_PROTOCOL\par
04592                                               : IGNORE_SHARDING_PROTOCOL) > 0;\par
04593 \par
04594   {\cf20 // Lists the tests and exits if the --gtest_list_tests flag was specified.}\par
04595   {\cf19 if} (GTEST_FLAG(list_tests)) \{\par
04596     {\cf20 // This must be called *after* FilterTests() has been called.}\par
04597     ListTestsMatchingFilter();\par
04598     {\cf19 return} {\cf17 true};\par
04599   \}\par
04600 \par
04601   random_seed_ = GTEST_FLAG(shuffle) ?\par
04602       GetRandomSeedFromFlag(GTEST_FLAG(random_seed)) : 0;\par
04603 \par
04604   {\cf20 // True iff at least one test has failed.}\par
04605   {\cf18 bool} failed = {\cf17 false};\par
04606 \par
04607   TestEventListener* repeater = listeners()->repeater();\par
04608 \par
04609   start_timestamp_ = GetTimeInMillis();\par
04610   repeater->OnTestProgramStart(*parent_);\par
04611 \par
04612   {\cf20 // How many times to repeat the tests?  We don't want to repeat them}\par
04613   {\cf20 // when we are inside the subprocess of a death test.}\par
04614   {\cf17 const} {\cf18 int} repeat = in_subprocess_for_death_test ? 1 : GTEST_FLAG(repeat);\par
04615   {\cf20 // Repeats forever if the repeat count is negative.}\par
04616   {\cf17 const} {\cf18 bool} forever = repeat < 0;\par
04617   {\cf19 for} ({\cf18 int} i = 0; forever || i != repeat; i++) \{\par
04618     {\cf20 // We want to preserve failures generated by ad-hoc test}\par
04619     {\cf20 // assertions executed before RUN_ALL_TESTS().}\par
04620     ClearNonAdHocTestResult();\par
04621 \par
04622     {\cf17 const} TimeInMillis start = GetTimeInMillis();\par
04623 \par
04624     {\cf20 // Shuffles test cases and tests if requested.}\par
04625     {\cf19 if} (has_tests_to_run && GTEST_FLAG(shuffle)) \{\par
04626       random()->Reseed(random_seed_);\par
04627       {\cf20 // This should be done before calling OnTestIterationStart(),}\par
04628       {\cf20 // such that a test event listener can see the actual test order}\par
04629       {\cf20 // in the event.}\par
04630       ShuffleTests();\par
04631     \}\par
04632 \par
04633     {\cf20 // Tells the unit test event listeners that the tests are about to start.}\par
04634     repeater->OnTestIterationStart(*parent_, i);\par
04635 \par
04636     {\cf20 // Runs each test case if there is at least one test to run.}\par
04637     {\cf19 if} (has_tests_to_run) \{\par
04638       {\cf20 // Sets up all environments beforehand.}\par
04639       repeater->OnEnvironmentsSetUpStart(*parent_);\par
04640       ForEach(environments_, SetUpEnvironment);\par
04641       repeater->OnEnvironmentsSetUpEnd(*parent_);\par
04642 \par
04643       {\cf20 // Runs the tests only if there was no fatal failure during global}\par
04644       {\cf20 // set-up.}\par
04645       {\cf19 if} (!Test::HasFatalFailure()) \{\par
04646         {\cf19 for} ({\cf18 int} test_index = 0; test_index < total_test_case_count();\par
04647              test_index++) \{\par
04648           GetMutableTestCase(test_index)->Run();\par
04649         \}\par
04650       \}\par
04651 \par
04652       {\cf20 // Tears down all environments in reverse order afterwards.}\par
04653       repeater->OnEnvironmentsTearDownStart(*parent_);\par
04654       std::for_each(environments_.rbegin(), environments_.rend(),\par
04655                     TearDownEnvironment);\par
04656       repeater->OnEnvironmentsTearDownEnd(*parent_);\par
04657     \}\par
04658 \par
04659     elapsed_time_ = GetTimeInMillis() - start;\par
04660 \par
04661     {\cf20 // Tells the unit test event listener that the tests have just finished.}\par
04662     repeater->OnTestIterationEnd(*parent_, i);\par
04663 \par
04664     {\cf20 // Gets the result and clears it.}\par
04665     {\cf19 if} (!Passed()) \{\par
04666       failed = {\cf17 true};\par
04667     \}\par
04668 \par
04669     {\cf20 // Restores the original test order after the iteration.  This}\par
04670     {\cf20 // allows the user to quickly repro a failure that happens in the}\par
04671     {\cf20 // N-th iteration without repeating the first (N - 1) iterations.}\par
04672     {\cf20 // This is not enclosed in "if (GTEST_FLAG(shuffle)) \{ ... \}", in}\par
04673     {\cf20 // case the user somehow changes the value of the flag somewhere}\par
04674     {\cf20 // (it's always safe to unshuffle the tests).}\par
04675     UnshuffleTests();\par
04676 \par
04677     {\cf19 if} (GTEST_FLAG(shuffle)) \{\par
04678       {\cf20 // Picks a new random seed for each iteration.}\par
04679       random_seed_ = GetNextRandomSeed(random_seed_);\par
04680     \}\par
04681   \}\par
04682 \par
04683   repeater->OnTestProgramEnd(*parent_);\par
04684 \par
04685   {\cf19 return} !failed;\par
04686 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ClearNonAdHocTestResult()}, {\b FilterTests()}, {\b testing::internal::ForEach()}, {\b testing::internal::g_help_flag}, {\b GetMutableTestCase()}, {\b testing::internal::GetNextRandomSeed()}, {\b testing::internal::GetRandomSeedFromFlag()}, {\b testing::internal::GetTimeInMillis()}, {\b GTEST_FLAG}, {\b testing::Test::HasFatalFailure()}, {\b HONOR_SHARDING_PROTOCOL}, {\b IGNORE_SHARDING_PROTOCOL}, {\b listeners()}, {\b ListTestsMatchingFilter()}, {\b testing::TestEventListener::OnEnvironmentsSetUpEnd()}, {\b testing::TestEventListener::OnEnvironmentsSetUpStart()}, {\b testing::TestEventListener::OnEnvironmentsTearDownEnd()}, {\b testing::TestEventListener::OnEnvironmentsTearDownStart()}, {\b testing::TestEventListener::OnTestIterationEnd()}, {\b testing::TestEventListener::OnTestIterationStart()}, {\b testing::TestEventListener::OnTestProgramEnd()}, {\b testing::TestEventListener::OnTestProgramStart()}, {\b Passed()}, {\b PostFlagParsingInit()}, {\b random()}, {\b random_seed()}, {\b testing::internal::Random::Reseed()}, {\b testing::internal::ShouldShard()}, {\b ShuffleTests()}, {\b total_test_case_count()}, {\b UnshuffleTests()} \'E8 {\b testing::internal::WriteToShardStatusFileIfNeeded()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::UnitTest::Run()}.}\par
}
{\xe \v set_current_test_case\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:set_current_test_case}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::set_current_test_case ({\b TestCase} *  {\i a_current_test_case}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 676}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00676                                                             \{\par
00677     current_test_case_ = a_current_test_case;\par
00678   \}\par
}
}
{\xe \v set_current_test_info\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:set_current_test_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::set_current_test_info ({\b TestInfo} *  {\i a_current_test_info}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 683}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00683                                                             \{\par
00684     current_test_info_ = a_current_test_info;\par
00685   \}\par
}
}
{\xe \v set_os_stack_trace_getter\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:set_os_stack_trace_getter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::set_os_stack_trace_getter ({\b OsStackTraceGetterInterface} *  {\i getter})}}
\par
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4906}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04907                                          \{\par
04908   {\cf19 if} (os_stack_trace_getter_ != getter) \{\par
04909     {\cf17 delete} os_stack_trace_getter_;\par
04910     os_stack_trace_getter_ = getter;\par
04911   \}\par
04912 \}\par
}
}
{\xe \v SetGlobalTestPartResultReporter\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:SetGlobalTestPartResultReporter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::SetGlobalTestPartResultReporter ({\b TestPartResultReporterInterface} *  {\i reporter})}}
\par
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 708}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00709                                                \{\par
00710   internal::MutexLock lock(&global_test_part_result_reporter_mutex_);\par
00711   global_test_part_result_repoter_ = reporter;\par
00712 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter()}.}\par
}
{\xe \v SetTestPartResultReporterForCurrentThread\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:SetTestPartResultReporterForCurrentThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::SetTestPartResultReporterForCurrentThread ({\b TestPartResultReporterInterface} *  {\i reporter})}}
\par
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 721}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00722                                                \{\par
00723   per_thread_test_part_result_reporter_.set(reporter);\par
00724 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::HasNewFatalFailureHelper::HasNewFatalFailureHelper()}, {\b testing::internal::HasNewFatalFailureHelper::~HasNewFatalFailureHelper()} \'E8 {\b testing::ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter()}.}\par
}
{\xe \v ShuffleTests\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:ShuffleTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::ShuffleTests ()}}
\par
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4938}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04938                                 \{\par
04939   {\cf20 // Shuffles the death test cases.}\par
04940   ShuffleRange(random(), 0, last_death_test_case_ + 1, &test_case_indices_);\par
04941 \par
04942   {\cf20 // Shuffles the non-death test cases.}\par
04943   ShuffleRange(random(), last_death_test_case_ + 1,\par
04944                {\cf17 static_cast<}{\cf18 int}{\cf17 >}(test_cases_.size()), &test_case_indices_);\par
04945 \par
04946   {\cf20 // Shuffles the tests inside each test case.}\par
04947   {\cf19 for} ({\cf18 size_t} i = 0; i < test_cases_.size(); i++) \{\par
04948     test_cases_[i]->ShuffleTests(random());\par
04949   \}\par
04950 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b random()} \'E8 {\b testing::internal::ShuffleRange()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b RunAllTests()}.}\par
}
{\xe \v start_timestamp\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:start_timestamp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TimeInMillis} testing::internal::UnitTestImpl::start_timestamp () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 561}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00561 \{ {\cf19 return} start_timestamp_; \}\par
}
}
{\xe \v successful_test_case_count\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:successful_test_case_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::UnitTestImpl::successful_test_case_count () const}}
\par
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 727}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00727                                                    \{\par
00728   {\cf19 return} CountIf(test_cases_, TestCasePassed);\par
00729 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CountIf()}.}\par
}
{\xe \v successful_test_count\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:successful_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::UnitTestImpl::successful_test_count () const}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 748}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00748                                               \{\par
00749   {\cf19 return} SumOverTestCaseList(test_cases_, &TestCase::successful_test_count);\par
00750 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestCase::successful_test_count()}.}\par
}
{\xe \v test_case_to_run_count\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:test_case_to_run_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::UnitTestImpl::test_case_to_run_count () const}}
\par
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 743}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00743                                                \{\par
00744   {\cf19 return} CountIf(test_cases_, ShouldRunTestCase);\par
00745 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::CountIf()}.}\par
}
{\xe \v test_to_run_count\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:test_to_run_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::UnitTestImpl::test_to_run_count () const}}
\par
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 779}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00779                                           \{\par
00780   {\cf19 return} SumOverTestCaseList(test_cases_, &TestCase::test_to_run_count);\par
00781 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestCase::test_to_run_count()}.}\par
}
{\xe \v total_test_case_count\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:total_test_case_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::UnitTestImpl::total_test_case_count () const}}
\par
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 737}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00737                                               \{\par
00738   {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(test_cases_.size());\par
00739 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b RunAllTests()}.}\par
}
{\xe \v total_test_count\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:total_test_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int testing::internal::UnitTestImpl::total_test_count () const}}
\par
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 774}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00774                                          \{\par
00775   {\cf19 return} SumOverTestCaseList(test_cases_, &TestCase::total_test_count);\par
00776 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::TestCase::total_test_count()}.}\par
}
{\xe \v UnshuffleTests\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:UnshuffleTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::UnitTestImpl::UnshuffleTests ()}}
\par
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 4953}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 04953                                   \{\par
04954   {\cf19 for} ({\cf18 size_t} i = 0; i < test_cases_.size(); i++) \{\par
04955     {\cf20 // Unshuffles the tests in each test case.}\par
04956     test_cases_[i]->UnshuffleTests();\par
04957     {\cf20 // Resets the index of each test case.}\par
04958     test_case_indices_[i] = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(i);\par
04959   \}\par
04960 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b RunAllTests()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'C4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FF \'EF\'EE \'E4\'F0\'F3\'E7\'FC\'FF\'EC \'EA\'EB\'E0\'F1\'F1\'E0 \'E8 \'F4\'F3\'ED\'EA\'F6\'E8\'FF\'EC, \'EE\'F2\'ED\'EE\'F1\'FF\'F9\'E8\'EC\'F1\'FF \'EA \'EA\'EB\'E0\'F1\'F1\'F3\par
\pard\plain 
{\xe \v ::testing::UnitTest\:testing::internal::UnitTestImpl}
{\xe \v testing::internal::UnitTestImpl\:::testing::UnitTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b ::testing::UnitTest}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 806}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-internal-inl.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::UnitTestOptions\par \pard\plain 
{\tc\tcl2 \v testing::internal::UnitTestOptions}
{\xe \v testing::internal::UnitTestOptions}
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
\par
{
{\f2 #include <gtest-internal-inl.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b GetOutputFormat} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b GetAbsolutePathToOutputFile} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b PatternMatchesString} (const char *pattern, const char *str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b FilterMatchesTest} (const std::string &test_case_name, const std::string &test_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b MatchesFilter} (const std::string &name, const char *filter)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal-inl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 373}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v FilterMatchesTest\:testing::internal::UnitTestOptions}
{\xe \v testing::internal::UnitTestOptions\:FilterMatchesTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::UnitTestOptions::FilterMatchesTest (const std::string &  {\i test_case_name}, const std::string &  {\i test_name}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 502}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00503                                                                     \{\par
00504   {\cf17 const} std::string& full_name = test_case_name + {\cf22 "."} + test_name.c_str();\par
00505 \par
00506   {\cf20 // Split --gtest_filter at '-', if there is one, to separate into}\par
00507   {\cf20 // positive filter and negative filter portions}\par
00508   {\cf17 const} {\cf18 char}* {\cf17 const} p = GTEST_FLAG(filter).c_str();\par
00509   {\cf17 const} {\cf18 char}* {\cf17 const} dash = strchr(p, {\cf23 '-'});\par
00510   std::string positive;\par
00511   std::string negative;\par
00512   {\cf19 if} (dash == NULL) \{\par
00513     positive = GTEST_FLAG(filter).c_str();  {\cf20 // Whole string is a positive filter}\par
00514     negative = {\cf22 ""};\par
00515   \} {\cf19 else} \{\par
00516     positive = std::string(p, dash);   {\cf20 // Everything up to the dash}\par
00517     negative = std::string(dash + 1);  {\cf20 // Everything after the dash}\par
00518     {\cf19 if} (positive.empty()) \{\par
00519       {\cf20 // Treat '-test1' as the same as '*-test1'}\par
00520       positive = kUniversalFilter;\par
00521     \}\par
00522   \}\par
00523 \par
00524   {\cf20 // A filter is a colon-separated list of patterns.  It matches a}\par
00525   {\cf20 // test if any pattern in it matches the test.}\par
00526   {\cf19 return} (MatchesFilter(full_name, positive.c_str()) &&\par
00527           !MatchesFilter(full_name, negative.c_str()));\par
00528 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GTEST_FLAG} \'E8 {\b MatchesFilter()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::FilterTests()}.}\par
}
{\xe \v GetAbsolutePathToOutputFile\:testing::internal::UnitTestOptions}
{\xe \v testing::internal::UnitTestOptions\:GetAbsolutePathToOutputFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::UnitTestOptions::GetAbsolutePathToOutputFile (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 426}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00426                                                        \{\par
00427   {\cf17 const} {\cf18 char}* {\cf17 const} gtest_output_flag = GTEST_FLAG(output).c_str();\par
00428   {\cf19 if} (gtest_output_flag == NULL)\par
00429     {\cf19 return} {\cf22 ""};\par
00430 \par
00431   {\cf17 const} {\cf18 char}* {\cf17 const} colon = strchr(gtest_output_flag, {\cf23 ':'});\par
00432   {\cf19 if} (colon == NULL)\par
00433     {\cf19 return} internal::FilePath::ConcatPaths(\par
00434         internal::FilePath(\par
00435             UnitTest::GetInstance()->original_working_dir()),\par
00436         internal::FilePath(kDefaultOutputFile)).string();\par
00437 \par
00438   internal::FilePath output_name(colon + 1);\par
00439   {\cf19 if} (!output_name.IsAbsolutePath())\par
00440     {\cf20 // TODO(wan@google.com): on Windows \\some\\path is not an absolute}\par
00441     {\cf20 // path (as its meaning depends on the current drive), yet the}\par
00442     {\cf20 // following logic for turning it into an absolute path is wrong.}\par
00443     {\cf20 // Fix it.}\par
00444     output_name = internal::FilePath::ConcatPaths(\par
00445         internal::FilePath(UnitTest::GetInstance()->original_working_dir()),\par
00446         internal::FilePath(colon + 1));\par
00447 \par
00448   {\cf19 if} (!output_name.IsDirectory())\par
00449     {\cf19 return} output_name.string();\par
00450 \par
00451   internal::FilePath result(internal::FilePath::GenerateUniqueFileName(\par
00452       output_name, internal::GetCurrentExecutableName(),\par
00453       GetOutputFormat().c_str()));\par
00454   {\cf19 return} result.string();\par
00455 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::FilePath::ConcatPaths()}, {\b testing::internal::FilePath::GenerateUniqueFileName()}, {\b testing::internal::GetCurrentExecutableName()}, {\b testing::UnitTest::GetInstance()}, {\b GetOutputFormat()}, {\b GTEST_FLAG}, {\b testing::internal::FilePath::IsAbsolutePath()}, {\b testing::internal::FilePath::IsDirectory()} \'E8 {\b testing::internal::FilePath::string()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::ConfigureXmlOutput()}.}\par
}
{\xe \v GetOutputFormat\:testing::internal::UnitTestOptions}
{\xe \v testing::internal::UnitTestOptions\:GetOutputFormat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string testing::internal::UnitTestOptions::GetOutputFormat (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 414}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00414                                            \{\par
00415   {\cf17 const} {\cf18 char}* {\cf17 const} gtest_output_flag = GTEST_FLAG(output).c_str();\par
00416   {\cf19 if} (gtest_output_flag == NULL) {\cf19 return} std::string({\cf22 ""});\par
00417 \par
00418   {\cf17 const} {\cf18 char}* {\cf17 const} colon = strchr(gtest_output_flag, {\cf23 ':'});\par
00419   {\cf19 return} (colon == NULL) ?\par
00420       std::string(gtest_output_flag) :\par
00421       std::string(gtest_output_flag, colon - gtest_output_flag);\par
00422 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b GTEST_FLAG}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UnitTestImpl::ConfigureXmlOutput()} \'E8 {\b GetAbsolutePathToOutputFile()}.}\par
}
{\xe \v MatchesFilter\:testing::internal::UnitTestOptions}
{\xe \v testing::internal::UnitTestOptions\:MatchesFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::UnitTestOptions::MatchesFilter (const std::string &  {\i name}, const char *  {\i filter}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 479}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00480                                                \{\par
00481   {\cf17 const} {\cf18 char} *cur_pattern = filter;\par
00482   {\cf19 for} (;;) \{\par
00483     {\cf19 if} (PatternMatchesString(cur_pattern, name.c_str())) \{\par
00484       {\cf19 return} {\cf17 true};\par
00485     \}\par
00486 \par
00487     {\cf20 // Finds the next pattern in the filter.}\par
00488     cur_pattern = strchr(cur_pattern, {\cf23 ':'});\par
00489 \par
00490     {\cf20 // Returns if no more pattern can be found.}\par
00491     {\cf19 if} (cur_pattern == NULL) \{\par
00492       {\cf19 return} {\cf17 false};\par
00493     \}\par
00494 \par
00495     {\cf20 // Skips the pattern separater (the ':' character).}\par
00496     cur_pattern++;\par
00497   \}\par
00498 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b PatternMatchesString()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b FilterMatchesTest()}, {\b testing::internal::UnitTestImpl::FilterTests()} \'E8 {\b testing::internal::UnitTestImpl::GetTestCase()}.}\par
}
{\xe \v PatternMatchesString\:testing::internal::UnitTestOptions}
{\xe \v testing::internal::UnitTestOptions\:PatternMatchesString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool testing::internal::UnitTestOptions::PatternMatchesString (const char *  {\i pattern}, const char *  {\i str}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 462}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00463                                                             \{\par
00464   {\cf19 switch} (*pattern) \{\par
00465     {\cf19 case} {\cf23 '\\0'}:\par
00466     {\cf19 case} {\cf23 ':'}:  {\cf20 // Either ':' or '\\0' marks the end of the pattern.}\par
00467       {\cf19 return} *str == {\cf23 '\\0'};\par
00468     {\cf19 case} {\cf23 '?'}:  {\cf20 // Matches any single character.}\par
00469       {\cf19 return} *str != {\cf23 '\\0'} && PatternMatchesString(pattern + 1, str + 1);\par
00470     {\cf19 case} {\cf23 '*'}:  {\cf20 // Matches any string (possibly empty) of characters.}\par
00471       {\cf19 return} (*str != {\cf23 '\\0'} && PatternMatchesString(pattern, str + 1)) ||\par
00472           PatternMatchesString(pattern + 1, str);\par
00473     {\cf19 default}:  {\cf20 // Non-special character.  Matches itself.}\par
00474       {\cf19 return} *pattern == *str &&\par
00475           PatternMatchesString(pattern + 1, str + 1);\par
00476   \}\par
00477 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b PatternMatchesString()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b MatchesFilter()} \'E8 {\b PatternMatchesString()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'EE\'E2 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E0\'F5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest-internal-inl.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::UniversalPrinter< T >\par \pard\plain 
{\tc\tcl2 \v testing::internal::UniversalPrinter< T >}
{\xe \v testing::internal::UniversalPrinter< T >}
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
\par
{
{\f2 #include <gtest-printers.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b Print} (const T &value, ::std::ostream *os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class testing::internal::UniversalPrinter< T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 702}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Print\:testing::internal::UniversalPrinter< T >}
{\xe \v testing::internal::UniversalPrinter< T >\:Print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static void {\b testing::internal::UniversalPrinter}< T >::Print (const T &  {\i value}, ::std::ostream *  {\i os}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 711}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00711                                                     \{\par
00712     {\cf20 // By default, ::testing::internal::PrintTo() is used for printing}\par
00713     {\cf20 // the value.}\par
00714     {\cf20 //}\par
00715     {\cf20 // Thanks to Koenig look-up, if T is a class and has its own}\par
00716     {\cf20 // PrintTo() function defined in its namespace, that function will}\par
00717     {\cf20 // be visible here.  Since it is more specific than the generic ones}\par
00718     {\cf20 // in ::testing::internal, it will be picked by the compiler in the}\par
00719     {\cf20 // following statement - exactly what we want.}\par
00720     PrintTo(value, os);\par
00721   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::PrintTo()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UniversalTersePrinter< T[N]>::Print()}, {\b testing::internal::PrintTo()} \'E8 {\b testing::internal::UniversalPrint()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::UniversalPrinter< T & >\par \pard\plain 
{\tc\tcl2 \v testing::internal::UniversalPrinter< T & >}
{\xe \v testing::internal::UniversalPrinter< T & >}
{\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
\par
{
{\f2 #include <gtest-printers.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b Print} (const T &value, ::std::ostream *os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class testing::internal::UniversalPrinter< T & >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 771}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Print\:testing::internal::UniversalPrinter< T & >}
{\xe \v testing::internal::UniversalPrinter< T & >\:Print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static void {\b testing::internal::UniversalPrinter}< T & >::Print (const T &  {\i value}, ::std::ostream *  {\i os}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 777}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00777                                                     \{\par
00778     {\cf20 // Prints the address of the value.  We use reinterpret_cast here}\par
00779     {\cf20 // as static_cast doesn't compile when T is a function type.}\par
00780     *os << {\cf22 "@"} << {\cf17 reinterpret_cast<}{\cf17 const }{\cf18 void}*{\cf17 >}(&value) << {\cf22 " "};\par
00781 \par
00782     {\cf20 // Then prints the value itself.}\par
00783     UniversalPrint(value, os);\par
00784   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UniversalPrint()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::UniversalPrinter< T[N]>\par \pard\plain 
{\tc\tcl2 \v testing::internal::UniversalPrinter< T[N]>}
{\xe \v testing::internal::UniversalPrinter< T[N]>}
{\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
\par
{
{\f2 #include <gtest-printers.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b Print} (const T(&a)[N], ::std::ostream *os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, size_t N>\par
class testing::internal::UniversalPrinter< T[N]>\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 760}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Print\:testing::internal::UniversalPrinter< T[N]>}
{\xe \v testing::internal::UniversalPrinter< T[N]>\:Print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , size_t N> static void {\b testing::internal::UniversalPrinter}< T[N]>::Print (const T(&)  {\i a}[N], ::std::ostream *  {\i os}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 764}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00764                                                      \{\par
00765     UniversalPrintArray(a, N, os);\par
00766   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UniversalPrintArray()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::UniversalTersePrinter< T >\par \pard\plain 
{\tc\tcl2 \v testing::internal::UniversalTersePrinter< T >}
{\xe \v testing::internal::UniversalTersePrinter< T >}
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
\par
{
{\f2 #include <gtest-printers.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b Print} (const T &value, ::std::ostream *os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class testing::internal::UniversalTersePrinter< T >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 794}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Print\:testing::internal::UniversalTersePrinter< T >}
{\xe \v testing::internal::UniversalTersePrinter< T >\:Print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static void {\b testing::internal::UniversalTersePrinter}< T >::Print (const T &  {\i value}, ::std::ostream *  {\i os}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 796}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00796                                                     \{\par
00797     UniversalPrint(value, os);\par
00798   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UniversalPrint()}.}\par
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b testing::internal::UniversalTersePrinter< char * >::Print()}, {\b testing::internal::UniversalTersePrinter< wchar_t * >::Print()}, {\b testing::PrintToString()} \'E8 {\b testing::internal::UniversalTersePrint()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::UniversalTersePrinter< char * >\par \pard\plain 
{\tc\tcl2 \v testing::internal::UniversalTersePrinter< char * >}
{\xe \v testing::internal::UniversalTersePrinter< char * >}
{\bkmkstart AAAAAAABYQ}
{\bkmkend AAAAAAABYQ}
\par
{
{\f2 #include <gtest-printers.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b Print} (char *str, ::std::ostream *os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 826}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Print\:testing::internal::UniversalTersePrinter< char * >}
{\xe \v testing::internal::UniversalTersePrinter< char * >\:Print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void {\b testing::internal::UniversalTersePrinter}< char * >::Print (char *  {\i str}, ::std::ostream *  {\i os}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYR}
{\bkmkend AAAAAAABYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 828}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00828                                                \{\par
00829     UniversalTersePrinter<const char*>::Print(str, os);\par
00830   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UniversalTersePrinter< T >::Print()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::UniversalTersePrinter< const char * >\par \pard\plain 
{\tc\tcl2 \v testing::internal::UniversalTersePrinter< const char * >}
{\xe \v testing::internal::UniversalTersePrinter< const char * >}
{\bkmkstart AAAAAAABYS}
{\bkmkend AAAAAAABYS}
\par
{
{\f2 #include <gtest-printers.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b Print} (const char *str, ::std::ostream *os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 815}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Print\:testing::internal::UniversalTersePrinter< const char * >}
{\xe \v testing::internal::UniversalTersePrinter< const char * >\:Print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void {\b testing::internal::UniversalTersePrinter}< const char * >::Print (const char *  {\i str}, ::std::ostream *  {\i os}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYT}
{\bkmkend AAAAAAABYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 817}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00817                                                      \{\par
00818     {\cf19 if} (str == NULL) \{\par
00819       *os << {\cf22 "NULL"};\par
00820     \} {\cf19 else} \{\par
00821       UniversalPrint(std::string(str), os);\par
00822     \}\par
00823   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UniversalPrint()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::UniversalTersePrinter< T & >\par \pard\plain 
{\tc\tcl2 \v testing::internal::UniversalTersePrinter< T & >}
{\xe \v testing::internal::UniversalTersePrinter< T & >}
{\bkmkstart AAAAAAABYU}
{\bkmkend AAAAAAABYU}
\par
{
{\f2 #include <gtest-printers.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b Print} (const T &value, ::std::ostream *os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class testing::internal::UniversalTersePrinter< T & >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 801}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Print\:testing::internal::UniversalTersePrinter< T & >}
{\xe \v testing::internal::UniversalTersePrinter< T & >\:Print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static void {\b testing::internal::UniversalTersePrinter}< T & >::Print (const T &  {\i value}, ::std::ostream *  {\i os}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYV}
{\bkmkend AAAAAAABYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 803}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00803                                                     \{\par
00804     UniversalPrint(value, os);\par
00805   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UniversalPrint()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'EA\'EB\'E0\'F1\'F1\'E0 testing::internal::UniversalTersePrinter< T[N]>\par \pard\plain 
{\tc\tcl2 \v testing::internal::UniversalTersePrinter< T[N]>}
{\xe \v testing::internal::UniversalTersePrinter< T[N]>}
{\bkmkstart AAAAAAABYW}
{\bkmkend AAAAAAABYW}
\par
{
{\f2 #include <gtest-printers.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b Print} (const T(&value)[N], ::std::ostream *os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, size_t N>\par
class testing::internal::UniversalTersePrinter< T[N]>\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 808}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Print\:testing::internal::UniversalTersePrinter< T[N]>}
{\xe \v testing::internal::UniversalTersePrinter< T[N]>\:Print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , size_t N> static void {\b testing::internal::UniversalTersePrinter}< T[N]>::Print (const T(&)  {\i value}[N], ::std::ostream *  {\i os}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYX}
{\bkmkend AAAAAAABYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 810}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00810                                                          \{\par
00811     UniversalPrinter<T[N]>::Print(value, os);\par
00812   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UniversalPrinter< T >::Print()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::UniversalTersePrinter< wchar_t * >\par \pard\plain 
{\tc\tcl2 \v testing::internal::UniversalTersePrinter< wchar_t * >}
{\xe \v testing::internal::UniversalTersePrinter< wchar_t * >}
{\bkmkstart AAAAAAABYY}
{\bkmkend AAAAAAABYY}
\par
{
{\f2 #include <gtest-printers.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F1\'F2\'E0\'F2\'E8\'F7\'E5\'F1\'EA\'E8\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b Print} (wchar_t *str, ::std::ostream *os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 848}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v Print\:testing::internal::UniversalTersePrinter< wchar_t * >}
{\xe \v testing::internal::UniversalTersePrinter< wchar_t * >\:Print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void {\b testing::internal::UniversalTersePrinter}< wchar_t * >::Print (wchar_t *  {\i str}, ::std::ostream *  {\i os}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYZ}
{\bkmkend AAAAAAABYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 850}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00850                                                   \{\par
00851     UniversalTersePrinter<const wchar_t*>::Print(str, os);\par
00852   \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::UniversalTersePrinter< T >::Print()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D8\'E0\'E1\'EB\'EE\'ED \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB testing::internal::WrapPrinterType< type >\par \pard\plain 
{\tc\tcl2 \v testing::internal::WrapPrinterType< type >}
{\xe \v testing::internal::WrapPrinterType< type >}
{\bkmkstart AAAAAAABZA}
{\bkmkend AAAAAAABZA}
\par
{
{\f2 #include <gtest-printers.h>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b DefaultPrinterType} type>\par
struct testing::internal::WrapPrinterType< type >\par
}
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 373}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'F1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/include/gtest/{\b gtest-printers.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'CA\'EB\'E0\'F1\'F1 testing::internal::XmlUnitTestResultPrinter\par \pard\plain 
{\tc\tcl2 \v testing::internal::XmlUnitTestResultPrinter}
{\xe \v testing::internal::XmlUnitTestResultPrinter}
{\bkmkstart AAAAAAABZB}
{\bkmkend AAAAAAABZB}
\'C3\'F0\'E0\'F4 \'ED\'E0\'F1\'EB\'E5\'E4\'EE\'E2\'E0\'ED\'E8\'FF:testing::internal::XmlUnitTestResultPrinter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtesting_1_1internal_1_1_xml_unit_test_result_printer.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'F2\'EA\'F0\'FB\'F2\'FB\'E5 \'F7\'EB\'E5\'ED\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XmlUnitTestResultPrinter} (const char *output_file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTestIterationEnd} (const {\b UnitTest} &unit_test, int iteration)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'EE\'E4\'F0\'EE\'E1\'ED\'EE\'E5 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'E5\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3347}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CA\'EE\'ED\'F1\'F2\'F0\'F3\'EA\'F2\'EE\'F0(\'FB)\par
\pard\plain 
{\xe \v XmlUnitTestResultPrinter\:testing::internal::XmlUnitTestResultPrinter}
{\xe \v testing::internal::XmlUnitTestResultPrinter\:XmlUnitTestResultPrinter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
testing::internal::XmlUnitTestResultPrinter::XmlUnitTestResultPrinter (const char *  {\i output_file}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABZC}
{\bkmkend AAAAAAABZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3420}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03421     : output_file_(output_file) \{\par
03422   {\cf19 if} (output_file_.c_str() == NULL || output_file_.empty()) \{\par
03423     fprintf(stderr, {\cf22 "XML output file may not be null\\n"});\par
03424     fflush(stderr);\par
03425     exit(EXIT_FAILURE);\par
03426   \}\par
03427 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E5\'F2\'EE\'E4\'FB\par
\pard\plain 
{\xe \v OnTestIterationEnd\:testing::internal::XmlUnitTestResultPrinter}
{\xe \v testing::internal::XmlUnitTestResultPrinter\:OnTestIterationEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void testing::internal::XmlUnitTestResultPrinter::OnTestIterationEnd (const {\b UnitTest} &  {\i unit_test}, int  {\i iteration}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'CF\'E5\'F0\'E5\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'FF\'E5\'F2 \'EC\'E5\'F2\'EE\'E4 \'EF\'F0\'E5\'E4\'EA\'E0 {\b testing::EmptyTestEventListener} ({\i \'F1\'F2\'F0.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3430}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 03431                                                          \{\par
03432   FILE* xmlout = NULL;\par
03433   FilePath output_file(output_file_);\par
03434   FilePath output_dir(output_file.RemoveFileName());\par
03435 \par
03436   {\cf19 if} (output_dir.CreateDirectoriesRecursively()) \{\par
03437     xmlout = posix::FOpen(output_file_.c_str(), {\cf22 "w"});\par
03438   \}\par
03439   {\cf19 if} (xmlout == NULL) \{\par
03440     {\cf20 // TODO(wan): report the reason of the failure.}\par
03441     {\cf20 //}\par
03442     {\cf20 // We don't do it for now as:}\par
03443     {\cf20 //}\par
03444     {\cf20 //   1. There is no urgent need for it.}\par
03445     {\cf20 //   2. It's a bit involved to make the errno variable thread-safe on}\par
03446     {\cf20 //      all three operating systems (Linux, Windows, and Mac OS).}\par
03447     {\cf20 //   3. To interpret the meaning of errno in a thread-safe way,}\par
03448     {\cf20 //      we need the strerror_r() function, which is not available on}\par
03449     {\cf20 //      Windows.}\par
03450     fprintf(stderr,\par
03451             {\cf22 "Unable to open file \\"%s\\"\\n"},\par
03452             output_file_.c_str());\par
03453     fflush(stderr);\par
03454     exit(EXIT_FAILURE);\par
03455   \}\par
03456   std::stringstream stream;\par
03457   PrintXmlUnitTest(&stream, unit_test);\par
03458   fprintf(xmlout, {\cf22 "%s"}, StringStreamToString(&stream).c_str());\par
03459   fclose(xmlout);\par
03460 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::internal::FilePath::CreateDirectoriesRecursively()}, {\b testing::internal::posix::FOpen()}, {\b testing::internal::FilePath::RemoveFileName()} \'E8 {\b testing::internal::StringStreamToString()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\'CE\'E1\'FA\'FF\'E2\'EB\'E5\'ED\'E8\'FF \'E8 \'EE\'EF\'E8\'F1\'E0\'ED\'E8\'FF \'F7\'EB\'E5\'ED\'EE\'E2 \'EA\'EB\'E0\'F1\'F1\'E0 \'ED\'E0\'F5\'EE\'E4\'FF\'F2\'F1\'FF \'E2 \'F4\'E0\'E9\'EB\'E5:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
gtest/src/{\b gtest.cc}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'D4\'E0\'E9\'EB\'FB{\tc \v \'D4\'E0\'E9\'EB\'FB}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/gtest-death-test.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest-death-test.h}
{\xe \v gtest/include/gtest/gtest-death-test.h}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/internal/gtest-death-test-internal.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_DEATH_IF_SUPPORTED}(statement,  regex)\~     {\b GTEST_UNSUPPORTED_DEATH_TEST_}(statement, regex, )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_DEATH_IF_SUPPORTED}(statement,  regex)\~     {\b GTEST_UNSUPPORTED_DEATH_TEST_}(statement, regex, return)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_string_} (death_test_style)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v ASSERT_DEATH_IF_SUPPORTED\:gtest-death-test.h}
{\xe \v gtest-death-test.h\:ASSERT_DEATH_IF_SUPPORTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_DEATH_IF_SUPPORTED( statement,  regex)\~     {\b GTEST_UNSUPPORTED_DEATH_TEST_}(statement, regex, return)}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-death-test.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 288}}\par
}
{\xe \v EXPECT_DEATH_IF_SUPPORTED\:gtest-death-test.h}
{\xe \v gtest-death-test.h\:EXPECT_DEATH_IF_SUPPORTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_DEATH_IF_SUPPORTED( statement,  regex)\~     {\b GTEST_UNSUPPORTED_DEATH_TEST_}(statement, regex, )}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-death-test.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 286}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-death-test.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest-death-test.h}
{\xe \v gtest/include/gtest/gtest-death-test.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2005, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: wan@google.com (Zhanyong Wan)}\par
00031 {\cf20 //}\par
00032 {\cf20 // The Google C++ Testing Framework (Google Test)}\par
00033 {\cf20 //}\par
00034 {\cf20 // This header file defines the public API for death tests.  It is}\par
00035 {\cf20 // #included by gtest.h so a user doesn't need to include this}\par
00036 {\cf20 // directly.}\par
00037 \par
00038 {\cf21 #ifndef GTEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_}\par
00039 {\cf21 #define GTEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_}\par
00040 \par
00041 {\cf21 #include "gtest/internal/gtest-death-test-internal.h"}\par
00042 \par
00043 {\cf17 namespace }testing \{\par
00044 \par
00045 {\cf20 // This flag controls the style of death tests.  Valid values are "threadsafe",}\par
00046 {\cf20 // meaning that the death test child process will re-execute the test binary}\par
00047 {\cf20 // from the start, running only a single death test, or "fast",}\par
00048 {\cf20 // meaning that the child process will execute the test logic immediately}\par
00049 {\cf20 // after forking.}\par
00050 GTEST_DECLARE_string_(death_test_style);\par
00051 \par
00052 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
00053 \par
00054 {\cf17 namespace }internal \{\par
00055 \par
00056 {\cf20 // Returns a Boolean value indicating whether the caller is currently}\par
00057 {\cf20 // executing in the context of the death test child process.  Tools such as}\par
00058 {\cf20 // Valgrind heap checkers may need this to modify their behavior in death}\par
00059 {\cf20 // tests.  IMPORTANT: This is an internal utility.  Using it may break the}\par
00060 {\cf20 // implementation of death tests.  User code MUST NOT use it.}\par
00061 GTEST_API_ {\cf18 bool} InDeathTestChild();\par
00062 \par
00063 \}  {\cf20 // namespace internal}\par
00064 \par
00065 {\cf20 // The following macros are useful for writing death tests.}\par
00066 \par
00067 {\cf20 // Here's what happens when an ASSERT_DEATH* or EXPECT_DEATH* is}\par
00068 {\cf20 // executed:}\par
00069 {\cf20 //}\par
00070 {\cf20 //   1. It generates a warning if there is more than one active}\par
00071 {\cf20 //   thread.  This is because it's safe to fork() or clone() only}\par
00072 {\cf20 //   when there is a single thread.}\par
00073 {\cf20 //}\par
00074 {\cf20 //   2. The parent process clone()s a sub-process and runs the death}\par
00075 {\cf20 //   test in it; the sub-process exits with code 0 at the end of the}\par
00076 {\cf20 //   death test, if it hasn't exited already.}\par
00077 {\cf20 //}\par
00078 {\cf20 //   3. The parent process waits for the sub-process to terminate.}\par
00079 {\cf20 //}\par
00080 {\cf20 //   4. The parent process checks the exit code and error message of}\par
00081 {\cf20 //   the sub-process.}\par
00082 {\cf20 //}\par
00083 {\cf20 // Examples:}\par
00084 {\cf20 //}\par
00085 {\cf20 //   ASSERT_DEATH(server.SendMessage(56, "Hello"), "Invalid port number");}\par
00086 {\cf20 //   for (int i = 0; i < 5; i++) \{}\par
00087 {\cf20 //     EXPECT_DEATH(server.ProcessRequest(i),}\par
00088 {\cf20 //                  "Invalid request .* in ProcessRequest()")}\par
00089 {\cf20 //                  << "Failed to die on request " << i;}\par
00090 {\cf20 //   \}}\par
00091 {\cf20 //}\par
00092 {\cf20 //   ASSERT_EXIT(server.ExitNow(), ::testing::ExitedWithCode(0), "Exiting");}\par
00093 {\cf20 //}\par
00094 {\cf20 //   bool KilledBySIGHUP(int exit_code) \{}\par
00095 {\cf20 //     return WIFSIGNALED(exit_code) && WTERMSIG(exit_code) == SIGHUP;}\par
00096 {\cf20 //   \}}\par
00097 {\cf20 //}\par
00098 {\cf20 //   ASSERT_EXIT(client.HangUpServer(), KilledBySIGHUP, "Hanging up!");}\par
00099 {\cf20 //}\par
00100 {\cf20 // On the regular expressions used in death tests:}\par
00101 {\cf20 //}\par
00102 {\cf20 //   On POSIX-compliant systems (*nix), we use the <regex.h> library,}\par
00103 {\cf20 //   which uses the POSIX extended regex syntax.}\par
00104 {\cf20 //}\par
00105 {\cf20 //   On other platforms (e.g. Windows), we only support a simple regex}\par
00106 {\cf20 //   syntax implemented as part of Google Test.  This limited}\par
00107 {\cf20 //   implementation should be enough most of the time when writing}\par
00108 {\cf20 //   death tests; though it lacks many features you can find in PCRE}\par
00109 {\cf20 //   or POSIX extended regex syntax.  For example, we don't support}\par
00110 {\cf20 //   union ("x|y"), grouping ("(xy)"), brackets ("[xy]"), and}\par
00111 {\cf20 //   repetition count ("x\{5,7\}"), among others.}\par
00112 {\cf20 //}\par
00113 {\cf20 //   Below is the syntax that we do support.  We chose it to be a}\par
00114 {\cf20 //   subset of both PCRE and POSIX extended regex, so it's easy to}\par
00115 {\cf20 //   learn wherever you come from.  In the following: 'A' denotes a}\par
00116 {\cf20 //   literal character, period (.), or a single \\\\ escape sequence;}\par
00117 {\cf20 //   'x' and 'y' denote regular expressions; 'm' and 'n' are for}\par
00118 {\cf20 //   natural numbers.}\par
00119 {\cf20 //}\par
00120 {\cf20 //     c     matches any literal character c}\par
00121 {\cf20 //     \\\\d   matches any decimal digit}\par
00122 {\cf20 //     \\\\D   matches any character that's not a decimal digit}\par
00123 {\cf20 //     \\\\f   matches \\f}\par
00124 {\cf20 //     \\\\n   matches \\n}\par
00125 {\cf20 //     \\\\r   matches \\r}\par
00126 {\cf20 //     \\\\s   matches any ASCII whitespace, including \\n}\par
00127 {\cf20 //     \\\\S   matches any character that's not a whitespace}\par
00128 {\cf20 //     \\\\t   matches \\t}\par
00129 {\cf20 //     \\\\v   matches \\v}\par
00130 {\cf20 //     \\\\w   matches any letter, _, or decimal digit}\par
00131 {\cf20 //     \\\\W   matches any character that \\\\w doesn't match}\par
00132 {\cf20 //     \\\\c   matches any literal character c, which must be a punctuation}\par
00133 {\cf20 //     .     matches any single character except \\n}\par
00134 {\cf20 //     A?    matches 0 or 1 occurrences of A}\par
00135 {\cf20 //     A*    matches 0 or many occurrences of A}\par
00136 {\cf20 //     A+    matches 1 or many occurrences of A}\par
00137 {\cf20 //     ^     matches the beginning of a string (not that of each line)}\par
00138 {\cf20 //     $     matches the end of a string (not that of each line)}\par
00139 {\cf20 //     xy    matches x followed by y}\par
00140 {\cf20 //}\par
00141 {\cf20 //   If you accidentally use PCRE or POSIX extended regex features}\par
00142 {\cf20 //   not implemented by us, you will get a run-time failure.  In that}\par
00143 {\cf20 //   case, please try to rewrite your regular expression within the}\par
00144 {\cf20 //   above syntax.}\par
00145 {\cf20 //}\par
00146 {\cf20 //   This implementation is *not* meant to be as highly tuned or robust}\par
00147 {\cf20 //   as a compiled regex library, but should perform well enough for a}\par
00148 {\cf20 //   death test, which already incurs significant overhead by launching}\par
00149 {\cf20 //   a child process.}\par
00150 {\cf20 //}\par
00151 {\cf20 // Known caveats:}\par
00152 {\cf20 //}\par
00153 {\cf20 //   A "threadsafe" style death test obtains the path to the test}\par
00154 {\cf20 //   program from argv[0] and re-executes it in the sub-process.  For}\par
00155 {\cf20 //   simplicity, the current implementation doesn't search the PATH}\par
00156 {\cf20 //   when launching the sub-process.  This means that the user must}\par
00157 {\cf20 //   invoke the test program via a path that contains at least one}\par
00158 {\cf20 //   path separator (e.g. path/to/foo_test and}\par
00159 {\cf20 //   /absolute/path/to/bar_test are fine, but foo_test is not).  This}\par
00160 {\cf20 //   is rarely a problem as people usually don't put the test binary}\par
00161 {\cf20 //   directory in PATH.}\par
00162 {\cf20 //}\par
00163 {\cf20 // TODO(wan@google.com): make thread-safe death tests search the PATH.}\par
00164 \par
00165 {\cf20 // Asserts that a given statement causes the program to exit, with an}\par
00166 {\cf20 // integer exit status that satisfies predicate, and emitting error output}\par
00167 {\cf20 // that matches regex.}\par
00168 {\cf21 # define ASSERT_EXIT(statement, predicate, regex) \\}\par
00169 {\cf21     GTEST_DEATH_TEST_(statement, predicate, regex, GTEST_FATAL_FAILURE_)}\par
00170 \par
00171 {\cf20 // Like ASSERT_EXIT, but continues on to successive tests in the}\par
00172 {\cf20 // test case, if any:}\par
00173 {\cf21 # define EXPECT_EXIT(statement, predicate, regex) \\}\par
00174 {\cf21     GTEST_DEATH_TEST_(statement, predicate, regex, GTEST_NONFATAL_FAILURE_)}\par
00175 \par
00176 {\cf20 // Asserts that a given statement causes the program to exit, either by}\par
00177 {\cf20 // explicitly exiting with a nonzero exit code or being killed by a}\par
00178 {\cf20 // signal, and emitting error output that matches regex.}\par
00179 {\cf21 # define ASSERT_DEATH(statement, regex) \\}\par
00180 {\cf21     ASSERT_EXIT(statement, ::testing::internal::ExitedUnsuccessfully, regex)}\par
00181 \par
00182 {\cf20 // Like ASSERT_DEATH, but continues on to successive tests in the}\par
00183 {\cf20 // test case, if any:}\par
00184 {\cf21 # define EXPECT_DEATH(statement, regex) \\}\par
00185 {\cf21     EXPECT_EXIT(statement, ::testing::internal::ExitedUnsuccessfully, regex)}\par
00186 \par
00187 {\cf20 // Two predicate classes that can be used in \{ASSERT,EXPECT\}_EXIT*:}\par
00188 \par
00189 {\cf20 // Tests that an exit code describes a normal exit with a given exit code.}\par
00190 {\cf17 class }GTEST_API_ ExitedWithCode \{\par
00191  {\cf17 public}:\par
00192   {\cf17 explicit} ExitedWithCode({\cf18 int} exit_code);\par
00193   {\cf18 bool} operator()({\cf18 int} exit_status) {\cf17 const};\par
00194  {\cf17 private}:\par
00195   {\cf20 // No implementation - assignment is unsupported.}\par
00196   {\cf18 void} operator=({\cf17 const} ExitedWithCode& other);\par
00197 \par
00198   {\cf17 const} {\cf18 int} exit_code_;\par
00199 \};\par
00200 \par
00201 {\cf21 # if !GTEST_OS_WINDOWS}\par
00202 {\cf20 // Tests that an exit code describes an exit due to termination by a}\par
00203 {\cf20 // given signal.}\par
00204 {\cf17 class }GTEST_API_ KilledBySignal \{\par
00205  {\cf17 public}:\par
00206   {\cf17 explicit} KilledBySignal({\cf18 int} signum);\par
00207   {\cf18 bool} operator()({\cf18 int} exit_status) {\cf17 const};\par
00208  {\cf17 private}:\par
00209   {\cf17 const} {\cf18 int} signum_;\par
00210 \};\par
00211 {\cf21 # endif  }{\cf20 // !GTEST_OS_WINDOWS}\par
00212 \par
00213 {\cf20 // EXPECT_DEBUG_DEATH asserts that the given statements die in debug mode.}\par
00214 {\cf20 // The death testing framework causes this to have interesting semantics,}\par
00215 {\cf20 // since the sideeffects of the call are only visible in opt mode, and not}\par
00216 {\cf20 // in debug mode.}\par
00217 {\cf20 //}\par
00218 {\cf20 // In practice, this can be used to test functions that utilize the}\par
00219 {\cf20 // LOG(DFATAL) macro using the following style:}\par
00220 {\cf20 //}\par
00221 {\cf20 // int DieInDebugOr12(int* sideeffect) \{}\par
00222 {\cf20 //   if (sideeffect) \{}\par
00223 {\cf20 //     *sideeffect = 12;}\par
00224 {\cf20 //   \}}\par
00225 {\cf20 //   LOG(DFATAL) << "death";}\par
00226 {\cf20 //   return 12;}\par
00227 {\cf20 // \}}\par
00228 {\cf20 //}\par
00229 {\cf20 // TEST(TestCase, TestDieOr12WorksInDgbAndOpt) \{}\par
00230 {\cf20 //   int sideeffect = 0;}\par
00231 {\cf20 //   // Only asserts in dbg.}\par
00232 {\cf20 //   EXPECT_DEBUG_DEATH(DieInDebugOr12(&sideeffect), "death");}\par
00233 {\cf20 //}\par
00234 {\cf20 // #ifdef NDEBUG}\par
00235 {\cf20 //   // opt-mode has sideeffect visible.}\par
00236 {\cf20 //   EXPECT_EQ(12, sideeffect);}\par
00237 {\cf20 // #else}\par
00238 {\cf20 //   // dbg-mode no visible sideeffect.}\par
00239 {\cf20 //   EXPECT_EQ(0, sideeffect);}\par
00240 {\cf20 // #endif}\par
00241 {\cf20 // \}}\par
00242 {\cf20 //}\par
00243 {\cf20 // This will assert that DieInDebugReturn12InOpt() crashes in debug}\par
00244 {\cf20 // mode, usually due to a DCHECK or LOG(DFATAL), but returns the}\par
00245 {\cf20 // appropriate fallback value (12 in this case) in opt mode. If you}\par
00246 {\cf20 // need to test that a function has appropriate side-effects in opt}\par
00247 {\cf20 // mode, include assertions against the side-effects.  A general}\par
00248 {\cf20 // pattern for this is:}\par
00249 {\cf20 //}\par
00250 {\cf20 // EXPECT_DEBUG_DEATH(\{}\par
00251 {\cf20 //   // Side-effects here will have an effect after this statement in}\par
00252 {\cf20 //   // opt mode, but none in debug mode.}\par
00253 {\cf20 //   EXPECT_EQ(12, DieInDebugOr12(&sideeffect));}\par
00254 {\cf20 // \}, "death");}\par
00255 {\cf20 //}\par
00256 {\cf21 # ifdef NDEBUG}\par
00257 \par
00258 {\cf21 #  define EXPECT_DEBUG_DEATH(statement, regex) \\}\par
00259 {\cf21   GTEST_EXECUTE_STATEMENT_(statement, regex)}\par
00260 \par
00261 {\cf21 #  define ASSERT_DEBUG_DEATH(statement, regex) \\}\par
00262 {\cf21   GTEST_EXECUTE_STATEMENT_(statement, regex)}\par
00263 \par
00264 {\cf21 # else}\par
00265 \par
00266 {\cf21 #  define EXPECT_DEBUG_DEATH(statement, regex) \\}\par
00267 {\cf21   EXPECT_DEATH(statement, regex)}\par
00268 \par
00269 {\cf21 #  define ASSERT_DEBUG_DEATH(statement, regex) \\}\par
00270 {\cf21   ASSERT_DEATH(statement, regex)}\par
00271 \par
00272 {\cf21 # endif  }{\cf20 // NDEBUG for EXPECT_DEBUG_DEATH}\par
00273 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
00274 \par
00275 {\cf20 // EXPECT_DEATH_IF_SUPPORTED(statement, regex) and}\par
00276 {\cf20 // ASSERT_DEATH_IF_SUPPORTED(statement, regex) expand to real death tests if}\par
00277 {\cf20 // death tests are supported; otherwise they just issue a warning.  This is}\par
00278 {\cf20 // useful when you are combining death test assertions with normal test}\par
00279 {\cf20 // assertions in one test.}\par
00280 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
00281 {\cf21 # define EXPECT_DEATH_IF_SUPPORTED(statement, regex) \\}\par
00282 {\cf21     EXPECT_DEATH(statement, regex)}\par
00283 {\cf21 # define ASSERT_DEATH_IF_SUPPORTED(statement, regex) \\}\par
00284 {\cf21     ASSERT_DEATH(statement, regex)}\par
00285 {\cf21 #else}\par
00286 {\cf21 # define EXPECT_DEATH_IF_SUPPORTED(statement, regex) \\}\par
00287 {\cf21     GTEST_UNSUPPORTED_DEATH_TEST_(statement, regex, )}\par
00288 {\cf21 # define ASSERT_DEATH_IF_SUPPORTED(statement, regex) \\}\par
00289 {\cf21     GTEST_UNSUPPORTED_DEATH_TEST_(statement, regex, return)}\par
00290 {\cf21 #endif}\par
00291 \par
00292 \}  {\cf20 // namespace testing}\par
00293 \par
00294 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/gtest-message.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest-message.h}
{\xe \v gtest/include/gtest/gtest-message.h}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <limits>}\par
{\f2 #include "gtest/internal/gtest-port.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::Message}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator<<} (const testing::internal::Secret &, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b testing::operator<<} (std::ostream &os, const Message &sb)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::string {\b testing::internal::StreamableToString} (const T &streamable)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 
{\xe \v operator<<\:gtest-message.h}
{\xe \v gtest-message.h\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void operator<< (const testing::internal::Secret & , int )}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-message.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest-message.h}
{\xe \v gtest/include/gtest/gtest-message.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2005, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: wan@google.com (Zhanyong Wan)}\par
00031 {\cf20 //}\par
00032 {\cf20 // The Google C++ Testing Framework (Google Test)}\par
00033 {\cf20 //}\par
00034 {\cf20 // This header file defines the Message class.}\par
00035 {\cf20 //}\par
00036 {\cf20 // IMPORTANT NOTE: Due to limitation of the C++ language, we have to}\par
00037 {\cf20 // leave some internal implementation details in this header file.}\par
00038 {\cf20 // They are clearly marked by comments like this:}\par
00039 {\cf20 //}\par
00040 {\cf20 //   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
00041 {\cf20 //}\par
00042 {\cf20 // Such code is NOT meant to be used by a user directly, and is subject}\par
00043 {\cf20 // to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user}\par
00044 {\cf20 // program!}\par
00045 \par
00046 {\cf21 #ifndef GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_}\par
00047 {\cf21 #define GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_}\par
00048 \par
00049 {\cf21 #include <limits>}\par
00050 \par
00051 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00052 \par
00053 {\cf20 // Ensures that there is at least one operator<< in the global namespace.}\par
00054 {\cf20 // See Message& operator<<(...) below for why.}\par
00055 {\cf18 void} operator<<({\cf17 const} testing::internal::Secret&, {\cf18 int});\par
00056 \par
00057 {\cf17 namespace }testing \{\par
00058 \par
00059 {\cf20 // The Message class works like an ostream repeater.}\par
00060 {\cf20 //}\par
00061 {\cf20 // Typical usage:}\par
00062 {\cf20 //}\par
00063 {\cf20 //   1. You stream a bunch of values to a Message object.}\par
00064 {\cf20 //      It will remember the text in a stringstream.}\par
00065 {\cf20 //   2. Then you stream the Message object to an ostream.}\par
00066 {\cf20 //      This causes the text in the Message to be streamed}\par
00067 {\cf20 //      to the ostream.}\par
00068 {\cf20 //}\par
00069 {\cf20 // For example;}\par
00070 {\cf20 //}\par
00071 {\cf20 //   testing::Message foo;}\par
00072 {\cf20 //   foo << 1 << " != " << 2;}\par
00073 {\cf20 //   std::cout << foo;}\par
00074 {\cf20 //}\par
00075 {\cf20 // will print "1 != 2".}\par
00076 {\cf20 //}\par
00077 {\cf20 // Message is not intended to be inherited from.  In particular, its}\par
00078 {\cf20 // destructor is not virtual.}\par
00079 {\cf20 //}\par
00080 {\cf20 // Note that stringstream behaves differently in gcc and in MSVC.  You}\par
00081 {\cf20 // can stream a NULL char pointer to it in the former, but not in the}\par
00082 {\cf20 // latter (it causes an access violation if you do).  The Message}\par
00083 {\cf20 // class hides this difference by treating a NULL char pointer as}\par
00084 {\cf20 // "(null)".}\par
00085 {\cf17 class }GTEST_API_ Message \{\par
00086  {\cf17 private}:\par
00087   {\cf20 // The type of basic IO manipulators (endl, ends, and flush) for}\par
00088   {\cf20 // narrow streams.}\par
00089   {\cf17 typedef} std::ostream& (*BasicNarrowIoManip)(std::ostream&);\par
00090 \par
00091  {\cf17 public}:\par
00092   {\cf20 // Constructs an empty Message.}\par
00093   Message();\par
00094 \par
00095   {\cf20 // Copy constructor.}\par
00096   Message({\cf17 const} Message& msg) : ss_(new ::std::stringstream) \{  {\cf20 // NOLINT}\par
00097     *ss_ << msg.GetString();\par
00098   \}\par
00099 \par
00100   {\cf20 // Constructs a Message from a C-string.}\par
00101   {\cf17 explicit} Message({\cf17 const} {\cf18 char}* str) : ss_(new ::std::stringstream) \{\par
00102     *ss_ << str;\par
00103   \}\par
00104 \par
00105 {\cf21 #if GTEST_OS_SYMBIAN}\par
00106   {\cf20 // Streams a value (either a pointer or not) to this object.}\par
00107   {\cf17 template} <{\cf17 typename} T>\par
00108   {\cf17 inline} Message& operator <<({\cf17 const} T& value) \{\par
00109     StreamHelper({\cf17 typename} internal::is_pointer<T>::type(), value);\par
00110     {\cf19 return} *{\cf17 this};\par
00111   \}\par
00112 {\cf21 #else}\par
00113   {\cf20 // Streams a non-pointer value to this object.}\par
00114   {\cf17 template} <{\cf17 typename} T>\par
00115   {\cf17 inline} Message& operator <<({\cf17 const} T& val) \{\par
00116     {\cf20 // Some libraries overload << for STL containers.  These}\par
00117     {\cf20 // overloads are defined in the global namespace instead of ::std.}\par
00118     {\cf20 //}\par
00119     {\cf20 // C++'s symbol lookup rule (i.e. Koenig lookup) says that these}\par
00120     {\cf20 // overloads are visible in either the std namespace or the global}\par
00121     {\cf20 // namespace, but not other namespaces, including the testing}\par
00122     {\cf20 // namespace which Google Test's Message class is in.}\par
00123     {\cf20 //}\par
00124     {\cf20 // To allow STL containers (and other types that has a << operator}\par
00125     {\cf20 // defined in the global namespace) to be used in Google Test}\par
00126     {\cf20 // assertions, testing::Message must access the custom << operator}\par
00127     {\cf20 // from the global namespace.  With this using declaration,}\par
00128     {\cf20 // overloads of << defined in the global namespace and those}\par
00129     {\cf20 // visible via Koenig lookup are both exposed in this function.}\par
00130     using ::operator <<;\par
00131     *ss_ << val;\par
00132     {\cf19 return} *{\cf17 this};\par
00133   \}\par
00134 \par
00135   {\cf20 // Streams a pointer value to this object.}\par
00136   {\cf20 //}\par
00137   {\cf20 // This function is an overload of the previous one.  When you}\par
00138   {\cf20 // stream a pointer to a Message, this definition will be used as it}\par
00139   {\cf20 // is more specialized.  (The C++ Standard, section}\par
00140   {\cf20 // [temp.func.order].)  If you stream a non-pointer, then the}\par
00141   {\cf20 // previous definition will be used.}\par
00142   {\cf20 //}\par
00143   {\cf20 // The reason for this overload is that streaming a NULL pointer to}\par
00144   {\cf20 // ostream is undefined behavior.  Depending on the compiler, you}\par
00145   {\cf20 // may get "0", "(nil)", "(null)", or an access violation.  To}\par
00146   {\cf20 // ensure consistent result across compilers, we always treat NULL}\par
00147   {\cf20 // as "(null)".}\par
00148   {\cf17 template} <{\cf17 typename} T>\par
00149   {\cf17 inline} Message& operator <<(T* {\cf17 const}& pointer) \{  {\cf20 // NOLINT}\par
00150     {\cf19 if} (pointer == NULL) \{\par
00151       *ss_ << {\cf22 "(null)"};\par
00152     \} {\cf19 else} \{\par
00153       *ss_ << pointer;\par
00154     \}\par
00155     {\cf19 return} *{\cf17 this};\par
00156   \}\par
00157 {\cf21 #endif  }{\cf20 // GTEST_OS_SYMBIAN}\par
00158 \par
00159   {\cf20 // Since the basic IO manipulators are overloaded for both narrow}\par
00160   {\cf20 // and wide streams, we have to provide this specialized definition}\par
00161   {\cf20 // of operator <<, even though its body is the same as the}\par
00162   {\cf20 // templatized version above.  Without this definition, streaming}\par
00163   {\cf20 // endl or other basic IO manipulators to Message will confuse the}\par
00164   {\cf20 // compiler.}\par
00165   Message& operator <<(BasicNarrowIoManip val) \{\par
00166     *ss_ << val;\par
00167     {\cf19 return} *{\cf17 this};\par
00168   \}\par
00169 \par
00170   {\cf20 // Instead of 1/0, we want to see true/false for bool values.}\par
00171   Message& operator <<({\cf18 bool} b) \{\par
00172     {\cf19 return} *{\cf17 this} << (b ? {\cf22 "true"} : {\cf22 "false"});\par
00173   \}\par
00174 \par
00175   {\cf20 // These two overloads allow streaming a wide C string to a Message}\par
00176   {\cf20 // using the UTF-8 encoding.}\par
00177   Message& operator <<({\cf17 const} {\cf18 wchar_t}* wide_c_str);\par
00178   Message& operator <<({\cf18 wchar_t}* wide_c_str);\par
00179 \par
00180 {\cf21 #if GTEST_HAS_STD_WSTRING}\par
00181   {\cf20 // Converts the given wide string to a narrow string using the UTF-8}\par
00182   {\cf20 // encoding, and streams the result to this Message object.}\par
00183   Message& operator <<(const ::std::wstring& wstr);\par
00184 {\cf21 #endif  }{\cf20 // GTEST_HAS_STD_WSTRING}\par
00185 \par
00186 {\cf21 #if GTEST_HAS_GLOBAL_WSTRING}\par
00187   {\cf20 // Converts the given wide string to a narrow string using the UTF-8}\par
00188   {\cf20 // encoding, and streams the result to this Message object.}\par
00189   Message& operator <<(const ::wstring& wstr);\par
00190 {\cf21 #endif  }{\cf20 // GTEST_HAS_GLOBAL_WSTRING}\par
00191 \par
00192   {\cf20 // Gets the text streamed to this object so far as an std::string.}\par
00193   {\cf20 // Each '\\0' character in the buffer is replaced with "\\\\0".}\par
00194   {\cf20 //}\par
00195   {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
00196   std::string GetString() {\cf17 const};\par
00197 \par
00198  {\cf17 private}:\par
00199 \par
00200 {\cf21 #if GTEST_OS_SYMBIAN}\par
00201   {\cf20 // These are needed as the Nokia Symbian Compiler cannot decide between}\par
00202   {\cf20 // const T& and const T* in a function template. The Nokia compiler _can_}\par
00203   {\cf20 // decide between class template specializations for T and T*, so a}\par
00204   {\cf20 // tr1::type_traits-like is_pointer works, and we can overload on that.}\par
00205   {\cf17 template} <{\cf17 typename} T>\par
00206   {\cf17 inline} {\cf18 void} StreamHelper(internal::true_type {\cf20 /*is_pointer*/}, T* pointer) \{\par
00207     {\cf19 if} (pointer == NULL) \{\par
00208       *ss_ << {\cf22 "(null)"};\par
00209     \} {\cf19 else} \{\par
00210       *ss_ << pointer;\par
00211     \}\par
00212   \}\par
00213   {\cf17 template} <{\cf17 typename} T>\par
00214   {\cf17 inline} {\cf18 void} StreamHelper(internal::false_type {\cf20 /*is_pointer*/},\par
00215                            {\cf17 const} T& value) \{\par
00216     {\cf20 // See the comments in Message& operator <<(const T&) above for why}\par
00217     {\cf20 // we need this using statement.}\par
00218     using ::operator <<;\par
00219     *ss_ << value;\par
00220   \}\par
00221 {\cf21 #endif  }{\cf20 // GTEST_OS_SYMBIAN}\par
00222 \par
00223   {\cf20 // We'll hold the text streamed to this object here.}\par
00224   {\cf17 const} internal::scoped_ptr< ::std::stringstream> ss_;\par
00225 \par
00226   {\cf20 // We declare (but don't implement) this to prevent the compiler}\par
00227   {\cf20 // from implementing the assignment operator.}\par
00228   {\cf18 void} operator=({\cf17 const} Message&);\par
00229 \};\par
00230 \par
00231 {\cf20 // Streams a Message to an ostream.}\par
00232 {\cf17 inline} std::ostream& operator <<(std::ostream& os, {\cf17 const} Message& sb) \{\par
00233   {\cf19 return} os << sb.GetString();\par
00234 \}\par
00235 \par
00236 {\cf17 namespace }internal \{\par
00237 \par
00238 {\cf20 // Converts a streamable value to an std::string.  A NULL pointer is}\par
00239 {\cf20 // converted to "(null)".  When the input value is a ::string,}\par
00240 {\cf20 // ::std::string, ::wstring, or ::std::wstring object, each NUL}\par
00241 {\cf20 // character in it is replaced with "\\\\0".}\par
00242 {\cf17 template} <{\cf17 typename} T>\par
00243 std::string StreamableToString({\cf17 const} T& streamable) \{\par
00244   {\cf19 return} (Message() << streamable).GetString();\par
00245 \}\par
00246 \par
00247 \}  {\cf20 // namespace internal}\par
00248 \}  {\cf20 // namespace testing}\par
00249 \par
00250 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/gtest-param-test.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest-param-test.h}
{\xe \v gtest/include/gtest/gtest-param-test.h}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/internal/gtest-port.h"}\par
{\f2 #include <utility>}\par
{\f2 #include "gtest/internal/gtest-internal.h"}\par
{\f2 #include "gtest/internal/gtest-param-util.h"}\par
{\f2 #include "gtest/internal/gtest-param-util-generated.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-param-test.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest-param-test.h}
{\xe \v gtest/include/gtest/gtest-param-test.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // This file was GENERATED by command:}\par
00002 {\cf20 //     pump.py gtest-param-test.h.pump}\par
00003 {\cf20 // DO NOT EDIT BY HAND!!!}\par
00004 \par
00005 {\cf20 // Copyright 2008, Google Inc.}\par
00006 {\cf20 // All rights reserved.}\par
00007 {\cf20 //}\par
00008 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00009 {\cf20 // modification, are permitted provided that the following conditions are}\par
00010 {\cf20 // met:}\par
00011 {\cf20 //}\par
00012 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00013 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00014 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00015 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00016 {\cf20 // in the documentation and/or other materials provided with the}\par
00017 {\cf20 // distribution.}\par
00018 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00019 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00020 {\cf20 // this software without specific prior written permission.}\par
00021 {\cf20 //}\par
00022 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00023 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00025 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00026 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00027 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00028 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00029 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00030 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00031 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00032 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00033 {\cf20 //}\par
00034 {\cf20 // Authors: vladl@google.com (Vlad Losev)}\par
00035 {\cf20 //}\par
00036 {\cf20 // Macros and functions for implementing parameterized tests}\par
00037 {\cf20 // in Google C++ Testing Framework (Google Test)}\par
00038 {\cf20 //}\par
00039 {\cf20 // This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!}\par
00040 {\cf20 //}\par
00041 {\cf21 #ifndef GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_}\par
00042 {\cf21 #define GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_}\par
00043 \par
00044 \par
00045 {\cf20 // Value-parameterized tests allow you to test your code with different}\par
00046 {\cf20 // parameters without writing multiple copies of the same test.}\par
00047 {\cf20 //}\par
00048 {\cf20 // Here is how you use value-parameterized tests:}\par
00049 \par
00050 {\cf21 #if 0}\par
00051 \par
00052 {\cf20 // To write value-parameterized tests, first you should define a fixture}\par
00053 {\cf20 // class. It is usually derived from testing::TestWithParam<T> (see below for}\par
00054 {\cf20 // another inheritance scheme that's sometimes useful in more complicated}\par
00055 {\cf20 // class hierarchies), where the type of your parameter values.}\par
00056 {\cf20 // TestWithParam<T> is itself derived from testing::Test. T can be any}\par
00057 {\cf20 // copyable type. If it's a raw pointer, you are responsible for managing the}\par
00058 {\cf20 // lifespan of the pointed values.}\par
00059 \par
00060 {\cf17 class }FooTest : {\cf17 public} ::testing::TestWithParam<const char*> \{\par
00061   {\cf20 // You can implement all the usual class fixture members here.}\par
00062 \};\par
00063 \par
00064 {\cf20 // Then, use the TEST_P macro to define as many parameterized tests}\par
00065 {\cf20 // for this fixture as you want. The _P suffix is for "parameterized"}\par
00066 {\cf20 // or "pattern", whichever you prefer to think.}\par
00067 \par
00068 TEST_P(FooTest, DoesBlah) \{\par
00069   {\cf20 // Inside a test, access the test parameter with the GetParam() method}\par
00070   {\cf20 // of the TestWithParam<T> class:}\par
00071   EXPECT_TRUE(foo.Blah(GetParam()));\par
00072   ...\par
00073 \}\par
00074 \par
00075 TEST_P(FooTest, HasBlahBlah) \{\par
00076   ...\par
00077 \}\par
00078 \par
00079 {\cf20 // Finally, you can use INSTANTIATE_TEST_CASE_P to instantiate the test}\par
00080 {\cf20 // case with any set of parameters you want. Google Test defines a number}\par
00081 {\cf20 // of functions for generating test parameters. They return what we call}\par
00082 {\cf20 // (surprise!) parameter generators. Here is a  summary of them, which}\par
00083 {\cf20 // are all in the testing namespace:}\par
00084 {\cf20 //}\par
00085 {\cf20 //}\par
00086 {\cf20 //  Range(begin, end [, step]) - Yields values \{begin, begin+step,}\par
00087 {\cf20 //                               begin+step+step, ...\}. The values do not}\par
00088 {\cf20 //                               include end. step defaults to 1.}\par
00089 {\cf20 //  Values(v1, v2, ..., vN)    - Yields values \{v1, v2, ..., vN\}.}\par
00090 {\cf20 //  ValuesIn(container)        - Yields values from a C-style array, an STL}\par
00091 {\cf20 //  ValuesIn(begin,end)          container, or an iterator range [begin, end).}\par
00092 {\cf20 //  Bool()                     - Yields sequence \{false, true\}.}\par
00093 {\cf20 //  Combine(g1, g2, ..., gN)   - Yields all combinations (the Cartesian product}\par
00094 {\cf20 //                               for the math savvy) of the values generated}\par
00095 {\cf20 //                               by the N generators.}\par
00096 {\cf20 //}\par
00097 {\cf20 // For more details, see comments at the definitions of these functions below}\par
00098 {\cf20 // in this file.}\par
00099 {\cf20 //}\par
00100 {\cf20 // The following statement will instantiate tests from the FooTest test case}\par
00101 {\cf20 // each with parameter values "meeny", "miny", and "moe".}\par
00102 \par
00103 INSTANTIATE_TEST_CASE_P(InstantiationName,\par
00104                         FooTest,\par
00105                         Values({\cf22 "meeny"}, {\cf22 "miny"}, {\cf22 "moe"}));\par
00106 \par
00107 {\cf20 // To distinguish different instances of the pattern, (yes, you}\par
00108 {\cf20 // can instantiate it more then once) the first argument to the}\par
00109 {\cf20 // INSTANTIATE_TEST_CASE_P macro is a prefix that will be added to the}\par
00110 {\cf20 // actual test case name. Remember to pick unique prefixes for different}\par
00111 {\cf20 // instantiations. The tests from the instantiation above will have}\par
00112 {\cf20 // these names:}\par
00113 {\cf20 //}\par
00114 {\cf20 //    * InstantiationName/FooTest.DoesBlah/0 for "meeny"}\par
00115 {\cf20 //    * InstantiationName/FooTest.DoesBlah/1 for "miny"}\par
00116 {\cf20 //    * InstantiationName/FooTest.DoesBlah/2 for "moe"}\par
00117 {\cf20 //    * InstantiationName/FooTest.HasBlahBlah/0 for "meeny"}\par
00118 {\cf20 //    * InstantiationName/FooTest.HasBlahBlah/1 for "miny"}\par
00119 {\cf20 //    * InstantiationName/FooTest.HasBlahBlah/2 for "moe"}\par
00120 {\cf20 //}\par
00121 {\cf20 // You can use these names in --gtest_filter.}\par
00122 {\cf20 //}\par
00123 {\cf20 // This statement will instantiate all tests from FooTest again, each}\par
00124 {\cf20 // with parameter values "cat" and "dog":}\par
00125 \par
00126 {\cf17 const} {\cf18 char}* pets[] = \{{\cf22 "cat"}, {\cf22 "dog"}\};\par
00127 INSTANTIATE_TEST_CASE_P(AnotherInstantiationName, FooTest, ValuesIn(pets));\par
00128 \par
00129 {\cf20 // The tests from the instantiation above will have these names:}\par
00130 {\cf20 //}\par
00131 {\cf20 //    * AnotherInstantiationName/FooTest.DoesBlah/0 for "cat"}\par
00132 {\cf20 //    * AnotherInstantiationName/FooTest.DoesBlah/1 for "dog"}\par
00133 {\cf20 //    * AnotherInstantiationName/FooTest.HasBlahBlah/0 for "cat"}\par
00134 {\cf20 //    * AnotherInstantiationName/FooTest.HasBlahBlah/1 for "dog"}\par
00135 {\cf20 //}\par
00136 {\cf20 // Please note that INSTANTIATE_TEST_CASE_P will instantiate all tests}\par
00137 {\cf20 // in the given test case, whether their definitions come before or}\par
00138 {\cf20 // AFTER the INSTANTIATE_TEST_CASE_P statement.}\par
00139 {\cf20 //}\par
00140 {\cf20 // Please also note that generator expressions (including parameters to the}\par
00141 {\cf20 // generators) are evaluated in InitGoogleTest(), after main() has started.}\par
00142 {\cf20 // This allows the user on one hand, to adjust generator parameters in order}\par
00143 {\cf20 // to dynamically determine a set of tests to run and on the other hand,}\par
00144 {\cf20 // give the user a chance to inspect the generated tests with Google Test}\par
00145 {\cf20 // reflection API before RUN_ALL_TESTS() is executed.}\par
00146 {\cf20 //}\par
00147 {\cf20 // You can see samples/sample7_unittest.cc and samples/sample8_unittest.cc}\par
00148 {\cf20 // for more examples.}\par
00149 {\cf20 //}\par
00150 {\cf20 // In the future, we plan to publish the API for defining new parameter}\par
00151 {\cf20 // generators. But for now this interface remains part of the internal}\par
00152 {\cf20 // implementation and is subject to change.}\par
00153 {\cf20 //}\par
00154 {\cf20 //}\par
00155 {\cf20 // A parameterized test fixture must be derived from testing::Test and from}\par
00156 {\cf20 // testing::WithParamInterface<T>, where T is the type of the parameter}\par
00157 {\cf20 // values. Inheriting from TestWithParam<T> satisfies that requirement because}\par
00158 {\cf20 // TestWithParam<T> inherits from both Test and WithParamInterface. In more}\par
00159 {\cf20 // complicated hierarchies, however, it is occasionally useful to inherit}\par
00160 {\cf20 // separately from Test and WithParamInterface. For example:}\par
00161 \par
00162 {\cf17 class }BaseTest : {\cf17 public} ::testing::Test \{\par
00163   {\cf20 // You can inherit all the usual members for a non-parameterized test}\par
00164   {\cf20 // fixture here.}\par
00165 \};\par
00166 \par
00167 {\cf17 class }DerivedTest : {\cf17 public} BaseTest, {\cf17 public} ::testing::WithParamInterface<int> \{\par
00168   {\cf20 // The usual test fixture members go here too.}\par
00169 \};\par
00170 \par
00171 TEST_F(BaseTest, HasFoo) \{\par
00172   {\cf20 // This is an ordinary non-parameterized test.}\par
00173 \}\par
00174 \par
00175 TEST_P(DerivedTest, DoesBlah) \{\par
00176   {\cf20 // GetParam works just the same here as if you inherit from TestWithParam.}\par
00177   EXPECT_TRUE(foo.Blah(GetParam()));\par
00178 \}\par
00179 \par
00180 {\cf21 #endif  }{\cf20 // 0}\par
00181 \par
00182 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00183 \par
00184 {\cf21 #if !GTEST_OS_SYMBIAN}\par
00185 {\cf21 # include <utility>}\par
00186 {\cf21 #endif}\par
00187 \par
00188 {\cf20 // scripts/fuse_gtest.py depends on gtest's own header being #included}\par
00189 {\cf20 // *unconditionally*.  Therefore these #includes cannot be moved}\par
00190 {\cf20 // inside #if GTEST_HAS_PARAM_TEST.}\par
00191 {\cf21 #include "gtest/internal/gtest-internal.h"}\par
00192 {\cf21 #include "gtest/internal/gtest-param-util.h"}\par
00193 {\cf21 #include "gtest/internal/gtest-param-util-generated.h"}\par
00194 \par
00195 {\cf21 #if GTEST_HAS_PARAM_TEST}\par
00196 \par
00197 {\cf17 namespace }testing \{\par
00198 \par
00199 {\cf20 // Functions producing parameter generators.}\par
00200 {\cf20 //}\par
00201 {\cf20 // Google Test uses these generators to produce parameters for value-}\par
00202 {\cf20 // parameterized tests. When a parameterized test case is instantiated}\par
00203 {\cf20 // with a particular generator, Google Test creates and runs tests}\par
00204 {\cf20 // for each element in the sequence produced by the generator.}\par
00205 {\cf20 //}\par
00206 {\cf20 // In the following sample, tests from test case FooTest are instantiated}\par
00207 {\cf20 // each three times with parameter values 3, 5, and 8:}\par
00208 {\cf20 //}\par
00209 {\cf20 // class FooTest : public TestWithParam<int> \{ ... \};}\par
00210 {\cf20 //}\par
00211 {\cf20 // TEST_P(FooTest, TestThis) \{}\par
00212 {\cf20 // \}}\par
00213 {\cf20 // TEST_P(FooTest, TestThat) \{}\par
00214 {\cf20 // \}}\par
00215 {\cf20 // INSTANTIATE_TEST_CASE_P(TestSequence, FooTest, Values(3, 5, 8));}\par
00216 {\cf20 //}\par
00217 \par
00218 {\cf20 // Range() returns generators providing sequences of values in a range.}\par
00219 {\cf20 //}\par
00220 {\cf20 // Synopsis:}\par
00221 {\cf20 // Range(start, end)}\par
00222 {\cf20 //   - returns a generator producing a sequence of values \{start, start+1,}\par
00223 {\cf20 //     start+2, ..., \}.}\par
00224 {\cf20 // Range(start, end, step)}\par
00225 {\cf20 //   - returns a generator producing a sequence of values \{start, start+step,}\par
00226 {\cf20 //     start+step+step, ..., \}.}\par
00227 {\cf20 // Notes:}\par
00228 {\cf20 //   * The generated sequences never include end. For example, Range(1, 5)}\par
00229 {\cf20 //     returns a generator producing a sequence \{1, 2, 3, 4\}. Range(1, 9, 2)}\par
00230 {\cf20 //     returns a generator producing \{1, 3, 5, 7\}.}\par
00231 {\cf20 //   * start and end must have the same type. That type may be any integral or}\par
00232 {\cf20 //     floating-point type or a user defined type satisfying these conditions:}\par
00233 {\cf20 //     * It must be assignable (have operator=() defined).}\par
00234 {\cf20 //     * It must have operator+() (operator+(int-compatible type) for}\par
00235 {\cf20 //       two-operand version).}\par
00236 {\cf20 //     * It must have operator<() defined.}\par
00237 {\cf20 //     Elements in the resulting sequences will also have that type.}\par
00238 {\cf20 //   * Condition start < end must be satisfied in order for resulting sequences}\par
00239 {\cf20 //     to contain any elements.}\par
00240 {\cf20 //}\par
00241 {\cf17 template} <{\cf17 typename} T, {\cf17 typename} IncrementT>\par
00242 internal::ParamGenerator<T> Range(T start, T end, IncrementT step) \{\par
00243   {\cf19 return} internal::ParamGenerator<T>(\par
00244       {\cf17 new} internal::RangeGenerator<T, IncrementT>(start, end, step));\par
00245 \}\par
00246 \par
00247 {\cf17 template} <{\cf17 typename} T>\par
00248 internal::ParamGenerator<T> Range(T start, T end) \{\par
00249   {\cf19 return} Range(start, end, 1);\par
00250 \}\par
00251 \par
00252 {\cf20 // ValuesIn() function allows generation of tests with parameters coming from}\par
00253 {\cf20 // a container.}\par
00254 {\cf20 //}\par
00255 {\cf20 // Synopsis:}\par
00256 {\cf20 // ValuesIn(const T (&array)[N])}\par
00257 {\cf20 //   - returns a generator producing sequences with elements from}\par
00258 {\cf20 //     a C-style array.}\par
00259 {\cf20 // ValuesIn(const Container& container)}\par
00260 {\cf20 //   - returns a generator producing sequences with elements from}\par
00261 {\cf20 //     an STL-style container.}\par
00262 {\cf20 // ValuesIn(Iterator begin, Iterator end)}\par
00263 {\cf20 //   - returns a generator producing sequences with elements from}\par
00264 {\cf20 //     a range [begin, end) defined by a pair of STL-style iterators. These}\par
00265 {\cf20 //     iterators can also be plain C pointers.}\par
00266 {\cf20 //}\par
00267 {\cf20 // Please note that ValuesIn copies the values from the containers}\par
00268 {\cf20 // passed in and keeps them to generate tests in RUN_ALL_TESTS().}\par
00269 {\cf20 //}\par
00270 {\cf20 // Examples:}\par
00271 {\cf20 //}\par
00272 {\cf20 // This instantiates tests from test case StringTest}\par
00273 {\cf20 // each with C-string values of "foo", "bar", and "baz":}\par
00274 {\cf20 //}\par
00275 {\cf20 // const char* strings[] = \{"foo", "bar", "baz"\};}\par
00276 {\cf20 // INSTANTIATE_TEST_CASE_P(StringSequence, SrtingTest, ValuesIn(strings));}\par
00277 {\cf20 //}\par
00278 {\cf20 // This instantiates tests from test case StlStringTest}\par
00279 {\cf20 // each with STL strings with values "a" and "b":}\par
00280 {\cf20 //}\par
00281 {\cf20 // ::std::vector< ::std::string> GetParameterStrings() \{}\par
00282 {\cf20 //   ::std::vector< ::std::string> v;}\par
00283 {\cf20 //   v.push_back("a");}\par
00284 {\cf20 //   v.push_back("b");}\par
00285 {\cf20 //   return v;}\par
00286 {\cf20 // \}}\par
00287 {\cf20 //}\par
00288 {\cf20 // INSTANTIATE_TEST_CASE_P(CharSequence,}\par
00289 {\cf20 //                         StlStringTest,}\par
00290 {\cf20 //                         ValuesIn(GetParameterStrings()));}\par
00291 {\cf20 //}\par
00292 {\cf20 //}\par
00293 {\cf20 // This will also instantiate tests from CharTest}\par
00294 {\cf20 // each with parameter values 'a' and 'b':}\par
00295 {\cf20 //}\par
00296 {\cf20 // ::std::list<char> GetParameterChars() \{}\par
00297 {\cf20 //   ::std::list<char> list;}\par
00298 {\cf20 //   list.push_back('a');}\par
00299 {\cf20 //   list.push_back('b');}\par
00300 {\cf20 //   return list;}\par
00301 {\cf20 // \}}\par
00302 {\cf20 // ::std::list<char> l = GetParameterChars();}\par
00303 {\cf20 // INSTANTIATE_TEST_CASE_P(CharSequence2,}\par
00304 {\cf20 //                         CharTest,}\par
00305 {\cf20 //                         ValuesIn(l.begin(), l.end()));}\par
00306 {\cf20 //}\par
00307 {\cf17 template} <{\cf17 typename} ForwardIterator>\par
00308 internal::ParamGenerator<\par
00309   typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>\par
00310 ValuesIn(ForwardIterator begin, ForwardIterator end) \{\par
00311   {\cf17 typedef} typename ::testing::internal::IteratorTraits<ForwardIterator>\par
00312       ::value_type ParamType;\par
00313   {\cf19 return} internal::ParamGenerator<ParamType>(\par
00314       {\cf17 new} internal::ValuesInIteratorRangeGenerator<ParamType>(begin, end));\par
00315 \}\par
00316 \par
00317 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} N>\par
00318 internal::ParamGenerator<T> ValuesIn({\cf17 const} T (&array)[N]) \{\par
00319   {\cf19 return} ValuesIn(array, array + N);\par
00320 \}\par
00321 \par
00322 {\cf17 template} <{\cf17 class} Container>\par
00323 internal::ParamGenerator<typename Container::value_type> ValuesIn(\par
00324     {\cf17 const} Container& container) \{\par
00325   {\cf19 return} ValuesIn(container.begin(), container.end());\par
00326 \}\par
00327 \par
00328 {\cf20 // Values() allows generating tests from explicitly specified list of}\par
00329 {\cf20 // parameters.}\par
00330 {\cf20 //}\par
00331 {\cf20 // Synopsis:}\par
00332 {\cf20 // Values(T v1, T v2, ..., T vN)}\par
00333 {\cf20 //   - returns a generator producing sequences with elements v1, v2, ..., vN.}\par
00334 {\cf20 //}\par
00335 {\cf20 // For example, this instantiates tests from test case BarTest each}\par
00336 {\cf20 // with values "one", "two", and "three":}\par
00337 {\cf20 //}\par
00338 {\cf20 // INSTANTIATE_TEST_CASE_P(NumSequence, BarTest, Values("one", "two", "three"));}\par
00339 {\cf20 //}\par
00340 {\cf20 // This instantiates tests from test case BazTest each with values 1, 2, 3.5.}\par
00341 {\cf20 // The exact type of values will depend on the type of parameter in BazTest.}\par
00342 {\cf20 //}\par
00343 {\cf20 // INSTANTIATE_TEST_CASE_P(FloatingNumbers, BazTest, Values(1, 2, 3.5));}\par
00344 {\cf20 //}\par
00345 {\cf20 // Currently, Values() supports from 1 to 50 parameters.}\par
00346 {\cf20 //}\par
00347 {\cf17 template} <{\cf17 typename} T1>\par
00348 internal::ValueArray1<T1> Values(T1 v1) \{\par
00349   {\cf19 return} internal::ValueArray1<T1>(v1);\par
00350 \}\par
00351 \par
00352 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
00353 internal::ValueArray2<T1, T2> Values(T1 v1, T2 v2) \{\par
00354   {\cf19 return} internal::ValueArray2<T1, T2>(v1, v2);\par
00355 \}\par
00356 \par
00357 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3>\par
00358 internal::ValueArray3<T1, T2, T3> Values(T1 v1, T2 v2, T3 v3) \{\par
00359   {\cf19 return} internal::ValueArray3<T1, T2, T3>(v1, v2, v3);\par
00360 \}\par
00361 \par
00362 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4>\par
00363 internal::ValueArray4<T1, T2, T3, T4> Values(T1 v1, T2 v2, T3 v3, T4 v4) \{\par
00364   {\cf19 return} internal::ValueArray4<T1, T2, T3, T4>(v1, v2, v3, v4);\par
00365 \}\par
00366 \par
00367 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5>\par
00368 internal::ValueArray5<T1, T2, T3, T4, T5> Values(T1 v1, T2 v2, T3 v3, T4 v4,\par
00369     T5 v5) \{\par
00370   {\cf19 return} internal::ValueArray5<T1, T2, T3, T4, T5>(v1, v2, v3, v4, v5);\par
00371 \}\par
00372 \par
00373 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00374     {\cf17 typename} T6>\par
00375 internal::ValueArray6<T1, T2, T3, T4, T5, T6> Values(T1 v1, T2 v2, T3 v3,\par
00376     T4 v4, T5 v5, T6 v6) \{\par
00377   {\cf19 return} internal::ValueArray6<T1, T2, T3, T4, T5, T6>(v1, v2, v3, v4, v5, v6);\par
00378 \}\par
00379 \par
00380 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00381     {\cf17 typename} T6, {\cf17 typename} T7>\par
00382 internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7> Values(T1 v1, T2 v2, T3 v3,\par
00383     T4 v4, T5 v5, T6 v6, T7 v7) \{\par
00384   {\cf19 return} internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7>(v1, v2, v3, v4, v5,\par
00385       v6, v7);\par
00386 \}\par
00387 \par
00388 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00389     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8>\par
00390 internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8> Values(T1 v1, T2 v2,\par
00391     T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8) \{\par
00392   {\cf19 return} internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8>(v1, v2, v3, v4,\par
00393       v5, v6, v7, v8);\par
00394 \}\par
00395 \par
00396 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00397     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9>\par
00398 internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9> Values(T1 v1, T2 v2,\par
00399     T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9) \{\par
00400   {\cf19 return} internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9>(v1, v2, v3,\par
00401       v4, v5, v6, v7, v8, v9);\par
00402 \}\par
00403 \par
00404 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00405     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10>\par
00406 internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Values(T1 v1,\par
00407     T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10) \{\par
00408   {\cf19 return} internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(v1,\par
00409       v2, v3, v4, v5, v6, v7, v8, v9, v10);\par
00410 \}\par
00411 \par
00412 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00413     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00414     {\cf17 typename} T11>\par
00415 internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,\par
00416     T11> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00417     T10 v10, T11 v11) \{\par
00418   {\cf19 return} internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,\par
00419       T11>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);\par
00420 \}\par
00421 \par
00422 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00423     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00424     {\cf17 typename} T11, {\cf17 typename} T12>\par
00425 internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00426     T12> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00427     T10 v10, T11 v11, T12 v12) \{\par
00428   {\cf19 return} internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00429       T12>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);\par
00430 \}\par
00431 \par
00432 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00433     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00434     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13>\par
00435 internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
00436     T13> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00437     T10 v10, T11 v11, T12 v12, T13 v13) \{\par
00438   {\cf19 return} internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00439       T12, T13>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);\par
00440 \}\par
00441 \par
00442 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00443     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00444     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14>\par
00445 internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00446     T14> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00447     T10 v10, T11 v11, T12 v12, T13 v13, T14 v14) \{\par
00448   {\cf19 return} internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00449       T12, T13, T14>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\par
00450       v14);\par
00451 \}\par
00452 \par
00453 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00454     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00455     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15>\par
00456 internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00457     T14, T15> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\par
00458     T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15) \{\par
00459   {\cf19 return} internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00460       T12, T13, T14, T15>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\par
00461       v13, v14, v15);\par
00462 \}\par
00463 \par
00464 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00465     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00466     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00467     {\cf17 typename} T16>\par
00468 internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00469     T14, T15, T16> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\par
00470     T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\par
00471     T16 v16) \{\par
00472   {\cf19 return} internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00473       T12, T13, T14, T15, T16>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\par
00474       v12, v13, v14, v15, v16);\par
00475 \}\par
00476 \par
00477 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00478     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00479     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00480     {\cf17 typename} T16, {\cf17 typename} T17>\par
00481 internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00482     T14, T15, T16, T17> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\par
00483     T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\par
00484     T16 v16, T17 v17) \{\par
00485   {\cf19 return} internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00486       T12, T13, T14, T15, T16, T17>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\par
00487       v11, v12, v13, v14, v15, v16, v17);\par
00488 \}\par
00489 \par
00490 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00491     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00492     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00493     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18>\par
00494 internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00495     T14, T15, T16, T17, T18> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\par
00496     T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\par
00497     T16 v16, T17 v17, T18 v18) \{\par
00498   {\cf19 return} internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00499       T12, T13, T14, T15, T16, T17, T18>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\par
00500       v10, v11, v12, v13, v14, v15, v16, v17, v18);\par
00501 \}\par
00502 \par
00503 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00504     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00505     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00506     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19>\par
00507 internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00508     T14, T15, T16, T17, T18, T19> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\par
00509     T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\par
00510     T15 v15, T16 v16, T17 v17, T18 v18, T19 v19) \{\par
00511   {\cf19 return} internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00512       T12, T13, T14, T15, T16, T17, T18, T19>(v1, v2, v3, v4, v5, v6, v7, v8,\par
00513       v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);\par
00514 \}\par
00515 \par
00516 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00517     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00518     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00519     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20>\par
00520 internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00521     T14, T15, T16, T17, T18, T19, T20> Values(T1 v1, T2 v2, T3 v3, T4 v4,\par
00522     T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\par
00523     T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20) \{\par
00524   {\cf19 return} internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00525       T12, T13, T14, T15, T16, T17, T18, T19, T20>(v1, v2, v3, v4, v5, v6, v7,\par
00526       v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20);\par
00527 \}\par
00528 \par
00529 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00530     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00531     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00532     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00533     {\cf17 typename} T21>\par
00534 internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00535     T14, T15, T16, T17, T18, T19, T20, T21> Values(T1 v1, T2 v2, T3 v3, T4 v4,\par
00536     T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\par
00537     T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21) \{\par
00538   {\cf19 return} internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00539       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(v1, v2, v3, v4, v5, v6,\par
00540       v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21);\par
00541 \}\par
00542 \par
00543 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00544     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00545     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00546     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00547     {\cf17 typename} T21, {\cf17 typename} T22>\par
00548 internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00549     T14, T15, T16, T17, T18, T19, T20, T21, T22> Values(T1 v1, T2 v2, T3 v3,\par
00550     T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\par
00551     T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\par
00552     T21 v21, T22 v22) \{\par
00553   {\cf19 return} internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00554       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>(v1, v2, v3, v4,\par
00555       v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\par
00556       v20, v21, v22);\par
00557 \}\par
00558 \par
00559 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00560     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00561     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00562     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00563     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23>\par
00564 internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00565     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> Values(T1 v1, T2 v2,\par
00566     T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\par
00567     T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\par
00568     T21 v21, T22 v22, T23 v23) \{\par
00569   {\cf19 return} internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00570       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>(v1, v2, v3,\par
00571       v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\par
00572       v20, v21, v22, v23);\par
00573 \}\par
00574 \par
00575 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00576     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00577     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00578     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00579     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24>\par
00580 internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00581     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> Values(T1 v1, T2 v2,\par
00582     T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\par
00583     T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\par
00584     T21 v21, T22 v22, T23 v23, T24 v24) \{\par
00585   {\cf19 return} internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00586       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>(v1, v2,\par
00587       v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\par
00588       v19, v20, v21, v22, v23, v24);\par
00589 \}\par
00590 \par
00591 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00592     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00593     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00594     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00595     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25>\par
00596 internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00597     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Values(T1 v1,\par
00598     T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11,\par
00599     T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19,\par
00600     T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25) \{\par
00601   {\cf19 return} internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00602       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>(v1,\par
00603       v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\par
00604       v18, v19, v20, v21, v22, v23, v24, v25);\par
00605 \}\par
00606 \par
00607 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00608     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00609     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00610     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00611     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00612     {\cf17 typename} T26>\par
00613 internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00614     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00615     T26> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00616     T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00617     T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
00618     T26 v26) \{\par
00619   {\cf19 return} internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00620       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00621       T26>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,\par
00622       v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26);\par
00623 \}\par
00624 \par
00625 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00626     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00627     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00628     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00629     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00630     {\cf17 typename} T26, {\cf17 typename} T27>\par
00631 internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00632     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
00633     T27> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00634     T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00635     T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
00636     T26 v26, T27 v27) \{\par
00637   {\cf19 return} internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00638       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00639       T26, T27>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\par
00640       v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27);\par
00641 \}\par
00642 \par
00643 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00644     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00645     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00646     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00647     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00648     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28>\par
00649 internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00650     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
00651     T28> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00652     T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00653     T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
00654     T26 v26, T27 v27, T28 v28) \{\par
00655   {\cf19 return} internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00656       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00657       T26, T27, T28>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\par
00658       v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27,\par
00659       v28);\par
00660 \}\par
00661 \par
00662 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00663     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00664     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00665     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00666     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00667     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29>\par
00668 internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00669     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00670     T29> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00671     T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00672     T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
00673     T26 v26, T27 v27, T28 v28, T29 v29) \{\par
00674   {\cf19 return} internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00675       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00676       T26, T27, T28, T29>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\par
00677       v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,\par
00678       v27, v28, v29);\par
00679 \}\par
00680 \par
00681 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00682     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00683     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00684     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00685     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00686     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30>\par
00687 internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00688     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00689     T29, T30> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\par
00690     T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,\par
00691     T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,\par
00692     T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30) \{\par
00693   {\cf19 return} internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00694       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00695       T26, T27, T28, T29, T30>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\par
00696       v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,\par
00697       v26, v27, v28, v29, v30);\par
00698 \}\par
00699 \par
00700 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00701     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00702     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00703     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00704     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00705     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00706     {\cf17 typename} T31>\par
00707 internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00708     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00709     T29, T30, T31> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\par
00710     T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\par
00711     T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\par
00712     T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31) \{\par
00713   {\cf19 return} internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00714       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00715       T26, T27, T28, T29, T30, T31>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\par
00716       v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,\par
00717       v25, v26, v27, v28, v29, v30, v31);\par
00718 \}\par
00719 \par
00720 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00721     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00722     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00723     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00724     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00725     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00726     {\cf17 typename} T31, {\cf17 typename} T32>\par
00727 internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00728     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00729     T29, T30, T31, T32> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\par
00730     T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\par
00731     T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\par
00732     T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\par
00733     T32 v32) \{\par
00734   {\cf19 return} internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00735       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00736       T26, T27, T28, T29, T30, T31, T32>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\par
00737       v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\par
00738       v24, v25, v26, v27, v28, v29, v30, v31, v32);\par
00739 \}\par
00740 \par
00741 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00742     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00743     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00744     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00745     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00746     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00747     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33>\par
00748 internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00749     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00750     T29, T30, T31, T32, T33> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\par
00751     T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\par
00752     T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\par
00753     T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\par
00754     T32 v32, T33 v33) \{\par
00755   {\cf19 return} internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00756       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00757       T26, T27, T28, T29, T30, T31, T32, T33>(v1, v2, v3, v4, v5, v6, v7, v8,\par
00758       v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\par
00759       v24, v25, v26, v27, v28, v29, v30, v31, v32, v33);\par
00760 \}\par
00761 \par
00762 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00763     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00764     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00765     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00766     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00767     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00768     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34>\par
00769 internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00770     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00771     T29, T30, T31, T32, T33, T34> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\par
00772     T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\par
00773     T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22,\par
00774     T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30,\par
00775     T31 v31, T32 v32, T33 v33, T34 v34) \{\par
00776   {\cf19 return} internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00777       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00778       T26, T27, T28, T29, T30, T31, T32, T33, T34>(v1, v2, v3, v4, v5, v6, v7,\par
00779       v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\par
00780       v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34);\par
00781 \}\par
00782 \par
00783 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00784     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00785     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00786     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00787     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00788     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00789     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35>\par
00790 internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00791     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00792     T29, T30, T31, T32, T33, T34, T35> Values(T1 v1, T2 v2, T3 v3, T4 v4,\par
00793     T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\par
00794     T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\par
00795     T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\par
00796     T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35) \{\par
00797   {\cf19 return} internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00798       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00799       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35>(v1, v2, v3, v4, v5, v6,\par
00800       v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\par
00801       v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35);\par
00802 \}\par
00803 \par
00804 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00805     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00806     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00807     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00808     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00809     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00810     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00811     {\cf17 typename} T36>\par
00812 internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00813     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00814     T29, T30, T31, T32, T33, T34, T35, T36> Values(T1 v1, T2 v2, T3 v3, T4 v4,\par
00815     T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\par
00816     T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\par
00817     T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\par
00818     T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36) \{\par
00819   {\cf19 return} internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00820       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00821       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36>(v1, v2, v3, v4,\par
00822       v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\par
00823       v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\par
00824       v34, v35, v36);\par
00825 \}\par
00826 \par
00827 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00828     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00829     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00830     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00831     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00832     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00833     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00834     {\cf17 typename} T36, {\cf17 typename} T37>\par
00835 internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00836     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00837     T29, T30, T31, T32, T33, T34, T35, T36, T37> Values(T1 v1, T2 v2, T3 v3,\par
00838     T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\par
00839     T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\par
00840     T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\par
00841     T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\par
00842     T37 v37) \{\par
00843   {\cf19 return} internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00844       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00845       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37>(v1, v2, v3,\par
00846       v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\par
00847       v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\par
00848       v34, v35, v36, v37);\par
00849 \}\par
00850 \par
00851 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00852     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00853     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00854     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00855     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00856     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00857     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00858     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38>\par
00859 internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00860     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00861     T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> Values(T1 v1, T2 v2,\par
00862     T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\par
00863     T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\par
00864     T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\par
00865     T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\par
00866     T37 v37, T38 v38) \{\par
00867   {\cf19 return} internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00868       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00869       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38>(v1, v2,\par
00870       v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\par
00871       v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32,\par
00872       v33, v34, v35, v36, v37, v38);\par
00873 \}\par
00874 \par
00875 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00876     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00877     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00878     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00879     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00880     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00881     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00882     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39>\par
00883 internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00884     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00885     T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Values(T1 v1, T2 v2,\par
00886     T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\par
00887     T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\par
00888     T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\par
00889     T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\par
00890     T37 v37, T38 v38, T39 v39) \{\par
00891   {\cf19 return} internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00892       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00893       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39>(v1,\par
00894       v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\par
00895       v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31,\par
00896       v32, v33, v34, v35, v36, v37, v38, v39);\par
00897 \}\par
00898 \par
00899 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00900     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00901     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00902     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00903     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00904     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00905     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00906     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40>\par
00907 internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00908     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00909     T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Values(T1 v1,\par
00910     T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11,\par
00911     T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19,\par
00912     T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27,\par
00913     T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35,\par
00914     T36 v36, T37 v37, T38 v38, T39 v39, T40 v40) \{\par
00915   {\cf19 return} internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00916       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00917       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\par
00918       T40>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,\par
00919       v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29,\par
00920       v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40);\par
00921 \}\par
00922 \par
00923 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00924     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00925     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00926     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00927     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00928     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00929     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00930     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
00931     {\cf17 typename} T41>\par
00932 internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00933     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00934     T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\par
00935     T41> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00936     T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00937     T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
00938     T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
00939     T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41) \{\par
00940   {\cf19 return} internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00941       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00942       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\par
00943       T40, T41>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\par
00944       v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28,\par
00945       v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41);\par
00946 \}\par
00947 \par
00948 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00949     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00950     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00951     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00952     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00953     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00954     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00955     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
00956     {\cf17 typename} T41, {\cf17 typename} T42>\par
00957 internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00958     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00959     T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\par
00960     T42> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00961     T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00962     T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
00963     T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
00964     T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\par
00965     T42 v42) \{\par
00966   {\cf19 return} internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00967       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00968       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\par
00969       T40, T41, T42>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\par
00970       v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27,\par
00971       v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41,\par
00972       v42);\par
00973 \}\par
00974 \par
00975 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00976     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00977     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00978     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00979     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00980     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00981     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00982     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
00983     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43>\par
00984 internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00985     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00986     T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\par
00987     T43> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00988     T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00989     T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
00990     T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
00991     T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\par
00992     T42 v42, T43 v43) \{\par
00993   {\cf19 return} internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00994       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
00995       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\par
00996       T40, T41, T42, T43>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\par
00997       v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,\par
00998       v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40,\par
00999       v41, v42, v43);\par
01000 \}\par
01001 \par
01002 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01003     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01004     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01005     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01006     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01007     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01008     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01009     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01010     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44>\par
01011 internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
01012     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
01013     T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
01014     T44> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
01015     T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
01016     T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
01017     T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
01018     T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\par
01019     T42 v42, T43 v43, T44 v44) \{\par
01020   {\cf19 return} internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
01021       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
01022       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\par
01023       T40, T41, T42, T43, T44>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\par
01024       v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,\par
01025       v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39,\par
01026       v40, v41, v42, v43, v44);\par
01027 \}\par
01028 \par
01029 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01030     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01031     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01032     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01033     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01034     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01035     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01036     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01037     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45>\par
01038 internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
01039     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
01040     T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
01041     T44, T45> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\par
01042     T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,\par
01043     T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,\par
01044     T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32,\par
01045     T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40,\par
01046     T41 v41, T42 v42, T43 v43, T44 v44, T45 v45) \{\par
01047   {\cf19 return} internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
01048       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
01049       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\par
01050       T40, T41, T42, T43, T44, T45>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\par
01051       v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,\par
01052       v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38,\par
01053       v39, v40, v41, v42, v43, v44, v45);\par
01054 \}\par
01055 \par
01056 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01057     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01058     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01059     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01060     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01061     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01062     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01063     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01064     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
01065     {\cf17 typename} T46>\par
01066 internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
01067     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
01068     T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
01069     T44, T45, T46> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\par
01070     T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\par
01071     T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\par
01072     T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\par
01073     T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\par
01074     T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46) \{\par
01075   {\cf19 return} internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
01076       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
01077       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\par
01078       T40, T41, T42, T43, T44, T45, T46>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\par
01079       v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\par
01080       v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37,\par
01081       v38, v39, v40, v41, v42, v43, v44, v45, v46);\par
01082 \}\par
01083 \par
01084 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01085     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01086     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01087     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01088     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01089     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01090     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01091     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01092     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
01093     {\cf17 typename} T46, {\cf17 typename} T47>\par
01094 internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
01095     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
01096     T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
01097     T44, T45, T46, T47> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\par
01098     T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\par
01099     T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\par
01100     T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\par
01101     T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\par
01102     T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47) \{\par
01103   {\cf19 return} internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
01104       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
01105       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\par
01106       T40, T41, T42, T43, T44, T45, T46, T47>(v1, v2, v3, v4, v5, v6, v7, v8,\par
01107       v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\par
01108       v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37,\par
01109       v38, v39, v40, v41, v42, v43, v44, v45, v46, v47);\par
01110 \}\par
01111 \par
01112 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01113     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01114     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01115     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01116     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01117     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01118     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01119     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01120     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
01121     {\cf17 typename} T46, {\cf17 typename} T47, {\cf17 typename} T48>\par
01122 internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
01123     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
01124     T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
01125     T44, T45, T46, T47, T48> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\par
01126     T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\par
01127     T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\par
01128     T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\par
01129     T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\par
01130     T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47,\par
01131     T48 v48) \{\par
01132   {\cf19 return} internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
01133       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
01134       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\par
01135       T40, T41, T42, T43, T44, T45, T46, T47, T48>(v1, v2, v3, v4, v5, v6, v7,\par
01136       v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\par
01137       v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36,\par
01138       v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48);\par
01139 \}\par
01140 \par
01141 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01142     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01143     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01144     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01145     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01146     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01147     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01148     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01149     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
01150     {\cf17 typename} T46, {\cf17 typename} T47, {\cf17 typename} T48, {\cf17 typename} T49>\par
01151 internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
01152     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
01153     T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
01154     T44, T45, T46, T47, T48, T49> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\par
01155     T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\par
01156     T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22,\par
01157     T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30,\par
01158     T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38,\par
01159     T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46,\par
01160     T47 v47, T48 v48, T49 v49) \{\par
01161   {\cf19 return} internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
01162       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
01163       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\par
01164       T40, T41, T42, T43, T44, T45, T46, T47, T48, T49>(v1, v2, v3, v4, v5, v6,\par
01165       v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\par
01166       v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35,\par
01167       v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49);\par
01168 \}\par
01169 \par
01170 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01171     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01172     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01173     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01174     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01175     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01176     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01177     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01178     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
01179     {\cf17 typename} T46, {\cf17 typename} T47, {\cf17 typename} T48, {\cf17 typename} T49, {\cf17 typename} T50>\par
01180 internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
01181     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
01182     T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
01183     T44, T45, T46, T47, T48, T49, T50> Values(T1 v1, T2 v2, T3 v3, T4 v4,\par
01184     T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\par
01185     T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\par
01186     T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\par
01187     T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37,\par
01188     T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45,\par
01189     T46 v46, T47 v47, T48 v48, T49 v49, T50 v50) \{\par
01190   {\cf19 return} internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
01191       T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
01192       T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\par
01193       T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>(v1, v2, v3, v4,\par
01194       v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\par
01195       v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\par
01196       v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47,\par
01197       v48, v49, v50);\par
01198 \}\par
01199 \par
01200 {\cf20 // Bool() allows generating tests with parameters in a set of (false, true).}\par
01201 {\cf20 //}\par
01202 {\cf20 // Synopsis:}\par
01203 {\cf20 // Bool()}\par
01204 {\cf20 //   - returns a generator producing sequences with elements \{false, true\}.}\par
01205 {\cf20 //}\par
01206 {\cf20 // It is useful when testing code that depends on Boolean flags. Combinations}\par
01207 {\cf20 // of multiple flags can be tested when several Bool()'s are combined using}\par
01208 {\cf20 // Combine() function.}\par
01209 {\cf20 //}\par
01210 {\cf20 // In the following example all tests in the test case FlagDependentTest}\par
01211 {\cf20 // will be instantiated twice with parameters false and true.}\par
01212 {\cf20 //}\par
01213 {\cf20 // class FlagDependentTest : public testing::TestWithParam<bool> \{}\par
01214 {\cf20 //   virtual void SetUp() \{}\par
01215 {\cf20 //     external_flag = GetParam();}\par
01216 {\cf20 //   \}}\par
01217 {\cf20 // \}}\par
01218 {\cf20 // INSTANTIATE_TEST_CASE_P(BoolSequence, FlagDependentTest, Bool());}\par
01219 {\cf20 //}\par
01220 {\cf17 inline} internal::ParamGenerator<bool> Bool() \{\par
01221   {\cf19 return} Values({\cf17 false}, {\cf17 true});\par
01222 \}\par
01223 \par
01224 {\cf21 # if GTEST_HAS_COMBINE}\par
01225 {\cf20 // Combine() allows the user to combine two or more sequences to produce}\par
01226 {\cf20 // values of a Cartesian product of those sequences' elements.}\par
01227 {\cf20 //}\par
01228 {\cf20 // Synopsis:}\par
01229 {\cf20 // Combine(gen1, gen2, ..., genN)}\par
01230 {\cf20 //   - returns a generator producing sequences with elements coming from}\par
01231 {\cf20 //     the Cartesian product of elements from the sequences generated by}\par
01232 {\cf20 //     gen1, gen2, ..., genN. The sequence elements will have a type of}\par
01233 {\cf20 //     tuple<T1, T2, ..., TN> where T1, T2, ..., TN are the types}\par
01234 {\cf20 //     of elements from sequences produces by gen1, gen2, ..., genN.}\par
01235 {\cf20 //}\par
01236 {\cf20 // Combine can have up to 10 arguments. This number is currently limited}\par
01237 {\cf20 // by the maximum number of elements in the tuple implementation used by Google}\par
01238 {\cf20 // Test.}\par
01239 {\cf20 //}\par
01240 {\cf20 // Example:}\par
01241 {\cf20 //}\par
01242 {\cf20 // This will instantiate tests in test case AnimalTest each one with}\par
01243 {\cf20 // the parameter values tuple("cat", BLACK), tuple("cat", WHITE),}\par
01244 {\cf20 // tuple("dog", BLACK), and tuple("dog", WHITE):}\par
01245 {\cf20 //}\par
01246 {\cf20 // enum Color \{ BLACK, GRAY, WHITE \};}\par
01247 {\cf20 // class AnimalTest}\par
01248 {\cf20 //     : public testing::TestWithParam<tuple<const char*, Color> > \{...\};}\par
01249 {\cf20 //}\par
01250 {\cf20 // TEST_P(AnimalTest, AnimalLooksNice) \{...\}}\par
01251 {\cf20 //}\par
01252 {\cf20 // INSTANTIATE_TEST_CASE_P(AnimalVariations, AnimalTest,}\par
01253 {\cf20 //                         Combine(Values("cat", "dog"),}\par
01254 {\cf20 //                                 Values(BLACK, WHITE)));}\par
01255 {\cf20 //}\par
01256 {\cf20 // This will instantiate tests in FlagDependentTest with all variations of two}\par
01257 {\cf20 // Boolean flags:}\par
01258 {\cf20 //}\par
01259 {\cf20 // class FlagDependentTest}\par
01260 {\cf20 //     : public testing::TestWithParam<tuple<bool, bool> > \{}\par
01261 {\cf20 //   virtual void SetUp() \{}\par
01262 {\cf20 //     // Assigns external_flag_1 and external_flag_2 values from the tuple.}\par
01263 {\cf20 //     tie(external_flag_1, external_flag_2) = GetParam();}\par
01264 {\cf20 //   \}}\par
01265 {\cf20 // \};}\par
01266 {\cf20 //}\par
01267 {\cf20 // TEST_P(FlagDependentTest, TestFeature1) \{}\par
01268 {\cf20 //   // Test your code using external_flag_1 and external_flag_2 here.}\par
01269 {\cf20 // \}}\par
01270 {\cf20 // INSTANTIATE_TEST_CASE_P(TwoBoolSequence, FlagDependentTest,}\par
01271 {\cf20 //                         Combine(Bool(), Bool()));}\par
01272 {\cf20 //}\par
01273 {\cf17 template} <{\cf17 typename} Generator1, {\cf17 typename} Generator2>\par
01274 internal::CartesianProductHolder2<Generator1, Generator2> Combine(\par
01275     {\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2) \{\par
01276   {\cf19 return} internal::CartesianProductHolder2<Generator1, Generator2>(\par
01277       g1, g2);\par
01278 \}\par
01279 \par
01280 {\cf17 template} <{\cf17 typename} Generator1, {\cf17 typename} Generator2, {\cf17 typename} Generator3>\par
01281 internal::CartesianProductHolder3<Generator1, Generator2, Generator3> Combine(\par
01282     {\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2, {\cf17 const} Generator3& g3) \{\par
01283   {\cf19 return} internal::CartesianProductHolder3<Generator1, Generator2, Generator3>(\par
01284       g1, g2, g3);\par
01285 \}\par
01286 \par
01287 {\cf17 template} <{\cf17 typename} Generator1, {\cf17 typename} Generator2, {\cf17 typename} Generator3,\par
01288     {\cf17 typename} Generator4>\par
01289 internal::CartesianProductHolder4<Generator1, Generator2, Generator3,\par
01290     Generator4> Combine(\par
01291     {\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2, {\cf17 const} Generator3& g3,\par
01292         {\cf17 const} Generator4& g4) \{\par
01293   {\cf19 return} internal::CartesianProductHolder4<Generator1, Generator2, Generator3,\par
01294       Generator4>(\par
01295       g1, g2, g3, g4);\par
01296 \}\par
01297 \par
01298 {\cf17 template} <{\cf17 typename} Generator1, {\cf17 typename} Generator2, {\cf17 typename} Generator3,\par
01299     {\cf17 typename} Generator4, {\cf17 typename} Generator5>\par
01300 internal::CartesianProductHolder5<Generator1, Generator2, Generator3,\par
01301     Generator4, Generator5> Combine(\par
01302     {\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2, {\cf17 const} Generator3& g3,\par
01303         {\cf17 const} Generator4& g4, {\cf17 const} Generator5& g5) \{\par
01304   {\cf19 return} internal::CartesianProductHolder5<Generator1, Generator2, Generator3,\par
01305       Generator4, Generator5>(\par
01306       g1, g2, g3, g4, g5);\par
01307 \}\par
01308 \par
01309 {\cf17 template} <{\cf17 typename} Generator1, {\cf17 typename} Generator2, {\cf17 typename} Generator3,\par
01310     {\cf17 typename} Generator4, {\cf17 typename} Generator5, {\cf17 typename} Generator6>\par
01311 internal::CartesianProductHolder6<Generator1, Generator2, Generator3,\par
01312     Generator4, Generator5, Generator6> Combine(\par
01313     {\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2, {\cf17 const} Generator3& g3,\par
01314         {\cf17 const} Generator4& g4, {\cf17 const} Generator5& g5, {\cf17 const} Generator6& g6) \{\par
01315   {\cf19 return} internal::CartesianProductHolder6<Generator1, Generator2, Generator3,\par
01316       Generator4, Generator5, Generator6>(\par
01317       g1, g2, g3, g4, g5, g6);\par
01318 \}\par
01319 \par
01320 {\cf17 template} <{\cf17 typename} Generator1, {\cf17 typename} Generator2, {\cf17 typename} Generator3,\par
01321     {\cf17 typename} Generator4, {\cf17 typename} Generator5, {\cf17 typename} Generator6,\par
01322     {\cf17 typename} Generator7>\par
01323 internal::CartesianProductHolder7<Generator1, Generator2, Generator3,\par
01324     Generator4, Generator5, Generator6, Generator7> Combine(\par
01325     {\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2, {\cf17 const} Generator3& g3,\par
01326         {\cf17 const} Generator4& g4, {\cf17 const} Generator5& g5, {\cf17 const} Generator6& g6,\par
01327         {\cf17 const} Generator7& g7) \{\par
01328   {\cf19 return} internal::CartesianProductHolder7<Generator1, Generator2, Generator3,\par
01329       Generator4, Generator5, Generator6, Generator7>(\par
01330       g1, g2, g3, g4, g5, g6, g7);\par
01331 \}\par
01332 \par
01333 {\cf17 template} <{\cf17 typename} Generator1, {\cf17 typename} Generator2, {\cf17 typename} Generator3,\par
01334     {\cf17 typename} Generator4, {\cf17 typename} Generator5, {\cf17 typename} Generator6,\par
01335     {\cf17 typename} Generator7, {\cf17 typename} Generator8>\par
01336 internal::CartesianProductHolder8<Generator1, Generator2, Generator3,\par
01337     Generator4, Generator5, Generator6, Generator7, Generator8> Combine(\par
01338     {\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2, {\cf17 const} Generator3& g3,\par
01339         {\cf17 const} Generator4& g4, {\cf17 const} Generator5& g5, {\cf17 const} Generator6& g6,\par
01340         {\cf17 const} Generator7& g7, {\cf17 const} Generator8& g8) \{\par
01341   {\cf19 return} internal::CartesianProductHolder8<Generator1, Generator2, Generator3,\par
01342       Generator4, Generator5, Generator6, Generator7, Generator8>(\par
01343       g1, g2, g3, g4, g5, g6, g7, g8);\par
01344 \}\par
01345 \par
01346 {\cf17 template} <{\cf17 typename} Generator1, {\cf17 typename} Generator2, {\cf17 typename} Generator3,\par
01347     {\cf17 typename} Generator4, {\cf17 typename} Generator5, {\cf17 typename} Generator6,\par
01348     {\cf17 typename} Generator7, {\cf17 typename} Generator8, {\cf17 typename} Generator9>\par
01349 internal::CartesianProductHolder9<Generator1, Generator2, Generator3,\par
01350     Generator4, Generator5, Generator6, Generator7, Generator8,\par
01351     Generator9> Combine(\par
01352     {\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2, {\cf17 const} Generator3& g3,\par
01353         {\cf17 const} Generator4& g4, {\cf17 const} Generator5& g5, {\cf17 const} Generator6& g6,\par
01354         {\cf17 const} Generator7& g7, {\cf17 const} Generator8& g8, {\cf17 const} Generator9& g9) \{\par
01355   {\cf19 return} internal::CartesianProductHolder9<Generator1, Generator2, Generator3,\par
01356       Generator4, Generator5, Generator6, Generator7, Generator8, Generator9>(\par
01357       g1, g2, g3, g4, g5, g6, g7, g8, g9);\par
01358 \}\par
01359 \par
01360 {\cf17 template} <{\cf17 typename} Generator1, {\cf17 typename} Generator2, {\cf17 typename} Generator3,\par
01361     {\cf17 typename} Generator4, {\cf17 typename} Generator5, {\cf17 typename} Generator6,\par
01362     {\cf17 typename} Generator7, {\cf17 typename} Generator8, {\cf17 typename} Generator9,\par
01363     {\cf17 typename} Generator10>\par
01364 internal::CartesianProductHolder10<Generator1, Generator2, Generator3,\par
01365     Generator4, Generator5, Generator6, Generator7, Generator8, Generator9,\par
01366     Generator10> Combine(\par
01367     {\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2, {\cf17 const} Generator3& g3,\par
01368         {\cf17 const} Generator4& g4, {\cf17 const} Generator5& g5, {\cf17 const} Generator6& g6,\par
01369         {\cf17 const} Generator7& g7, {\cf17 const} Generator8& g8, {\cf17 const} Generator9& g9,\par
01370         {\cf17 const} Generator10& g10) \{\par
01371   {\cf19 return} internal::CartesianProductHolder10<Generator1, Generator2, Generator3,\par
01372       Generator4, Generator5, Generator6, Generator7, Generator8, Generator9,\par
01373       Generator10>(\par
01374       g1, g2, g3, g4, g5, g6, g7, g8, g9, g10);\par
01375 \}\par
01376 {\cf21 # endif  }{\cf20 // GTEST_HAS_COMBINE}\par
01377 \par
01378 \par
01379 \par
01380 {\cf21 # define TEST_P(test_case_name, test_name) \\}\par
01381 {\cf21   class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\}\par
01382 {\cf21       : public test_case_name \{ \\}\par
01383 {\cf21    public: \\}\par
01384 {\cf21     GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() \{\} \\}\par
01385 {\cf21     virtual void TestBody(); \\}\par
01386 {\cf21    private: \\}\par
01387 {\cf21     static int AddToRegistry() \{ \\}\par
01388 {\cf21       ::testing::UnitTest::GetInstance()->parameterized_test_registry(). \\}\par
01389 {\cf21           GetTestCasePatternHolder<test_case_name>(\\}\par
01390 {\cf21               #test_case_name, \\}\par
01391 {\cf21               ::testing::internal::CodeLocation(\\}\par
01392 {\cf21                   __FILE__, __LINE__))->AddTestPattern(\\}\par
01393 {\cf21                       #test_case_name, \\}\par
01394 {\cf21                       #test_name, \\}\par
01395 {\cf21                       new ::testing::internal::TestMetaFactory< \\}\par
01396 {\cf21                           GTEST_TEST_CLASS_NAME_(\\}\par
01397 {\cf21                               test_case_name, test_name)>()); \\}\par
01398 {\cf21       return 0; \\}\par
01399 {\cf21     \} \\}\par
01400 {\cf21     static int gtest_registering_dummy_ GTEST_ATTRIBUTE_UNUSED_; \\}\par
01401 {\cf21     GTEST_DISALLOW_COPY_AND_ASSIGN_(\\}\par
01402 {\cf21         GTEST_TEST_CLASS_NAME_(test_case_name, test_name)); \\}\par
01403 {\cf21   \}; \\}\par
01404 {\cf21   int GTEST_TEST_CLASS_NAME_(test_case_name, \\}\par
01405 {\cf21                              test_name)::gtest_registering_dummy_ = \\}\par
01406 {\cf21       GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::AddToRegistry(); \\}\par
01407 {\cf21   void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()}\par
01408 \par
01409 {\cf20 // The optional last argument to INSTANTIATE_TEST_CASE_P allows the user}\par
01410 {\cf20 // to specify a function or functor that generates custom test name suffixes}\par
01411 {\cf20 // based on the test parameters. The function should accept one argument of}\par
01412 {\cf20 // type testing::TestParamInfo<class ParamType>, and return std::string.}\par
01413 {\cf20 //}\par
01414 {\cf20 // testing::PrintToStringParamName is a builtin test suffix generator that}\par
01415 {\cf20 // returns the value of testing::PrintToString(GetParam()). It does not work}\par
01416 {\cf20 // for std::string or C strings.}\par
01417 {\cf20 //}\par
01418 {\cf20 // Note: test names must be non-empty, unique, and may only contain ASCII}\par
01419 {\cf20 // alphanumeric characters or underscore.}\par
01420 \par
01421 {\cf21 # define INSTANTIATE_TEST_CASE_P(prefix, test_case_name, generator, ...) \\}\par
01422 {\cf21   ::testing::internal::ParamGenerator<test_case_name::ParamType> \\}\par
01423 {\cf21       gtest_##prefix##test_case_name##_EvalGenerator_() \{ return generator; \} \\}\par
01424 {\cf21   ::std::string gtest_##prefix##test_case_name##_EvalGenerateName_( \\}\par
01425 {\cf21       const ::testing::TestParamInfo<test_case_name::ParamType>& info) \{ \\}\par
01426 {\cf21     return ::testing::internal::GetParamNameGen<test_case_name::ParamType> \\}\par
01427 {\cf21         (__VA_ARGS__)(info); \\}\par
01428 {\cf21   \} \\}\par
01429 {\cf21   int gtest_##prefix##test_case_name##_dummy_ GTEST_ATTRIBUTE_UNUSED_ = \\}\par
01430 {\cf21       ::testing::UnitTest::GetInstance()->parameterized_test_registry(). \\}\par
01431 {\cf21           GetTestCasePatternHolder<test_case_name>(\\}\par
01432 {\cf21               #test_case_name, \\}\par
01433 {\cf21               ::testing::internal::CodeLocation(\\}\par
01434 {\cf21                   __FILE__, __LINE__))->AddTestCaseInstantiation(\\}\par
01435 {\cf21                       #prefix, \\}\par
01436 {\cf21                       &gtest_##prefix##test_case_name##_EvalGenerator_, \\}\par
01437 {\cf21                       &gtest_##prefix##test_case_name##_EvalGenerateName_, \\}\par
01438 {\cf21                       __FILE__, __LINE__)}\par
01439 \par
01440 \}  {\cf20 // namespace testing}\par
01441 \par
01442 {\cf21 #endif  }{\cf20 // GTEST_HAS_PARAM_TEST}\par
01443 \par
01444 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/gtest-printers.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest-printers.h}
{\xe \v gtest/include/gtest/gtest-printers.h}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <ostream>}\par
{\f2 #include <sstream>}\par
{\f2 #include <string>}\par
{\f2 #include <utility>}\par
{\f2 #include <vector>}\par
{\f2 #include "gtest/internal/gtest-port.h"}\par
{\f2 #include "gtest/internal/gtest-internal.h"}\par
{\f2 #include "gtest/internal/custom/gtest-printers.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal2::TypeWithoutFormatter< T, kTypeKind >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal2::TypeWithoutFormatter< T, kProtobuf >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal2::TypeWithoutFormatter< T, kConvertibleToInteger >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::FormatForComparison< ToPrint, OtherOperand >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::FormatForComparison< ToPrint[N], OtherOperand >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::WrapPrinterType< type >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::UniversalPrinter< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::UniversalPrinter< T[N]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::UniversalPrinter< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::UniversalTersePrinter< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::UniversalTersePrinter< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::UniversalTersePrinter< T[N]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::UniversalTersePrinter< const char * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::UniversalTersePrinter< char * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::UniversalTersePrinter< wchar_t * >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing_internal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_}(CharType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_IMPL_FORMAT_C_STRING_AS_STRING_}(CharType,  OtherStringType)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef ::std::vector< string > {\b testing::internal::Strings}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b testing::internal2::TypeKind} \{ {\b testing::internal2::kProtobuf}
, {\b testing::internal2::kConvertibleToInteger}
, {\b testing::internal2::kOtherType}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b testing::internal::DefaultPrinterType} \{ {\b testing::internal::kPrintContainer}
, {\b testing::internal::kPrintPointer}
, {\b testing::internal::kPrintFunctionPointer}
, {\b testing::internal::kPrintOther}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal2::PrintBytesInObjectTo} (const unsigned char *obj_bytes, size_t count, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Char , typename CharTraits , typename T > ::std::basic_ostream< Char, CharTraits > & {\b testing::internal2::operator<<} (::std::basic_ostream< Char, CharTraits > &os, const T &x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b testing_internal::DefaultPrintNonContainerTo} (const T &value, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::internal::GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::internal::GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_} (wchar_t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::internal::GTEST_IMPL_FORMAT_C_STRING_AS_STRING_} (char, ::std::string)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > std::string {\b testing::internal::FormatForComparisonFailureMessage} (const T1 &value, const T2 &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b testing::internal::UniversalPrint} (const T &value, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C > void {\b testing::internal::DefaultPrintTo} (WrapPrinterType< kPrintContainer >, const C &container, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b testing::internal::DefaultPrintTo} (WrapPrinterType< kPrintPointer >, T *p, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b testing::internal::DefaultPrintTo} (WrapPrinterType< kPrintFunctionPointer >, T *p, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b testing::internal::DefaultPrintTo} (WrapPrinterType< kPrintOther >, const T &value, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b testing::internal::PrintTo} (const T &value, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::PrintTo} (unsigned char c, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::PrintTo} (signed char c, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::PrintTo} (char c, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::PrintTo} (bool x, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::PrintTo} (wchar_t wc, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::PrintTo} (const char *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::PrintTo} (char *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::PrintTo} (const signed char *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::PrintTo} (signed char *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::PrintTo} (const unsigned char *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::PrintTo} (unsigned char *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::PrintTo} (const wchar_t *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::PrintTo} (wchar_t *s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b testing::internal::PrintRawArrayTo} (const T a[], size_t count, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::PrintStringTo} (const ::std::string &s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::PrintTo} (const ::std::string &s, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > void {\b testing::internal::PrintTo} (const ::std::pair< T1, T2 > &value, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b testing::internal::UniversalPrintArray} (const T *begin, size_t len, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::UniversalPrintArray} (const char *begin, size_t len, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::UniversalPrintArray} (const wchar_t *begin, size_t len, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b testing::internal::UniversalTersePrint} (const T &value, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > ::std::string {\b testing::PrintToString} (const T &value)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const size_t {\b testing::internal2::kProtobufOneLinerMaxLength} = 50\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_\:gtest-printers.h}
{\xe \v gtest-printers.h\:GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_( CharType)}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   {\cf17 template} <{\cf17 typename} OtherOperand>                                      \\\par
  class FormatForComparison<CharType*, OtherOperand> \{                  \\\par
   public:                                                              \\\par
    static ::std::string Format(CharType* value) \{                      \\\par
      return ::testing::PrintToString({\cf17 static_cast<}{\cf17 const }{\cf18 void}*{\cf17 >}(value)); \\\par
    \}                                                                   \\\par
  \}\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 292}}\par
}
{\xe \v GTEST_IMPL_FORMAT_C_STRING_AS_STRING_\:gtest-printers.h}
{\xe \v gtest-printers.h\:GTEST_IMPL_FORMAT_C_STRING_AS_STRING_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_IMPL_FORMAT_C_STRING_AS_STRING_( CharType,  OtherStringType)}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   {\cf17 template} <>                                                           \\\par
  class FormatForComparison<CharType*, OtherStringType> \{               \\\par
   public:                                                              \\\par
    static ::std::string Format(CharType* value) \{                      \\\par
      return ::testing::PrintToString(value);                           \\\par
    \}                                                                   \\\par
  \}\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-printers.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 311}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-printers.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest-printers.h}
{\xe \v gtest/include/gtest/gtest-printers.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2007, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: wan@google.com (Zhanyong Wan)}\par
00031 \par
00032 {\cf20 // Google Test - The Google C++ Testing Framework}\par
00033 {\cf20 //}\par
00034 {\cf20 // This file implements a universal value printer that can print a}\par
00035 {\cf20 // value of any type T:}\par
00036 {\cf20 //}\par
00037 {\cf20 //   void ::testing::internal::UniversalPrinter<T>::Print(value, ostream_ptr);}\par
00038 {\cf20 //}\par
00039 {\cf20 // A user can teach this function how to print a class type T by}\par
00040 {\cf20 // defining either operator<<() or PrintTo() in the namespace that}\par
00041 {\cf20 // defines T.  More specifically, the FIRST defined function in the}\par
00042 {\cf20 // following list will be used (assuming T is defined in namespace}\par
00043 {\cf20 // foo):}\par
00044 {\cf20 //}\par
00045 {\cf20 //   1. foo::PrintTo(const T&, ostream*)}\par
00046 {\cf20 //   2. operator<<(ostream&, const T&) defined in either foo or the}\par
00047 {\cf20 //      global namespace.}\par
00048 {\cf20 //}\par
00049 {\cf20 // If none of the above is defined, it will print the debug string of}\par
00050 {\cf20 // the value if it is a protocol buffer, or print the raw bytes in the}\par
00051 {\cf20 // value otherwise.}\par
00052 {\cf20 //}\par
00053 {\cf20 // To aid debugging: when T is a reference type, the address of the}\par
00054 {\cf20 // value is also printed; when T is a (const) char pointer, both the}\par
00055 {\cf20 // pointer value and the NUL-terminated string it points to are}\par
00056 {\cf20 // printed.}\par
00057 {\cf20 //}\par
00058 {\cf20 // We also provide some convenient wrappers:}\par
00059 {\cf20 //}\par
00060 {\cf20 //   // Prints a value to a string.  For a (const or not) char}\par
00061 {\cf20 //   // pointer, the NUL-terminated string (but not the pointer) is}\par
00062 {\cf20 //   // printed.}\par
00063 {\cf20 //   std::string ::testing::PrintToString(const T& value);}\par
00064 {\cf20 //}\par
00065 {\cf20 //   // Prints a value tersely: for a reference type, the referenced}\par
00066 {\cf20 //   // value (but not the address) is printed; for a (const or not) char}\par
00067 {\cf20 //   // pointer, the NUL-terminated string (but not the pointer) is}\par
00068 {\cf20 //   // printed.}\par
00069 {\cf20 //   void ::testing::internal::UniversalTersePrint(const T& value, ostream*);}\par
00070 {\cf20 //}\par
00071 {\cf20 //   // Prints value using the type inferred by the compiler.  The difference}\par
00072 {\cf20 //   // from UniversalTersePrint() is that this function prints both the}\par
00073 {\cf20 //   // pointer and the NUL-terminated string for a (const or not) char pointer.}\par
00074 {\cf20 //   void ::testing::internal::UniversalPrint(const T& value, ostream*);}\par
00075 {\cf20 //}\par
00076 {\cf20 //   // Prints the fields of a tuple tersely to a string vector, one}\par
00077 {\cf20 //   // element for each field. Tuple support must be enabled in}\par
00078 {\cf20 //   // gtest-port.h.}\par
00079 {\cf20 //   std::vector<string> UniversalTersePrintTupleFieldsToStrings(}\par
00080 {\cf20 //       const Tuple& value);}\par
00081 {\cf20 //}\par
00082 {\cf20 // Known limitation:}\par
00083 {\cf20 //}\par
00084 {\cf20 // The print primitives print the elements of an STL-style container}\par
00085 {\cf20 // using the compiler-inferred type of *iter where iter is a}\par
00086 {\cf20 // const_iterator of the container.  When const_iterator is an input}\par
00087 {\cf20 // iterator but not a forward iterator, this inferred type may not}\par
00088 {\cf20 // match value_type, and the print output may be incorrect.  In}\par
00089 {\cf20 // practice, this is rarely a problem as for most containers}\par
00090 {\cf20 // const_iterator is a forward iterator.  We'll fix this if there's an}\par
00091 {\cf20 // actual need for it.  Note that this fix cannot rely on value_type}\par
00092 {\cf20 // being defined as many user-defined container types don't have}\par
00093 {\cf20 // value_type.}\par
00094 \par
00095 {\cf21 #ifndef GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_}\par
00096 {\cf21 #define GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_}\par
00097 \par
00098 {\cf21 #include <ostream>}  {\cf20 // NOLINT}\par
00099 {\cf21 #include <sstream>}\par
00100 {\cf21 #include <string>}\par
00101 {\cf21 #include <utility>}\par
00102 {\cf21 #include <vector>}\par
00103 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00104 {\cf21 #include "gtest/internal/gtest-internal.h"}\par
00105 \par
00106 {\cf21 #if GTEST_HAS_STD_TUPLE_}\par
00107 {\cf21 # include <tuple>}\par
00108 {\cf21 #endif}\par
00109 \par
00110 {\cf17 namespace }testing \{\par
00111 \par
00112 {\cf20 // Definitions in the 'internal' and 'internal2' name spaces are}\par
00113 {\cf20 // subject to change without notice.  DO NOT USE THEM IN USER CODE!}\par
00114 {\cf17 namespace }internal2 \{\par
00115 \par
00116 {\cf20 // Prints the given number of bytes in the given object to the given}\par
00117 {\cf20 // ostream.}\par
00118 GTEST_API_ {\cf18 void} PrintBytesInObjectTo({\cf17 const} {\cf18 unsigned} {\cf18 char}* obj_bytes,\par
00119                                      {\cf18 size_t} count,\par
00120                                      ::std::ostream* os);\par
00121 \par
00122 {\cf20 // For selecting which printer to use when a given type has neither <<}\par
00123 {\cf20 // nor PrintTo().}\par
00124 {\cf17 enum} TypeKind \{\par
00125   kProtobuf,              {\cf20 // a protobuf type}\par
00126   kConvertibleToInteger,  {\cf20 // a type implicitly convertible to BiggestInt}\par
00127                           {\cf20 // (e.g. a named or unnamed enum type)}\par
00128   kOtherType              {\cf20 // anything else}\par
00129 \};\par
00130 \par
00131 {\cf20 // TypeWithoutFormatter<T, kTypeKind>::PrintValue(value, os) is called}\par
00132 {\cf20 // by the universal printer to print a value of type T when neither}\par
00133 {\cf20 // operator<< nor PrintTo() is defined for T, where kTypeKind is the}\par
00134 {\cf20 // "kind" of T as defined by enum TypeKind.}\par
00135 {\cf17 template} <{\cf17 typename} T, TypeKind kTypeKind>\par
00136 {\cf17 class }TypeWithoutFormatter \{\par
00137  {\cf17 public}:\par
00138   {\cf20 // This default version is called when kTypeKind is kOtherType.}\par
00139   {\cf17 static} {\cf18 void} PrintValue({\cf17 const} T& value, ::std::ostream* os) \{\par
00140     PrintBytesInObjectTo({\cf17 reinterpret_cast<}{\cf17 const }{\cf18 unsigned} {\cf18 char}*{\cf17 >}(&value),\par
00141                          {\cf17 sizeof}(value), os);\par
00142   \}\par
00143 \};\par
00144 \par
00145 {\cf20 // We print a protobuf using its ShortDebugString() when the string}\par
00146 {\cf20 // doesn't exceed this many characters; otherwise we print it using}\par
00147 {\cf20 // DebugString() for better readability.}\par
00148 {\cf17 const} {\cf18 size_t} kProtobufOneLinerMaxLength = 50;\par
00149 \par
00150 {\cf17 template} <{\cf17 typename} T>\par
00151 {\cf17 class }TypeWithoutFormatter<T, kProtobuf> \{\par
00152  {\cf17 public}:\par
00153   {\cf17 static} {\cf18 void} PrintValue({\cf17 const} T& value, ::std::ostream* os) \{\par
00154     std::string pretty_str = value.ShortDebugString();\par
00155     {\cf19 if} (pretty_str.length() > kProtobufOneLinerMaxLength) \{\par
00156       pretty_str = {\cf22 "\\n"} + value.DebugString();\par
00157     \}\par
00158     *os << ({\cf22 "<"} + pretty_str + {\cf22 ">"});\par
00159   \}\par
00160 \};\par
00161 \par
00162 {\cf17 template} <{\cf17 typename} T>\par
00163 {\cf17 class }TypeWithoutFormatter<T, kConvertibleToInteger> \{\par
00164  {\cf17 public}:\par
00165   {\cf20 // Since T has no << operator or PrintTo() but can be implicitly}\par
00166   {\cf20 // converted to BiggestInt, we print it as a BiggestInt.}\par
00167   {\cf20 //}\par
00168   {\cf20 // Most likely T is an enum type (either named or unnamed), in which}\par
00169   {\cf20 // case printing it as an integer is the desired behavior.  In case}\par
00170   {\cf20 // T is not an enum, printing it as an integer is the best we can do}\par
00171   {\cf20 // given that it has no user-defined printer.}\par
00172   {\cf17 static} {\cf18 void} PrintValue({\cf17 const} T& value, ::std::ostream* os) \{\par
00173     {\cf17 const} internal::BiggestInt kBigInt = value;\par
00174     *os << kBigInt;\par
00175   \}\par
00176 \};\par
00177 \par
00178 {\cf20 // Prints the given value to the given ostream.  If the value is a}\par
00179 {\cf20 // protocol message, its debug string is printed; if it's an enum or}\par
00180 {\cf20 // of a type implicitly convertible to BiggestInt, it's printed as an}\par
00181 {\cf20 // integer; otherwise the bytes in the value are printed.  This is}\par
00182 {\cf20 // what UniversalPrinter<T>::Print() does when it knows nothing about}\par
00183 {\cf20 // type T and T has neither << operator nor PrintTo().}\par
00184 {\cf20 //}\par
00185 {\cf20 // A user can override this behavior for a class type Foo by defining}\par
00186 {\cf20 // a << operator in the namespace where Foo is defined.}\par
00187 {\cf20 //}\par
00188 {\cf20 // We put this operator in namespace 'internal2' instead of 'internal'}\par
00189 {\cf20 // to simplify the implementation, as much code in 'internal' needs to}\par
00190 {\cf20 // use << in STL, which would conflict with our own << were it defined}\par
00191 {\cf20 // in 'internal'.}\par
00192 {\cf20 //}\par
00193 {\cf20 // Note that this operator<< takes a generic std::basic_ostream<Char,}\par
00194 {\cf20 // CharTraits> type instead of the more restricted std::ostream.  If}\par
00195 {\cf20 // we define it to take an std::ostream instead, we'll get an}\par
00196 {\cf20 // "ambiguous overloads" compiler error when trying to print a type}\par
00197 {\cf20 // Foo that supports streaming to std::basic_ostream<Char,}\par
00198 {\cf20 // CharTraits>, as the compiler cannot tell whether}\par
00199 {\cf20 // operator<<(std::ostream&, const T&) or}\par
00200 {\cf20 // operator<<(std::basic_stream<Char, CharTraits>, const Foo&) is more}\par
00201 {\cf20 // specific.}\par
00202 {\cf17 template} <{\cf17 typename} Char, {\cf17 typename} CharTraits, {\cf17 typename} T>\par
00203 ::std::basic_ostream<Char, CharTraits>& operator<<(\par
00204     ::std::basic_ostream<Char, CharTraits>& os, {\cf17 const} T& x) \{\par
00205   TypeWithoutFormatter<T,\par
00206       (internal::IsAProtocolMessage<T>::value ? kProtobuf :\par
00207        internal::ImplicitlyConvertible<const T&, internal::BiggestInt>::value ?\par
00208        kConvertibleToInteger : kOtherType)>::PrintValue(x, &os);\par
00209   {\cf19 return} os;\par
00210 \}\par
00211 \par
00212 \}  {\cf20 // namespace internal2}\par
00213 \}  {\cf20 // namespace testing}\par
00214 \par
00215 {\cf20 // This namespace MUST NOT BE NESTED IN ::testing, or the name look-up}\par
00216 {\cf20 // magic needed for implementing UniversalPrinter won't work.}\par
00217 {\cf17 namespace }testing_internal \{\par
00218 \par
00219 {\cf20 // Used to print a value that is not an STL-style container when the}\par
00220 {\cf20 // user doesn't define PrintTo() for it.}\par
00221 {\cf17 template} <{\cf17 typename} T>\par
00222 {\cf18 void} DefaultPrintNonContainerTo({\cf17 const} T& value, ::std::ostream* os) \{\par
00223   {\cf20 // With the following statement, during unqualified name lookup,}\par
00224   {\cf20 // testing::internal2::operator<< appears as if it was declared in}\par
00225   {\cf20 // the nearest enclosing namespace that contains both}\par
00226   {\cf20 // ::testing_internal and ::testing::internal2, i.e. the global}\par
00227   {\cf20 // namespace.  For more details, refer to the C++ Standard section}\par
00228   {\cf20 // 7.3.4-1 [namespace.udir].  This allows us to fall back onto}\par
00229   {\cf20 // testing::internal2::operator<< in case T doesn't come with a <<}\par
00230   {\cf20 // operator.}\par
00231   {\cf20 //}\par
00232   {\cf20 // We cannot write 'using ::testing::internal2::operator<<;', which}\par
00233   {\cf20 // gcc 3.3 fails to compile due to a compiler bug.}\par
00234   {\cf17 using namespace }::testing::internal2;  {\cf20 // NOLINT}\par
00235 \par
00236   {\cf20 // Assuming T is defined in namespace foo, in the next statement,}\par
00237   {\cf20 // the compiler will consider all of:}\par
00238   {\cf20 //}\par
00239   {\cf20 //   1. foo::operator<< (thanks to Koenig look-up),}\par
00240   {\cf20 //   2. ::operator<< (as the current namespace is enclosed in ::),}\par
00241   {\cf20 //   3. testing::internal2::operator<< (thanks to the using statement above).}\par
00242   {\cf20 //}\par
00243   {\cf20 // The operator<< whose type matches T best will be picked.}\par
00244   {\cf20 //}\par
00245   {\cf20 // We deliberately allow #2 to be a candidate, as sometimes it's}\par
00246   {\cf20 // impossible to define #1 (e.g. when foo is ::std, defining}\par
00247   {\cf20 // anything in it is undefined behavior unless you are a compiler}\par
00248   {\cf20 // vendor.).}\par
00249   *os << value;\par
00250 \}\par
00251 \par
00252 \}  {\cf20 // namespace testing_internal}\par
00253 \par
00254 {\cf17 namespace }testing \{\par
00255 {\cf17 namespace }internal \{\par
00256 \par
00257 {\cf20 // FormatForComparison<ToPrint, OtherOperand>::Format(value) formats a}\par
00258 {\cf20 // value of type ToPrint that is an operand of a comparison assertion}\par
00259 {\cf20 // (e.g. ASSERT_EQ).  OtherOperand is the type of the other operand in}\par
00260 {\cf20 // the comparison, and is used to help determine the best way to}\par
00261 {\cf20 // format the value.  In particular, when the value is a C string}\par
00262 {\cf20 // (char pointer) and the other operand is an STL string object, we}\par
00263 {\cf20 // want to format the C string as a string, since we know it is}\par
00264 {\cf20 // compared by value with the string object.  If the value is a char}\par
00265 {\cf20 // pointer but the other operand is not an STL string object, we don't}\par
00266 {\cf20 // know whether the pointer is supposed to point to a NUL-terminated}\par
00267 {\cf20 // string, and thus want to print it as a pointer to be safe.}\par
00268 {\cf20 //}\par
00269 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
00270 \par
00271 {\cf20 // The default case.}\par
00272 {\cf17 template} <{\cf17 typename} ToPr{\cf18 int}, {\cf17 typename} OtherOperand>\par
00273 {\cf17 class }FormatForComparison \{\par
00274  {\cf17 public}:\par
00275   static ::std::string Format({\cf17 const} ToPrint& value) \{\par
00276     return ::testing::PrintToString(value);\par
00277   \}\par
00278 \};\par
00279 \par
00280 {\cf20 // Array.}\par
00281 {\cf17 template} <{\cf17 typename} ToPr{\cf18 int}, {\cf18 size_t} N, {\cf17 typename} OtherOperand>\par
00282 {\cf17 class }FormatForComparison<ToPrint[N], OtherOperand> \{\par
00283  {\cf17 public}:\par
00284   static ::std::string Format({\cf17 const} ToPrint* value) \{\par
00285     {\cf19 return} FormatForComparison<const ToPrint*, OtherOperand>::Format(value);\par
00286   \}\par
00287 \};\par
00288 \par
00289 {\cf20 // By default, print C string as pointers to be safe, as we don't know}\par
00290 {\cf20 // whether they actually point to a NUL-terminated string.}\par
00291 \par
00292 {\cf21 #define GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(CharType)                \\}\par
00293 {\cf21   template <typename OtherOperand>                                      \\}\par
00294 {\cf21   class FormatForComparison<CharType*, OtherOperand> \{                  \\}\par
00295 {\cf21    public:                                                              \\}\par
00296 {\cf21     static ::std::string Format(CharType* value) \{                      \\}\par
00297 {\cf21       return ::testing::PrintToString(static_cast<const void*>(value)); \\}\par
00298 {\cf21     \}                                                                   \\}\par
00299 {\cf21   \}}\par
00300 \par
00301 GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_({\cf18 char});\par
00302 GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_({\cf17 const} {\cf18 char});\par
00303 GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_({\cf18 wchar_t});\par
00304 GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_({\cf17 const} {\cf18 wchar_t});\par
00305 \par
00306 {\cf21 #undef GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_}\par
00307 \par
00308 {\cf20 // If a C string is compared with an STL string object, we know it's meant}\par
00309 {\cf20 // to point to a NUL-terminated string, and thus can print it as a string.}\par
00310 \par
00311 {\cf21 #define GTEST_IMPL_FORMAT_C_STRING_AS_STRING_(CharType, OtherStringType) \\}\par
00312 {\cf21   template <>                                                           \\}\par
00313 {\cf21   class FormatForComparison<CharType*, OtherStringType> \{               \\}\par
00314 {\cf21    public:                                                              \\}\par
00315 {\cf21     static ::std::string Format(CharType* value) \{                      \\}\par
00316 {\cf21       return ::testing::PrintToString(value);                           \\}\par
00317 {\cf21     \}                                                                   \\}\par
00318 {\cf21   \}}\par
00319 \par
00320 GTEST_IMPL_FORMAT_C_STRING_AS_STRING_({\cf18 char}, ::std::string);\par
00321 GTEST_IMPL_FORMAT_C_STRING_AS_STRING_({\cf17 const} {\cf18 char}, ::std::string);\par
00322 \par
00323 {\cf21 #if GTEST_HAS_GLOBAL_STRING}\par
00324 GTEST_IMPL_FORMAT_C_STRING_AS_STRING_({\cf18 char}, ::string);\par
00325 GTEST_IMPL_FORMAT_C_STRING_AS_STRING_({\cf17 const} {\cf18 char}, ::string);\par
00326 {\cf21 #endif}\par
00327 \par
00328 {\cf21 #if GTEST_HAS_GLOBAL_WSTRING}\par
00329 GTEST_IMPL_FORMAT_C_STRING_AS_STRING_({\cf18 wchar_t}, ::wstring);\par
00330 GTEST_IMPL_FORMAT_C_STRING_AS_STRING_({\cf17 const} {\cf18 wchar_t}, ::wstring);\par
00331 {\cf21 #endif}\par
00332 \par
00333 {\cf21 #if GTEST_HAS_STD_WSTRING}\par
00334 GTEST_IMPL_FORMAT_C_STRING_AS_STRING_({\cf18 wchar_t}, ::std::wstring);\par
00335 GTEST_IMPL_FORMAT_C_STRING_AS_STRING_({\cf17 const} {\cf18 wchar_t}, ::std::wstring);\par
00336 {\cf21 #endif}\par
00337 \par
00338 {\cf21 #undef GTEST_IMPL_FORMAT_C_STRING_AS_STRING_}\par
00339 \par
00340 {\cf20 // Formats a comparison assertion (e.g. ASSERT_EQ, EXPECT_LT, and etc)}\par
00341 {\cf20 // operand to be used in a failure message.  The type (but not value)}\par
00342 {\cf20 // of the other operand may affect the format.  This allows us to}\par
00343 {\cf20 // print a char* as a raw pointer when it is compared against another}\par
00344 {\cf20 // char* or void*, and print it as a C string when it is compared}\par
00345 {\cf20 // against an std::string object, for example.}\par
00346 {\cf20 //}\par
00347 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
00348 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
00349 std::string FormatForComparisonFailureMessage(\par
00350     {\cf17 const} T1& value, {\cf17 const} T2& {\cf20 /* other_operand */}) \{\par
00351   {\cf19 return} FormatForComparison<T1, T2>::Format(value);\par
00352 \}\par
00353 \par
00354 {\cf20 // UniversalPrinter<T>::Print(value, ostream_ptr) prints the given}\par
00355 {\cf20 // value to the given ostream.  The caller must ensure that}\par
00356 {\cf20 // 'ostream_ptr' is not NULL, or the behavior is undefined.}\par
00357 {\cf20 //}\par
00358 {\cf20 // We define UniversalPrinter as a class template (as opposed to a}\par
00359 {\cf20 // function template), as we need to partially specialize it for}\par
00360 {\cf20 // reference types, which cannot be done with function templates.}\par
00361 {\cf17 template} <{\cf17 typename} T>\par
00362 {\cf17 class }UniversalPrinter;\par
00363 \par
00364 {\cf17 template} <{\cf17 typename} T>\par
00365 {\cf18 void} UniversalPrint({\cf17 const} T& value, ::std::ostream* os);\par
00366 \par
00367 {\cf17 enum} DefaultPrinterType \{\par
00368   kPrintContainer,\par
00369   kPrintPointer,\par
00370   kPrintFunctionPointer,\par
00371   kPrintOther,\par
00372 \};\par
00373 {\cf17 template} <DefaultPr{\cf18 int}erType type> {\cf17 struct }WrapPrinterType \{\};\par
00374 \par
00375 {\cf20 // Used to print an STL-style container when the user doesn't define}\par
00376 {\cf20 // a PrintTo() for it.}\par
00377 {\cf17 template} <{\cf17 typename} C>\par
00378 {\cf18 void} DefaultPrintTo(WrapPrinterType<kPrintContainer> {\cf20 /* dummy */},\par
00379                     {\cf17 const} C& container, ::std::ostream* os) \{\par
00380   {\cf17 const} {\cf18 size_t} kMaxCount = 32;  {\cf20 // The maximum number of elements to print.}\par
00381   *os << {\cf23 '\{'};\par
00382   {\cf18 size_t} count = 0;\par
00383   {\cf19 for} ({\cf17 typename} C::const_iterator it = container.begin();\par
00384        it != container.end(); ++it, ++count) \{\par
00385     {\cf19 if} (count > 0) \{\par
00386       *os << {\cf23 ','};\par
00387       {\cf19 if} (count == kMaxCount) \{  {\cf20 // Enough has been printed.}\par
00388         *os << {\cf22 " ..."};\par
00389         {\cf19 break};\par
00390       \}\par
00391     \}\par
00392     *os << {\cf23 ' '};\par
00393     {\cf20 // We cannot call PrintTo(*it, os) here as PrintTo() doesn't}\par
00394     {\cf20 // handle *it being a native array.}\par
00395     internal::UniversalPrint(*it, os);\par
00396   \}\par
00397 \par
00398   {\cf19 if} (count > 0) \{\par
00399     *os << {\cf23 ' '};\par
00400   \}\par
00401   *os << {\cf23 '\}'};\par
00402 \}\par
00403 \par
00404 {\cf20 // Used to print a pointer that is neither a char pointer nor a member}\par
00405 {\cf20 // pointer, when the user doesn't define PrintTo() for it.  (A member}\par
00406 {\cf20 // variable pointer or member function pointer doesn't really point to}\par
00407 {\cf20 // a location in the address space.  Their representation is}\par
00408 {\cf20 // implementation-defined.  Therefore they will be printed as raw}\par
00409 {\cf20 // bytes.)}\par
00410 {\cf17 template} <{\cf17 typename} T>\par
00411 {\cf18 void} DefaultPrintTo(WrapPrinterType<kPrintPointer> {\cf20 /* dummy */},\par
00412                     T* p, ::std::ostream* os) \{\par
00413   {\cf19 if} (p == NULL) \{\par
00414     *os << {\cf22 "NULL"};\par
00415   \} {\cf19 else} \{\par
00416     {\cf20 // T is not a function type.  We just call << to print p,}\par
00417     {\cf20 // relying on ADL to pick up user-defined << for their pointer}\par
00418     {\cf20 // types, if any.}\par
00419     *os << p;\par
00420   \}\par
00421 \}\par
00422 {\cf17 template} <{\cf17 typename} T>\par
00423 {\cf18 void} DefaultPrintTo(WrapPrinterType<kPrintFunctionPointer> {\cf20 /* dummy */},\par
00424                     T* p, ::std::ostream* os) \{\par
00425   {\cf19 if} (p == NULL) \{\par
00426     *os << {\cf22 "NULL"};\par
00427   \} {\cf19 else} \{\par
00428     {\cf20 // T is a function type, so '*os << p' doesn't do what we want}\par
00429     {\cf20 // (it just prints p as bool).  We want to print p as a const}\par
00430     {\cf20 // void*.  However, we cannot cast it to const void* directly,}\par
00431     {\cf20 // even using reinterpret_cast, as earlier versions of gcc}\par
00432     {\cf20 // (e.g. 3.4.5) cannot compile the cast when p is a function}\par
00433     {\cf20 // pointer.  Casting to UInt64 first solves the problem.}\par
00434     *os << reinterpret_cast<const void*>(\par
00435         {\cf17 reinterpret_cast<}internal::UInt64{\cf17 >}(p));\par
00436   \}\par
00437 \}\par
00438 \par
00439 {\cf20 // Used to print a non-container, non-pointer value when the user}\par
00440 {\cf20 // doesn't define PrintTo() for it.}\par
00441 {\cf17 template} <{\cf17 typename} T>\par
00442 {\cf18 void} DefaultPrintTo(WrapPrinterType<kPrintOther> {\cf20 /* dummy */},\par
00443                     {\cf17 const} T& value, ::std::ostream* os) \{\par
00444   ::testing_internal::DefaultPrintNonContainerTo(value, os);\par
00445 \}\par
00446 \par
00447 {\cf20 // Prints the given value using the << operator if it has one;}\par
00448 {\cf20 // otherwise prints the bytes in it.  This is what}\par
00449 {\cf20 // UniversalPrinter<T>::Print() does when PrintTo() is not specialized}\par
00450 {\cf20 // or overloaded for type T.}\par
00451 {\cf20 //}\par
00452 {\cf20 // A user can override this behavior for a class type Foo by defining}\par
00453 {\cf20 // an overload of PrintTo() in the namespace where Foo is defined.  We}\par
00454 {\cf20 // give the user this option as sometimes defining a << operator for}\par
00455 {\cf20 // Foo is not desirable (e.g. the coding style may prevent doing it,}\par
00456 {\cf20 // or there is already a << operator but it doesn't do what the user}\par
00457 {\cf20 // wants).}\par
00458 {\cf17 template} <{\cf17 typename} T>\par
00459 {\cf18 void} PrintTo({\cf17 const} T& value, ::std::ostream* os) \{\par
00460   {\cf20 // DefaultPrintTo() is overloaded.  The type of its first argument}\par
00461   {\cf20 // determines which version will be picked.}\par
00462   {\cf20 //}\par
00463   {\cf20 // Note that we check for container types here, prior to we check}\par
00464   {\cf20 // for protocol message types in our operator<<.  The rationale is:}\par
00465   {\cf20 //}\par
00466   {\cf20 // For protocol messages, we want to give people a chance to}\par
00467   {\cf20 // override Google Mock's format by defining a PrintTo() or}\par
00468   {\cf20 // operator<<.  For STL containers, other formats can be}\par
00469   {\cf20 // incompatible with Google Mock's format for the container}\par
00470   {\cf20 // elements; therefore we check for container types here to ensure}\par
00471   {\cf20 // that our format is used.}\par
00472   {\cf20 //}\par
00473   {\cf20 // Note that MSVC and clang-cl do allow an implicit conversion from}\par
00474   {\cf20 // pointer-to-function to pointer-to-object, but clang-cl warns on it.}\par
00475   {\cf20 // So don't use ImplicitlyConvertible if it can be helped since it will}\par
00476   {\cf20 // cause this warning, and use a separate overload of DefaultPrintTo for}\par
00477   {\cf20 // function pointers so that the `*os << p` in the object pointer overload}\par
00478   {\cf20 // doesn't cause that warning either.}\par
00479   DefaultPrintTo(\par
00480       WrapPrinterType<{\cf17 sizeof}(IsContainerTest<T>(0)) == {\cf17 sizeof}(IsContainer)\par
00481           ? kPrintContainer : !is_pointer<T>::value\par
00482                 ? kPrintOther\par
00483 #{\cf19 if} GTEST_LANG_CXX11\par
00484                 : std::is_function<{\cf17 typename} std::remove_pointer<T>::type>::value\par
00485 #{\cf19 else}\par
00486                 : !internal::ImplicitlyConvertible<T, const void*>::value\par
00487 #endif\par
00488                       ? kPrintFunctionPointer\par
00489                       : kPrintPointer>(),\par
00490       value, os);\par
00491 \}\par
00492 \par
00493 {\cf20 // The following list of PrintTo() overloads tells}\par
00494 {\cf20 // UniversalPrinter<T>::Print() how to print standard types (built-in}\par
00495 {\cf20 // types, strings, plain arrays, and pointers).}\par
00496 \par
00497 {\cf20 // Overloads for various char types.}\par
00498 GTEST_API_ {\cf18 void} PrintTo({\cf18 unsigned} {\cf18 char} c, ::std::ostream* os);\par
00499 GTEST_API_ {\cf18 void} PrintTo({\cf18 signed} {\cf18 char} c, ::std::ostream* os);\par
00500 {\cf17 inline} {\cf18 void} PrintTo({\cf18 char} c, ::std::ostream* os) \{\par
00501   {\cf20 // When printing a plain char, we always treat it as unsigned.  This}\par
00502   {\cf20 // way, the output won't be affected by whether the compiler thinks}\par
00503   {\cf20 // char is signed or not.}\par
00504   PrintTo({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(c), os);\par
00505 \}\par
00506 \par
00507 {\cf20 // Overloads for other simple built-in types.}\par
00508 {\cf17 inline} {\cf18 void} PrintTo({\cf18 bool} x, ::std::ostream* os) \{\par
00509   *os << (x ? {\cf22 "true"} : {\cf22 "false"});\par
00510 \}\par
00511 \par
00512 {\cf20 // Overload for wchar_t type.}\par
00513 {\cf20 // Prints a wchar_t as a symbol if it is printable or as its internal}\par
00514 {\cf20 // code otherwise and also as its decimal code (except for L'\\0').}\par
00515 {\cf20 // The L'\\0' char is printed as "L'\\\\0'". The decimal code is printed}\par
00516 {\cf20 // as signed integer when wchar_t is implemented by the compiler}\par
00517 {\cf20 // as a signed type and is printed as an unsigned integer when wchar_t}\par
00518 {\cf20 // is implemented as an unsigned type.}\par
00519 GTEST_API_ {\cf18 void} PrintTo({\cf18 wchar_t} wc, ::std::ostream* os);\par
00520 \par
00521 {\cf20 // Overloads for C strings.}\par
00522 GTEST_API_ {\cf18 void} PrintTo({\cf17 const} {\cf18 char}* s, ::std::ostream* os);\par
00523 {\cf17 inline} {\cf18 void} PrintTo({\cf18 char}* s, ::std::ostream* os) \{\par
00524   PrintTo(ImplicitCast_<const char*>(s), os);\par
00525 \}\par
00526 \par
00527 {\cf20 // signed/unsigned char is often used for representing binary data, so}\par
00528 {\cf20 // we print pointers to it as void* to be safe.}\par
00529 {\cf17 inline} {\cf18 void} PrintTo({\cf17 const} {\cf18 signed} {\cf18 char}* s, ::std::ostream* os) \{\par
00530   PrintTo(ImplicitCast_<const void*>(s), os);\par
00531 \}\par
00532 {\cf17 inline} {\cf18 void} PrintTo({\cf18 signed} {\cf18 char}* s, ::std::ostream* os) \{\par
00533   PrintTo(ImplicitCast_<const void*>(s), os);\par
00534 \}\par
00535 {\cf17 inline} {\cf18 void} PrintTo({\cf17 const} {\cf18 unsigned} {\cf18 char}* s, ::std::ostream* os) \{\par
00536   PrintTo(ImplicitCast_<const void*>(s), os);\par
00537 \}\par
00538 {\cf17 inline} {\cf18 void} PrintTo({\cf18 unsigned} {\cf18 char}* s, ::std::ostream* os) \{\par
00539   PrintTo(ImplicitCast_<const void*>(s), os);\par
00540 \}\par
00541 \par
00542 {\cf20 // MSVC can be configured to define wchar_t as a typedef of unsigned}\par
00543 {\cf20 // short.  It defines _NATIVE_WCHAR_T_DEFINED when wchar_t is a native}\par
00544 {\cf20 // type.  When wchar_t is a typedef, defining an overload for const}\par
00545 {\cf20 // wchar_t* would cause unsigned short* be printed as a wide string,}\par
00546 {\cf20 // possibly causing invalid memory accesses.}\par
00547 {\cf21 #if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)}\par
00548 {\cf20 // Overloads for wide C strings}\par
00549 GTEST_API_ {\cf18 void} PrintTo({\cf17 const} {\cf18 wchar_t}* s, ::std::ostream* os);\par
00550 {\cf17 inline} {\cf18 void} PrintTo({\cf18 wchar_t}* s, ::std::ostream* os) \{\par
00551   PrintTo(ImplicitCast_<const wchar_t*>(s), os);\par
00552 \}\par
00553 {\cf21 #endif}\par
00554 \par
00555 {\cf20 // Overload for C arrays.  Multi-dimensional arrays are printed}\par
00556 {\cf20 // properly.}\par
00557 \par
00558 {\cf20 // Prints the given number of elements in an array, without printing}\par
00559 {\cf20 // the curly braces.}\par
00560 {\cf17 template} <{\cf17 typename} T>\par
00561 {\cf18 void} PrintRawArrayTo({\cf17 const} T a[], {\cf18 size_t} count, ::std::ostream* os) \{\par
00562   UniversalPrint(a[0], os);\par
00563   {\cf19 for} ({\cf18 size_t} i = 1; i != count; i++) \{\par
00564     *os << {\cf22 ", "};\par
00565     UniversalPrint(a[i], os);\par
00566   \}\par
00567 \}\par
00568 \par
00569 {\cf20 // Overloads for ::string and ::std::string.}\par
00570 {\cf21 #if GTEST_HAS_GLOBAL_STRING}\par
00571 GTEST_API_ {\cf18 void} PrintStringTo(const ::string&s, ::std::ostream* os);\par
00572 {\cf17 inline} {\cf18 void} PrintTo(const ::string& s, ::std::ostream* os) \{\par
00573   PrintStringTo(s, os);\par
00574 \}\par
00575 {\cf21 #endif  }{\cf20 // GTEST_HAS_GLOBAL_STRING}\par
00576 \par
00577 GTEST_API_ {\cf18 void} PrintStringTo(const ::std::string&s, ::std::ostream* os);\par
00578 {\cf17 inline} {\cf18 void} PrintTo(const ::std::string& s, ::std::ostream* os) \{\par
00579   PrintStringTo(s, os);\par
00580 \}\par
00581 \par
00582 {\cf20 // Overloads for ::wstring and ::std::wstring.}\par
00583 {\cf21 #if GTEST_HAS_GLOBAL_WSTRING}\par
00584 GTEST_API_ {\cf18 void} PrintWideStringTo(const ::wstring&s, ::std::ostream* os);\par
00585 {\cf17 inline} {\cf18 void} PrintTo(const ::wstring& s, ::std::ostream* os) \{\par
00586   PrintWideStringTo(s, os);\par
00587 \}\par
00588 {\cf21 #endif  }{\cf20 // GTEST_HAS_GLOBAL_WSTRING}\par
00589 \par
00590 {\cf21 #if GTEST_HAS_STD_WSTRING}\par
00591 GTEST_API_ {\cf18 void} PrintWideStringTo(const ::std::wstring&s, ::std::ostream* os);\par
00592 {\cf17 inline} {\cf18 void} PrintTo(const ::std::wstring& s, ::std::ostream* os) \{\par
00593   PrintWideStringTo(s, os);\par
00594 \}\par
00595 {\cf21 #endif  }{\cf20 // GTEST_HAS_STD_WSTRING}\par
00596 \par
00597 {\cf21 #if GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_}\par
00598 {\cf20 // Helper function for printing a tuple.  T must be instantiated with}\par
00599 {\cf20 // a tuple type.}\par
00600 {\cf17 template} <{\cf17 typename} T>\par
00601 {\cf18 void} PrintTupleTo({\cf17 const} T& t, ::std::ostream* os);\par
00602 {\cf21 #endif  }{\cf20 // GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_}\par
00603 \par
00604 {\cf21 #if GTEST_HAS_TR1_TUPLE}\par
00605 {\cf20 // Overload for ::std::tr1::tuple.  Needed for printing function arguments,}\par
00606 {\cf20 // which are packed as tuples.}\par
00607 \par
00608 {\cf20 // Overloaded PrintTo() for tuples of various arities.  We support}\par
00609 {\cf20 // tuples of up-to 10 fields.  The following implementation works}\par
00610 {\cf20 // regardless of whether tr1::tuple is implemented using the}\par
00611 {\cf20 // non-standard variadic template feature or not.}\par
00612 \par
00613 {\cf17 inline} {\cf18 void} PrintTo(const ::std::tr1::tuple<>& t, ::std::ostream* os) \{\par
00614   PrintTupleTo(t, os);\par
00615 \}\par
00616 \par
00617 {\cf17 template} <{\cf17 typename} T1>\par
00618 {\cf18 void} PrintTo(const ::std::tr1::tuple<T1>& t, ::std::ostream* os) \{\par
00619   PrintTupleTo(t, os);\par
00620 \}\par
00621 \par
00622 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
00623 {\cf18 void} PrintTo(const ::std::tr1::tuple<T1, T2>& t, ::std::ostream* os) \{\par
00624   PrintTupleTo(t, os);\par
00625 \}\par
00626 \par
00627 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3>\par
00628 {\cf18 void} PrintTo(const ::std::tr1::tuple<T1, T2, T3>& t, ::std::ostream* os) \{\par
00629   PrintTupleTo(t, os);\par
00630 \}\par
00631 \par
00632 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4>\par
00633 {\cf18 void} PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4>& t, ::std::ostream* os) \{\par
00634   PrintTupleTo(t, os);\par
00635 \}\par
00636 \par
00637 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5>\par
00638 {\cf18 void} PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5>& t,\par
00639              ::std::ostream* os) \{\par
00640   PrintTupleTo(t, os);\par
00641 \}\par
00642 \par
00643 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00644           {\cf17 typename} T6>\par
00645 {\cf18 void} PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6>& t,\par
00646              ::std::ostream* os) \{\par
00647   PrintTupleTo(t, os);\par
00648 \}\par
00649 \par
00650 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00651           {\cf17 typename} T6, {\cf17 typename} T7>\par
00652 {\cf18 void} PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7>& t,\par
00653              ::std::ostream* os) \{\par
00654   PrintTupleTo(t, os);\par
00655 \}\par
00656 \par
00657 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00658           {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8>\par
00659 {\cf18 void} PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8>& t,\par
00660              ::std::ostream* os) \{\par
00661   PrintTupleTo(t, os);\par
00662 \}\par
00663 \par
00664 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00665           {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9>\par
00666 {\cf18 void} PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>& t,\par
00667              ::std::ostream* os) \{\par
00668   PrintTupleTo(t, os);\par
00669 \}\par
00670 \par
00671 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00672           {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10>\par
00673 {\cf18 void} PrintTo(\par
00674     const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>& t,\par
00675     ::std::ostream* os) \{\par
00676   PrintTupleTo(t, os);\par
00677 \}\par
00678 {\cf21 #endif  }{\cf20 // GTEST_HAS_TR1_TUPLE}\par
00679 \par
00680 {\cf21 #if GTEST_HAS_STD_TUPLE_}\par
00681 {\cf17 template} <{\cf17 typename}... Types>\par
00682 {\cf18 void} PrintTo(const ::std::tuple<Types...>& t, ::std::ostream* os) \{\par
00683   PrintTupleTo(t, os);\par
00684 \}\par
00685 {\cf21 #endif  }{\cf20 // GTEST_HAS_STD_TUPLE_}\par
00686 \par
00687 {\cf20 // Overload for std::pair.}\par
00688 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
00689 {\cf18 void} PrintTo(const ::std::pair<T1, T2>& value, ::std::ostream* os) \{\par
00690   *os << {\cf23 '('};\par
00691   {\cf20 // We cannot use UniversalPrint(value.first, os) here, as T1 may be}\par
00692   {\cf20 // a reference type.  The same for printing value.second.}\par
00693   UniversalPrinter<T1>::Print(value.first, os);\par
00694   *os << {\cf22 ", "};\par
00695   UniversalPrinter<T2>::Print(value.second, os);\par
00696   *os << {\cf23 ')'};\par
00697 \}\par
00698 \par
00699 {\cf20 // Implements printing a non-reference type T by letting the compiler}\par
00700 {\cf20 // pick the right overload of PrintTo() for T.}\par
00701 {\cf17 template} <{\cf17 typename} T>\par
00702 {\cf17 class }UniversalPrinter \{\par
00703  {\cf17 public}:\par
00704   {\cf20 // MSVC warns about adding const to a function type, so we want to}\par
00705   {\cf20 // disable the warning.}\par
00706   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4180)\par
00707 \par
00708   {\cf20 // Note: we deliberately don't call this PrintTo(), as that name}\par
00709   {\cf20 // conflicts with ::testing::internal::PrintTo in the body of the}\par
00710   {\cf20 // function.}\par
00711   static {\cf18 void} Print(const T& value, ::std::ostream* os) \{\par
00712     {\cf20 // By default, ::testing::internal::PrintTo() is used for printing}\par
00713     {\cf20 // the value.}\par
00714     {\cf20 //}\par
00715     {\cf20 // Thanks to Koenig look-up, if T is a class and has its own}\par
00716     {\cf20 // PrintTo() function defined in its namespace, that function will}\par
00717     {\cf20 // be visible here.  Since it is more specific than the generic ones}\par
00718     {\cf20 // in ::testing::internal, it will be picked by the compiler in the}\par
00719     {\cf20 // following statement - exactly what we want.}\par
00720     PrintTo(value, os);\par
00721   \}\par
00722 \par
00723   GTEST_DISABLE_MSC_WARNINGS_POP_()\par
00724 \};\par
00725 \par
00726 {\cf20 // UniversalPrintArray(begin, len, os) prints an array of 'len'}\par
00727 {\cf20 // elements, starting at address 'begin'.}\par
00728 {\cf17 template} <{\cf17 typename} T>\par
00729 {\cf18 void} UniversalPrintArray({\cf17 const} T* begin, {\cf18 size_t} len, ::std::ostream* os) \{\par
00730   {\cf19 if} (len == 0) \{\par
00731     *os << {\cf22 "\{\}"};\par
00732   \} {\cf19 else} \{\par
00733     *os << {\cf22 "\{ "};\par
00734     {\cf17 const} {\cf18 size_t} kThreshold = 18;\par
00735     {\cf17 const} {\cf18 size_t} kChunkSize = 8;\par
00736     {\cf20 // If the array has more than kThreshold elements, we'll have to}\par
00737     {\cf20 // omit some details by printing only the first and the last}\par
00738     {\cf20 // kChunkSize elements.}\par
00739     {\cf20 // TODO(wan@google.com): let the user control the threshold using a flag.}\par
00740     {\cf19 if} (len <= kThreshold) \{\par
00741       PrintRawArrayTo(begin, len, os);\par
00742     \} {\cf19 else} \{\par
00743       PrintRawArrayTo(begin, kChunkSize, os);\par
00744       *os << {\cf22 ", ..., "};\par
00745       PrintRawArrayTo(begin + len - kChunkSize, kChunkSize, os);\par
00746     \}\par
00747     *os << {\cf22 " \}"};\par
00748   \}\par
00749 \}\par
00750 {\cf20 // This overload prints a (const) char array compactly.}\par
00751 GTEST_API_ {\cf18 void} UniversalPrintArray(\par
00752     {\cf17 const} {\cf18 char}* begin, {\cf18 size_t} len, ::std::ostream* os);\par
00753 \par
00754 {\cf20 // This overload prints a (const) wchar_t array compactly.}\par
00755 GTEST_API_ {\cf18 void} UniversalPrintArray(\par
00756     {\cf17 const} {\cf18 wchar_t}* begin, {\cf18 size_t} len, ::std::ostream* os);\par
00757 \par
00758 {\cf20 // Implements printing an array type T[N].}\par
00759 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} N>\par
00760 {\cf17 class }UniversalPrinter<T[N]> \{\par
00761  {\cf17 public}:\par
00762   {\cf20 // Prints the given array, omitting some elements when there are too}\par
00763   {\cf20 // many.}\par
00764   {\cf17 static} {\cf18 void} Print({\cf17 const} T (&a)[N], ::std::ostream* os) \{\par
00765     UniversalPrintArray(a, N, os);\par
00766   \}\par
00767 \};\par
00768 \par
00769 {\cf20 // Implements printing a reference type T&.}\par
00770 {\cf17 template} <{\cf17 typename} T>\par
00771 {\cf17 class }UniversalPrinter<T&> \{\par
00772  {\cf17 public}:\par
00773   {\cf20 // MSVC warns about adding const to a function type, so we want to}\par
00774   {\cf20 // disable the warning.}\par
00775   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4180)\par
00776 \par
00777   static {\cf18 void} Print(const T& value, ::std::ostream* os) \{\par
00778     {\cf20 // Prints the address of the value.  We use reinterpret_cast here}\par
00779     {\cf20 // as static_cast doesn't compile when T is a function type.}\par
00780     *os << {\cf22 "@"} << {\cf17 reinterpret_cast<}{\cf17 const }{\cf18 void}*{\cf17 >}(&value) << {\cf22 " "};\par
00781 \par
00782     {\cf20 // Then prints the value itself.}\par
00783     UniversalPrint(value, os);\par
00784   \}\par
00785 \par
00786   GTEST_DISABLE_MSC_WARNINGS_POP_()\par
00787 \};\par
00788 \par
00789 {\cf20 // Prints a value tersely: for a reference type, the referenced value}\par
00790 {\cf20 // (but not the address) is printed; for a (const) char pointer, the}\par
00791 {\cf20 // NUL-terminated string (but not the pointer) is printed.}\par
00792 \par
00793 {\cf17 template} <{\cf17 typename} T>\par
00794 {\cf17 class }UniversalTersePrinter \{\par
00795  {\cf17 public}:\par
00796   {\cf17 static} {\cf18 void} Print({\cf17 const} T& value, ::std::ostream* os) \{\par
00797     UniversalPrint(value, os);\par
00798   \}\par
00799 \};\par
00800 {\cf17 template} <{\cf17 typename} T>\par
00801 {\cf17 class }UniversalTersePrinter<T&> \{\par
00802  {\cf17 public}:\par
00803   {\cf17 static} {\cf18 void} Print({\cf17 const} T& value, ::std::ostream* os) \{\par
00804     UniversalPrint(value, os);\par
00805   \}\par
00806 \};\par
00807 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} N>\par
00808 {\cf17 class }UniversalTersePrinter<T[N]> \{\par
00809  {\cf17 public}:\par
00810   {\cf17 static} {\cf18 void} Print({\cf17 const} T (&value)[N], ::std::ostream* os) \{\par
00811     UniversalPrinter<T[N]>::Print(value, os);\par
00812   \}\par
00813 \};\par
00814 {\cf17 template} <>\par
00815 {\cf17 class }UniversalTersePrinter<const char*> \{\par
00816  {\cf17 public}:\par
00817   {\cf17 static} {\cf18 void} Print({\cf17 const} {\cf18 char}* str, ::std::ostream* os) \{\par
00818     {\cf19 if} (str == NULL) \{\par
00819       *os << {\cf22 "NULL"};\par
00820     \} {\cf19 else} \{\par
00821       UniversalPrint(std::string(str), os);\par
00822     \}\par
00823   \}\par
00824 \};\par
00825 {\cf17 template} <>\par
00826 {\cf17 class }UniversalTersePrinter<char*> \{\par
00827  {\cf17 public}:\par
00828   {\cf17 static} {\cf18 void} Print({\cf18 char}* str, ::std::ostream* os) \{\par
00829     UniversalTersePrinter<const char*>::Print(str, os);\par
00830   \}\par
00831 \};\par
00832 \par
00833 {\cf21 #if GTEST_HAS_STD_WSTRING}\par
00834 {\cf17 template} <>\par
00835 {\cf17 class }UniversalTersePrinter<const wchar_t*> \{\par
00836  {\cf17 public}:\par
00837   {\cf17 static} {\cf18 void} Print({\cf17 const} {\cf18 wchar_t}* str, ::std::ostream* os) \{\par
00838     {\cf19 if} (str == NULL) \{\par
00839       *os << {\cf22 "NULL"};\par
00840     \} {\cf19 else} \{\par
00841       UniversalPrint(::std::wstring(str), os);\par
00842     \}\par
00843   \}\par
00844 \};\par
00845 {\cf21 #endif}\par
00846 \par
00847 {\cf17 template} <>\par
00848 {\cf17 class }UniversalTersePrinter<wchar_t*> \{\par
00849  {\cf17 public}:\par
00850   {\cf17 static} {\cf18 void} Print({\cf18 wchar_t}* str, ::std::ostream* os) \{\par
00851     UniversalTersePrinter<const wchar_t*>::Print(str, os);\par
00852   \}\par
00853 \};\par
00854 \par
00855 {\cf17 template} <{\cf17 typename} T>\par
00856 {\cf18 void} UniversalTersePrint({\cf17 const} T& value, ::std::ostream* os) \{\par
00857   UniversalTersePrinter<T>::Print(value, os);\par
00858 \}\par
00859 \par
00860 {\cf20 // Prints a value using the type inferred by the compiler.  The}\par
00861 {\cf20 // difference between this and UniversalTersePrint() is that for a}\par
00862 {\cf20 // (const) char pointer, this prints both the pointer and the}\par
00863 {\cf20 // NUL-terminated string.}\par
00864 {\cf17 template} <{\cf17 typename} T>\par
00865 {\cf18 void} UniversalPrint({\cf17 const} T& value, ::std::ostream* os) \{\par
00866   {\cf20 // A workarond for the bug in VC++ 7.1 that prevents us from instantiating}\par
00867   {\cf20 // UniversalPrinter with T directly.}\par
00868   {\cf17 typedef} T T1;\par
00869   UniversalPrinter<T1>::Print(value, os);\par
00870 \}\par
00871 \par
00872 typedef ::std::vector<string> Strings;\par
00873 \par
00874 {\cf20 // TuplePolicy<TupleT> must provide:}\par
00875 {\cf20 // - tuple_size}\par
00876 {\cf20 //     size of tuple TupleT.}\par
00877 {\cf20 // - get<size_t I>(const TupleT& t)}\par
00878 {\cf20 //     static function extracting element I of tuple TupleT.}\par
00879 {\cf20 // - tuple_element<size_t I>::type}\par
00880 {\cf20 //     type of element I of tuple TupleT.}\par
00881 {\cf17 template} <{\cf17 typename} TupleT>\par
00882 {\cf17 struct }TuplePolicy;\par
00883 \par
00884 {\cf21 #if GTEST_HAS_TR1_TUPLE}\par
00885 {\cf17 template} <{\cf17 typename} TupleT>\par
00886 {\cf17 struct }TuplePolicy \{\par
00887   {\cf17 typedef} TupleT Tuple;\par
00888   {\cf17 static} {\cf17 const} {\cf18 size_t} tuple_size = ::std::tr1::tuple_size<Tuple>::value;\par
00889 \par
00890   {\cf17 template} <{\cf18 size_t} I>\par
00891   {\cf17 struct }tuple_element : ::std::tr1::tuple_element<I, Tuple> \{\};\par
00892 \par
00893   {\cf17 template} <{\cf18 size_t} I>\par
00894   {\cf17 static} {\cf17 typename} AddReference<\par
00895       {\cf17 const} typename ::std::tr1::tuple_element<I, Tuple>::type>::type get(\par
00896       {\cf17 const} Tuple& tuple) \{\par
00897     return ::std::tr1::get<I>(tuple);\par
00898   \}\par
00899 \};\par
00900 {\cf17 template} <{\cf17 typename} TupleT>\par
00901 {\cf17 const} {\cf18 size_t} TuplePolicy<TupleT>::tuple_size;\par
00902 {\cf21 #endif  }{\cf20 // GTEST_HAS_TR1_TUPLE}\par
00903 \par
00904 {\cf21 #if GTEST_HAS_STD_TUPLE_}\par
00905 {\cf17 template} <{\cf17 typename}... Types>\par
00906 {\cf17 struct }TuplePolicy< ::std::tuple<Types...> > \{\par
00907   {\cf17 typedef} ::std::tuple<Types...> Tuple;\par
00908   {\cf17 static} {\cf17 const} {\cf18 size_t} tuple_size = ::std::tuple_size<Tuple>::value;\par
00909 \par
00910   {\cf17 template} <{\cf18 size_t} I>\par
00911   {\cf17 struct }tuple_element : ::std::tuple_element<I, Tuple> \{\};\par
00912 \par
00913   {\cf17 template} <{\cf18 size_t} I>\par
00914   {\cf17 static} {\cf17 const} typename ::std::tuple_element<I, Tuple>::type& get(\par
00915       {\cf17 const} Tuple& tuple) \{\par
00916     return ::std::get<I>(tuple);\par
00917   \}\par
00918 \};\par
00919 {\cf17 template} <{\cf17 typename}... Types>\par
00920 {\cf17 const} {\cf18 size_t} TuplePolicy< ::std::tuple<Types...> >::tuple_size;\par
00921 {\cf21 #endif  }{\cf20 // GTEST_HAS_STD_TUPLE_}\par
00922 \par
00923 {\cf21 #if GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_}\par
00924 {\cf20 // This helper template allows PrintTo() for tuples and}\par
00925 {\cf20 // UniversalTersePrintTupleFieldsToStrings() to be defined by}\par
00926 {\cf20 // induction on the number of tuple fields.  The idea is that}\par
00927 {\cf20 // TuplePrefixPrinter<N>::PrintPrefixTo(t, os) prints the first N}\par
00928 {\cf20 // fields in tuple t, and can be defined in terms of}\par
00929 {\cf20 // TuplePrefixPrinter<N - 1>.}\par
00930 {\cf20 //}\par
00931 {\cf20 // The inductive case.}\par
00932 {\cf17 template} <{\cf18 size_t} N>\par
00933 {\cf17 struct }TuplePrefixPrinter \{\par
00934   {\cf20 // Prints the first N fields of a tuple.}\par
00935   {\cf17 template} <{\cf17 typename} Tuple>\par
00936   {\cf17 static} {\cf18 void} PrintPrefixTo({\cf17 const} Tuple& t, ::std::ostream* os) \{\par
00937     TuplePrefixPrinter<N - 1>::PrintPrefixTo(t, os);\par
00938     GTEST_INTENTIONAL_CONST_COND_PUSH_()\par
00939     if (N > 1) \{\par
00940     GTEST_INTENTIONAL_CONST_COND_POP_()\par
00941       *os << {\cf22 ", "};\par
00942     \}\par
00943     UniversalPrinter<\par
00944         {\cf17 typename} TuplePolicy<Tuple>::template tuple_element<N - 1>::type>\par
00945         ::Print(TuplePolicy<Tuple>::template get<N - 1>(t), os);\par
00946   \}\par
00947 \par
00948   {\cf20 // Tersely prints the first N fields of a tuple to a string vector,}\par
00949   {\cf20 // one element for each field.}\par
00950   {\cf17 template} <{\cf17 typename} Tuple>\par
00951   {\cf17 static} {\cf18 void} TersePrintPrefixToStrings({\cf17 const} Tuple& t, Strings* strings) \{\par
00952     TuplePrefixPrinter<N - 1>::TersePrintPrefixToStrings(t, strings);\par
00953     ::std::stringstream ss;\par
00954     UniversalTersePrint(TuplePolicy<Tuple>::template get<N - 1>(t), &ss);\par
00955     strings->push_back(ss.str());\par
00956   \}\par
00957 \};\par
00958 \par
00959 {\cf20 // Base case.}\par
00960 {\cf17 template} <>\par
00961 {\cf17 struct }TuplePrefixPrinter<0> \{\par
00962   {\cf17 template} <{\cf17 typename} Tuple>\par
00963   {\cf17 static} {\cf18 void} PrintPrefixTo({\cf17 const} Tuple&, ::std::ostream*) \{\}\par
00964 \par
00965   {\cf17 template} <{\cf17 typename} Tuple>\par
00966   {\cf17 static} {\cf18 void} TersePrintPrefixToStrings({\cf17 const} Tuple&, Strings*) \{\}\par
00967 \};\par
00968 \par
00969 {\cf20 // Helper function for printing a tuple.}\par
00970 {\cf20 // Tuple must be either std::tr1::tuple or std::tuple type.}\par
00971 {\cf17 template} <{\cf17 typename} Tuple>\par
00972 {\cf18 void} PrintTupleTo({\cf17 const} Tuple& t, ::std::ostream* os) \{\par
00973   *os << {\cf22 "("};\par
00974   TuplePrefixPrinter<TuplePolicy<Tuple>::tuple_size>::PrintPrefixTo(t, os);\par
00975   *os << {\cf22 ")"};\par
00976 \}\par
00977 \par
00978 {\cf20 // Prints the fields of a tuple tersely to a string vector, one}\par
00979 {\cf20 // element for each field.  See the comment before}\par
00980 {\cf20 // UniversalTersePrint() for how we define "tersely".}\par
00981 {\cf17 template} <{\cf17 typename} Tuple>\par
00982 Strings UniversalTersePrintTupleFieldsToStrings({\cf17 const} Tuple& value) \{\par
00983   Strings result;\par
00984   TuplePrefixPrinter<TuplePolicy<Tuple>::tuple_size>::\par
00985       TersePrintPrefixToStrings(value, &result);\par
00986   {\cf19 return} result;\par
00987 \}\par
00988 {\cf21 #endif  }{\cf20 // GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_}\par
00989 \par
00990 \}  {\cf20 // namespace internal}\par
00991 \par
00992 {\cf17 template} <{\cf17 typename} T>\par
00993 ::std::string PrintToString({\cf17 const} T& value) \{\par
00994   ::std::stringstream ss;\par
00995   internal::UniversalTersePrinter<T>::Print(value, &ss);\par
00996   {\cf19 return} ss.str();\par
00997 \}\par
00998 \par
00999 \}  {\cf20 // namespace testing}\par
01000 \par
01001 {\cf20 // Include any custom printer added by the local installation.}\par
01002 {\cf20 // We must include this header at the end to make sure it can use the}\par
01003 {\cf20 // declarations from this file.}\par
01004 {\cf21 #include "gtest/internal/custom/gtest-printers.h"}\par
01005 \par
01006 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/internal/custom/gtest-printers.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/custom/gtest-printers.h}
{\xe \v gtest/include/gtest/internal/custom/gtest-printers.h}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-printers.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/custom/gtest-printers.h}
{\xe \v gtest/include/gtest/internal/custom/gtest-printers.h}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2015, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // This file provides an injection point for custom printers in a local}\par
00031 {\cf20 // installation of gTest.}\par
00032 {\cf20 // It will be included from gtest-printers.h and the overrides in this file}\par
00033 {\cf20 // will be visible to everyone.}\par
00034 {\cf20 // See documentation at gtest/gtest-printers.h for details on how to define a}\par
00035 {\cf20 // custom printer.}\par
00036 {\cf20 //}\par
00037 {\cf20 // ** Custom implementation starts here **}\par
00038 \par
00039 {\cf21 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H_}\par
00040 {\cf21 #define GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H_}\par
00041 \par
00042 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/gtest-spi.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest-spi.h}
{\xe \v gtest/include/gtest/gtest-spi.h}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/gtest.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::ScopedFakeTestPartResultReporter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::SingleFailureChecker}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_FATAL_FAILURE}(statement,  substr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_FATAL_FAILURE_ON_ALL_THREADS}(statement,  substr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_NONFATAL_FAILURE}(statement,  substr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS}(statement,  substr)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v EXPECT_FATAL_FAILURE\:gtest-spi.h}
{\xe \v gtest-spi.h\:EXPECT_FATAL_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_FATAL_FAILURE( statement,  substr)}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   {\cf19 do} \{ \\\par
    class GTestExpectFatalFailureHelper \{\\\par
     public:\\\par
      static {\cf18 void} Execute() \{ statement; \}\\\par
    \};\\\par
    ::testing::TestPartResultArray gtest_failures;\\\par
    ::testing::internal::SingleFailureChecker gtest_checker(\\\par
        &gtest_failures, ::testing::TestPartResult::kFatalFailure, (substr));\\\par
    \{\\\par
      ::testing::ScopedFakeTestPartResultReporter gtest_reporter(\\\par
          ::testing::ScopedFakeTestPartResultReporter:: \\\par
          INTERCEPT_ONLY_CURRENT_THREAD, &gtest_failures);\\\par
      GTestExpectFatalFailureHelper::Execute();\\\par
    \}\\\par
  \} {\cf19 while} (::testing::internal::AlwaysFalse())\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-spi.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 137}}\par
}
{\xe \v EXPECT_FATAL_FAILURE_ON_ALL_THREADS\:gtest-spi.h}
{\xe \v gtest-spi.h\:EXPECT_FATAL_FAILURE_ON_ALL_THREADS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_FATAL_FAILURE_ON_ALL_THREADS( statement,  substr)}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   {\cf19 do} \{ \\\par
    class GTestExpectFatalFailureHelper \{\\\par
     public:\\\par
      static {\cf18 void} Execute() \{ statement; \}\\\par
    \};\\\par
    ::testing::TestPartResultArray gtest_failures;\\\par
    ::testing::internal::SingleFailureChecker gtest_checker(\\\par
        &gtest_failures, ::testing::TestPartResult::kFatalFailure, (substr));\\\par
    \{\\\par
      ::testing::ScopedFakeTestPartResultReporter gtest_reporter(\\\par
          ::testing::ScopedFakeTestPartResultReporter:: \\\par
          INTERCEPT_ALL_THREADS, &gtest_failures);\\\par
      GTestExpectFatalFailureHelper::Execute();\\\par
    \}\\\par
  \} {\cf19 while} (::testing::internal::AlwaysFalse())\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-spi.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 154}}\par
}
{\xe \v EXPECT_NONFATAL_FAILURE\:gtest-spi.h}
{\xe \v gtest-spi.h\:EXPECT_NONFATAL_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_NONFATAL_FAILURE( statement,  substr)}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   {\cf19 do} \{\\\par
    ::testing::TestPartResultArray gtest_failures;\\\par
    ::testing::internal::SingleFailureChecker gtest_checker(\\\par
        &gtest_failures, ::testing::TestPartResult::kNonFatalFailure, \\\par
        (substr));\\\par
    \{\\\par
      ::testing::ScopedFakeTestPartResultReporter gtest_reporter(\\\par
          ::testing::ScopedFakeTestPartResultReporter:: \\\par
          INTERCEPT_ONLY_CURRENT_THREAD, &gtest_failures);\\\par
      if (::testing::internal::AlwaysTrue()) \{ statement; \}\\\par
    \}\\\par
  \} {\cf19 while} (::testing::internal::AlwaysFalse())\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-spi.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 203}}\par
}
{\xe \v EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS\:gtest-spi.h}
{\xe \v gtest-spi.h\:EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS( statement,  substr)}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   {\cf19 do} \{\\\par
    ::testing::TestPartResultArray gtest_failures;\\\par
    ::testing::internal::SingleFailureChecker gtest_checker(\\\par
        &gtest_failures, ::testing::TestPartResult::kNonFatalFailure, \\\par
        (substr));\\\par
    \{\\\par
      ::testing::ScopedFakeTestPartResultReporter gtest_reporter(\\\par
          ::testing::ScopedFakeTestPartResultReporter::INTERCEPT_ALL_THREADS, \\\par
          &gtest_failures);\\\par
      if (::testing::internal::AlwaysTrue()) \{ statement; \}\\\par
    \}\\\par
  \} {\cf19 while} (::testing::internal::AlwaysFalse())\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-spi.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 217}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-spi.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest-spi.h}
{\xe \v gtest/include/gtest/gtest-spi.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2007, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: wan@google.com (Zhanyong Wan)}\par
00031 {\cf20 //}\par
00032 {\cf20 // Utilities for testing Google Test itself and code that uses Google Test}\par
00033 {\cf20 // (e.g. frameworks built on top of Google Test).}\par
00034 \par
00035 {\cf21 #ifndef GTEST_INCLUDE_GTEST_GTEST_SPI_H_}\par
00036 {\cf21 #define GTEST_INCLUDE_GTEST_GTEST_SPI_H_}\par
00037 \par
00038 {\cf21 #include "gtest/gtest.h"}\par
00039 \par
00040 {\cf17 namespace }testing \{\par
00041 \par
00042 {\cf20 // This helper class can be used to mock out Google Test failure reporting}\par
00043 {\cf20 // so that we can test Google Test or code that builds on Google Test.}\par
00044 {\cf20 //}\par
00045 {\cf20 // An object of this class appends a TestPartResult object to the}\par
00046 {\cf20 // TestPartResultArray object given in the constructor whenever a Google Test}\par
00047 {\cf20 // failure is reported. It can either intercept only failures that are}\par
00048 {\cf20 // generated in the same thread that created this object or it can intercept}\par
00049 {\cf20 // all generated failures. The scope of this mock object can be controlled with}\par
00050 {\cf20 // the second argument to the two arguments constructor.}\par
00051 {\cf17 class }GTEST_API_ ScopedFakeTestPartResultReporter\par
00052     : {\cf17 public} TestPartResultReporterInterface \{\par
00053  {\cf17 public}:\par
00054   {\cf20 // The two possible mocking modes of this object.}\par
00055   {\cf17 enum} InterceptMode \{\par
00056     INTERCEPT_ONLY_CURRENT_THREAD,  {\cf20 // Intercepts only thread local failures.}\par
00057     INTERCEPT_ALL_THREADS           {\cf20 // Intercepts all failures.}\par
00058   \};\par
00059 \par
00060   {\cf20 // The c'tor sets this object as the test part result reporter used}\par
00061   {\cf20 // by Google Test.  The 'result' parameter specifies where to report the}\par
00062   {\cf20 // results. This reporter will only catch failures generated in the current}\par
00063   {\cf20 // thread. DEPRECATED}\par
00064   {\cf17 explicit} ScopedFakeTestPartResultReporter(TestPartResultArray* result);\par
00065 \par
00066   {\cf20 // Same as above, but you can choose the interception scope of this object.}\par
00067   ScopedFakeTestPartResultReporter(InterceptMode intercept_mode,\par
00068                                    TestPartResultArray* result);\par
00069 \par
00070   {\cf20 // The d'tor restores the previous test part result reporter.}\par
00071   {\cf17 virtual} ~ScopedFakeTestPartResultReporter();\par
00072 \par
00073   {\cf20 // Appends the TestPartResult object to the TestPartResultArray}\par
00074   {\cf20 // received in the constructor.}\par
00075   {\cf20 //}\par
00076   {\cf20 // This method is from the TestPartResultReporterInterface}\par
00077   {\cf20 // interface.}\par
00078   {\cf17 virtual} {\cf18 void} ReportTestPartResult({\cf17 const} TestPartResult& result);\par
00079  {\cf17 private}:\par
00080   {\cf18 void} Init();\par
00081 \par
00082   {\cf17 const} InterceptMode intercept_mode_;\par
00083   TestPartResultReporterInterface* old_reporter_;\par
00084   TestPartResultArray* {\cf17 const} result_;\par
00085 \par
00086   GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedFakeTestPartResultReporter);\par
00087 \};\par
00088 \par
00089 {\cf17 namespace }internal \{\par
00090 \par
00091 {\cf20 // A helper class for implementing EXPECT_FATAL_FAILURE() and}\par
00092 {\cf20 // EXPECT_NONFATAL_FAILURE().  Its destructor verifies that the given}\par
00093 {\cf20 // TestPartResultArray contains exactly one failure that has the given}\par
00094 {\cf20 // type and contains the given substring.  If that's not the case, a}\par
00095 {\cf20 // non-fatal failure will be generated.}\par
00096 {\cf17 class }GTEST_API_ SingleFailureChecker \{\par
00097  {\cf17 public}:\par
00098   {\cf20 // The constructor remembers the arguments.}\par
00099   SingleFailureChecker({\cf17 const} TestPartResultArray* results,\par
00100                        TestPartResult::Type type, {\cf17 const} std::string& substr);\par
00101   ~SingleFailureChecker();\par
00102  {\cf17 private}:\par
00103   {\cf17 const} TestPartResultArray* {\cf17 const} results_;\par
00104   {\cf17 const} TestPartResult::Type type_;\par
00105   {\cf17 const} std::string substr_;\par
00106 \par
00107   GTEST_DISALLOW_COPY_AND_ASSIGN_(SingleFailureChecker);\par
00108 \};\par
00109 \par
00110 \}  {\cf20 // namespace internal}\par
00111 \par
00112 \}  {\cf20 // namespace testing}\par
00113 \par
00114 {\cf20 // A set of macros for testing Google Test assertions or code that's expected}\par
00115 {\cf20 // to generate Google Test fatal failures.  It verifies that the given}\par
00116 {\cf20 // statement will cause exactly one fatal Google Test failure with 'substr'}\par
00117 {\cf20 // being part of the failure message.}\par
00118 {\cf20 //}\par
00119 {\cf20 // There are two different versions of this macro. EXPECT_FATAL_FAILURE only}\par
00120 {\cf20 // affects and considers failures generated in the current thread and}\par
00121 {\cf20 // EXPECT_FATAL_FAILURE_ON_ALL_THREADS does the same but for all threads.}\par
00122 {\cf20 //}\par
00123 {\cf20 // The verification of the assertion is done correctly even when the statement}\par
00124 {\cf20 // throws an exception or aborts the current function.}\par
00125 {\cf20 //}\par
00126 {\cf20 // Known restrictions:}\par
00127 {\cf20 //   - 'statement' cannot reference local non-static variables or}\par
00128 {\cf20 //     non-static members of the current object.}\par
00129 {\cf20 //   - 'statement' cannot return a value.}\par
00130 {\cf20 //   - You cannot stream a failure message to this macro.}\par
00131 {\cf20 //}\par
00132 {\cf20 // Note that even though the implementations of the following two}\par
00133 {\cf20 // macros are much alike, we cannot refactor them to use a common}\par
00134 {\cf20 // helper macro, due to some peculiarity in how the preprocessor}\par
00135 {\cf20 // works.  The AcceptsMacroThatExpandsToUnprotectedComma test in}\par
00136 {\cf20 // gtest_unittest.cc will fail to compile if we do that.}\par
00137 {\cf21 #define EXPECT_FATAL_FAILURE(statement, substr) \\}\par
00138 {\cf21   do \{ \\}\par
00139 {\cf21     class GTestExpectFatalFailureHelper \{\\}\par
00140 {\cf21      public:\\}\par
00141 {\cf21       static void Execute() \{ statement; \}\\}\par
00142 {\cf21     \};\\}\par
00143 {\cf21     ::testing::TestPartResultArray gtest_failures;\\}\par
00144 {\cf21     ::testing::internal::SingleFailureChecker gtest_checker(\\}\par
00145 {\cf21         &gtest_failures, ::testing::TestPartResult::kFatalFailure, (substr));\\}\par
00146 {\cf21     \{\\}\par
00147 {\cf21       ::testing::ScopedFakeTestPartResultReporter gtest_reporter(\\}\par
00148 {\cf21           ::testing::ScopedFakeTestPartResultReporter:: \\}\par
00149 {\cf21           INTERCEPT_ONLY_CURRENT_THREAD, &gtest_failures);\\}\par
00150 {\cf21       GTestExpectFatalFailureHelper::Execute();\\}\par
00151 {\cf21     \}\\}\par
00152 {\cf21   \} while (::testing::internal::AlwaysFalse())}\par
00153 \par
00154 {\cf21 #define EXPECT_FATAL_FAILURE_ON_ALL_THREADS(statement, substr) \\}\par
00155 {\cf21   do \{ \\}\par
00156 {\cf21     class GTestExpectFatalFailureHelper \{\\}\par
00157 {\cf21      public:\\}\par
00158 {\cf21       static void Execute() \{ statement; \}\\}\par
00159 {\cf21     \};\\}\par
00160 {\cf21     ::testing::TestPartResultArray gtest_failures;\\}\par
00161 {\cf21     ::testing::internal::SingleFailureChecker gtest_checker(\\}\par
00162 {\cf21         &gtest_failures, ::testing::TestPartResult::kFatalFailure, (substr));\\}\par
00163 {\cf21     \{\\}\par
00164 {\cf21       ::testing::ScopedFakeTestPartResultReporter gtest_reporter(\\}\par
00165 {\cf21           ::testing::ScopedFakeTestPartResultReporter:: \\}\par
00166 {\cf21           INTERCEPT_ALL_THREADS, &gtest_failures);\\}\par
00167 {\cf21       GTestExpectFatalFailureHelper::Execute();\\}\par
00168 {\cf21     \}\\}\par
00169 {\cf21   \} while (::testing::internal::AlwaysFalse())}\par
00170 \par
00171 {\cf20 // A macro for testing Google Test assertions or code that's expected to}\par
00172 {\cf20 // generate Google Test non-fatal failures.  It asserts that the given}\par
00173 {\cf20 // statement will cause exactly one non-fatal Google Test failure with 'substr'}\par
00174 {\cf20 // being part of the failure message.}\par
00175 {\cf20 //}\par
00176 {\cf20 // There are two different versions of this macro. EXPECT_NONFATAL_FAILURE only}\par
00177 {\cf20 // affects and considers failures generated in the current thread and}\par
00178 {\cf20 // EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS does the same but for all threads.}\par
00179 {\cf20 //}\par
00180 {\cf20 // 'statement' is allowed to reference local variables and members of}\par
00181 {\cf20 // the current object.}\par
00182 {\cf20 //}\par
00183 {\cf20 // The verification of the assertion is done correctly even when the statement}\par
00184 {\cf20 // throws an exception or aborts the current function.}\par
00185 {\cf20 //}\par
00186 {\cf20 // Known restrictions:}\par
00187 {\cf20 //   - You cannot stream a failure message to this macro.}\par
00188 {\cf20 //}\par
00189 {\cf20 // Note that even though the implementations of the following two}\par
00190 {\cf20 // macros are much alike, we cannot refactor them to use a common}\par
00191 {\cf20 // helper macro, due to some peculiarity in how the preprocessor}\par
00192 {\cf20 // works.  If we do that, the code won't compile when the user gives}\par
00193 {\cf20 // EXPECT_NONFATAL_FAILURE() a statement that contains a macro that}\par
00194 {\cf20 // expands to code containing an unprotected comma.  The}\par
00195 {\cf20 // AcceptsMacroThatExpandsToUnprotectedComma test in gtest_unittest.cc}\par
00196 {\cf20 // catches that.}\par
00197 {\cf20 //}\par
00198 {\cf20 // For the same reason, we have to write}\par
00199 {\cf20 //   if (::testing::internal::AlwaysTrue()) \{ statement; \}}\par
00200 {\cf20 // instead of}\par
00201 {\cf20 //   GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement)}\par
00202 {\cf20 // to avoid an MSVC warning on unreachable code.}\par
00203 {\cf21 #define EXPECT_NONFATAL_FAILURE(statement, substr) \\}\par
00204 {\cf21   do \{\\}\par
00205 {\cf21     ::testing::TestPartResultArray gtest_failures;\\}\par
00206 {\cf21     ::testing::internal::SingleFailureChecker gtest_checker(\\}\par
00207 {\cf21         &gtest_failures, ::testing::TestPartResult::kNonFatalFailure, \\}\par
00208 {\cf21         (substr));\\}\par
00209 {\cf21     \{\\}\par
00210 {\cf21       ::testing::ScopedFakeTestPartResultReporter gtest_reporter(\\}\par
00211 {\cf21           ::testing::ScopedFakeTestPartResultReporter:: \\}\par
00212 {\cf21           INTERCEPT_ONLY_CURRENT_THREAD, &gtest_failures);\\}\par
00213 {\cf21       if (::testing::internal::AlwaysTrue()) \{ statement; \}\\}\par
00214 {\cf21     \}\\}\par
00215 {\cf21   \} while (::testing::internal::AlwaysFalse())}\par
00216 \par
00217 {\cf21 #define EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS(statement, substr) \\}\par
00218 {\cf21   do \{\\}\par
00219 {\cf21     ::testing::TestPartResultArray gtest_failures;\\}\par
00220 {\cf21     ::testing::internal::SingleFailureChecker gtest_checker(\\}\par
00221 {\cf21         &gtest_failures, ::testing::TestPartResult::kNonFatalFailure, \\}\par
00222 {\cf21         (substr));\\}\par
00223 {\cf21     \{\\}\par
00224 {\cf21       ::testing::ScopedFakeTestPartResultReporter gtest_reporter(\\}\par
00225 {\cf21           ::testing::ScopedFakeTestPartResultReporter::INTERCEPT_ALL_THREADS, \\}\par
00226 {\cf21           &gtest_failures);\\}\par
00227 {\cf21       if (::testing::internal::AlwaysTrue()) \{ statement; \}\\}\par
00228 {\cf21     \}\\}\par
00229 {\cf21   \} while (::testing::internal::AlwaysFalse())}\par
00230 \par
00231 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_GTEST_SPI_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/gtest-test-part.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest-test-part.h}
{\xe \v gtest/include/gtest/gtest-test-part.h}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iosfwd>}\par
{\f2 #include <vector>}\par
{\f2 #include "gtest/internal/gtest-internal.h"}\par
{\f2 #include "gtest/internal/gtest-string.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::TestPartResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::TestPartResultArray}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::TestPartResultReporterInterface}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::HasNewFatalFailureHelper}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b testing::operator<<} (std::ostream &os, const TestPartResult &result)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-test-part.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest-test-part.h}
{\xe \v gtest/include/gtest/gtest-test-part.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2008, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: mheule@google.com (Markus Heule)}\par
00031 {\cf20 //}\par
00032 \par
00033 {\cf21 #ifndef GTEST_INCLUDE_GTEST_GTEST_TEST_PART_H_}\par
00034 {\cf21 #define GTEST_INCLUDE_GTEST_GTEST_TEST_PART_H_}\par
00035 \par
00036 {\cf21 #include <iosfwd>}\par
00037 {\cf21 #include <vector>}\par
00038 {\cf21 #include "gtest/internal/gtest-internal.h"}\par
00039 {\cf21 #include "gtest/internal/gtest-string.h"}\par
00040 \par
00041 {\cf17 namespace }testing \{\par
00042 \par
00043 {\cf20 // A copyable object representing the result of a test part (i.e. an}\par
00044 {\cf20 // assertion or an explicit FAIL(), ADD_FAILURE(), or SUCCESS()).}\par
00045 {\cf20 //}\par
00046 {\cf20 // Don't inherit from TestPartResult as its destructor is not virtual.}\par
00047 {\cf17 class }GTEST_API_ TestPartResult \{\par
00048  {\cf17 public}:\par
00049   {\cf20 // The possible outcomes of a test part (i.e. an assertion or an}\par
00050   {\cf20 // explicit SUCCEED(), FAIL(), or ADD_FAILURE()).}\par
00051   {\cf17 enum} Type \{\par
00052     kSuccess,          {\cf20 // Succeeded.}\par
00053     kNonFatalFailure,  {\cf20 // Failed but the test can continue.}\par
00054     kFatalFailure      {\cf20 // Failed and the test should be terminated.}\par
00055   \};\par
00056 \par
00057   {\cf20 // C'tor.  TestPartResult does NOT have a default constructor.}\par
00058   {\cf20 // Always use this constructor (with parameters) to create a}\par
00059   {\cf20 // TestPartResult object.}\par
00060   TestPartResult(Type a_type,\par
00061                  {\cf17 const} {\cf18 char}* a_file_name,\par
00062                  {\cf18 int} a_line_number,\par
00063                  {\cf17 const} {\cf18 char}* a_message)\par
00064       : type_(a_type),\par
00065         file_name_(a_file_name == NULL ? {\cf22 ""} : a_file_name),\par
00066         line_number_(a_line_number),\par
00067         summary_(ExtractSummary(a_message)),\par
00068         message_(a_message) \{\par
00069   \}\par
00070 \par
00071   {\cf20 // Gets the outcome of the test part.}\par
00072   Type type(){\cf17  const }\{ {\cf19 return} type_; \}\par
00073 \par
00074   {\cf20 // Gets the name of the source file where the test part took place, or}\par
00075   {\cf20 // NULL if it's unknown.}\par
00076   {\cf17 const} {\cf18 char}* file_name(){\cf17  const }\{\par
00077     {\cf19 return} file_name_.empty() ? NULL : file_name_.c_str();\par
00078   \}\par
00079 \par
00080   {\cf20 // Gets the line in the source file where the test part took place,}\par
00081   {\cf20 // or -1 if it's unknown.}\par
00082   {\cf18 int} line_number(){\cf17  const }\{ {\cf19 return} line_number_; \}\par
00083 \par
00084   {\cf20 // Gets the summary of the failure message.}\par
00085   {\cf17 const} {\cf18 char}* summary(){\cf17  const }\{ {\cf19 return} summary_.c_str(); \}\par
00086 \par
00087   {\cf20 // Gets the message associated with the test part.}\par
00088   {\cf17 const} {\cf18 char}* message(){\cf17  const }\{ {\cf19 return} message_.c_str(); \}\par
00089 \par
00090   {\cf20 // Returns true iff the test part passed.}\par
00091   {\cf18 bool} passed(){\cf17  const }\{ {\cf19 return} type_ == kSuccess; \}\par
00092 \par
00093   {\cf20 // Returns true iff the test part failed.}\par
00094   {\cf18 bool} failed(){\cf17  const }\{ {\cf19 return} type_ != kSuccess; \}\par
00095 \par
00096   {\cf20 // Returns true iff the test part non-fatally failed.}\par
00097   {\cf18 bool} nonfatally_failed(){\cf17  const }\{ {\cf19 return} type_ == kNonFatalFailure; \}\par
00098 \par
00099   {\cf20 // Returns true iff the test part fatally failed.}\par
00100   {\cf18 bool} fatally_failed(){\cf17  const }\{ {\cf19 return} type_ == kFatalFailure; \}\par
00101 \par
00102  {\cf17 private}:\par
00103   Type type_;\par
00104 \par
00105   {\cf20 // Gets the summary of the failure message by omitting the stack}\par
00106   {\cf20 // trace in it.}\par
00107   {\cf17 static} std::string ExtractSummary({\cf17 const} {\cf18 char}* message);\par
00108 \par
00109   {\cf20 // The name of the source file where the test part took place, or}\par
00110   {\cf20 // "" if the source file is unknown.}\par
00111   std::string file_name_;\par
00112   {\cf20 // The line in the source file where the test part took place, or -1}\par
00113   {\cf20 // if the line number is unknown.}\par
00114   {\cf18 int} line_number_;\par
00115   std::string summary_;  {\cf20 // The test failure summary.}\par
00116   std::string message_;  {\cf20 // The test failure message.}\par
00117 \};\par
00118 \par
00119 {\cf20 // Prints a TestPartResult object.}\par
00120 std::ostream& operator<<(std::ostream& os, {\cf17 const} TestPartResult& result);\par
00121 \par
00122 {\cf20 // An array of TestPartResult objects.}\par
00123 {\cf20 //}\par
00124 {\cf20 // Don't inherit from TestPartResultArray as its destructor is not}\par
00125 {\cf20 // virtual.}\par
00126 {\cf17 class }GTEST_API_ TestPartResultArray \{\par
00127  {\cf17 public}:\par
00128   TestPartResultArray() \{\}\par
00129 \par
00130   {\cf20 // Appends the given TestPartResult to the array.}\par
00131   {\cf18 void} Append({\cf17 const} TestPartResult& result);\par
00132 \par
00133   {\cf20 // Returns the TestPartResult at the given index (0-based).}\par
00134   {\cf17 const} TestPartResult& GetTestPartResult({\cf18 int} index) {\cf17 const};\par
00135 \par
00136   {\cf20 // Returns the number of TestPartResult objects in the array.}\par
00137   {\cf18 int} size() {\cf17 const};\par
00138 \par
00139  {\cf17 private}:\par
00140   std::vector<TestPartResult> array_;\par
00141 \par
00142   GTEST_DISALLOW_COPY_AND_ASSIGN_(TestPartResultArray);\par
00143 \};\par
00144 \par
00145 {\cf20 // This interface knows how to report a test part result.}\par
00146 {\cf17 class }TestPartResultReporterInterface \{\par
00147  {\cf17 public}:\par
00148   {\cf17 virtual} ~TestPartResultReporterInterface() \{\}\par
00149 \par
00150   {\cf17 virtual} {\cf18 void} ReportTestPartResult({\cf17 const} TestPartResult& result) = 0;\par
00151 \};\par
00152 \par
00153 {\cf17 namespace }internal \{\par
00154 \par
00155 {\cf20 // This helper class is used by \{ASSERT|EXPECT\}_NO_FATAL_FAILURE to check if a}\par
00156 {\cf20 // statement generates new fatal failures. To do so it registers itself as the}\par
00157 {\cf20 // current test part result reporter. Besides checking if fatal failures were}\par
00158 {\cf20 // reported, it only delegates the reporting to the former result reporter.}\par
00159 {\cf20 // The original result reporter is restored in the destructor.}\par
00160 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
00161 {\cf17 class }GTEST_API_ HasNewFatalFailureHelper\par
00162     : {\cf17 public} TestPartResultReporterInterface \{\par
00163  {\cf17 public}:\par
00164   HasNewFatalFailureHelper();\par
00165   {\cf17 virtual} ~HasNewFatalFailureHelper();\par
00166   {\cf17 virtual} {\cf18 void} ReportTestPartResult({\cf17 const} TestPartResult& result);\par
00167   {\cf18 bool} has_new_fatal_failure(){\cf17  const }\{ {\cf19 return} has_new_fatal_failure_; \}\par
00168  {\cf17 private}:\par
00169   {\cf18 bool} has_new_fatal_failure_;\par
00170   TestPartResultReporterInterface* original_reporter_;\par
00171 \par
00172   GTEST_DISALLOW_COPY_AND_ASSIGN_(HasNewFatalFailureHelper);\par
00173 \};\par
00174 \par
00175 \}  {\cf20 // namespace internal}\par
00176 \par
00177 \}  {\cf20 // namespace testing}\par
00178 \par
00179 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_GTEST_TEST_PART_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/gtest-typed-test.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest-typed-test.h}
{\xe \v gtest/include/gtest/gtest-typed-test.h}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/internal/gtest-port.h"}\par
{\f2 #include "gtest/internal/gtest-type-util.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-typed-test.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest-typed-test.h}
{\xe \v gtest/include/gtest/gtest-typed-test.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2008 Google Inc.}\par
00002 {\cf20 // All Rights Reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: wan@google.com (Zhanyong Wan)}\par
00031 \par
00032 {\cf21 #ifndef GTEST_INCLUDE_GTEST_GTEST_TYPED_TEST_H_}\par
00033 {\cf21 #define GTEST_INCLUDE_GTEST_GTEST_TYPED_TEST_H_}\par
00034 \par
00035 {\cf20 // This header implements typed tests and type-parameterized tests.}\par
00036 \par
00037 {\cf20 // Typed (aka type-driven) tests repeat the same test for types in a}\par
00038 {\cf20 // list.  You must know which types you want to test with when writing}\par
00039 {\cf20 // typed tests. Here's how you do it:}\par
00040 \par
00041 {\cf21 #if 0}\par
00042 \par
00043 {\cf20 // First, define a fixture class template.  It should be parameterized}\par
00044 {\cf20 // by a type.  Remember to derive it from testing::Test.}\par
00045 {\cf17 template} <{\cf17 typename} T>\par
00046 {\cf17 class }FooTest : {\cf17 public} testing::Test \{\par
00047  {\cf17 public}:\par
00048   ...\par
00049   {\cf17 typedef} std::list<T> List;\par
00050   {\cf17 static} T shared_;\par
00051   T value_;\par
00052 \};\par
00053 \par
00054 {\cf20 // Next, associate a list of types with the test case, which will be}\par
00055 {\cf20 // repeated for each type in the list.  The typedef is necessary for}\par
00056 {\cf20 // the macro to parse correctly.}\par
00057 {\cf17 typedef} testing::Types<char, int, unsigned int> MyTypes;\par
00058 TYPED_TEST_CASE(FooTest, MyTypes);\par
00059 \par
00060 {\cf20 // If the type list contains only one type, you can write that type}\par
00061 {\cf20 // directly without Types<...>:}\par
00062 {\cf20 //   TYPED_TEST_CASE(FooTest, int);}\par
00063 \par
00064 {\cf20 // Then, use TYPED_TEST() instead of TEST_F() to define as many typed}\par
00065 {\cf20 // tests for this test case as you want.}\par
00066 TYPED_TEST(FooTest, DoesBlah) \{\par
00067   {\cf20 // Inside a test, refer to TypeParam to get the type parameter.}\par
00068   {\cf20 // Since we are inside a derived class template, C++ requires use to}\par
00069   {\cf20 // visit the members of FooTest via 'this'.}\par
00070   TypeParam n = this->value_;\par
00071 \par
00072   {\cf20 // To visit static members of the fixture, add the TestFixture::}\par
00073   {\cf20 // prefix.}\par
00074   n += TestFixture::shared_;\par
00075 \par
00076   {\cf20 // To refer to typedefs in the fixture, add the "typename}\par
00077   {\cf20 // TestFixture::" prefix.}\par
00078   {\cf17 typename} TestFixture::List values;\par
00079   values.push_back(n);\par
00080   ...\par
00081 \}\par
00082 \par
00083 TYPED_TEST(FooTest, HasPropertyA) \{ ... \}\par
00084 \par
00085 {\cf21 #endif  }{\cf20 // 0}\par
00086 \par
00087 {\cf20 // Type-parameterized tests are abstract test patterns parameterized}\par
00088 {\cf20 // by a type.  Compared with typed tests, type-parameterized tests}\par
00089 {\cf20 // allow you to define the test pattern without knowing what the type}\par
00090 {\cf20 // parameters are.  The defined pattern can be instantiated with}\par
00091 {\cf20 // different types any number of times, in any number of translation}\par
00092 {\cf20 // units.}\par
00093 {\cf20 //}\par
00094 {\cf20 // If you are designing an interface or concept, you can define a}\par
00095 {\cf20 // suite of type-parameterized tests to verify properties that any}\par
00096 {\cf20 // valid implementation of the interface/concept should have.  Then,}\par
00097 {\cf20 // each implementation can easily instantiate the test suite to verify}\par
00098 {\cf20 // that it conforms to the requirements, without having to write}\par
00099 {\cf20 // similar tests repeatedly.  Here's an example:}\par
00100 \par
00101 {\cf21 #if 0}\par
00102 \par
00103 {\cf20 // First, define a fixture class template.  It should be parameterized}\par
00104 {\cf20 // by a type.  Remember to derive it from testing::Test.}\par
00105 {\cf17 template} <{\cf17 typename} T>\par
00106 {\cf17 class }FooTest : {\cf17 public} testing::Test \{\par
00107   ...\par
00108 \};\par
00109 \par
00110 {\cf20 // Next, declare that you will define a type-parameterized test case}\par
00111 {\cf20 // (the _P suffix is for "parameterized" or "pattern", whichever you}\par
00112 {\cf20 // prefer):}\par
00113 TYPED_TEST_CASE_P(FooTest);\par
00114 \par
00115 {\cf20 // Then, use TYPED_TEST_P() to define as many type-parameterized tests}\par
00116 {\cf20 // for this type-parameterized test case as you want.}\par
00117 TYPED_TEST_P(FooTest, DoesBlah) \{\par
00118   {\cf20 // Inside a test, refer to TypeParam to get the type parameter.}\par
00119   TypeParam n = 0;\par
00120   ...\par
00121 \}\par
00122 \par
00123 TYPED_TEST_P(FooTest, HasPropertyA) \{ ... \}\par
00124 \par
00125 {\cf20 // Now the tricky part: you need to register all test patterns before}\par
00126 {\cf20 // you can instantiate them.  The first argument of the macro is the}\par
00127 {\cf20 // test case name; the rest are the names of the tests in this test}\par
00128 {\cf20 // case.}\par
00129 REGISTER_TYPED_TEST_CASE_P(FooTest,\par
00130                            DoesBlah, HasPropertyA);\par
00131 \par
00132 {\cf20 // Finally, you are free to instantiate the pattern with the types you}\par
00133 {\cf20 // want.  If you put the above code in a header file, you can #include}\par
00134 {\cf20 // it in multiple C++ source files and instantiate it multiple times.}\par
00135 {\cf20 //}\par
00136 {\cf20 // To distinguish different instances of the pattern, the first}\par
00137 {\cf20 // argument to the INSTANTIATE_* macro is a prefix that will be added}\par
00138 {\cf20 // to the actual test case name.  Remember to pick unique prefixes for}\par
00139 {\cf20 // different instances.}\par
00140 {\cf17 typedef} testing::Types<char, int, unsigned int> MyTypes;\par
00141 INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, MyTypes);\par
00142 \par
00143 {\cf20 // If the type list contains only one type, you can write that type}\par
00144 {\cf20 // directly without Types<...>:}\par
00145 {\cf20 //   INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, int);}\par
00146 \par
00147 {\cf21 #endif  }{\cf20 // 0}\par
00148 \par
00149 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00150 {\cf21 #include "gtest/internal/gtest-type-util.h"}\par
00151 \par
00152 {\cf20 // Implements typed tests.}\par
00153 \par
00154 {\cf21 #if GTEST_HAS_TYPED_TEST}\par
00155 \par
00156 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
00157 {\cf20 //}\par
00158 {\cf20 // Expands to the name of the typedef for the type parameters of the}\par
00159 {\cf20 // given test case.}\par
00160 {\cf21 # define GTEST_TYPE_PARAMS_(TestCaseName) gtest_type_params_##TestCaseName##_}\par
00161 \par
00162 {\cf20 // The 'Types' template argument below must have spaces around it}\par
00163 {\cf20 // since some compilers may choke on '>>' when passing a template}\par
00164 {\cf20 // instance (e.g. Types<int>)}\par
00165 {\cf21 # define TYPED_TEST_CASE(CaseName, Types) \\}\par
00166 {\cf21   typedef ::testing::internal::TypeList< Types >::type \\}\par
00167 {\cf21       GTEST_TYPE_PARAMS_(CaseName)}\par
00168 \par
00169 {\cf21 # define TYPED_TEST(CaseName, TestName) \\}\par
00170 {\cf21   template <typename gtest_TypeParam_> \\}\par
00171 {\cf21   class GTEST_TEST_CLASS_NAME_(CaseName, TestName) \\}\par
00172 {\cf21       : public CaseName<gtest_TypeParam_> \{ \\}\par
00173 {\cf21    private: \\}\par
00174 {\cf21     typedef CaseName<gtest_TypeParam_> TestFixture; \\}\par
00175 {\cf21     typedef gtest_TypeParam_ TypeParam; \\}\par
00176 {\cf21     virtual void TestBody(); \\}\par
00177 {\cf21   \}; \\}\par
00178 {\cf21   bool gtest_##CaseName##_##TestName##_registered_ GTEST_ATTRIBUTE_UNUSED_ = \\}\par
00179 {\cf21       ::testing::internal::TypeParameterizedTest< \\}\par
00180 {\cf21           CaseName, \\}\par
00181 {\cf21           ::testing::internal::TemplateSel< \\}\par
00182 {\cf21               GTEST_TEST_CLASS_NAME_(CaseName, TestName)>, \\}\par
00183 {\cf21           GTEST_TYPE_PARAMS_(CaseName)>::Register(\\}\par
00184 {\cf21               ""}, ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\par
00185               #CaseName, #TestName, 0); \\\par
00186   template <typename gtest_TypeParam_> \\\par
00187   void GTEST_TEST_CLASS_NAME_(CaseName, TestName)<gtest_TypeParam_>::TestBody()\par
00188 \par
00189 {\cf21 #endif  }{\cf20 // GTEST_HAS_TYPED_TEST}\par
00190 \par
00191 {\cf20 // Implements type-parameterized tests.}\par
00192 \par
00193 {\cf21 #if GTEST_HAS_TYPED_TEST_P}\par
00194 \par
00195 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
00196 {\cf20 //}\par
00197 {\cf20 // Expands to the namespace name that the type-parameterized tests for}\par
00198 {\cf20 // the given type-parameterized test case are defined in.  The exact}\par
00199 {\cf20 // name of the namespace is subject to change without notice.}\par
00200 {\cf21 # define GTEST_CASE_NAMESPACE_(TestCaseName) \\}\par
00201 {\cf21   gtest_case_##TestCaseName##_}\par
00202 \par
00203 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
00204 {\cf20 //}\par
00205 {\cf20 // Expands to the name of the variable used to remember the names of}\par
00206 {\cf20 // the defined tests in the given test case.}\par
00207 {\cf21 # define GTEST_TYPED_TEST_CASE_P_STATE_(TestCaseName) \\}\par
00208 {\cf21   gtest_typed_test_case_p_state_##TestCaseName##_}\par
00209 \par
00210 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE DIRECTLY.}\par
00211 {\cf20 //}\par
00212 {\cf20 // Expands to the name of the variable used to remember the names of}\par
00213 {\cf20 // the registered tests in the given test case.}\par
00214 {\cf21 # define GTEST_REGISTERED_TEST_NAMES_(TestCaseName) \\}\par
00215 {\cf21   gtest_registered_test_names_##TestCaseName##_}\par
00216 \par
00217 {\cf20 // The variables defined in the type-parameterized test macros are}\par
00218 {\cf20 // static as typically these macros are used in a .h file that can be}\par
00219 {\cf20 // #included in multiple translation units linked together.}\par
00220 {\cf21 # define TYPED_TEST_CASE_P(CaseName) \\}\par
00221 {\cf21   static ::testing::internal::TypedTestCasePState \\}\par
00222 {\cf21       GTEST_TYPED_TEST_CASE_P_STATE_(CaseName)}\par
00223 \par
00224 {\cf21 # define TYPED_TEST_P(CaseName, TestName) \\}\par
00225 {\cf21   namespace GTEST_CASE_NAMESPACE_(CaseName) \{ \\}\par
00226 {\cf21   template <typename gtest_TypeParam_> \\}\par
00227 {\cf21   class TestName : public CaseName<gtest_TypeParam_> \{ \\}\par
00228 {\cf21    private: \\}\par
00229 {\cf21     typedef CaseName<gtest_TypeParam_> TestFixture; \\}\par
00230 {\cf21     typedef gtest_TypeParam_ TypeParam; \\}\par
00231 {\cf21     virtual void TestBody(); \\}\par
00232 {\cf21   \}; \\}\par
00233 {\cf21   static bool gtest_##TestName##_defined_ GTEST_ATTRIBUTE_UNUSED_ = \\}\par
00234 {\cf21       GTEST_TYPED_TEST_CASE_P_STATE_(CaseName).AddTestName(\\}\par
00235 {\cf21           __FILE__, __LINE__, #CaseName, #TestName); \\}\par
00236 {\cf21   \} \\}\par
00237 {\cf21   template <typename gtest_TypeParam_> \\}\par
00238 {\cf21   void GTEST_CASE_NAMESPACE_(CaseName)::TestName<gtest_TypeParam_>::TestBody()}\par
00239 \par
00240 {\cf21 # define REGISTER_TYPED_TEST_CASE_P(CaseName, ...) \\}\par
00241 {\cf21   namespace GTEST_CASE_NAMESPACE_(CaseName) \{ \\}\par
00242 {\cf21   typedef ::testing::internal::Templates<__VA_ARGS__>::type gtest_AllTests_; \\}\par
00243 {\cf21   \} \\}\par
00244 {\cf21   static const char* const GTEST_REGISTERED_TEST_NAMES_(CaseName) \\}\par
00245 {\cf21       GTEST_ATTRIBUTE_UNUSED_ = \\}\par
00246 {\cf21           GTEST_TYPED_TEST_CASE_P_STATE_(CaseName).VerifyRegisteredTestNames(\\}\par
00247 {\cf21               __FILE__, __LINE__, #__VA_ARGS__)}\par
00248 \par
00249 {\cf20 // The 'Types' template argument below must have spaces around it}\par
00250 {\cf20 // since some compilers may choke on '>>' when passing a template}\par
00251 {\cf20 // instance (e.g. Types<int>)}\par
00252 {\cf21 # define INSTANTIATE_TYPED_TEST_CASE_P(Prefix, CaseName, Types) \\}\par
00253 {\cf21   bool gtest_##Prefix##_##CaseName GTEST_ATTRIBUTE_UNUSED_ = \\}\par
00254 {\cf21       ::testing::internal::TypeParameterizedTestCase<CaseName, \\}\par
00255 {\cf21           GTEST_CASE_NAMESPACE_(CaseName)::gtest_AllTests_, \\}\par
00256 {\cf21           ::testing::internal::TypeList< Types >::type>::Register(\\}\par
00257 {\cf21               #Prefix, \\}\par
00258 {\cf21               ::testing::internal::CodeLocation(__FILE__, __LINE__), \\}\par
00259 {\cf21               &GTEST_TYPED_TEST_CASE_P_STATE_(CaseName), \\}\par
00260 {\cf21               #CaseName, GTEST_REGISTERED_TEST_NAMES_(CaseName))}\par
00261 \par
00262 {\cf21 #endif  }{\cf20 // GTEST_HAS_TYPED_TEST_P}\par
00263 \par
00264 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_GTEST_TYPED_TEST_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/gtest.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest.h}
{\xe \v gtest/include/gtest/gtest.h}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <limits>}\par
{\f2 #include <ostream>}\par
{\f2 #include <vector>}\par
{\f2 #include "gtest/internal/gtest-internal.h"}\par
{\f2 #include "gtest/internal/gtest-string.h"}\par
{\f2 #include "gtest/gtest-death-test.h"}\par
{\f2 #include "gtest/gtest-message.h"}\par
{\f2 #include "gtest/gtest-param-test.h"}\par
{\f2 #include "gtest/gtest-printers.h"}\par
{\f2 #include "gtest/gtest_prod.h"}\par
{\f2 #include "gtest/gtest-test-part.h"}\par
{\f2 #include "gtest/gtest-typed-test.h"}\par
{\f2 #include "gtest/gtest_pred_impl.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::AssertionResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::Test}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::TestProperty}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::TestResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::TestInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::TestCase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::Environment}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::TestEventListener}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::EmptyTestEventListener}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::TestEventListeners}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::UnitTest}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::EqHelper< lhs_is_null_literal >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::EqHelper< true >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::AssertHelper}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_IMPL_CMP_HELPER_}(op_name,  op)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADD_FAILURE}()\~ {\b GTEST_NONFATAL_FAILURE_}("Failed")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ADD_FAILURE_AT}(file,  line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_FAIL}()\~ {\b GTEST_FATAL_FAILURE_}("Failed")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAIL}()\~ {\b GTEST_FAIL}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_SUCCEED}()\~ {\b GTEST_SUCCESS_}("Succeeded")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SUCCEED}()\~ {\b GTEST_SUCCEED}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_THROW}(statement,  expected_exception)\~   {\b GTEST_TEST_THROW_}(statement, expected_exception, {\b GTEST_NONFATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_NO_THROW}(statement)\~   {\b GTEST_TEST_NO_THROW_}(statement, {\b GTEST_NONFATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_ANY_THROW}(statement)\~   {\b GTEST_TEST_ANY_THROW_}(statement, {\b GTEST_NONFATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_THROW}(statement,  expected_exception)\~   {\b GTEST_TEST_THROW_}(statement, expected_exception, {\b GTEST_FATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_NO_THROW}(statement)\~   {\b GTEST_TEST_NO_THROW_}(statement, {\b GTEST_FATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_ANY_THROW}(statement)\~   {\b GTEST_TEST_ANY_THROW_}(statement, {\b GTEST_FATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_TRUE}(condition)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_FALSE}(condition)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_TRUE}(condition)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_FALSE}(condition)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_EQ}(val1,  val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_NE}(val1,  val2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperNE, val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_LE}(val1,  val2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperLE, val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_LT}(val1,  val2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperLT, val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_GE}(val1,  val2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperGE, val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_GT}(val1,  val2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperGT, val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ASSERT_EQ}(val1,  val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ASSERT_NE}(val1,  val2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperNE, val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ASSERT_LE}(val1,  val2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperLE, val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ASSERT_LT}(val1,  val2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperLT, val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ASSERT_GE}(val1,  val2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperGE, val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ASSERT_GT}(val1,  val2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperGT, val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_EQ}(val1,  val2)\~ {\b GTEST_ASSERT_EQ}(val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_NE}(val1,  val2)\~ {\b GTEST_ASSERT_NE}(val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_LE}(val1,  val2)\~ {\b GTEST_ASSERT_LE}(val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_LT}(val1,  val2)\~ {\b GTEST_ASSERT_LT}(val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_GE}(val1,  val2)\~ {\b GTEST_ASSERT_GE}(val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_GT}(val1,  val2)\~ {\b GTEST_ASSERT_GT}(val1, val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_STREQ}(s1,  s2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperSTREQ, s1, s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_STRNE}(s1,  s2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperSTRNE, s1, s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_STRCASEEQ}(s1,  s2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_STRCASENE}(s1,  s2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperSTRCASENE, s1, s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_STREQ}(s1,  s2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperSTREQ, s1, s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_STRNE}(s1,  s2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperSTRNE, s1, s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_STRCASEEQ}(s1,  s2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_STRCASENE}(s1,  s2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperSTRCASENE, s1, s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_FLOAT_EQ}(val1,  val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_DOUBLE_EQ}(val1,  val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_FLOAT_EQ}(val1,  val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_DOUBLE_EQ}(val1,  val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_NEAR}(val1,  val2,  abs_error)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_NEAR}(val1,  val2,  abs_error)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_NO_FATAL_FAILURE}(statement)\~     {\b GTEST_TEST_NO_FATAL_FAILURE_}(statement, {\b GTEST_FATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_NO_FATAL_FAILURE}(statement)\~     {\b GTEST_TEST_NO_FATAL_FAILURE_}(statement, {\b GTEST_NONFATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SCOPED_TRACE}(message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_TEST}(test_case_name,  test_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST}(test_case_name,  test_name)\~ {\b GTEST_TEST}(test_case_name, test_name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_F}(test_fixture,  test_name)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef internal::TimeInMillis {\b testing::TimeInMillis}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_bool_} (also_run_disabled_tests)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_bool_} (break_on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_bool_} (catch_exceptions)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_string_} (color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_string_} (filter)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_bool_} (list_tests)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_string_} (output)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_bool_} (print_time)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_int32_} (random_seed)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_int32_} (repeat)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_bool_} (show_internal_stack_frames)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_bool_} (shuffle)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_int32_} (stack_trace_depth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_bool_} (throw_on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_string_} (stream_result_to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class UnitTestImpl * {\b testing::internal::GetUnitTestImpl} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::ReportFailureInUnknownLocation} (TestPartResult::Type result_type, const std::string &message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::AssertionSuccess} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::AssertionFailure} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::AssertionFailure} (const Message &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Environment * {\b testing::AddGlobalTestEnvironment} (Environment *env)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::InitGoogleTest} (int *argc, char **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::InitGoogleTest} (int *argc, wchar_t **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > AssertionResult {\b testing::internal::CmpHelperEQFailure} (const char *lhs_expression, const char *rhs_expression, const T1 &lhs, const T2 &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > AssertionResult {\b testing::internal::CmpHelperEQ} (const char *lhs_expression, const char *rhs_expression, const T1 &lhs, const T2 &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::CmpHelperEQ} (const char *lhs_expression, const char *rhs_expression, BiggestInt lhs, BiggestInt rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > AssertionResult {\b testing::internal::CmpHelperOpFailure} (const char *expr1, const char *expr2, const T1 &val1, const T2 &val2, const char *op)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::internal::GTEST_IMPL_CMP_HELPER_} (NE, !=)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::internal::GTEST_IMPL_CMP_HELPER_} (LE,<=)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::internal::GTEST_IMPL_CMP_HELPER_} (LT,<)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::internal::GTEST_IMPL_CMP_HELPER_} (GE, >=)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::internal::GTEST_IMPL_CMP_HELPER_} (GT, >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::CmpHelperSTREQ} (const char *s1_expression, const char *s2_expression, const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::CmpHelperSTRCASEEQ} (const char *s1_expression, const char *s2_expression, const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::CmpHelperSTRNE} (const char *s1_expression, const char *s2_expression, const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::CmpHelperSTRCASENE} (const char *s1_expression, const char *s2_expression, const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::CmpHelperSTREQ} (const char *s1_expression, const char *s2_expression, const wchar_t *s1, const wchar_t *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::CmpHelperSTRNE} (const char *s1_expression, const char *s2_expression, const wchar_t *s1, const wchar_t *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::IsSubstring} (const char *needle_expr, const char *haystack_expr, const char *needle, const char *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::IsSubstring} (const char *needle_expr, const char *haystack_expr, const wchar_t *needle, const wchar_t *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::IsNotSubstring} (const char *needle_expr, const char *haystack_expr, const char *needle, const char *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::IsNotSubstring} (const char *needle_expr, const char *haystack_expr, const wchar_t *needle, const wchar_t *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::IsSubstring} (const char *needle_expr, const char *haystack_expr, const ::std::string &needle, const ::std::string &haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::IsNotSubstring} (const char *needle_expr, const char *haystack_expr, const ::std::string &needle, const ::std::string &haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename RawType > AssertionResult {\b testing::internal::CmpHelperFloatingPointEQ} (const char *lhs_expression, const char *rhs_expression, RawType lhs_value, RawType rhs_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::DoubleNearPredFormat} (const char *expr1, const char *expr2, const char *abs_error_expr, double val1, double val2, double abs_error)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::FloatLE} (const char *expr1, const char *expr2, float val1, float val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::DoubleLE} (const char *expr1, const char *expr2, double val1, double val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T1 , typename T2 > bool {\b testing::StaticAssertTypeEq} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::TempDir} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b RUN_ALL_TESTS} () {\b GTEST_MUST_USE_RESULT_}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b testing::kMaxStackTraceDepth} = 100\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v ADD_FAILURE\:gtest.h}
{\xe \v gtest.h\:ADD_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADD_FAILURE()\~ {\b GTEST_NONFATAL_FAILURE_}("Failed")}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1808}}\par
}
{\xe \v ADD_FAILURE_AT\:gtest.h}
{\xe \v gtest.h\:ADD_FAILURE_AT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ADD_FAILURE_AT( file,  line)}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_MESSAGE_AT_(file, line, {\cf22 "Failed"}, \\\par
                    ::testing::TestPartResult::kNonFatalFailure)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1812}}\par
}
{\xe \v ASSERT_ANY_THROW\:gtest.h}
{\xe \v gtest.h\:ASSERT_ANY_THROW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_ANY_THROW( statement)\~   {\b GTEST_TEST_ANY_THROW_}(statement, {\b GTEST_FATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1853}}\par
}
{\xe \v ASSERT_DOUBLE_EQ\:gtest.h}
{\xe \v gtest.h\:ASSERT_DOUBLE_EQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_DOUBLE_EQ( val1,  val2)}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\par
                      val1, val2)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2039}}\par
}
{\xe \v ASSERT_EQ\:gtest.h}
{\xe \v gtest.h\:ASSERT_EQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_EQ( val1,  val2)\~ {\b GTEST_ASSERT_EQ}(val1, val2)}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1956}}\par
}
{\xe \v ASSERT_FALSE\:gtest.h}
{\xe \v gtest.h\:ASSERT_FALSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_FALSE( condition)}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_TEST_BOOLEAN_(!(condition), #condition, {\cf17 true}, {\cf17 false}, \\\par
                      GTEST_FATAL_FAILURE_)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1868}}\par
}
{\xe \v ASSERT_FLOAT_EQ\:gtest.h}
{\xe \v gtest.h\:ASSERT_FLOAT_EQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_FLOAT_EQ( val1,  val2)}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\par
                      val1, val2)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2035}}\par
}
{\xe \v ASSERT_GE\:gtest.h}
{\xe \v gtest.h\:ASSERT_GE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_GE( val1,  val2)\~ {\b GTEST_ASSERT_GE}(val1, val2)}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1972}}\par
}
{\xe \v ASSERT_GT\:gtest.h}
{\xe \v gtest.h\:ASSERT_GT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_GT( val1,  val2)\~ {\b GTEST_ASSERT_GT}(val1, val2)}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1976}}\par
}
{\xe \v ASSERT_LE\:gtest.h}
{\xe \v gtest.h\:ASSERT_LE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_LE( val1,  val2)\~ {\b GTEST_ASSERT_LE}(val1, val2)}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1964}}\par
}
{\xe \v ASSERT_LT\:gtest.h}
{\xe \v gtest.h\:ASSERT_LT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_LT( val1,  val2)\~ {\b GTEST_ASSERT_LT}(val1, val2)}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1968}}\par
}
{\xe \v ASSERT_NE\:gtest.h}
{\xe \v gtest.h\:ASSERT_NE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_NE( val1,  val2)\~ {\b GTEST_ASSERT_NE}(val1, val2)}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1960}}\par
}
{\xe \v ASSERT_NEAR\:gtest.h}
{\xe \v gtest.h\:ASSERT_NEAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_NEAR( val1,  val2,  abs_error)}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\par
                      val1, val2, abs_error)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2047}}\par
}
{\xe \v ASSERT_NO_FATAL_FAILURE\:gtest.h}
{\xe \v gtest.h\:ASSERT_NO_FATAL_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_NO_FATAL_FAILURE( statement)\~     {\b GTEST_TEST_NO_FATAL_FAILURE_}(statement, {\b GTEST_FATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2099}}\par
}
{\xe \v ASSERT_NO_THROW\:gtest.h}
{\xe \v gtest.h\:ASSERT_NO_THROW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_NO_THROW( statement)\~   {\b GTEST_TEST_NO_THROW_}(statement, {\b GTEST_FATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1851}}\par
}
{\xe \v ASSERT_STRCASEEQ\:gtest.h}
{\xe \v gtest.h\:ASSERT_STRCASEEQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_STRCASEEQ( s1,  s2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2008}}\par
}
{\xe \v ASSERT_STRCASENE\:gtest.h}
{\xe \v gtest.h\:ASSERT_STRCASENE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_STRCASENE( s1,  s2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperSTRCASENE, s1, s2)}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2010}}\par
}
{\xe \v ASSERT_STREQ\:gtest.h}
{\xe \v gtest.h\:ASSERT_STREQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_STREQ( s1,  s2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperSTREQ, s1, s2)}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2004}}\par
}
{\xe \v ASSERT_STRNE\:gtest.h}
{\xe \v gtest.h\:ASSERT_STRNE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_STRNE( s1,  s2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperSTRNE, s1, s2)}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2006}}\par
}
{\xe \v ASSERT_THROW\:gtest.h}
{\xe \v gtest.h\:ASSERT_THROW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_THROW( statement,  expected_exception)\~   {\b GTEST_TEST_THROW_}(statement, expected_exception, {\b GTEST_FATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1849}}\par
}
{\xe \v ASSERT_TRUE\:gtest.h}
{\xe \v gtest.h\:ASSERT_TRUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_TRUE( condition)}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_TEST_BOOLEAN_((condition), #condition, {\cf17 false}, {\cf17 true}, \\\par
                      GTEST_FATAL_FAILURE_)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1865}}\par
}
{\xe \v EXPECT_ANY_THROW\:gtest.h}
{\xe \v gtest.h\:EXPECT_ANY_THROW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_ANY_THROW( statement)\~   {\b GTEST_TEST_ANY_THROW_}(statement, {\b GTEST_NONFATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1847}}\par
}
{\xe \v EXPECT_DOUBLE_EQ\:gtest.h}
{\xe \v gtest.h\:EXPECT_DOUBLE_EQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_DOUBLE_EQ( val1,  val2)}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\par
                      val1, val2)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2031}}\par
}
{\xe \v EXPECT_EQ\:gtest.h}
{\xe \v gtest.h\:EXPECT_EQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_EQ( val1,  val2)}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   EXPECT_PRED_FORMAT2(::testing::internal:: \\\par
                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\par
                      val1, val2)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1922}}\par
}
{\xe \v EXPECT_FALSE\:gtest.h}
{\xe \v gtest.h\:EXPECT_FALSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_FALSE( condition)}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_TEST_BOOLEAN_(!(condition), #condition, {\cf17 true}, {\cf17 false}, \\\par
                      GTEST_NONFATAL_FAILURE_)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1862}}\par
}
{\xe \v EXPECT_FLOAT_EQ\:gtest.h}
{\xe \v gtest.h\:EXPECT_FLOAT_EQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_FLOAT_EQ( val1,  val2)}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\par
                      val1, val2)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2027}}\par
}
{\xe \v EXPECT_GE\:gtest.h}
{\xe \v gtest.h\:EXPECT_GE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_GE( val1,  val2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperGE, val1, val2)}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1932}}\par
}
{\xe \v EXPECT_GT\:gtest.h}
{\xe \v gtest.h\:EXPECT_GT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_GT( val1,  val2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperGT, val1, val2)}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1934}}\par
}
{\xe \v EXPECT_LE\:gtest.h}
{\xe \v gtest.h\:EXPECT_LE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_LE( val1,  val2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperLE, val1, val2)}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1928}}\par
}
{\xe \v EXPECT_LT\:gtest.h}
{\xe \v gtest.h\:EXPECT_LT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_LT( val1,  val2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperLT, val1, val2)}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1930}}\par
}
{\xe \v EXPECT_NE\:gtest.h}
{\xe \v gtest.h\:EXPECT_NE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_NE( val1,  val2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperNE, val1, val2)}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1926}}\par
}
{\xe \v EXPECT_NEAR\:gtest.h}
{\xe \v gtest.h\:EXPECT_NEAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_NEAR( val1,  val2,  abs_error)}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\par
                      val1, val2, abs_error)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2043}}\par
}
{\xe \v EXPECT_NO_FATAL_FAILURE\:gtest.h}
{\xe \v gtest.h\:EXPECT_NO_FATAL_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_NO_FATAL_FAILURE( statement)\~     {\b GTEST_TEST_NO_FATAL_FAILURE_}(statement, {\b GTEST_NONFATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2101}}\par
}
{\xe \v EXPECT_NO_THROW\:gtest.h}
{\xe \v gtest.h\:EXPECT_NO_THROW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_NO_THROW( statement)\~   {\b GTEST_TEST_NO_THROW_}(statement, {\b GTEST_NONFATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1845}}\par
}
{\xe \v EXPECT_STRCASEEQ\:gtest.h}
{\xe \v gtest.h\:EXPECT_STRCASEEQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_STRCASEEQ( s1,  s2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1999}}\par
}
{\xe \v EXPECT_STRCASENE\:gtest.h}
{\xe \v gtest.h\:EXPECT_STRCASENE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_STRCASENE( s1,  s2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperSTRCASENE, s1, s2)}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2001}}\par
}
{\xe \v EXPECT_STREQ\:gtest.h}
{\xe \v gtest.h\:EXPECT_STREQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_STREQ( s1,  s2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperSTREQ, s1, s2)}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1995}}\par
}
{\xe \v EXPECT_STRNE\:gtest.h}
{\xe \v gtest.h\:EXPECT_STRNE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_STRNE( s1,  s2)\~   {\b EXPECT_PRED_FORMAT2}(::testing::internal::CmpHelperSTRNE, s1, s2)}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1997}}\par
}
{\xe \v EXPECT_THROW\:gtest.h}
{\xe \v gtest.h\:EXPECT_THROW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_THROW( statement,  expected_exception)\~   {\b GTEST_TEST_THROW_}(statement, expected_exception, {\b GTEST_NONFATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1843}}\par
}
{\xe \v EXPECT_TRUE\:gtest.h}
{\xe \v gtest.h\:EXPECT_TRUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_TRUE( condition)}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_TEST_BOOLEAN_((condition), #condition, {\cf17 false}, {\cf17 true}, \\\par
                      GTEST_NONFATAL_FAILURE_)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1859}}\par
}
{\xe \v FAIL\:gtest.h}
{\xe \v gtest.h\:FAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAIL()\~ {\b GTEST_FAIL}()}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1822}}\par
}
{\xe \v GTEST_ASSERT_EQ\:gtest.h}
{\xe \v gtest.h\:GTEST_ASSERT_EQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ASSERT_EQ( val1,  val2)}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   ASSERT_PRED_FORMAT2(::testing::internal:: \\\par
                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\par
                      val1, val2)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1937}}\par
}
{\xe \v GTEST_ASSERT_GE\:gtest.h}
{\xe \v gtest.h\:GTEST_ASSERT_GE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ASSERT_GE( val1,  val2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperGE, val1, val2)}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1947}}\par
}
{\xe \v GTEST_ASSERT_GT\:gtest.h}
{\xe \v gtest.h\:GTEST_ASSERT_GT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ASSERT_GT( val1,  val2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperGT, val1, val2)}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1949}}\par
}
{\xe \v GTEST_ASSERT_LE\:gtest.h}
{\xe \v gtest.h\:GTEST_ASSERT_LE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ASSERT_LE( val1,  val2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperLE, val1, val2)}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1943}}\par
}
{\xe \v GTEST_ASSERT_LT\:gtest.h}
{\xe \v gtest.h\:GTEST_ASSERT_LT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ASSERT_LT( val1,  val2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperLT, val1, val2)}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1945}}\par
}
{\xe \v GTEST_ASSERT_NE\:gtest.h}
{\xe \v gtest.h\:GTEST_ASSERT_NE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ASSERT_NE( val1,  val2)\~   {\b ASSERT_PRED_FORMAT2}(::testing::internal::CmpHelperNE, val1, val2)}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1941}}\par
}
{\xe \v GTEST_FAIL\:gtest.h}
{\xe \v gtest.h\:GTEST_FAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_FAIL()\~ {\b GTEST_FATAL_FAILURE_}("Failed")}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1817}}\par
}
{\xe \v GTEST_IMPL_CMP_HELPER_\:gtest.h}
{\xe \v gtest.h\:GTEST_IMPL_CMP_HELPER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_IMPL_CMP_HELPER_( op_name,  op)}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\\\par
AssertionResult CmpHelper##op_name({\cf17 const} {\cf18 char}* expr1, {\cf17 const} {\cf18 char}* expr2, \\\par
                                   {\cf17 const} T1& val1, {\cf17 const} T2& val2) \{\\\par
  if (val1 op val2) \{\\\par
    return AssertionSuccess();\\\par
  \} {\cf19 else} \{\\\par
    return CmpHelperOpFailure(expr1, expr2, val1, val2, #op);\\\par
  \}\\\par
\}\\\par
GTEST_API_ AssertionResult CmpHelper##op_name(\\\par
    {\cf17 const} {\cf18 char}* expr1, {\cf17 const} {\cf18 char}* expr2, BiggestInt val1, BiggestInt val2)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1506}}\par
}
{\xe \v GTEST_SUCCEED\:gtest.h}
{\xe \v gtest.h\:GTEST_SUCCEED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_SUCCEED()\~ {\b GTEST_SUCCESS_}("Succeeded")}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1826}}\par
}
{\xe \v GTEST_TEST\:gtest.h}
{\xe \v gtest.h\:GTEST_TEST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_TEST( test_case_name,  test_name)}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_TEST_(test_case_name, test_name, \\\par
              ::testing::Test, ::testing::internal::GetTestTypeId())\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2180}}\par
}
{\xe \v SCOPED_TRACE\:gtest.h}
{\xe \v gtest.h\:SCOPED_TRACE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SCOPED_TRACE( message)}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   ::testing::internal::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)(\\\par
    __FILE__, __LINE__, ::testing::Message() << (message))\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2115}}\par
}
{\xe \v SUCCEED\:gtest.h}
{\xe \v gtest.h\:SUCCEED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SUCCEED()\~ {\b GTEST_SUCCEED}()}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1831}}\par
}
{\xe \v TEST\:gtest.h}
{\xe \v gtest.h\:TEST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST( test_case_name,  test_name)\~ {\b GTEST_TEST}(test_case_name, test_name)}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2187}}\par
}
{\xe \v TEST_F\:gtest.h}
{\xe \v gtest.h\:TEST_F}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_F( test_fixture,  test_name)}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_TEST_(test_fixture, test_name, test_fixture, \\\par
              ::testing::internal::GetTypeId<test_fixture>())\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2216}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 
{\xe \v RUN_ALL_TESTS\:gtest.h}
{\xe \v gtest.h\:RUN_ALL_TESTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int RUN_ALL_TESTS (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2236}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 02236                            \{\par
02237   return ::testing::UnitTest::GetInstance()->Run();\par
02238 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b main()}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest.h}
{\xe \v gtest/include/gtest/gtest.h}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2005, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: wan@google.com (Zhanyong Wan)}\par
00031 {\cf20 //}\par
00032 {\cf20 // The Google C++ Testing Framework (Google Test)}\par
00033 {\cf20 //}\par
00034 {\cf20 // This header file defines the public API for Google Test.  It should be}\par
00035 {\cf20 // included by any test program that uses Google Test.}\par
00036 {\cf20 //}\par
00037 {\cf20 // IMPORTANT NOTE: Due to limitation of the C++ language, we have to}\par
00038 {\cf20 // leave some internal implementation details in this header file.}\par
00039 {\cf20 // They are clearly marked by comments like this:}\par
00040 {\cf20 //}\par
00041 {\cf20 //   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
00042 {\cf20 //}\par
00043 {\cf20 // Such code is NOT meant to be used by a user directly, and is subject}\par
00044 {\cf20 // to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user}\par
00045 {\cf20 // program!}\par
00046 {\cf20 //}\par
00047 {\cf20 // Acknowledgment: Google Test borrowed the idea of automatic test}\par
00048 {\cf20 // registration from Barthelemy Dagenais' (barthelemy@prologique.com)}\par
00049 {\cf20 // easyUnit framework.}\par
00050 \par
00051 {\cf21 #ifndef GTEST_INCLUDE_GTEST_GTEST_H_}\par
00052 {\cf21 #define GTEST_INCLUDE_GTEST_GTEST_H_}\par
00053 \par
00054 {\cf21 #include <limits>}\par
00055 {\cf21 #include <ostream>}\par
00056 {\cf21 #include <vector>}\par
00057 \par
00058 {\cf21 #include "gtest/internal/gtest-internal.h"}\par
00059 {\cf21 #include "gtest/internal/gtest-string.h"}\par
00060 {\cf21 #include "gtest/gtest-death-test.h"}\par
00061 {\cf21 #include "gtest/gtest-message.h"}\par
00062 {\cf21 #include "gtest/gtest-param-test.h"}\par
00063 {\cf21 #include "gtest/gtest-printers.h"}\par
00064 {\cf21 #include "gtest/gtest_prod.h"}\par
00065 {\cf21 #include "gtest/gtest-test-part.h"}\par
00066 {\cf21 #include "gtest/gtest-typed-test.h"}\par
00067 \par
00068 {\cf20 // Depending on the platform, different string classes are available.}\par
00069 {\cf20 // On Linux, in addition to ::std::string, Google also makes use of}\par
00070 {\cf20 // class ::string, which has the same interface as ::std::string, but}\par
00071 {\cf20 // has a different implementation.}\par
00072 {\cf20 //}\par
00073 {\cf20 // You can define GTEST_HAS_GLOBAL_STRING to 1 to indicate that}\par
00074 {\cf20 // ::string is available AND is a distinct type to ::std::string, or}\par
00075 {\cf20 // define it to 0 to indicate otherwise.}\par
00076 {\cf20 //}\par
00077 {\cf20 // If ::std::string and ::string are the same class on your platform}\par
00078 {\cf20 // due to aliasing, you should define GTEST_HAS_GLOBAL_STRING to 0.}\par
00079 {\cf20 //}\par
00080 {\cf20 // If you do not define GTEST_HAS_GLOBAL_STRING, it is defined}\par
00081 {\cf20 // heuristically.}\par
00082 \par
00083 {\cf17 namespace }testing \{\par
00084 \par
00085 {\cf20 // Declares the flags.}\par
00086 \par
00087 {\cf20 // This flag temporary enables the disabled tests.}\par
00088 GTEST_DECLARE_bool_(also_run_disabled_tests);\par
00089 \par
00090 {\cf20 // This flag brings the debugger on an assertion failure.}\par
00091 GTEST_DECLARE_bool_(break_on_failure);\par
00092 \par
00093 {\cf20 // This flag controls whether Google Test catches all test-thrown exceptions}\par
00094 {\cf20 // and logs them as failures.}\par
00095 GTEST_DECLARE_bool_(catch_exceptions);\par
00096 \par
00097 {\cf20 // This flag enables using colors in terminal output. Available values are}\par
00098 {\cf20 // "yes" to enable colors, "no" (disable colors), or "auto" (the default)}\par
00099 {\cf20 // to let Google Test decide.}\par
00100 GTEST_DECLARE_string_(color);\par
00101 \par
00102 {\cf20 // This flag sets up the filter to select by name using a glob pattern}\par
00103 {\cf20 // the tests to run. If the filter is not given all tests are executed.}\par
00104 GTEST_DECLARE_string_(filter);\par
00105 \par
00106 {\cf20 // This flag causes the Google Test to list tests. None of the tests listed}\par
00107 {\cf20 // are actually run if the flag is provided.}\par
00108 GTEST_DECLARE_bool_(list_tests);\par
00109 \par
00110 {\cf20 // This flag controls whether Google Test emits a detailed XML report to a file}\par
00111 {\cf20 // in addition to its normal textual output.}\par
00112 GTEST_DECLARE_string_(output);\par
00113 \par
00114 {\cf20 // This flags control whether Google Test prints the elapsed time for each}\par
00115 {\cf20 // test.}\par
00116 GTEST_DECLARE_bool_(print_time);\par
00117 \par
00118 {\cf20 // This flag specifies the random number seed.}\par
00119 GTEST_DECLARE_int32_(random_seed);\par
00120 \par
00121 {\cf20 // This flag sets how many times the tests are repeated. The default value}\par
00122 {\cf20 // is 1. If the value is -1 the tests are repeating forever.}\par
00123 GTEST_DECLARE_int32_(repeat);\par
00124 \par
00125 {\cf20 // This flag controls whether Google Test includes Google Test internal}\par
00126 {\cf20 // stack frames in failure stack traces.}\par
00127 GTEST_DECLARE_bool_(show_internal_stack_frames);\par
00128 \par
00129 {\cf20 // When this flag is specified, tests' order is randomized on every iteration.}\par
00130 GTEST_DECLARE_bool_(shuffle);\par
00131 \par
00132 {\cf20 // This flag specifies the maximum number of stack frames to be}\par
00133 {\cf20 // printed in a failure message.}\par
00134 GTEST_DECLARE_int32_(stack_trace_depth);\par
00135 \par
00136 {\cf20 // When this flag is specified, a failed assertion will throw an}\par
00137 {\cf20 // exception if exceptions are enabled, or exit the program with a}\par
00138 {\cf20 // non-zero code otherwise.}\par
00139 GTEST_DECLARE_bool_(throw_on_failure);\par
00140 \par
00141 {\cf20 // When this flag is set with a "host:port" string, on supported}\par
00142 {\cf20 // platforms test results are streamed to the specified port on}\par
00143 {\cf20 // the specified host machine.}\par
00144 GTEST_DECLARE_string_(stream_result_to);\par
00145 \par
00146 {\cf20 // The upper limit for valid stack trace depths.}\par
00147 {\cf17 const} {\cf18 int} kMaxStackTraceDepth = 100;\par
00148 \par
00149 {\cf17 namespace }internal \{\par
00150 \par
00151 {\cf17 class }AssertHelper;\par
00152 {\cf17 class }DefaultGlobalTestPartResultReporter;\par
00153 {\cf17 class }ExecDeathTest;\par
00154 {\cf17 class }NoExecDeathTest;\par
00155 {\cf17 class }FinalSuccessChecker;\par
00156 {\cf17 class }GTestFlagSaver;\par
00157 {\cf17 class }StreamingListenerTest;\par
00158 {\cf17 class }TestResultAccessor;\par
00159 {\cf17 class }TestEventListenersAccessor;\par
00160 {\cf17 class }TestEventRepeater;\par
00161 {\cf17 class }UnitTestRecordPropertyTestHelper;\par
00162 {\cf17 class }WindowsDeathTest;\par
00163 {\cf17 class }UnitTestImpl* GetUnitTestImpl();\par
00164 {\cf18 void} ReportFailureInUnknownLocation(TestPartResult::Type result_type,\par
00165                                     {\cf17 const} std::string& message);\par
00166 \par
00167 \}  {\cf20 // namespace internal}\par
00168 \par
00169 {\cf20 // The friend relationship of some of these classes is cyclic.}\par
00170 {\cf20 // If we don't forward declare them the compiler might confuse the classes}\par
00171 {\cf20 // in friendship clauses with same named classes on the scope.}\par
00172 {\cf17 class }Test;\par
00173 {\cf17 class }TestCase;\par
00174 {\cf17 class }TestInfo;\par
00175 {\cf17 class }UnitTest;\par
00176 \par
00177 {\cf20 // A class for indicating whether an assertion was successful.  When}\par
00178 {\cf20 // the assertion wasn't successful, the AssertionResult object}\par
00179 {\cf20 // remembers a non-empty message that describes how it failed.}\par
00180 {\cf20 //}\par
00181 {\cf20 // To create an instance of this class, use one of the factory functions}\par
00182 {\cf20 // (AssertionSuccess() and AssertionFailure()).}\par
00183 {\cf20 //}\par
00184 {\cf20 // This class is useful for two purposes:}\par
00185 {\cf20 //   1. Defining predicate functions to be used with Boolean test assertions}\par
00186 {\cf20 //      EXPECT_TRUE/EXPECT_FALSE and their ASSERT_ counterparts}\par
00187 {\cf20 //   2. Defining predicate-format functions to be}\par
00188 {\cf20 //      used with predicate assertions (ASSERT_PRED_FORMAT*, etc).}\par
00189 {\cf20 //}\par
00190 {\cf20 // For example, if you define IsEven predicate:}\par
00191 {\cf20 //}\par
00192 {\cf20 //   testing::AssertionResult IsEven(int n) \{}\par
00193 {\cf20 //     if ((n % 2) == 0)}\par
00194 {\cf20 //       return testing::AssertionSuccess();}\par
00195 {\cf20 //     else}\par
00196 {\cf20 //       return testing::AssertionFailure() << n << " is odd";}\par
00197 {\cf20 //   \}}\par
00198 {\cf20 //}\par
00199 {\cf20 // Then the failed expectation EXPECT_TRUE(IsEven(Fib(5)))}\par
00200 {\cf20 // will print the message}\par
00201 {\cf20 //}\par
00202 {\cf20 //   Value of: IsEven(Fib(5))}\par
00203 {\cf20 //     Actual: false (5 is odd)}\par
00204 {\cf20 //   Expected: true}\par
00205 {\cf20 //}\par
00206 {\cf20 // instead of a more opaque}\par
00207 {\cf20 //}\par
00208 {\cf20 //   Value of: IsEven(Fib(5))}\par
00209 {\cf20 //     Actual: false}\par
00210 {\cf20 //   Expected: true}\par
00211 {\cf20 //}\par
00212 {\cf20 // in case IsEven is a simple Boolean predicate.}\par
00213 {\cf20 //}\par
00214 {\cf20 // If you expect your predicate to be reused and want to support informative}\par
00215 {\cf20 // messages in EXPECT_FALSE and ASSERT_FALSE (negative assertions show up}\par
00216 {\cf20 // about half as often as positive ones in our tests), supply messages for}\par
00217 {\cf20 // both success and failure cases:}\par
00218 {\cf20 //}\par
00219 {\cf20 //   testing::AssertionResult IsEven(int n) \{}\par
00220 {\cf20 //     if ((n % 2) == 0)}\par
00221 {\cf20 //       return testing::AssertionSuccess() << n << " is even";}\par
00222 {\cf20 //     else}\par
00223 {\cf20 //       return testing::AssertionFailure() << n << " is odd";}\par
00224 {\cf20 //   \}}\par
00225 {\cf20 //}\par
00226 {\cf20 // Then a statement EXPECT_FALSE(IsEven(Fib(6))) will print}\par
00227 {\cf20 //}\par
00228 {\cf20 //   Value of: IsEven(Fib(6))}\par
00229 {\cf20 //     Actual: true (8 is even)}\par
00230 {\cf20 //   Expected: false}\par
00231 {\cf20 //}\par
00232 {\cf20 // NB: Predicates that support negative Boolean assertions have reduced}\par
00233 {\cf20 // performance in positive ones so be careful not to use them in tests}\par
00234 {\cf20 // that have lots (tens of thousands) of positive Boolean assertions.}\par
00235 {\cf20 //}\par
00236 {\cf20 // To use this class with EXPECT_PRED_FORMAT assertions such as:}\par
00237 {\cf20 //}\par
00238 {\cf20 //   // Verifies that Foo() returns an even number.}\par
00239 {\cf20 //   EXPECT_PRED_FORMAT1(IsEven, Foo());}\par
00240 {\cf20 //}\par
00241 {\cf20 // you need to define:}\par
00242 {\cf20 //}\par
00243 {\cf20 //   testing::AssertionResult IsEven(const char* expr, int n) \{}\par
00244 {\cf20 //     if ((n % 2) == 0)}\par
00245 {\cf20 //       return testing::AssertionSuccess();}\par
00246 {\cf20 //     else}\par
00247 {\cf20 //       return testing::AssertionFailure()}\par
00248 {\cf20 //         << "Expected: " << expr << " is even\\n  Actual: it's " << n;}\par
00249 {\cf20 //   \}}\par
00250 {\cf20 //}\par
00251 {\cf20 // If Foo() returns 5, you will see the following message:}\par
00252 {\cf20 //}\par
00253 {\cf20 //   Expected: Foo() is even}\par
00254 {\cf20 //     Actual: it's 5}\par
00255 {\cf20 //}\par
00256 {\cf17 class }GTEST_API_ AssertionResult \{\par
00257  {\cf17 public}:\par
00258   {\cf20 // Copy constructor.}\par
00259   {\cf20 // Used in EXPECT_TRUE/FALSE(assertion_result).}\par
00260   AssertionResult({\cf17 const} AssertionResult& other);\par
00261 \par
00262   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 {\cf20 /* forcing value to bool */})\par
00263 \par
00264   {\cf20 // Used in the EXPECT_TRUE/FALSE(bool_expression).}\par
00265   {\cf20 //}\par
00266   {\cf20 // T must be contextually convertible to bool.}\par
00267   {\cf20 //}\par
00268   {\cf20 // The second parameter prevents this overload from being considered if}\par
00269   {\cf20 // the argument is implicitly convertible to AssertionResult. In that case}\par
00270   {\cf20 // we want AssertionResult's copy constructor to be used.}\par
00271   {\cf17 template} <{\cf17 typename} T>\par
00272   {\cf17 explicit} AssertionResult(\par
00273       {\cf17 const} T& success,\par
00274       {\cf17 typename} internal::EnableIf<\par
00275           !internal::ImplicitlyConvertible<T, AssertionResult>::value>::type*\par
00276           {\cf20 /*enabler*/} = NULL)\par
00277       : success_(success) \{\}\par
00278 \par
00279   GTEST_DISABLE_MSC_WARNINGS_POP_()\par
00280 \par
00281   {\cf20 // Assignment operator.}\par
00282   AssertionResult& operator=(AssertionResult other) \{\par
00283     swap(other);\par
00284     {\cf19 return} *{\cf17 this};\par
00285   \}\par
00286 \par
00287   {\cf20 // Returns true iff the assertion succeeded.}\par
00288   {\cf17 operator} bool(){\cf17  const }\{ {\cf19 return} success_; \}  {\cf20 // NOLINT}\par
00289 \par
00290   {\cf20 // Returns the assertion's negation. Used with EXPECT/ASSERT_FALSE.}\par
00291   AssertionResult operator!() {\cf17 const};\par
00292 \par
00293   {\cf20 // Returns the text streamed into this AssertionResult. Test assertions}\par
00294   {\cf20 // use it when they fail (i.e., the predicate's outcome doesn't match the}\par
00295   {\cf20 // assertion's expectation). When nothing has been streamed into the}\par
00296   {\cf20 // object, returns an empty string.}\par
00297   {\cf17 const} {\cf18 char}* message(){\cf17  const }\{\par
00298     {\cf19 return} message_.get() != NULL ?  message_->c_str() : {\cf22 ""};\par
00299   \}\par
00300   {\cf20 // TODO(vladl@google.com): Remove this after making sure no clients use it.}\par
00301   {\cf20 // Deprecated; please use message() instead.}\par
00302   {\cf17 const} {\cf18 char}* failure_message(){\cf17  const }\{ {\cf19 return} message(); \}\par
00303 \par
00304   {\cf20 // Streams a custom failure message into this object.}\par
00305   {\cf17 template} <{\cf17 typename} T> AssertionResult& operator<<({\cf17 const} T& value) \{\par
00306     AppendMessage(Message() << value);\par
00307     {\cf19 return} *{\cf17 this};\par
00308   \}\par
00309 \par
00310   {\cf20 // Allows streaming basic output manipulators such as endl or flush into}\par
00311   {\cf20 // this object.}\par
00312   AssertionResult& operator<<(\par
00313       ::std::ostream& (*basic_manipulator)(::std::ostream& stream)) \{\par
00314     AppendMessage(Message() << basic_manipulator);\par
00315     {\cf19 return} *{\cf17 this};\par
00316   \}\par
00317 \par
00318  {\cf17 private}:\par
00319   {\cf20 // Appends the contents of message to message_.}\par
00320   {\cf18 void} AppendMessage({\cf17 const} Message& a_message) \{\par
00321     {\cf19 if} (message_.get() == NULL)\par
00322       message_.reset(new ::std::string);\par
00323     message_->append(a_message.GetString().c_str());\par
00324   \}\par
00325 \par
00326   {\cf20 // Swap the contents of this AssertionResult with other.}\par
00327   {\cf18 void} swap(AssertionResult& other);\par
00328 \par
00329   {\cf20 // Stores result of the assertion predicate.}\par
00330   {\cf18 bool} success_;\par
00331   {\cf20 // Stores the message describing the condition in case the expectation}\par
00332   {\cf20 // construct is not satisfied with the predicate's outcome.}\par
00333   {\cf20 // Referenced via a pointer to avoid taking too much stack frame space}\par
00334   {\cf20 // with test assertions.}\par
00335   internal::scoped_ptr< ::std::string> message_;\par
00336 \};\par
00337 \par
00338 {\cf20 // Makes a successful assertion result.}\par
00339 GTEST_API_ AssertionResult AssertionSuccess();\par
00340 \par
00341 {\cf20 // Makes a failed assertion result.}\par
00342 GTEST_API_ AssertionResult AssertionFailure();\par
00343 \par
00344 {\cf20 // Makes a failed assertion result with the given failure message.}\par
00345 {\cf20 // Deprecated; use AssertionFailure() << msg.}\par
00346 GTEST_API_ AssertionResult AssertionFailure({\cf17 const} Message& msg);\par
00347 \par
00348 {\cf20 // The abstract class that all tests inherit from.}\par
00349 {\cf20 //}\par
00350 {\cf20 // In Google Test, a unit test program contains one or many TestCases, and}\par
00351 {\cf20 // each TestCase contains one or many Tests.}\par
00352 {\cf20 //}\par
00353 {\cf20 // When you define a test using the TEST macro, you don't need to}\par
00354 {\cf20 // explicitly derive from Test - the TEST macro automatically does}\par
00355 {\cf20 // this for you.}\par
00356 {\cf20 //}\par
00357 {\cf20 // The only time you derive from Test is when defining a test fixture}\par
00358 {\cf20 // to be used a TEST_F.  For example:}\par
00359 {\cf20 //}\par
00360 {\cf20 //   class FooTest : public testing::Test \{}\par
00361 {\cf20 //    protected:}\par
00362 {\cf20 //     void SetUp() override \{ ... \}}\par
00363 {\cf20 //     void TearDown() override \{ ... \}}\par
00364 {\cf20 //     ...}\par
00365 {\cf20 //   \};}\par
00366 {\cf20 //}\par
00367 {\cf20 //   TEST_F(FooTest, Bar) \{ ... \}}\par
00368 {\cf20 //   TEST_F(FooTest, Baz) \{ ... \}}\par
00369 {\cf20 //}\par
00370 {\cf20 // Test is not copyable.}\par
00371 {\cf17 class }GTEST_API_ Test \{\par
00372  {\cf17 public}:\par
00373   {\cf17 friend} {\cf17 class }TestInfo;\par
00374 \par
00375   {\cf20 // Defines types for pointers to functions that set up and tear down}\par
00376   {\cf20 // a test case.}\par
00377   {\cf17 typedef} internal::SetUpTestCaseFunc SetUpTestCaseFunc;\par
00378   {\cf17 typedef} internal::TearDownTestCaseFunc TearDownTestCaseFunc;\par
00379 \par
00380   {\cf20 // The d'tor is virtual as we intend to inherit from Test.}\par
00381   {\cf17 virtual} ~Test();\par
00382 \par
00383   {\cf20 // Sets up the stuff shared by all tests in this test case.}\par
00384   {\cf20 //}\par
00385   {\cf20 // Google Test will call Foo::SetUpTestCase() before running the first}\par
00386   {\cf20 // test in test case Foo.  Hence a sub-class can define its own}\par
00387   {\cf20 // SetUpTestCase() method to shadow the one defined in the super}\par
00388   {\cf20 // class.}\par
00389   {\cf17 static} {\cf18 void} SetUpTestCase() \{\}\par
00390 \par
00391   {\cf20 // Tears down the stuff shared by all tests in this test case.}\par
00392   {\cf20 //}\par
00393   {\cf20 // Google Test will call Foo::TearDownTestCase() after running the last}\par
00394   {\cf20 // test in test case Foo.  Hence a sub-class can define its own}\par
00395   {\cf20 // TearDownTestCase() method to shadow the one defined in the super}\par
00396   {\cf20 // class.}\par
00397   {\cf17 static} {\cf18 void} TearDownTestCase() \{\}\par
00398 \par
00399   {\cf20 // Returns true iff the current test has a fatal failure.}\par
00400   {\cf17 static} {\cf18 bool} HasFatalFailure();\par
00401 \par
00402   {\cf20 // Returns true iff the current test has a non-fatal failure.}\par
00403   {\cf17 static} {\cf18 bool} HasNonfatalFailure();\par
00404 \par
00405   {\cf20 // Returns true iff the current test has a (either fatal or}\par
00406   {\cf20 // non-fatal) failure.}\par
00407   {\cf17 static} {\cf18 bool} HasFailure() \{ {\cf19 return} HasFatalFailure() || HasNonfatalFailure(); \}\par
00408 \par
00409   {\cf20 // Logs a property for the current test, test case, or for the entire}\par
00410   {\cf20 // invocation of the test program when used outside of the context of a}\par
00411   {\cf20 // test case.  Only the last value for a given key is remembered.  These}\par
00412   {\cf20 // are public static so they can be called from utility functions that are}\par
00413   {\cf20 // not members of the test fixture.  Calls to RecordProperty made during}\par
00414   {\cf20 // lifespan of the test (from the moment its constructor starts to the}\par
00415   {\cf20 // moment its destructor finishes) will be output in XML as attributes of}\par
00416   {\cf20 // the <testcase> element.  Properties recorded from fixture's}\par
00417   {\cf20 // SetUpTestCase or TearDownTestCase are logged as attributes of the}\par
00418   {\cf20 // corresponding <testsuite> element.  Calls to RecordProperty made in the}\par
00419   {\cf20 // global context (before or after invocation of RUN_ALL_TESTS and from}\par
00420   {\cf20 // SetUp/TearDown method of Environment objects registered with Google}\par
00421   {\cf20 // Test) will be output as attributes of the <testsuites> element.}\par
00422   {\cf17 static} {\cf18 void} RecordProperty({\cf17 const} std::string& key, {\cf17 const} std::string& value);\par
00423   {\cf17 static} {\cf18 void} RecordProperty({\cf17 const} std::string& key, {\cf18 int} value);\par
00424 \par
00425  {\cf17 protected}:\par
00426   {\cf20 // Creates a Test object.}\par
00427   Test();\par
00428 \par
00429   {\cf20 // Sets up the test fixture.}\par
00430   {\cf17 virtual} {\cf18 void} SetUp();\par
00431 \par
00432   {\cf20 // Tears down the test fixture.}\par
00433   {\cf17 virtual} {\cf18 void} TearDown();\par
00434 \par
00435  {\cf17 private}:\par
00436   {\cf20 // Returns true iff the current test has the same fixture class as}\par
00437   {\cf20 // the first test in the current test case.}\par
00438   {\cf17 static} {\cf18 bool} HasSameFixtureClass();\par
00439 \par
00440   {\cf20 // Runs the test after the test fixture has been set up.}\par
00441   {\cf20 //}\par
00442   {\cf20 // A sub-class must implement this to define the test logic.}\par
00443   {\cf20 //}\par
00444   {\cf20 // DO NOT OVERRIDE THIS FUNCTION DIRECTLY IN A USER PROGRAM.}\par
00445   {\cf20 // Instead, use the TEST or TEST_F macro.}\par
00446   {\cf17 virtual} {\cf18 void} TestBody() = 0;\par
00447 \par
00448   {\cf20 // Sets up, executes, and tears down the test.}\par
00449   {\cf18 void} Run();\par
00450 \par
00451   {\cf20 // Deletes self.  We deliberately pick an unusual name for this}\par
00452   {\cf20 // internal method to avoid clashing with names used in user TESTs.}\par
00453   {\cf18 void} DeleteSelf_() \{ {\cf17 delete} {\cf17 this}; \}\par
00454 \par
00455   {\cf17 const} internal::scoped_ptr< GTEST_FLAG_SAVER_ > gtest_flag_saver_;\par
00456 \par
00457   {\cf20 // Often a user misspells SetUp() as Setup() and spends a long time}\par
00458   {\cf20 // wondering why it is never called by Google Test.  The declaration of}\par
00459   {\cf20 // the following method is solely for catching such an error at}\par
00460   {\cf20 // compile time:}\par
00461   {\cf20 //}\par
00462   {\cf20 //   - The return type is deliberately chosen to be not void, so it}\par
00463   {\cf20 //   will be a conflict if void Setup() is declared in the user's}\par
00464   {\cf20 //   test fixture.}\par
00465   {\cf20 //}\par
00466   {\cf20 //   - This method is private, so it will be another compiler error}\par
00467   {\cf20 //   if the method is called from the user's test fixture.}\par
00468   {\cf20 //}\par
00469   {\cf20 // DO NOT OVERRIDE THIS FUNCTION.}\par
00470   {\cf20 //}\par
00471   {\cf20 // If you see an error about overriding the following function or}\par
00472   {\cf20 // about it being private, you have mis-spelled SetUp() as Setup().}\par
00473   {\cf17 struct }Setup_should_be_spelled_SetUp \{\};\par
00474   {\cf17 virtual} Setup_should_be_spelled_SetUp* Setup() \{ {\cf19 return} NULL; \}\par
00475 \par
00476   {\cf20 // We disallow copying Tests.}\par
00477   GTEST_DISALLOW_COPY_AND_ASSIGN_(Test);\par
00478 \};\par
00479 \par
00480 {\cf17 typedef} internal::TimeInMillis TimeInMillis;\par
00481 \par
00482 {\cf20 // A copyable object representing a user specified test property which can be}\par
00483 {\cf20 // output as a key/value string pair.}\par
00484 {\cf20 //}\par
00485 {\cf20 // Don't inherit from TestProperty as its destructor is not virtual.}\par
00486 {\cf17 class }TestProperty \{\par
00487  {\cf17 public}:\par
00488   {\cf20 // C'tor.  TestProperty does NOT have a default constructor.}\par
00489   {\cf20 // Always use this constructor (with parameters) to create a}\par
00490   {\cf20 // TestProperty object.}\par
00491   TestProperty({\cf17 const} std::string& a_key, {\cf17 const} std::string& a_value) :\par
00492     key_(a_key), value_(a_value) \{\par
00493   \}\par
00494 \par
00495   {\cf20 // Gets the user supplied key.}\par
00496   {\cf17 const} {\cf18 char}* key(){\cf17  const }\{\par
00497     {\cf19 return} key_.c_str();\par
00498   \}\par
00499 \par
00500   {\cf20 // Gets the user supplied value.}\par
00501   {\cf17 const} {\cf18 char}* value(){\cf17  const }\{\par
00502     {\cf19 return} value_.c_str();\par
00503   \}\par
00504 \par
00505   {\cf20 // Sets a new value, overriding the one supplied in the constructor.}\par
00506   {\cf18 void} SetValue({\cf17 const} std::string& new_value) \{\par
00507     value_ = new_value;\par
00508   \}\par
00509 \par
00510  {\cf17 private}:\par
00511   {\cf20 // The key supplied by the user.}\par
00512   std::string key_;\par
00513   {\cf20 // The value supplied by the user.}\par
00514   std::string value_;\par
00515 \};\par
00516 \par
00517 {\cf20 // The result of a single Test.  This includes a list of}\par
00518 {\cf20 // TestPartResults, a list of TestProperties, a count of how many}\par
00519 {\cf20 // death tests there are in the Test, and how much time it took to run}\par
00520 {\cf20 // the Test.}\par
00521 {\cf20 //}\par
00522 {\cf20 // TestResult is not copyable.}\par
00523 {\cf17 class }GTEST_API_ TestResult \{\par
00524  {\cf17 public}:\par
00525   {\cf20 // Creates an empty TestResult.}\par
00526   TestResult();\par
00527 \par
00528   {\cf20 // D'tor.  Do not inherit from TestResult.}\par
00529   ~TestResult();\par
00530 \par
00531   {\cf20 // Gets the number of all test parts.  This is the sum of the number}\par
00532   {\cf20 // of successful test parts and the number of failed test parts.}\par
00533   {\cf18 int} total_part_count() {\cf17 const};\par
00534 \par
00535   {\cf20 // Returns the number of the test properties.}\par
00536   {\cf18 int} test_property_count() {\cf17 const};\par
00537 \par
00538   {\cf20 // Returns true iff the test passed (i.e. no test part failed).}\par
00539   {\cf18 bool} Passed(){\cf17  const }\{ {\cf19 return} !Failed(); \}\par
00540 \par
00541   {\cf20 // Returns true iff the test failed.}\par
00542   {\cf18 bool} Failed() {\cf17 const};\par
00543 \par
00544   {\cf20 // Returns true iff the test fatally failed.}\par
00545   {\cf18 bool} HasFatalFailure() {\cf17 const};\par
00546 \par
00547   {\cf20 // Returns true iff the test has a non-fatal failure.}\par
00548   {\cf18 bool} HasNonfatalFailure() {\cf17 const};\par
00549 \par
00550   {\cf20 // Returns the elapsed time, in milliseconds.}\par
00551   TimeInMillis elapsed_time(){\cf17  const }\{ {\cf19 return} elapsed_time_; \}\par
00552 \par
00553   {\cf20 // Returns the i-th test part result among all the results. i can range}\par
00554   {\cf20 // from 0 to test_property_count() - 1. If i is not in that range, aborts}\par
00555   {\cf20 // the program.}\par
00556   {\cf17 const} TestPartResult& GetTestPartResult({\cf18 int} i) {\cf17 const};\par
00557 \par
00558   {\cf20 // Returns the i-th test property. i can range from 0 to}\par
00559   {\cf20 // test_property_count() - 1. If i is not in that range, aborts the}\par
00560   {\cf20 // program.}\par
00561   {\cf17 const} TestProperty& GetTestProperty({\cf18 int} i) {\cf17 const};\par
00562 \par
00563  {\cf17 private}:\par
00564   {\cf17 friend} {\cf17 class }TestInfo;\par
00565   {\cf17 friend} {\cf17 class }TestCase;\par
00566   {\cf17 friend} {\cf17 class }UnitTest;\par
00567   {\cf17 friend} {\cf17 class }internal::DefaultGlobalTestPartResultReporter;\par
00568   {\cf17 friend} {\cf17 class }internal::ExecDeathTest;\par
00569   {\cf17 friend} {\cf17 class }internal::TestResultAccessor;\par
00570   {\cf17 friend} {\cf17 class }internal::UnitTestImpl;\par
00571   {\cf17 friend} {\cf17 class }internal::WindowsDeathTest;\par
00572 \par
00573   {\cf20 // Gets the vector of TestPartResults.}\par
00574   {\cf17 const} std::vector<TestPartResult>& test_part_results(){\cf17  const }\{\par
00575     {\cf19 return} test_part_results_;\par
00576   \}\par
00577 \par
00578   {\cf20 // Gets the vector of TestProperties.}\par
00579   {\cf17 const} std::vector<TestProperty>& test_properties(){\cf17  const }\{\par
00580     {\cf19 return} test_properties_;\par
00581   \}\par
00582 \par
00583   {\cf20 // Sets the elapsed time.}\par
00584   {\cf18 void} set_elapsed_time(TimeInMillis elapsed) \{ elapsed_time_ = elapsed; \}\par
00585 \par
00586   {\cf20 // Adds a test property to the list. The property is validated and may add}\par
00587   {\cf20 // a non-fatal failure if invalid (e.g., if it conflicts with reserved}\par
00588   {\cf20 // key names). If a property is already recorded for the same key, the}\par
00589   {\cf20 // value will be updated, rather than storing multiple values for the same}\par
00590   {\cf20 // key.  xml_element specifies the element for which the property is being}\par
00591   {\cf20 // recorded and is used for validation.}\par
00592   {\cf18 void} RecordProperty({\cf17 const} std::string& xml_element,\par
00593                       {\cf17 const} TestProperty& test_property);\par
00594 \par
00595   {\cf20 // Adds a failure if the key is a reserved attribute of Google Test}\par
00596   {\cf20 // testcase tags.  Returns true if the property is valid.}\par
00597   {\cf20 // TODO(russr): Validate attribute names are legal and human readable.}\par
00598   {\cf17 static} {\cf18 bool} ValidateTestProperty({\cf17 const} std::string& xml_element,\par
00599                                    {\cf17 const} TestProperty& test_property);\par
00600 \par
00601   {\cf20 // Adds a test part result to the list.}\par
00602   {\cf18 void} AddTestPartResult({\cf17 const} TestPartResult& test_part_result);\par
00603 \par
00604   {\cf20 // Returns the death test count.}\par
00605   {\cf18 int} death_test_count(){\cf17  const }\{ {\cf19 return} death_test_count_; \}\par
00606 \par
00607   {\cf20 // Increments the death test count, returning the new count.}\par
00608   {\cf18 int} increment_death_test_count() \{ {\cf19 return} ++death_test_count_; \}\par
00609 \par
00610   {\cf20 // Clears the test part results.}\par
00611   {\cf18 void} ClearTestPartResults();\par
00612 \par
00613   {\cf20 // Clears the object.}\par
00614   {\cf18 void} Clear();\par
00615 \par
00616   {\cf20 // Protects mutable state of the property vector and of owned}\par
00617   {\cf20 // properties, whose values may be updated.}\par
00618   internal::Mutex test_properites_mutex_;\par
00619 \par
00620   {\cf20 // The vector of TestPartResults}\par
00621   std::vector<TestPartResult> test_part_results_;\par
00622   {\cf20 // The vector of TestProperties}\par
00623   std::vector<TestProperty> test_properties_;\par
00624   {\cf20 // Running count of death tests.}\par
00625   {\cf18 int} death_test_count_;\par
00626   {\cf20 // The elapsed time, in milliseconds.}\par
00627   TimeInMillis elapsed_time_;\par
00628 \par
00629   {\cf20 // We disallow copying TestResult.}\par
00630   GTEST_DISALLOW_COPY_AND_ASSIGN_(TestResult);\par
00631 \};  {\cf20 // class TestResult}\par
00632 \par
00633 {\cf20 // A TestInfo object stores the following information about a test:}\par
00634 {\cf20 //}\par
00635 {\cf20 //   Test case name}\par
00636 {\cf20 //   Test name}\par
00637 {\cf20 //   Whether the test should be run}\par
00638 {\cf20 //   A function pointer that creates the test object when invoked}\par
00639 {\cf20 //   Test result}\par
00640 {\cf20 //}\par
00641 {\cf20 // The constructor of TestInfo registers itself with the UnitTest}\par
00642 {\cf20 // singleton such that the RUN_ALL_TESTS() macro knows which tests to}\par
00643 {\cf20 // run.}\par
00644 {\cf17 class }GTEST_API_ TestInfo \{\par
00645  {\cf17 public}:\par
00646   {\cf20 // Destructs a TestInfo object.  This function is not virtual, so}\par
00647   {\cf20 // don't inherit from TestInfo.}\par
00648   ~TestInfo();\par
00649 \par
00650   {\cf20 // Returns the test case name.}\par
00651   {\cf17 const} {\cf18 char}* test_case_name(){\cf17  const }\{ {\cf19 return} test_case_name_.c_str(); \}\par
00652 \par
00653   {\cf20 // Returns the test name.}\par
00654   {\cf17 const} {\cf18 char}* name(){\cf17  const }\{ {\cf19 return} name_.c_str(); \}\par
00655 \par
00656   {\cf20 // Returns the name of the parameter type, or NULL if this is not a typed}\par
00657   {\cf20 // or a type-parameterized test.}\par
00658   {\cf17 const} {\cf18 char}* type_param(){\cf17  const }\{\par
00659     {\cf19 if} (type_param_.get() != NULL)\par
00660       {\cf19 return} type_param_->c_str();\par
00661     {\cf19 return} NULL;\par
00662   \}\par
00663 \par
00664   {\cf20 // Returns the text representation of the value parameter, or NULL if this}\par
00665   {\cf20 // is not a value-parameterized test.}\par
00666   {\cf17 const} {\cf18 char}* value_param(){\cf17  const }\{\par
00667     {\cf19 if} (value_param_.get() != NULL)\par
00668       {\cf19 return} value_param_->c_str();\par
00669     {\cf19 return} NULL;\par
00670   \}\par
00671 \par
00672   {\cf20 // Returns the file name where this test is defined.}\par
00673   {\cf17 const} {\cf18 char}* file(){\cf17  const }\{ {\cf19 return} location_.file.c_str(); \}\par
00674 \par
00675   {\cf20 // Returns the line where this test is defined.}\par
00676   {\cf18 int} line(){\cf17  const }\{ {\cf19 return} location_.line; \}\par
00677 \par
00678   {\cf20 // Returns true if this test should run, that is if the test is not}\par
00679   {\cf20 // disabled (or it is disabled but the also_run_disabled_tests flag has}\par
00680   {\cf20 // been specified) and its full name matches the user-specified filter.}\par
00681   {\cf20 //}\par
00682   {\cf20 // Google Test allows the user to filter the tests by their full names.}\par
00683   {\cf20 // The full name of a test Bar in test case Foo is defined as}\par
00684   {\cf20 // "Foo.Bar".  Only the tests that match the filter will run.}\par
00685   {\cf20 //}\par
00686   {\cf20 // A filter is a colon-separated list of glob (not regex) patterns,}\par
00687   {\cf20 // optionally followed by a '-' and a colon-separated list of}\par
00688   {\cf20 // negative patterns (tests to exclude).  A test is run if it}\par
00689   {\cf20 // matches one of the positive patterns and does not match any of}\par
00690   {\cf20 // the negative patterns.}\par
00691   {\cf20 //}\par
00692   {\cf20 // For example, *A*:Foo.* is a filter that matches any string that}\par
00693   {\cf20 // contains the character 'A' or starts with "Foo.".}\par
00694   {\cf18 bool} should_run(){\cf17  const }\{ {\cf19 return} should_run_; \}\par
00695 \par
00696   {\cf20 // Returns true iff this test will appear in the XML report.}\par
00697   {\cf18 bool} is_reportable(){\cf17  const }\{\par
00698     {\cf20 // For now, the XML report includes all tests matching the filter.}\par
00699     {\cf20 // In the future, we may trim tests that are excluded because of}\par
00700     {\cf20 // sharding.}\par
00701     {\cf19 return} matches_filter_;\par
00702   \}\par
00703 \par
00704   {\cf20 // Returns the result of the test.}\par
00705   {\cf17 const} TestResult* result(){\cf17  const }\{ {\cf19 return} &result_; \}\par
00706 \par
00707  {\cf17 private}:\par
00708 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
00709   {\cf17 friend} {\cf17 class }internal::DefaultDeathTestFactory;\par
00710 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
00711   {\cf17 friend} {\cf17 class }Test;\par
00712   {\cf17 friend} {\cf17 class }TestCase;\par
00713   {\cf17 friend} {\cf17 class }internal::UnitTestImpl;\par
00714   {\cf17 friend} {\cf17 class }internal::StreamingListenerTest;\par
00715   {\cf17 friend} TestInfo* internal::MakeAndRegisterTestInfo(\par
00716       {\cf17 const} {\cf18 char}* test_case_name,\par
00717       {\cf17 const} {\cf18 char}* name,\par
00718       {\cf17 const} {\cf18 char}* type_param,\par
00719       {\cf17 const} {\cf18 char}* value_param,\par
00720       internal::CodeLocation code_location,\par
00721       internal::TypeId fixture_class_id,\par
00722       Test::SetUpTestCaseFunc set_up_tc,\par
00723       Test::TearDownTestCaseFunc tear_down_tc,\par
00724       internal::TestFactoryBase* factory);\par
00725 \par
00726   {\cf20 // Constructs a TestInfo object. The newly constructed instance assumes}\par
00727   {\cf20 // ownership of the factory object.}\par
00728   TestInfo({\cf17 const} std::string& test_case_name,\par
00729            {\cf17 const} std::string& name,\par
00730            {\cf17 const} {\cf18 char}* a_type_param,   {\cf20 // NULL if not a type-parameterized test}\par
00731            {\cf17 const} {\cf18 char}* a_value_param,  {\cf20 // NULL if not a value-parameterized test}\par
00732            internal::CodeLocation a_code_location,\par
00733            internal::TypeId fixture_class_id,\par
00734            internal::TestFactoryBase* factory);\par
00735 \par
00736   {\cf20 // Increments the number of death tests encountered in this test so}\par
00737   {\cf20 // far.}\par
00738   {\cf18 int} increment_death_test_count() \{\par
00739     {\cf19 return} result_.increment_death_test_count();\par
00740   \}\par
00741 \par
00742   {\cf20 // Creates the test object, runs it, records its result, and then}\par
00743   {\cf20 // deletes it.}\par
00744   {\cf18 void} Run();\par
00745 \par
00746   {\cf17 static} {\cf18 void} ClearTestResult(TestInfo* test_info) \{\par
00747     test_info->result_.Clear();\par
00748   \}\par
00749 \par
00750   {\cf20 // These fields are immutable properties of the test.}\par
00751   {\cf17 const} std::string test_case_name_;     {\cf20 // Test case name}\par
00752   {\cf17 const} std::string name_;               {\cf20 // Test name}\par
00753   {\cf20 // Name of the parameter type, or NULL if this is not a typed or a}\par
00754   {\cf20 // type-parameterized test.}\par
00755   {\cf17 const} internal::scoped_ptr<const ::std::string> type_param_;\par
00756   {\cf20 // Text representation of the value parameter, or NULL if this is not a}\par
00757   {\cf20 // value-parameterized test.}\par
00758   {\cf17 const} internal::scoped_ptr<const ::std::string> value_param_;\par
00759   internal::CodeLocation location_;\par
00760   {\cf17 const} internal::TypeId fixture_class_id_;   {\cf20 // ID of the test fixture class}\par
00761   {\cf18 bool} should_run_;                 {\cf20 // True iff this test should run}\par
00762   {\cf18 bool} is_disabled_;                {\cf20 // True iff this test is disabled}\par
00763   {\cf18 bool} matches_filter_;             {\cf20 // True if this test matches the}\par
00764                                     {\cf20 // user-specified filter.}\par
00765   internal::TestFactoryBase* {\cf17 const} factory_;  {\cf20 // The factory that creates}\par
00766                                               {\cf20 // the test object}\par
00767 \par
00768   {\cf20 // This field is mutable and needs to be reset before running the}\par
00769   {\cf20 // test for the second time.}\par
00770   TestResult result_;\par
00771 \par
00772   GTEST_DISALLOW_COPY_AND_ASSIGN_(TestInfo);\par
00773 \};\par
00774 \par
00775 {\cf20 // A test case, which consists of a vector of TestInfos.}\par
00776 {\cf20 //}\par
00777 {\cf20 // TestCase is not copyable.}\par
00778 {\cf17 class }GTEST_API_ TestCase \{\par
00779  {\cf17 public}:\par
00780   {\cf20 // Creates a TestCase with the given name.}\par
00781   {\cf20 //}\par
00782   {\cf20 // TestCase does NOT have a default constructor.  Always use this}\par
00783   {\cf20 // constructor to create a TestCase object.}\par
00784   {\cf20 //}\par
00785   {\cf20 // Arguments:}\par
00786   {\cf20 //}\par
00787   {\cf20 //   name:         name of the test case}\par
00788   {\cf20 //   a_type_param: the name of the test's type parameter, or NULL if}\par
00789   {\cf20 //                 this is not a type-parameterized test.}\par
00790   {\cf20 //   set_up_tc:    pointer to the function that sets up the test case}\par
00791   {\cf20 //   tear_down_tc: pointer to the function that tears down the test case}\par
00792   TestCase({\cf17 const} {\cf18 char}* name, {\cf17 const} {\cf18 char}* a_type_param,\par
00793            Test::SetUpTestCaseFunc set_up_tc,\par
00794            Test::TearDownTestCaseFunc tear_down_tc);\par
00795 \par
00796   {\cf20 // Destructor of TestCase.}\par
00797   {\cf17 virtual} ~TestCase();\par
00798 \par
00799   {\cf20 // Gets the name of the TestCase.}\par
00800   {\cf17 const} {\cf18 char}* name(){\cf17  const }\{ {\cf19 return} name_.c_str(); \}\par
00801 \par
00802   {\cf20 // Returns the name of the parameter type, or NULL if this is not a}\par
00803   {\cf20 // type-parameterized test case.}\par
00804   {\cf17 const} {\cf18 char}* type_param(){\cf17  const }\{\par
00805     {\cf19 if} (type_param_.get() != NULL)\par
00806       {\cf19 return} type_param_->c_str();\par
00807     {\cf19 return} NULL;\par
00808   \}\par
00809 \par
00810   {\cf20 // Returns true if any test in this test case should run.}\par
00811   {\cf18 bool} should_run(){\cf17  const }\{ {\cf19 return} should_run_; \}\par
00812 \par
00813   {\cf20 // Gets the number of successful tests in this test case.}\par
00814   {\cf18 int} successful_test_count() {\cf17 const};\par
00815 \par
00816   {\cf20 // Gets the number of failed tests in this test case.}\par
00817   {\cf18 int} failed_test_count() {\cf17 const};\par
00818 \par
00819   {\cf20 // Gets the number of disabled tests that will be reported in the XML report.}\par
00820   {\cf18 int} reportable_disabled_test_count() {\cf17 const};\par
00821 \par
00822   {\cf20 // Gets the number of disabled tests in this test case.}\par
00823   {\cf18 int} disabled_test_count() {\cf17 const};\par
00824 \par
00825   {\cf20 // Gets the number of tests to be printed in the XML report.}\par
00826   {\cf18 int} reportable_test_count() {\cf17 const};\par
00827 \par
00828   {\cf20 // Get the number of tests in this test case that should run.}\par
00829   {\cf18 int} test_to_run_count() {\cf17 const};\par
00830 \par
00831   {\cf20 // Gets the number of all tests in this test case.}\par
00832   {\cf18 int} total_test_count() {\cf17 const};\par
00833 \par
00834   {\cf20 // Returns true iff the test case passed.}\par
00835   {\cf18 bool} Passed(){\cf17  const }\{ {\cf19 return} !Failed(); \}\par
00836 \par
00837   {\cf20 // Returns true iff the test case failed.}\par
00838   {\cf18 bool} Failed(){\cf17  const }\{ {\cf19 return} failed_test_count() > 0; \}\par
00839 \par
00840   {\cf20 // Returns the elapsed time, in milliseconds.}\par
00841   TimeInMillis elapsed_time(){\cf17  const }\{ {\cf19 return} elapsed_time_; \}\par
00842 \par
00843   {\cf20 // Returns the i-th test among all the tests. i can range from 0 to}\par
00844   {\cf20 // total_test_count() - 1. If i is not in that range, returns NULL.}\par
00845   {\cf17 const} TestInfo* GetTestInfo({\cf18 int} i) {\cf17 const};\par
00846 \par
00847   {\cf20 // Returns the TestResult that holds test properties recorded during}\par
00848   {\cf20 // execution of SetUpTestCase and TearDownTestCase.}\par
00849   {\cf17 const} TestResult& ad_hoc_test_result(){\cf17  const }\{ {\cf19 return} ad_hoc_test_result_; \}\par
00850 \par
00851  {\cf17 private}:\par
00852   {\cf17 friend} {\cf17 class }Test;\par
00853   {\cf17 friend} {\cf17 class }internal::UnitTestImpl;\par
00854 \par
00855   {\cf20 // Gets the (mutable) vector of TestInfos in this TestCase.}\par
00856   std::vector<TestInfo*>& test_info_list() \{ {\cf19 return} test_info_list_; \}\par
00857 \par
00858   {\cf20 // Gets the (immutable) vector of TestInfos in this TestCase.}\par
00859   {\cf17 const} std::vector<TestInfo*>& test_info_list(){\cf17  const }\{\par
00860     {\cf19 return} test_info_list_;\par
00861   \}\par
00862 \par
00863   {\cf20 // Returns the i-th test among all the tests. i can range from 0 to}\par
00864   {\cf20 // total_test_count() - 1. If i is not in that range, returns NULL.}\par
00865   TestInfo* GetMutableTestInfo({\cf18 int} i);\par
00866 \par
00867   {\cf20 // Sets the should_run member.}\par
00868   {\cf18 void} set_should_run({\cf18 bool} should) \{ should_run_ = should; \}\par
00869 \par
00870   {\cf20 // Adds a TestInfo to this test case.  Will delete the TestInfo upon}\par
00871   {\cf20 // destruction of the TestCase object.}\par
00872   {\cf18 void} AddTestInfo(TestInfo * test_info);\par
00873 \par
00874   {\cf20 // Clears the results of all tests in this test case.}\par
00875   {\cf18 void} ClearResult();\par
00876 \par
00877   {\cf20 // Clears the results of all tests in the given test case.}\par
00878   {\cf17 static} {\cf18 void} ClearTestCaseResult(TestCase* test_case) \{\par
00879     test_case->ClearResult();\par
00880   \}\par
00881 \par
00882   {\cf20 // Runs every test in this TestCase.}\par
00883   {\cf18 void} Run();\par
00884 \par
00885   {\cf20 // Runs SetUpTestCase() for this TestCase.  This wrapper is needed}\par
00886   {\cf20 // for catching exceptions thrown from SetUpTestCase().}\par
00887   {\cf18 void} RunSetUpTestCase() \{ (*set_up_tc_)(); \}\par
00888 \par
00889   {\cf20 // Runs TearDownTestCase() for this TestCase.  This wrapper is}\par
00890   {\cf20 // needed for catching exceptions thrown from TearDownTestCase().}\par
00891   {\cf18 void} RunTearDownTestCase() \{ (*tear_down_tc_)(); \}\par
00892 \par
00893   {\cf20 // Returns true iff test passed.}\par
00894   {\cf17 static} {\cf18 bool} TestPassed({\cf17 const} TestInfo* test_info) \{\par
00895     {\cf19 return} test_info->should_run() && test_info->result()->Passed();\par
00896   \}\par
00897 \par
00898   {\cf20 // Returns true iff test failed.}\par
00899   {\cf17 static} {\cf18 bool} TestFailed({\cf17 const} TestInfo* test_info) \{\par
00900     {\cf19 return} test_info->should_run() && test_info->result()->Failed();\par
00901   \}\par
00902 \par
00903   {\cf20 // Returns true iff the test is disabled and will be reported in the XML}\par
00904   {\cf20 // report.}\par
00905   {\cf17 static} {\cf18 bool} TestReportableDisabled({\cf17 const} TestInfo* test_info) \{\par
00906     {\cf19 return} test_info->is_reportable() && test_info->is_disabled_;\par
00907   \}\par
00908 \par
00909   {\cf20 // Returns true iff test is disabled.}\par
00910   {\cf17 static} {\cf18 bool} TestDisabled({\cf17 const} TestInfo* test_info) \{\par
00911     {\cf19 return} test_info->is_disabled_;\par
00912   \}\par
00913 \par
00914   {\cf20 // Returns true iff this test will appear in the XML report.}\par
00915   {\cf17 static} {\cf18 bool} TestReportable({\cf17 const} TestInfo* test_info) \{\par
00916     {\cf19 return} test_info->is_reportable();\par
00917   \}\par
00918 \par
00919   {\cf20 // Returns true if the given test should run.}\par
00920   {\cf17 static} {\cf18 bool} ShouldRunTest({\cf17 const} TestInfo* test_info) \{\par
00921     {\cf19 return} test_info->should_run();\par
00922   \}\par
00923 \par
00924   {\cf20 // Shuffles the tests in this test case.}\par
00925   {\cf18 void} ShuffleTests(internal::Random* random);\par
00926 \par
00927   {\cf20 // Restores the test order to before the first shuffle.}\par
00928   {\cf18 void} UnshuffleTests();\par
00929 \par
00930   {\cf20 // Name of the test case.}\par
00931   std::string name_;\par
00932   {\cf20 // Name of the parameter type, or NULL if this is not a typed or a}\par
00933   {\cf20 // type-parameterized test.}\par
00934   {\cf17 const} internal::scoped_ptr<const ::std::string> type_param_;\par
00935   {\cf20 // The vector of TestInfos in their original order.  It owns the}\par
00936   {\cf20 // elements in the vector.}\par
00937   std::vector<TestInfo*> test_info_list_;\par
00938   {\cf20 // Provides a level of indirection for the test list to allow easy}\par
00939   {\cf20 // shuffling and restoring the test order.  The i-th element in this}\par
00940   {\cf20 // vector is the index of the i-th test in the shuffled test list.}\par
00941   std::vector<int> test_indices_;\par
00942   {\cf20 // Pointer to the function that sets up the test case.}\par
00943   Test::SetUpTestCaseFunc set_up_tc_;\par
00944   {\cf20 // Pointer to the function that tears down the test case.}\par
00945   Test::TearDownTestCaseFunc tear_down_tc_;\par
00946   {\cf20 // True iff any test in this test case should run.}\par
00947   {\cf18 bool} should_run_;\par
00948   {\cf20 // Elapsed time, in milliseconds.}\par
00949   TimeInMillis elapsed_time_;\par
00950   {\cf20 // Holds test properties recorded during execution of SetUpTestCase and}\par
00951   {\cf20 // TearDownTestCase.}\par
00952   TestResult ad_hoc_test_result_;\par
00953 \par
00954   {\cf20 // We disallow copying TestCases.}\par
00955   GTEST_DISALLOW_COPY_AND_ASSIGN_(TestCase);\par
00956 \};\par
00957 \par
00958 {\cf20 // An Environment object is capable of setting up and tearing down an}\par
00959 {\cf20 // environment.  You should subclass this to define your own}\par
00960 {\cf20 // environment(s).}\par
00961 {\cf20 //}\par
00962 {\cf20 // An Environment object does the set-up and tear-down in virtual}\par
00963 {\cf20 // methods SetUp() and TearDown() instead of the constructor and the}\par
00964 {\cf20 // destructor, as:}\par
00965 {\cf20 //}\par
00966 {\cf20 //   1. You cannot safely throw from a destructor.  This is a problem}\par
00967 {\cf20 //      as in some cases Google Test is used where exceptions are enabled, and}\par
00968 {\cf20 //      we may want to implement ASSERT_* using exceptions where they are}\par
00969 {\cf20 //      available.}\par
00970 {\cf20 //   2. You cannot use ASSERT_* directly in a constructor or}\par
00971 {\cf20 //      destructor.}\par
00972 {\cf17 class }Environment \{\par
00973  {\cf17 public}:\par
00974   {\cf20 // The d'tor is virtual as we need to subclass Environment.}\par
00975   {\cf17 virtual} ~Environment() \{\}\par
00976 \par
00977   {\cf20 // Override this to define how to set up the environment.}\par
00978   {\cf17 virtual} {\cf18 void} SetUp() \{\}\par
00979 \par
00980   {\cf20 // Override this to define how to tear down the environment.}\par
00981   {\cf17 virtual} {\cf18 void} TearDown() \{\}\par
00982  {\cf17 private}:\par
00983   {\cf20 // If you see an error about overriding the following function or}\par
00984   {\cf20 // about it being private, you have mis-spelled SetUp() as Setup().}\par
00985   {\cf17 struct }Setup_should_be_spelled_SetUp \{\};\par
00986   {\cf17 virtual} Setup_should_be_spelled_SetUp* Setup() \{ {\cf19 return} NULL; \}\par
00987 \};\par
00988 \par
00989 {\cf20 // The interface for tracing execution of tests. The methods are organized in}\par
00990 {\cf20 // the order the corresponding events are fired.}\par
00991 {\cf17 class }TestEventListener \{\par
00992  {\cf17 public}:\par
00993   {\cf17 virtual} ~TestEventListener() \{\}\par
00994 \par
00995   {\cf20 // Fired before any test activity starts.}\par
00996   {\cf17 virtual} {\cf18 void} OnTestProgramStart({\cf17 const} UnitTest& unit_test) = 0;\par
00997 \par
00998   {\cf20 // Fired before each iteration of tests starts.  There may be more than}\par
00999   {\cf20 // one iteration if GTEST_FLAG(repeat) is set. iteration is the iteration}\par
01000   {\cf20 // index, starting from 0.}\par
01001   {\cf17 virtual} {\cf18 void} OnTestIterationStart({\cf17 const} UnitTest& unit_test,\par
01002                                     {\cf18 int} iteration) = 0;\par
01003 \par
01004   {\cf20 // Fired before environment set-up for each iteration of tests starts.}\par
01005   {\cf17 virtual} {\cf18 void} OnEnvironmentsSetUpStart({\cf17 const} UnitTest& unit_test) = 0;\par
01006 \par
01007   {\cf20 // Fired after environment set-up for each iteration of tests ends.}\par
01008   {\cf17 virtual} {\cf18 void} OnEnvironmentsSetUpEnd({\cf17 const} UnitTest& unit_test) = 0;\par
01009 \par
01010   {\cf20 // Fired before the test case starts.}\par
01011   {\cf17 virtual} {\cf18 void} OnTestCaseStart({\cf17 const} TestCase& test_case) = 0;\par
01012 \par
01013   {\cf20 // Fired before the test starts.}\par
01014   {\cf17 virtual} {\cf18 void} OnTestStart({\cf17 const} TestInfo& test_info) = 0;\par
01015 \par
01016   {\cf20 // Fired after a failed assertion or a SUCCEED() invocation.}\par
01017   {\cf17 virtual} {\cf18 void} OnTestPartResult({\cf17 const} TestPartResult& test_part_result) = 0;\par
01018 \par
01019   {\cf20 // Fired after the test ends.}\par
01020   {\cf17 virtual} {\cf18 void} OnTestEnd({\cf17 const} TestInfo& test_info) = 0;\par
01021 \par
01022   {\cf20 // Fired after the test case ends.}\par
01023   {\cf17 virtual} {\cf18 void} OnTestCaseEnd({\cf17 const} TestCase& test_case) = 0;\par
01024 \par
01025   {\cf20 // Fired before environment tear-down for each iteration of tests starts.}\par
01026   {\cf17 virtual} {\cf18 void} OnEnvironmentsTearDownStart({\cf17 const} UnitTest& unit_test) = 0;\par
01027 \par
01028   {\cf20 // Fired after environment tear-down for each iteration of tests ends.}\par
01029   {\cf17 virtual} {\cf18 void} OnEnvironmentsTearDownEnd({\cf17 const} UnitTest& unit_test) = 0;\par
01030 \par
01031   {\cf20 // Fired after each iteration of tests finishes.}\par
01032   {\cf17 virtual} {\cf18 void} OnTestIterationEnd({\cf17 const} UnitTest& unit_test,\par
01033                                   {\cf18 int} iteration) = 0;\par
01034 \par
01035   {\cf20 // Fired after all test activities have ended.}\par
01036   {\cf17 virtual} {\cf18 void} OnTestProgramEnd({\cf17 const} UnitTest& unit_test) = 0;\par
01037 \};\par
01038 \par
01039 {\cf20 // The convenience class for users who need to override just one or two}\par
01040 {\cf20 // methods and are not concerned that a possible change to a signature of}\par
01041 {\cf20 // the methods they override will not be caught during the build.  For}\par
01042 {\cf20 // comments about each method please see the definition of TestEventListener}\par
01043 {\cf20 // above.}\par
01044 {\cf17 class }EmptyTestEventListener : {\cf17 public} TestEventListener \{\par
01045  {\cf17 public}:\par
01046   {\cf17 virtual} {\cf18 void} OnTestProgramStart({\cf17 const} UnitTest& {\cf20 /*unit_test*/}) \{\}\par
01047   {\cf17 virtual} {\cf18 void} OnTestIterationStart({\cf17 const} UnitTest& {\cf20 /*unit_test*/},\par
01048                                     {\cf18 int} {\cf20 /*iteration*/}) \{\}\par
01049   {\cf17 virtual} {\cf18 void} OnEnvironmentsSetUpStart({\cf17 const} UnitTest& {\cf20 /*unit_test*/}) \{\}\par
01050   {\cf17 virtual} {\cf18 void} OnEnvironmentsSetUpEnd({\cf17 const} UnitTest& {\cf20 /*unit_test*/}) \{\}\par
01051   {\cf17 virtual} {\cf18 void} OnTestCaseStart({\cf17 const} TestCase& {\cf20 /*test_case*/}) \{\}\par
01052   {\cf17 virtual} {\cf18 void} OnTestStart({\cf17 const} TestInfo& {\cf20 /*test_info*/}) \{\}\par
01053   {\cf17 virtual} {\cf18 void} OnTestPartResult({\cf17 const} TestPartResult& {\cf20 /*test_part_result*/}) \{\}\par
01054   {\cf17 virtual} {\cf18 void} OnTestEnd({\cf17 const} TestInfo& {\cf20 /*test_info*/}) \{\}\par
01055   {\cf17 virtual} {\cf18 void} OnTestCaseEnd({\cf17 const} TestCase& {\cf20 /*test_case*/}) \{\}\par
01056   {\cf17 virtual} {\cf18 void} OnEnvironmentsTearDownStart({\cf17 const} UnitTest& {\cf20 /*unit_test*/}) \{\}\par
01057   {\cf17 virtual} {\cf18 void} OnEnvironmentsTearDownEnd({\cf17 const} UnitTest& {\cf20 /*unit_test*/}) \{\}\par
01058   {\cf17 virtual} {\cf18 void} OnTestIterationEnd({\cf17 const} UnitTest& {\cf20 /*unit_test*/},\par
01059                                   {\cf18 int} {\cf20 /*iteration*/}) \{\}\par
01060   {\cf17 virtual} {\cf18 void} OnTestProgramEnd({\cf17 const} UnitTest& {\cf20 /*unit_test*/}) \{\}\par
01061 \};\par
01062 \par
01063 {\cf20 // TestEventListeners lets users add listeners to track events in Google Test.}\par
01064 {\cf17 class }GTEST_API_ TestEventListeners \{\par
01065  {\cf17 public}:\par
01066   TestEventListeners();\par
01067   ~TestEventListeners();\par
01068 \par
01069   {\cf20 // Appends an event listener to the end of the list. Google Test assumes}\par
01070   {\cf20 // the ownership of the listener (i.e. it will delete the listener when}\par
01071   {\cf20 // the test program finishes).}\par
01072   {\cf18 void} Append(TestEventListener* listener);\par
01073 \par
01074   {\cf20 // Removes the given event listener from the list and returns it.  It then}\par
01075   {\cf20 // becomes the caller's responsibility to delete the listener. Returns}\par
01076   {\cf20 // NULL if the listener is not found in the list.}\par
01077   TestEventListener* Release(TestEventListener* listener);\par
01078 \par
01079   {\cf20 // Returns the standard listener responsible for the default console}\par
01080   {\cf20 // output.  Can be removed from the listeners list to shut down default}\par
01081   {\cf20 // console output.  Note that removing this object from the listener list}\par
01082   {\cf20 // with Release transfers its ownership to the caller and makes this}\par
01083   {\cf20 // function return NULL the next time.}\par
01084   TestEventListener* default_result_printer(){\cf17  const }\{\par
01085     {\cf19 return} default_result_printer_;\par
01086   \}\par
01087 \par
01088   {\cf20 // Returns the standard listener responsible for the default XML output}\par
01089   {\cf20 // controlled by the --gtest_output=xml flag.  Can be removed from the}\par
01090   {\cf20 // listeners list by users who want to shut down the default XML output}\par
01091   {\cf20 // controlled by this flag and substitute it with custom one.  Note that}\par
01092   {\cf20 // removing this object from the listener list with Release transfers its}\par
01093   {\cf20 // ownership to the caller and makes this function return NULL the next}\par
01094   {\cf20 // time.}\par
01095   TestEventListener* default_xml_generator(){\cf17  const }\{\par
01096     {\cf19 return} default_xml_generator_;\par
01097   \}\par
01098 \par
01099  {\cf17 private}:\par
01100   {\cf17 friend} {\cf17 class }TestCase;\par
01101   {\cf17 friend} {\cf17 class }TestInfo;\par
01102   {\cf17 friend} {\cf17 class }internal::DefaultGlobalTestPartResultReporter;\par
01103   {\cf17 friend} {\cf17 class }internal::NoExecDeathTest;\par
01104   {\cf17 friend} {\cf17 class }internal::TestEventListenersAccessor;\par
01105   {\cf17 friend} {\cf17 class }internal::UnitTestImpl;\par
01106 \par
01107   {\cf20 // Returns repeater that broadcasts the TestEventListener events to all}\par
01108   {\cf20 // subscribers.}\par
01109   TestEventListener* repeater();\par
01110 \par
01111   {\cf20 // Sets the default_result_printer attribute to the provided listener.}\par
01112   {\cf20 // The listener is also added to the listener list and previous}\par
01113   {\cf20 // default_result_printer is removed from it and deleted. The listener can}\par
01114   {\cf20 // also be NULL in which case it will not be added to the list. Does}\par
01115   {\cf20 // nothing if the previous and the current listener objects are the same.}\par
01116   {\cf18 void} SetDefaultResultPrinter(TestEventListener* listener);\par
01117 \par
01118   {\cf20 // Sets the default_xml_generator attribute to the provided listener.  The}\par
01119   {\cf20 // listener is also added to the listener list and previous}\par
01120   {\cf20 // default_xml_generator is removed from it and deleted. The listener can}\par
01121   {\cf20 // also be NULL in which case it will not be added to the list. Does}\par
01122   {\cf20 // nothing if the previous and the current listener objects are the same.}\par
01123   {\cf18 void} SetDefaultXmlGenerator(TestEventListener* listener);\par
01124 \par
01125   {\cf20 // Controls whether events will be forwarded by the repeater to the}\par
01126   {\cf20 // listeners in the list.}\par
01127   {\cf18 bool} EventForwardingEnabled() {\cf17 const};\par
01128   {\cf18 void} SuppressEventForwarding();\par
01129 \par
01130   {\cf20 // The actual list of listeners.}\par
01131   internal::TestEventRepeater* repeater_;\par
01132   {\cf20 // Listener responsible for the standard result output.}\par
01133   TestEventListener* default_result_printer_;\par
01134   {\cf20 // Listener responsible for the creation of the XML output file.}\par
01135   TestEventListener* default_xml_generator_;\par
01136 \par
01137   {\cf20 // We disallow copying TestEventListeners.}\par
01138   GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventListeners);\par
01139 \};\par
01140 \par
01141 {\cf20 // A UnitTest consists of a vector of TestCases.}\par
01142 {\cf20 //}\par
01143 {\cf20 // This is a singleton class.  The only instance of UnitTest is}\par
01144 {\cf20 // created when UnitTest::GetInstance() is first called.  This}\par
01145 {\cf20 // instance is never deleted.}\par
01146 {\cf20 //}\par
01147 {\cf20 // UnitTest is not copyable.}\par
01148 {\cf20 //}\par
01149 {\cf20 // This class is thread-safe as long as the methods are called}\par
01150 {\cf20 // according to their specification.}\par
01151 {\cf17 class }GTEST_API_ UnitTest \{\par
01152  {\cf17 public}:\par
01153   {\cf20 // Gets the singleton UnitTest object.  The first time this method}\par
01154   {\cf20 // is called, a UnitTest object is constructed and returned.}\par
01155   {\cf20 // Consecutive calls will return the same object.}\par
01156   {\cf17 static} UnitTest* GetInstance();\par
01157 \par
01158   {\cf20 // Runs all tests in this UnitTest object and prints the result.}\par
01159   {\cf20 // Returns 0 if successful, or 1 otherwise.}\par
01160   {\cf20 //}\par
01161   {\cf20 // This method can only be called from the main thread.}\par
01162   {\cf20 //}\par
01163   {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
01164   {\cf18 int} Run() GTEST_MUST_USE_RESULT_;\par
01165 \par
01166   {\cf20 // Returns the working directory when the first TEST() or TEST_F()}\par
01167   {\cf20 // was executed.  The UnitTest object owns the string.}\par
01168   {\cf17 const} {\cf18 char}* original_working_dir() {\cf17 const};\par
01169 \par
01170   {\cf20 // Returns the TestCase object for the test that's currently running,}\par
01171   {\cf20 // or NULL if no test is running.}\par
01172   {\cf17 const} TestCase* current_test_case() {\cf17 const}\par
01173       GTEST_LOCK_EXCLUDED_(mutex_);\par
01174 \par
01175   {\cf20 // Returns the TestInfo object for the test that's currently running,}\par
01176   {\cf20 // or NULL if no test is running.}\par
01177   {\cf17 const} TestInfo* current_test_info() {\cf17 const}\par
01178       GTEST_LOCK_EXCLUDED_(mutex_);\par
01179 \par
01180   {\cf20 // Returns the random seed used at the start of the current test run.}\par
01181   {\cf18 int} random_seed() {\cf17 const};\par
01182 \par
01183 {\cf21 #if GTEST_HAS_PARAM_TEST}\par
01184   {\cf20 // Returns the ParameterizedTestCaseRegistry object used to keep track of}\par
01185   {\cf20 // value-parameterized tests and instantiate and register them.}\par
01186   {\cf20 //}\par
01187   {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
01188   internal::ParameterizedTestCaseRegistry& parameterized_test_registry()\par
01189       GTEST_LOCK_EXCLUDED_(mutex_);\par
01190 {\cf21 #endif  }{\cf20 // GTEST_HAS_PARAM_TEST}\par
01191 \par
01192   {\cf20 // Gets the number of successful test cases.}\par
01193   {\cf18 int} successful_test_case_count() {\cf17 const};\par
01194 \par
01195   {\cf20 // Gets the number of failed test cases.}\par
01196   {\cf18 int} failed_test_case_count() {\cf17 const};\par
01197 \par
01198   {\cf20 // Gets the number of all test cases.}\par
01199   {\cf18 int} total_test_case_count() {\cf17 const};\par
01200 \par
01201   {\cf20 // Gets the number of all test cases that contain at least one test}\par
01202   {\cf20 // that should run.}\par
01203   {\cf18 int} test_case_to_run_count() {\cf17 const};\par
01204 \par
01205   {\cf20 // Gets the number of successful tests.}\par
01206   {\cf18 int} successful_test_count() {\cf17 const};\par
01207 \par
01208   {\cf20 // Gets the number of failed tests.}\par
01209   {\cf18 int} failed_test_count() {\cf17 const};\par
01210 \par
01211   {\cf20 // Gets the number of disabled tests that will be reported in the XML report.}\par
01212   {\cf18 int} reportable_disabled_test_count() {\cf17 const};\par
01213 \par
01214   {\cf20 // Gets the number of disabled tests.}\par
01215   {\cf18 int} disabled_test_count() {\cf17 const};\par
01216 \par
01217   {\cf20 // Gets the number of tests to be printed in the XML report.}\par
01218   {\cf18 int} reportable_test_count() {\cf17 const};\par
01219 \par
01220   {\cf20 // Gets the number of all tests.}\par
01221   {\cf18 int} total_test_count() {\cf17 const};\par
01222 \par
01223   {\cf20 // Gets the number of tests that should run.}\par
01224   {\cf18 int} test_to_run_count() {\cf17 const};\par
01225 \par
01226   {\cf20 // Gets the time of the test program start, in ms from the start of the}\par
01227   {\cf20 // UNIX epoch.}\par
01228   TimeInMillis start_timestamp() {\cf17 const};\par
01229 \par
01230   {\cf20 // Gets the elapsed time, in milliseconds.}\par
01231   TimeInMillis elapsed_time() {\cf17 const};\par
01232 \par
01233   {\cf20 // Returns true iff the unit test passed (i.e. all test cases passed).}\par
01234   {\cf18 bool} Passed() {\cf17 const};\par
01235 \par
01236   {\cf20 // Returns true iff the unit test failed (i.e. some test case failed}\par
01237   {\cf20 // or something outside of all tests failed).}\par
01238   {\cf18 bool} Failed() {\cf17 const};\par
01239 \par
01240   {\cf20 // Gets the i-th test case among all the test cases. i can range from 0 to}\par
01241   {\cf20 // total_test_case_count() - 1. If i is not in that range, returns NULL.}\par
01242   {\cf17 const} TestCase* GetTestCase({\cf18 int} i) {\cf17 const};\par
01243 \par
01244   {\cf20 // Returns the TestResult containing information on test failures and}\par
01245   {\cf20 // properties logged outside of individual test cases.}\par
01246   {\cf17 const} TestResult& ad_hoc_test_result() {\cf17 const};\par
01247 \par
01248   {\cf20 // Returns the list of event listeners that can be used to track events}\par
01249   {\cf20 // inside Google Test.}\par
01250   TestEventListeners& listeners();\par
01251 \par
01252  {\cf17 private}:\par
01253   {\cf20 // Registers and returns a global test environment.  When a test}\par
01254   {\cf20 // program is run, all global test environments will be set-up in}\par
01255   {\cf20 // the order they were registered.  After all tests in the program}\par
01256   {\cf20 // have finished, all global test environments will be torn-down in}\par
01257   {\cf20 // the *reverse* order they were registered.}\par
01258   {\cf20 //}\par
01259   {\cf20 // The UnitTest object takes ownership of the given environment.}\par
01260   {\cf20 //}\par
01261   {\cf20 // This method can only be called from the main thread.}\par
01262   Environment* AddEnvironment(Environment* env);\par
01263 \par
01264   {\cf20 // Adds a TestPartResult to the current TestResult object.  All}\par
01265   {\cf20 // Google Test assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc)}\par
01266   {\cf20 // eventually call this to report their results.  The user code}\par
01267   {\cf20 // should use the assertion macros instead of calling this directly.}\par
01268   {\cf18 void} AddTestPartResult(TestPartResult::Type result_type,\par
01269                          {\cf17 const} {\cf18 char}* file_name,\par
01270                          {\cf18 int} line_number,\par
01271                          {\cf17 const} std::string& message,\par
01272                          {\cf17 const} std::string& os_stack_trace)\par
01273       GTEST_LOCK_EXCLUDED_(mutex_);\par
01274 \par
01275   {\cf20 // Adds a TestProperty to the current TestResult object when invoked from}\par
01276   {\cf20 // inside a test, to current TestCase's ad_hoc_test_result_ when invoked}\par
01277   {\cf20 // from SetUpTestCase or TearDownTestCase, or to the global property set}\par
01278   {\cf20 // when invoked elsewhere.  If the result already contains a property with}\par
01279   {\cf20 // the same key, the value will be updated.}\par
01280   {\cf18 void} RecordProperty({\cf17 const} std::string& key, {\cf17 const} std::string& value);\par
01281 \par
01282   {\cf20 // Gets the i-th test case among all the test cases. i can range from 0 to}\par
01283   {\cf20 // total_test_case_count() - 1. If i is not in that range, returns NULL.}\par
01284   TestCase* GetMutableTestCase({\cf18 int} i);\par
01285 \par
01286   {\cf20 // Accessors for the implementation object.}\par
01287   internal::UnitTestImpl* impl() \{ {\cf19 return} impl_; \}\par
01288   {\cf17 const} internal::UnitTestImpl* impl(){\cf17  const }\{ {\cf19 return} impl_; \}\par
01289 \par
01290   {\cf20 // These classes and functions are friends as they need to access private}\par
01291   {\cf20 // members of UnitTest.}\par
01292   {\cf17 friend} {\cf17 class }Test;\par
01293   {\cf17 friend} {\cf17 class }internal::AssertHelper;\par
01294   {\cf17 friend} {\cf17 class }internal::ScopedTrace;\par
01295   {\cf17 friend} {\cf17 class }internal::StreamingListenerTest;\par
01296   {\cf17 friend} {\cf17 class }internal::UnitTestRecordPropertyTestHelper;\par
01297   {\cf17 friend} Environment* AddGlobalTestEnvironment(Environment* env);\par
01298   {\cf17 friend} internal::UnitTestImpl* internal::GetUnitTestImpl();\par
01299   {\cf17 friend} {\cf18 void} internal::ReportFailureInUnknownLocation(\par
01300       TestPartResult::Type result_type,\par
01301       {\cf17 const} std::string& message);\par
01302 \par
01303   {\cf20 // Creates an empty UnitTest.}\par
01304   UnitTest();\par
01305 \par
01306   {\cf20 // D'tor}\par
01307   {\cf17 virtual} ~UnitTest();\par
01308 \par
01309   {\cf20 // Pushes a trace defined by SCOPED_TRACE() on to the per-thread}\par
01310   {\cf20 // Google Test trace stack.}\par
01311   {\cf18 void} PushGTestTrace({\cf17 const} internal::TraceInfo& trace)\par
01312       GTEST_LOCK_EXCLUDED_(mutex_);\par
01313 \par
01314   {\cf20 // Pops a trace from the per-thread Google Test trace stack.}\par
01315   {\cf18 void} PopGTestTrace()\par
01316       GTEST_LOCK_EXCLUDED_(mutex_);\par
01317 \par
01318   {\cf20 // Protects mutable state in *impl_.  This is mutable as some const}\par
01319   {\cf20 // methods need to lock it too.}\par
01320   mutable internal::Mutex mutex_;\par
01321 \par
01322   {\cf20 // Opaque implementation object.  This field is never changed once}\par
01323   {\cf20 // the object is constructed.  We don't mark it as const here, as}\par
01324   {\cf20 // doing so will cause a warning in the constructor of UnitTest.}\par
01325   {\cf20 // Mutable state in *impl_ is protected by mutex_.}\par
01326   internal::UnitTestImpl* impl_;\par
01327 \par
01328   {\cf20 // We disallow copying UnitTest.}\par
01329   GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTest);\par
01330 \};\par
01331 \par
01332 {\cf20 // A convenient wrapper for adding an environment for the test}\par
01333 {\cf20 // program.}\par
01334 {\cf20 //}\par
01335 {\cf20 // You should call this before RUN_ALL_TESTS() is called, probably in}\par
01336 {\cf20 // main().  If you use gtest_main, you need to call this before main()}\par
01337 {\cf20 // starts for it to take effect.  For example, you can define a global}\par
01338 {\cf20 // variable like this:}\par
01339 {\cf20 //}\par
01340 {\cf20 //   testing::Environment* const foo_env =}\par
01341 {\cf20 //       testing::AddGlobalTestEnvironment(new FooEnvironment);}\par
01342 {\cf20 //}\par
01343 {\cf20 // However, we strongly recommend you to write your own main() and}\par
01344 {\cf20 // call AddGlobalTestEnvironment() there, as relying on initialization}\par
01345 {\cf20 // of global variables makes the code harder to read and may cause}\par
01346 {\cf20 // problems when you register multiple environments from different}\par
01347 {\cf20 // translation units and the environments have dependencies among them}\par
01348 {\cf20 // (remember that the compiler doesn't guarantee the order in which}\par
01349 {\cf20 // global variables from different translation units are initialized).}\par
01350 inline Environment* AddGlobalTestEnvironment(Environment* env) \{\par
01351   {\cf19 return} UnitTest::GetInstance()->AddEnvironment(env);\par
01352 \}\par
01353 \par
01354 {\cf20 // Initializes Google Test.  This must be called before calling}\par
01355 {\cf20 // RUN_ALL_TESTS().  In particular, it parses a command line for the}\par
01356 {\cf20 // flags that Google Test recognizes.  Whenever a Google Test flag is}\par
01357 {\cf20 // seen, it is removed from argv, and *argc is decremented.}\par
01358 {\cf20 //}\par
01359 {\cf20 // No value is returned.  Instead, the Google Test flag variables are}\par
01360 {\cf20 // updated.}\par
01361 {\cf20 //}\par
01362 {\cf20 // Calling the function for the second time has no user-visible effect.}\par
01363 GTEST_API_ {\cf18 void} InitGoogleTest({\cf18 int}* argc, {\cf18 char}** argv);\par
01364 \par
01365 {\cf20 // This overloaded version can be used in Windows programs compiled in}\par
01366 {\cf20 // UNICODE mode.}\par
01367 GTEST_API_ {\cf18 void} InitGoogleTest({\cf18 int}* argc, {\cf18 wchar_t}** argv);\par
01368 \par
01369 {\cf17 namespace }internal \{\par
01370 \par
01371 {\cf20 // Separate the error generating code from the code path to reduce the stack}\par
01372 {\cf20 // frame size of CmpHelperEQ. This helps reduce the overhead of some sanitizers}\par
01373 {\cf20 // when calling EXPECT_* in a tight loop.}\par
01374 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
01375 AssertionResult CmpHelperEQFailure({\cf17 const} {\cf18 char}* lhs_expression,\par
01376                                    {\cf17 const} {\cf18 char}* rhs_expression,\par
01377                                    {\cf17 const} T1& lhs, {\cf17 const} T2& rhs) \{\par
01378   {\cf19 return} EqFailure(lhs_expression,\par
01379                    rhs_expression,\par
01380                    FormatForComparisonFailureMessage(lhs, rhs),\par
01381                    FormatForComparisonFailureMessage(rhs, lhs),\par
01382                    {\cf17 false});\par
01383 \}\par
01384 \par
01385 {\cf20 // The helper function for \{ASSERT|EXPECT\}_EQ.}\par
01386 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
01387 AssertionResult CmpHelperEQ({\cf17 const} {\cf18 char}* lhs_expression,\par
01388                             {\cf17 const} {\cf18 char}* rhs_expression,\par
01389                             {\cf17 const} T1& lhs,\par
01390                             {\cf17 const} T2& rhs) \{\par
01391 GTEST_DISABLE_MSC_WARNINGS_PUSH_(4389 {\cf20 /* signed/unsigned mismatch */})\par
01392   {\cf19 if} (lhs == rhs) \{\par
01393     {\cf19 return} AssertionSuccess();\par
01394   \}\par
01395 GTEST_DISABLE_MSC_WARNINGS_POP_()\par
01396 \par
01397   {\cf19 return} CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);\par
01398 \}\par
01399 \par
01400 {\cf20 // With this overloaded version, we allow anonymous enums to be used}\par
01401 {\cf20 // in \{ASSERT|EXPECT\}_EQ when compiled with gcc 4, as anonymous enums}\par
01402 {\cf20 // can be implicitly cast to BiggestInt.}\par
01403 GTEST_API_ AssertionResult CmpHelperEQ({\cf17 const} {\cf18 char}* lhs_expression,\par
01404                                        {\cf17 const} {\cf18 char}* rhs_expression,\par
01405                                        BiggestInt lhs,\par
01406                                        BiggestInt rhs);\par
01407 \par
01408 {\cf20 // The helper class for \{ASSERT|EXPECT\}_EQ.  The template argument}\par
01409 {\cf20 // lhs_is_null_literal is true iff the first argument to ASSERT_EQ()}\par
01410 {\cf20 // is a null pointer literal.  The following default implementation is}\par
01411 {\cf20 // for lhs_is_null_literal being false.}\par
01412 {\cf17 template} <{\cf18 bool} lhs_is_null_literal>\par
01413 {\cf17 class }EqHelper \{\par
01414  {\cf17 public}:\par
01415   {\cf20 // This templatized version is for the general case.}\par
01416   {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
01417   {\cf17 static} AssertionResult Compare({\cf17 const} {\cf18 char}* lhs_expression,\par
01418                                  {\cf17 const} {\cf18 char}* rhs_expression,\par
01419                                  {\cf17 const} T1& lhs,\par
01420                                  {\cf17 const} T2& rhs) \{\par
01421     {\cf19 return} CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\par
01422   \}\par
01423 \par
01424   {\cf20 // With this overloaded version, we allow anonymous enums to be used}\par
01425   {\cf20 // in \{ASSERT|EXPECT\}_EQ when compiled with gcc 4, as anonymous}\par
01426   {\cf20 // enums can be implicitly cast to BiggestInt.}\par
01427   {\cf20 //}\par
01428   {\cf20 // Even though its body looks the same as the above version, we}\par
01429   {\cf20 // cannot merge the two, as it will make anonymous enums unhappy.}\par
01430   {\cf17 static} AssertionResult Compare({\cf17 const} {\cf18 char}* lhs_expression,\par
01431                                  {\cf17 const} {\cf18 char}* rhs_expression,\par
01432                                  BiggestInt lhs,\par
01433                                  BiggestInt rhs) \{\par
01434     {\cf19 return} CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\par
01435   \}\par
01436 \};\par
01437 \par
01438 {\cf20 // This specialization is used when the first argument to ASSERT_EQ()}\par
01439 {\cf20 // is a null pointer literal, like NULL, false, or 0.}\par
01440 {\cf17 template} <>\par
01441 {\cf17 class }EqHelper<true> \{\par
01442  {\cf17 public}:\par
01443   {\cf20 // We define two overloaded versions of Compare().  The first}\par
01444   {\cf20 // version will be picked when the second argument to ASSERT_EQ() is}\par
01445   {\cf20 // NOT a pointer, e.g. ASSERT_EQ(0, AnIntFunction()) or}\par
01446   {\cf20 // EXPECT_EQ(false, a_bool).}\par
01447   {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
01448   {\cf17 static} AssertionResult Compare(\par
01449       {\cf17 const} {\cf18 char}* lhs_expression,\par
01450       {\cf17 const} {\cf18 char}* rhs_expression,\par
01451       {\cf17 const} T1& lhs,\par
01452       {\cf17 const} T2& rhs,\par
01453       {\cf20 // The following line prevents this overload from being considered if T2}\par
01454       {\cf20 // is not a pointer type.  We need this because ASSERT_EQ(NULL, my_ptr)}\par
01455       {\cf20 // expands to Compare("", "", NULL, my_ptr), which requires a conversion}\par
01456       {\cf20 // to match the Secret* in the other overload, which would otherwise make}\par
01457       {\cf20 // this template match better.}\par
01458       {\cf17 typename} EnableIf<!is_pointer<T2>::value>::type* = 0) \{\par
01459     {\cf19 return} CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\par
01460   \}\par
01461 \par
01462   {\cf20 // This version will be picked when the second argument to ASSERT_EQ() is a}\par
01463   {\cf20 // pointer, e.g. ASSERT_EQ(NULL, a_pointer).}\par
01464   {\cf17 template} <{\cf17 typename} T>\par
01465   {\cf17 static} AssertionResult Compare(\par
01466       {\cf17 const} {\cf18 char}* lhs_expression,\par
01467       {\cf17 const} {\cf18 char}* rhs_expression,\par
01468       {\cf20 // We used to have a second template parameter instead of Secret*.  That}\par
01469       {\cf20 // template parameter would deduce to 'long', making this a better match}\par
01470       {\cf20 // than the first overload even without the first overload's EnableIf.}\par
01471       {\cf20 // Unfortunately, gcc with -Wconversion-null warns when "passing NULL to}\par
01472       {\cf20 // non-pointer argument" (even a deduced integral argument), so the old}\par
01473       {\cf20 // implementation caused warnings in user code.}\par
01474       Secret* {\cf20 /* lhs (NULL) */},\par
01475       T* rhs) \{\par
01476     {\cf20 // We already know that 'lhs' is a null pointer.}\par
01477     {\cf19 return} CmpHelperEQ(lhs_expression, rhs_expression,\par
01478                        {\cf17 static_cast<}T*{\cf17 >}(NULL), rhs);\par
01479   \}\par
01480 \};\par
01481 \par
01482 {\cf20 // Separate the error generating code from the code path to reduce the stack}\par
01483 {\cf20 // frame size of CmpHelperOP. This helps reduce the overhead of some sanitizers}\par
01484 {\cf20 // when calling EXPECT_OP in a tight loop.}\par
01485 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
01486 AssertionResult CmpHelperOpFailure({\cf17 const} {\cf18 char}* expr1, {\cf17 const} {\cf18 char}* expr2,\par
01487                                    {\cf17 const} T1& val1, {\cf17 const} T2& val2,\par
01488                                    {\cf17 const} {\cf18 char}* op) \{\par
01489   {\cf19 return} AssertionFailure()\par
01490          << {\cf22 "Expected: ("} << expr1 << {\cf22 ") "} << op << {\cf22 " ("} << expr2\par
01491          << {\cf22 "), actual: "} << FormatForComparisonFailureMessage(val1, val2)\par
01492          << {\cf22 " vs "} << FormatForComparisonFailureMessage(val2, val1);\par
01493 \}\par
01494 \par
01495 {\cf20 // A macro for implementing the helper functions needed to implement}\par
01496 {\cf20 // ASSERT_?? and EXPECT_??.  It is here just to avoid copy-and-paste}\par
01497 {\cf20 // of similar code.}\par
01498 {\cf20 //}\par
01499 {\cf20 // For each templatized helper function, we also define an overloaded}\par
01500 {\cf20 // version for BiggestInt in order to reduce code bloat and allow}\par
01501 {\cf20 // anonymous enums to be used with \{ASSERT|EXPECT\}_?? when compiled}\par
01502 {\cf20 // with gcc 4.}\par
01503 {\cf20 //}\par
01504 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
01505 \par
01506 {\cf21 #define GTEST_IMPL_CMP_HELPER_(op_name, op)\\}\par
01507 {\cf21 template <typename T1, typename T2>\\}\par
01508 {\cf21 AssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \\}\par
01509 {\cf21                                    const T1& val1, const T2& val2) \{\\}\par
01510 {\cf21   if (val1 op val2) \{\\}\par
01511 {\cf21     return AssertionSuccess();\\}\par
01512 {\cf21   \} else \{\\}\par
01513 {\cf21     return CmpHelperOpFailure(expr1, expr2, val1, val2, #op);\\}\par
01514 {\cf21   \}\\}\par
01515 {\cf21 \}\\}\par
01516 {\cf21 GTEST_API_ AssertionResult CmpHelper##op_name(\\}\par
01517 {\cf21     const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2)}\par
01518 \par
01519 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
01520 \par
01521 {\cf20 // Implements the helper function for \{ASSERT|EXPECT\}_NE}\par
01522 GTEST_IMPL_CMP_HELPER_(NE, !=);\par
01523 {\cf20 // Implements the helper function for \{ASSERT|EXPECT\}_LE}\par
01524 GTEST_IMPL_CMP_HELPER_(LE, <=);\par
01525 {\cf20 // Implements the helper function for \{ASSERT|EXPECT\}_LT}\par
01526 GTEST_IMPL_CMP_HELPER_(LT, <);\par
01527 {\cf20 // Implements the helper function for \{ASSERT|EXPECT\}_GE}\par
01528 GTEST_IMPL_CMP_HELPER_(GE, >=);\par
01529 {\cf20 // Implements the helper function for \{ASSERT|EXPECT\}_GT}\par
01530 GTEST_IMPL_CMP_HELPER_(GT, >);\par
01531 \par
01532 {\cf21 #undef GTEST_IMPL_CMP_HELPER_}\par
01533 \par
01534 {\cf20 // The helper function for \{ASSERT|EXPECT\}_STREQ.}\par
01535 {\cf20 //}\par
01536 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
01537 GTEST_API_ AssertionResult CmpHelperSTREQ({\cf17 const} {\cf18 char}* s1_expression,\par
01538                                           {\cf17 const} {\cf18 char}* s2_expression,\par
01539                                           {\cf17 const} {\cf18 char}* s1,\par
01540                                           {\cf17 const} {\cf18 char}* s2);\par
01541 \par
01542 {\cf20 // The helper function for \{ASSERT|EXPECT\}_STRCASEEQ.}\par
01543 {\cf20 //}\par
01544 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
01545 GTEST_API_ AssertionResult CmpHelperSTRCASEEQ({\cf17 const} {\cf18 char}* s1_expression,\par
01546                                               {\cf17 const} {\cf18 char}* s2_expression,\par
01547                                               {\cf17 const} {\cf18 char}* s1,\par
01548                                               {\cf17 const} {\cf18 char}* s2);\par
01549 \par
01550 {\cf20 // The helper function for \{ASSERT|EXPECT\}_STRNE.}\par
01551 {\cf20 //}\par
01552 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
01553 GTEST_API_ AssertionResult CmpHelperSTRNE({\cf17 const} {\cf18 char}* s1_expression,\par
01554                                           {\cf17 const} {\cf18 char}* s2_expression,\par
01555                                           {\cf17 const} {\cf18 char}* s1,\par
01556                                           {\cf17 const} {\cf18 char}* s2);\par
01557 \par
01558 {\cf20 // The helper function for \{ASSERT|EXPECT\}_STRCASENE.}\par
01559 {\cf20 //}\par
01560 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
01561 GTEST_API_ AssertionResult CmpHelperSTRCASENE({\cf17 const} {\cf18 char}* s1_expression,\par
01562                                               {\cf17 const} {\cf18 char}* s2_expression,\par
01563                                               {\cf17 const} {\cf18 char}* s1,\par
01564                                               {\cf17 const} {\cf18 char}* s2);\par
01565 \par
01566 \par
01567 {\cf20 // Helper function for *_STREQ on wide strings.}\par
01568 {\cf20 //}\par
01569 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
01570 GTEST_API_ AssertionResult CmpHelperSTREQ({\cf17 const} {\cf18 char}* s1_expression,\par
01571                                           {\cf17 const} {\cf18 char}* s2_expression,\par
01572                                           {\cf17 const} {\cf18 wchar_t}* s1,\par
01573                                           {\cf17 const} {\cf18 wchar_t}* s2);\par
01574 \par
01575 {\cf20 // Helper function for *_STRNE on wide strings.}\par
01576 {\cf20 //}\par
01577 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
01578 GTEST_API_ AssertionResult CmpHelperSTRNE({\cf17 const} {\cf18 char}* s1_expression,\par
01579                                           {\cf17 const} {\cf18 char}* s2_expression,\par
01580                                           {\cf17 const} {\cf18 wchar_t}* s1,\par
01581                                           {\cf17 const} {\cf18 wchar_t}* s2);\par
01582 \par
01583 \}  {\cf20 // namespace internal}\par
01584 \par
01585 {\cf20 // IsSubstring() and IsNotSubstring() are intended to be used as the}\par
01586 {\cf20 // first argument to \{EXPECT,ASSERT\}_PRED_FORMAT2(), not by}\par
01587 {\cf20 // themselves.  They check whether needle is a substring of haystack}\par
01588 {\cf20 // (NULL is considered a substring of itself only), and return an}\par
01589 {\cf20 // appropriate error message when they fail.}\par
01590 {\cf20 //}\par
01591 {\cf20 // The \{needle,haystack\}_expr arguments are the stringified}\par
01592 {\cf20 // expressions that generated the two real arguments.}\par
01593 GTEST_API_ AssertionResult IsSubstring(\par
01594     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01595     {\cf17 const} {\cf18 char}* needle, {\cf17 const} {\cf18 char}* haystack);\par
01596 GTEST_API_ AssertionResult IsSubstring(\par
01597     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01598     {\cf17 const} {\cf18 wchar_t}* needle, {\cf17 const} {\cf18 wchar_t}* haystack);\par
01599 GTEST_API_ AssertionResult IsNotSubstring(\par
01600     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01601     {\cf17 const} {\cf18 char}* needle, {\cf17 const} {\cf18 char}* haystack);\par
01602 GTEST_API_ AssertionResult IsNotSubstring(\par
01603     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01604     {\cf17 const} {\cf18 wchar_t}* needle, {\cf17 const} {\cf18 wchar_t}* haystack);\par
01605 GTEST_API_ AssertionResult IsSubstring(\par
01606     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01607     const ::std::string& needle, const ::std::string& haystack);\par
01608 GTEST_API_ AssertionResult IsNotSubstring(\par
01609     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01610     const ::std::string& needle, const ::std::string& haystack);\par
01611 \par
01612 {\cf21 #if GTEST_HAS_STD_WSTRING}\par
01613 GTEST_API_ AssertionResult IsSubstring(\par
01614     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01615     const ::std::wstring& needle, const ::std::wstring& haystack);\par
01616 GTEST_API_ AssertionResult IsNotSubstring(\par
01617     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01618     const ::std::wstring& needle, const ::std::wstring& haystack);\par
01619 {\cf21 #endif  }{\cf20 // GTEST_HAS_STD_WSTRING}\par
01620 \par
01621 {\cf17 namespace }internal \{\par
01622 \par
01623 {\cf20 // Helper template function for comparing floating-points.}\par
01624 {\cf20 //}\par
01625 {\cf20 // Template parameter:}\par
01626 {\cf20 //}\par
01627 {\cf20 //   RawType: the raw floating-point type (either float or double)}\par
01628 {\cf20 //}\par
01629 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
01630 {\cf17 template} <{\cf17 typename} RawType>\par
01631 AssertionResult CmpHelperFloatingPointEQ({\cf17 const} {\cf18 char}* lhs_expression,\par
01632                                          {\cf17 const} {\cf18 char}* rhs_expression,\par
01633                                          RawType lhs_value,\par
01634                                          RawType rhs_value) \{\par
01635   {\cf17 const} FloatingPoint<RawType> lhs(lhs_value), rhs(rhs_value);\par
01636 \par
01637   {\cf19 if} (lhs.AlmostEquals(rhs)) \{\par
01638     {\cf19 return} AssertionSuccess();\par
01639   \}\par
01640 \par
01641   ::std::stringstream lhs_ss;\par
01642   lhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\par
01643          << lhs_value;\par
01644 \par
01645   ::std::stringstream rhs_ss;\par
01646   rhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\par
01647          << rhs_value;\par
01648 \par
01649   {\cf19 return} EqFailure(lhs_expression,\par
01650                    rhs_expression,\par
01651                    StringStreamToString(&lhs_ss),\par
01652                    StringStreamToString(&rhs_ss),\par
01653                    {\cf17 false});\par
01654 \}\par
01655 \par
01656 {\cf20 // Helper function for implementing ASSERT_NEAR.}\par
01657 {\cf20 //}\par
01658 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.}\par
01659 GTEST_API_ AssertionResult DoubleNearPredFormat({\cf17 const} {\cf18 char}* expr1,\par
01660                                                 {\cf17 const} {\cf18 char}* expr2,\par
01661                                                 {\cf17 const} {\cf18 char}* abs_error_expr,\par
01662                                                 {\cf18 double} val1,\par
01663                                                 {\cf18 double} val2,\par
01664                                                 {\cf18 double} abs_error);\par
01665 \par
01666 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
01667 {\cf20 // A class that enables one to stream messages to assertion macros}\par
01668 {\cf17 class }GTEST_API_ AssertHelper \{\par
01669  {\cf17 public}:\par
01670   {\cf20 // Constructor.}\par
01671   AssertHelper(TestPartResult::Type type,\par
01672                {\cf17 const} {\cf18 char}* file,\par
01673                {\cf18 int} line,\par
01674                {\cf17 const} {\cf18 char}* message);\par
01675   ~AssertHelper();\par
01676 \par
01677   {\cf20 // Message assignment is a semantic trick to enable assertion}\par
01678   {\cf20 // streaming; see the GTEST_MESSAGE_ macro below.}\par
01679   {\cf18 void} operator=({\cf17 const} Message& message) {\cf17 const};\par
01680 \par
01681  {\cf17 private}:\par
01682   {\cf20 // We put our data in a struct so that the size of the AssertHelper class can}\par
01683   {\cf20 // be as small as possible.  This is important because gcc is incapable of}\par
01684   {\cf20 // re-using stack space even for temporary variables, so every EXPECT_EQ}\par
01685   {\cf20 // reserves stack space for another AssertHelper.}\par
01686   {\cf17 struct }AssertHelperData \{\par
01687     AssertHelperData(TestPartResult::Type t,\par
01688                      {\cf17 const} {\cf18 char}* srcfile,\par
01689                      {\cf18 int} line_num,\par
01690                      {\cf17 const} {\cf18 char}* msg)\par
01691         : type(t), file(srcfile), line(line_num), message(msg) \{ \}\par
01692 \par
01693     TestPartResult::Type {\cf17 const} type;\par
01694     {\cf17 const} {\cf18 char}* {\cf17 const} file;\par
01695     {\cf18 int} {\cf17 const} line;\par
01696     std::string {\cf17 const} message;\par
01697 \par
01698    {\cf17 private}:\par
01699     GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelperData);\par
01700   \};\par
01701 \par
01702   AssertHelperData* {\cf17 const} data_;\par
01703 \par
01704   GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelper);\par
01705 \};\par
01706 \par
01707 \}  {\cf20 // namespace internal}\par
01708 \par
01709 {\cf21 #if GTEST_HAS_PARAM_TEST}\par
01710 {\cf20 // The pure interface class that all value-parameterized tests inherit from.}\par
01711 {\cf20 // A value-parameterized class must inherit from both ::testing::Test and}\par
01712 {\cf20 // ::testing::WithParamInterface. In most cases that just means inheriting}\par
01713 {\cf20 // from ::testing::TestWithParam, but more complicated test hierarchies}\par
01714 {\cf20 // may need to inherit from Test and WithParamInterface at different levels.}\par
01715 {\cf20 //}\par
01716 {\cf20 // This interface has support for accessing the test parameter value via}\par
01717 {\cf20 // the GetParam() method.}\par
01718 {\cf20 //}\par
01719 {\cf20 // Use it with one of the parameter generator defining functions, like Range(),}\par
01720 {\cf20 // Values(), ValuesIn(), Bool(), and Combine().}\par
01721 {\cf20 //}\par
01722 {\cf20 // class FooTest : public ::testing::TestWithParam<int> \{}\par
01723 {\cf20 //  protected:}\par
01724 {\cf20 //   FooTest() \{}\par
01725 {\cf20 //     // Can use GetParam() here.}\par
01726 {\cf20 //   \}}\par
01727 {\cf20 //   virtual ~FooTest() \{}\par
01728 {\cf20 //     // Can use GetParam() here.}\par
01729 {\cf20 //   \}}\par
01730 {\cf20 //   virtual void SetUp() \{}\par
01731 {\cf20 //     // Can use GetParam() here.}\par
01732 {\cf20 //   \}}\par
01733 {\cf20 //   virtual void TearDown \{}\par
01734 {\cf20 //     // Can use GetParam() here.}\par
01735 {\cf20 //   \}}\par
01736 {\cf20 // \};}\par
01737 {\cf20 // TEST_P(FooTest, DoesBar) \{}\par
01738 {\cf20 //   // Can use GetParam() method here.}\par
01739 {\cf20 //   Foo foo;}\par
01740 {\cf20 //   ASSERT_TRUE(foo.DoesBar(GetParam()));}\par
01741 {\cf20 // \}}\par
01742 {\cf20 // INSTANTIATE_TEST_CASE_P(OneToTenRange, FooTest, ::testing::Range(1, 10));}\par
01743 \par
01744 {\cf17 template} <{\cf17 typename} T>\par
01745 {\cf17 class }WithParamInterface \{\par
01746  {\cf17 public}:\par
01747   {\cf17 typedef} T ParamType;\par
01748   {\cf17 virtual} ~WithParamInterface() \{\}\par
01749 \par
01750   {\cf20 // The current parameter value. Is also available in the test fixture's}\par
01751   {\cf20 // constructor. This member function is non-static, even though it only}\par
01752   {\cf20 // references static data, to reduce the opportunity for incorrect uses}\par
01753   {\cf20 // like writing 'WithParamInterface<bool>::GetParam()' for a test that}\par
01754   {\cf20 // uses a fixture whose parameter type is int.}\par
01755   {\cf17 const} ParamType& GetParam(){\cf17  const }\{\par
01756     GTEST_CHECK_(parameter_ != NULL)\par
01757         << {\cf22 "GetParam() can only be called inside a value-parameterized test "}\par
01758         << {\cf22 "-- did you intend to write TEST_P instead of TEST_F?"};\par
01759     {\cf19 return} *parameter_;\par
01760   \}\par
01761 \par
01762  {\cf17 private}:\par
01763   {\cf20 // Sets parameter value. The caller is responsible for making sure the value}\par
01764   {\cf20 // remains alive and unchanged throughout the current test.}\par
01765   {\cf17 static} {\cf18 void} SetParam({\cf17 const} ParamType* parameter) \{\par
01766     parameter_ = parameter;\par
01767   \}\par
01768 \par
01769   {\cf20 // Static value used for accessing parameter during a test lifetime.}\par
01770   {\cf17 static} {\cf17 const} ParamType* parameter_;\par
01771 \par
01772   {\cf20 // TestClass must be a subclass of WithParamInterface<T> and Test.}\par
01773   {\cf17 template} <{\cf17 class} TestClass> {\cf17 friend} {\cf17 class }internal::ParameterizedTestFactory;\par
01774 \};\par
01775 \par
01776 {\cf17 template} <{\cf17 typename} T>\par
01777 {\cf17 const} T* WithParamInterface<T>::parameter_ = NULL;\par
01778 \par
01779 {\cf20 // Most value-parameterized classes can ignore the existence of}\par
01780 {\cf20 // WithParamInterface, and can just inherit from ::testing::TestWithParam.}\par
01781 \par
01782 {\cf17 template} <{\cf17 typename} T>\par
01783 {\cf17 class }TestWithParam : {\cf17 public} Test, {\cf17 public} WithParamInterface<T> \{\par
01784 \};\par
01785 \par
01786 {\cf21 #endif  }{\cf20 // GTEST_HAS_PARAM_TEST}\par
01787 \par
01788 {\cf20 // Macros for indicating success/failure in test code.}\par
01789 \par
01790 {\cf20 // ADD_FAILURE unconditionally adds a failure to the current test.}\par
01791 {\cf20 // SUCCEED generates a success - it doesn't automatically make the}\par
01792 {\cf20 // current test successful, as a test is only successful when it has}\par
01793 {\cf20 // no failure.}\par
01794 {\cf20 //}\par
01795 {\cf20 // EXPECT_* verifies that a certain condition is satisfied.  If not,}\par
01796 {\cf20 // it behaves like ADD_FAILURE.  In particular:}\par
01797 {\cf20 //}\par
01798 {\cf20 //   EXPECT_TRUE  verifies that a Boolean condition is true.}\par
01799 {\cf20 //   EXPECT_FALSE verifies that a Boolean condition is false.}\par
01800 {\cf20 //}\par
01801 {\cf20 // FAIL and ASSERT_* are similar to ADD_FAILURE and EXPECT_*, except}\par
01802 {\cf20 // that they will also abort the current function on failure.  People}\par
01803 {\cf20 // usually want the fail-fast behavior of FAIL and ASSERT_*, but those}\par
01804 {\cf20 // writing data-driven tests often find themselves using ADD_FAILURE}\par
01805 {\cf20 // and EXPECT_* more.}\par
01806 \par
01807 {\cf20 // Generates a nonfatal failure with a generic message.}\par
01808 {\cf21 #define ADD_FAILURE() GTEST_NONFATAL_FAILURE_("Failed"})\par
01809 \par
01810 {\cf20 // Generates a nonfatal failure at the given source file location with}\par
01811 {\cf20 // a generic message.}\par
01812 {\cf21 #define ADD_FAILURE_AT(file, line) \\}\par
01813 {\cf21   GTEST_MESSAGE_AT_(file, line, "Failed"}, \\\par
01814                     ::testing::TestPartResult::kNonFatalFailure)\par
01815 \par
01816 {\cf20 // Generates a fatal failure with a generic message.}\par
01817 {\cf21 #define GTEST_FAIL() GTEST_FATAL_FAILURE_("Failed"})\par
01818 \par
01819 {\cf20 // Define this macro to 1 to omit the definition of FAIL(), which is a}\par
01820 {\cf20 // generic name and clashes with some other libraries.}\par
01821 {\cf21 #if !GTEST_DONT_DEFINE_FAIL}\par
01822 {\cf21 # define FAIL() GTEST_FAIL()}\par
01823 {\cf21 #endif}\par
01824 \par
01825 {\cf20 // Generates a success with a generic message.}\par
01826 {\cf21 #define GTEST_SUCCEED() GTEST_SUCCESS_("Succeeded"})\par
01827 \par
01828 {\cf20 // Define this macro to 1 to omit the definition of SUCCEED(), which}\par
01829 {\cf20 // is a generic name and clashes with some other libraries.}\par
01830 {\cf21 #if !GTEST_DONT_DEFINE_SUCCEED}\par
01831 {\cf21 # define SUCCEED() GTEST_SUCCEED()}\par
01832 {\cf21 #endif}\par
01833 \par
01834 {\cf20 // Macros for testing exceptions.}\par
01835 {\cf20 //}\par
01836 {\cf20 //    * \{ASSERT|EXPECT\}_THROW(statement, expected_exception):}\par
01837 {\cf20 //         Tests that the statement throws the expected exception.}\par
01838 {\cf20 //    * \{ASSERT|EXPECT\}_NO_THROW(statement):}\par
01839 {\cf20 //         Tests that the statement doesn't throw any exception.}\par
01840 {\cf20 //    * \{ASSERT|EXPECT\}_ANY_THROW(statement):}\par
01841 {\cf20 //         Tests that the statement throws an exception.}\par
01842 \par
01843 {\cf21 #define EXPECT_THROW(statement, expected_exception) \\}\par
01844 {\cf21   GTEST_TEST_THROW_(statement, expected_exception, GTEST_NONFATAL_FAILURE_)}\par
01845 {\cf21 #define EXPECT_NO_THROW(statement) \\}\par
01846 {\cf21   GTEST_TEST_NO_THROW_(statement, GTEST_NONFATAL_FAILURE_)}\par
01847 {\cf21 #define EXPECT_ANY_THROW(statement) \\}\par
01848 {\cf21   GTEST_TEST_ANY_THROW_(statement, GTEST_NONFATAL_FAILURE_)}\par
01849 {\cf21 #define ASSERT_THROW(statement, expected_exception) \\}\par
01850 {\cf21   GTEST_TEST_THROW_(statement, expected_exception, GTEST_FATAL_FAILURE_)}\par
01851 {\cf21 #define ASSERT_NO_THROW(statement) \\}\par
01852 {\cf21   GTEST_TEST_NO_THROW_(statement, GTEST_FATAL_FAILURE_)}\par
01853 {\cf21 #define ASSERT_ANY_THROW(statement) \\}\par
01854 {\cf21   GTEST_TEST_ANY_THROW_(statement, GTEST_FATAL_FAILURE_)}\par
01855 \par
01856 {\cf20 // Boolean assertions. Condition can be either a Boolean expression or an}\par
01857 {\cf20 // AssertionResult. For more information on how to use AssertionResult with}\par
01858 {\cf20 // these macros see comments on that class.}\par
01859 {\cf21 #define EXPECT_TRUE(condition) \\}\par
01860 {\cf21   GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\}\par
01861 {\cf21                       GTEST_NONFATAL_FAILURE_)}\par
01862 {\cf21 #define EXPECT_FALSE(condition) \\}\par
01863 {\cf21   GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\}\par
01864 {\cf21                       GTEST_NONFATAL_FAILURE_)}\par
01865 {\cf21 #define ASSERT_TRUE(condition) \\}\par
01866 {\cf21   GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\}\par
01867 {\cf21                       GTEST_FATAL_FAILURE_)}\par
01868 {\cf21 #define ASSERT_FALSE(condition) \\}\par
01869 {\cf21   GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\}\par
01870 {\cf21                       GTEST_FATAL_FAILURE_)}\par
01871 \par
01872 {\cf20 // Includes the auto-generated header that implements a family of}\par
01873 {\cf20 // generic predicate assertion macros.}\par
01874 {\cf21 #include "gtest/gtest_pred_impl.h"}\par
01875 \par
01876 {\cf20 // Macros for testing equalities and inequalities.}\par
01877 {\cf20 //}\par
01878 {\cf20 //    * \{ASSERT|EXPECT\}_EQ(v1, v2): Tests that v1 == v2}\par
01879 {\cf20 //    * \{ASSERT|EXPECT\}_NE(v1, v2): Tests that v1 != v2}\par
01880 {\cf20 //    * \{ASSERT|EXPECT\}_LT(v1, v2): Tests that v1 < v2}\par
01881 {\cf20 //    * \{ASSERT|EXPECT\}_LE(v1, v2): Tests that v1 <= v2}\par
01882 {\cf20 //    * \{ASSERT|EXPECT\}_GT(v1, v2): Tests that v1 > v2}\par
01883 {\cf20 //    * \{ASSERT|EXPECT\}_GE(v1, v2): Tests that v1 >= v2}\par
01884 {\cf20 //}\par
01885 {\cf20 // When they are not, Google Test prints both the tested expressions and}\par
01886 {\cf20 // their actual values.  The values must be compatible built-in types,}\par
01887 {\cf20 // or you will get a compiler error.  By "compatible" we mean that the}\par
01888 {\cf20 // values can be compared by the respective operator.}\par
01889 {\cf20 //}\par
01890 {\cf20 // Note:}\par
01891 {\cf20 //}\par
01892 {\cf20 //   1. It is possible to make a user-defined type work with}\par
01893 {\cf20 //   \{ASSERT|EXPECT\}_??(), but that requires overloading the}\par
01894 {\cf20 //   comparison operators and is thus discouraged by the Google C++}\par
01895 {\cf20 //   Usage Guide.  Therefore, you are advised to use the}\par
01896 {\cf20 //   \{ASSERT|EXPECT\}_TRUE() macro to assert that two objects are}\par
01897 {\cf20 //   equal.}\par
01898 {\cf20 //}\par
01899 {\cf20 //   2. The \{ASSERT|EXPECT\}_??() macros do pointer comparisons on}\par
01900 {\cf20 //   pointers (in particular, C strings).  Therefore, if you use it}\par
01901 {\cf20 //   with two C strings, you are testing how their locations in memory}\par
01902 {\cf20 //   are related, not how their content is related.  To compare two C}\par
01903 {\cf20 //   strings by content, use \{ASSERT|EXPECT\}_STR*().}\par
01904 {\cf20 //}\par
01905 {\cf20 //   3. \{ASSERT|EXPECT\}_EQ(v1, v2) is preferred to}\par
01906 {\cf20 //   \{ASSERT|EXPECT\}_TRUE(v1 == v2), as the former tells you}\par
01907 {\cf20 //   what the actual value is when it fails, and similarly for the}\par
01908 {\cf20 //   other comparisons.}\par
01909 {\cf20 //}\par
01910 {\cf20 //   4. Do not depend on the order in which \{ASSERT|EXPECT\}_??()}\par
01911 {\cf20 //   evaluate their arguments, which is undefined.}\par
01912 {\cf20 //}\par
01913 {\cf20 //   5. These macros evaluate their arguments exactly once.}\par
01914 {\cf20 //}\par
01915 {\cf20 // Examples:}\par
01916 {\cf20 //}\par
01917 {\cf20 //   EXPECT_NE(5, Foo());}\par
01918 {\cf20 //   EXPECT_EQ(NULL, a_pointer);}\par
01919 {\cf20 //   ASSERT_LT(i, array_size);}\par
01920 {\cf20 //   ASSERT_GT(records.size(), 0) << "There is no record left.";}\par
01921 \par
01922 {\cf21 #define EXPECT_EQ(val1, val2) \\}\par
01923 {\cf21   EXPECT_PRED_FORMAT2(::testing::internal:: \\}\par
01924 {\cf21                       EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\}\par
01925 {\cf21                       val1, val2)}\par
01926 {\cf21 #define EXPECT_NE(val1, val2) \\}\par
01927 {\cf21   EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)}\par
01928 {\cf21 #define EXPECT_LE(val1, val2) \\}\par
01929 {\cf21   EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)}\par
01930 {\cf21 #define EXPECT_LT(val1, val2) \\}\par
01931 {\cf21   EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)}\par
01932 {\cf21 #define EXPECT_GE(val1, val2) \\}\par
01933 {\cf21   EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)}\par
01934 {\cf21 #define EXPECT_GT(val1, val2) \\}\par
01935 {\cf21   EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)}\par
01936 \par
01937 {\cf21 #define GTEST_ASSERT_EQ(val1, val2) \\}\par
01938 {\cf21   ASSERT_PRED_FORMAT2(::testing::internal:: \\}\par
01939 {\cf21                       EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\}\par
01940 {\cf21                       val1, val2)}\par
01941 {\cf21 #define GTEST_ASSERT_NE(val1, val2) \\}\par
01942 {\cf21   ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)}\par
01943 {\cf21 #define GTEST_ASSERT_LE(val1, val2) \\}\par
01944 {\cf21   ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)}\par
01945 {\cf21 #define GTEST_ASSERT_LT(val1, val2) \\}\par
01946 {\cf21   ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)}\par
01947 {\cf21 #define GTEST_ASSERT_GE(val1, val2) \\}\par
01948 {\cf21   ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)}\par
01949 {\cf21 #define GTEST_ASSERT_GT(val1, val2) \\}\par
01950 {\cf21   ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)}\par
01951 \par
01952 {\cf20 // Define macro GTEST_DONT_DEFINE_ASSERT_XY to 1 to omit the definition of}\par
01953 {\cf20 // ASSERT_XY(), which clashes with some users' own code.}\par
01954 \par
01955 {\cf21 #if !GTEST_DONT_DEFINE_ASSERT_EQ}\par
01956 {\cf21 # define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)}\par
01957 {\cf21 #endif}\par
01958 \par
01959 {\cf21 #if !GTEST_DONT_DEFINE_ASSERT_NE}\par
01960 {\cf21 # define ASSERT_NE(val1, val2) GTEST_ASSERT_NE(val1, val2)}\par
01961 {\cf21 #endif}\par
01962 \par
01963 {\cf21 #if !GTEST_DONT_DEFINE_ASSERT_LE}\par
01964 {\cf21 # define ASSERT_LE(val1, val2) GTEST_ASSERT_LE(val1, val2)}\par
01965 {\cf21 #endif}\par
01966 \par
01967 {\cf21 #if !GTEST_DONT_DEFINE_ASSERT_LT}\par
01968 {\cf21 # define ASSERT_LT(val1, val2) GTEST_ASSERT_LT(val1, val2)}\par
01969 {\cf21 #endif}\par
01970 \par
01971 {\cf21 #if !GTEST_DONT_DEFINE_ASSERT_GE}\par
01972 {\cf21 # define ASSERT_GE(val1, val2) GTEST_ASSERT_GE(val1, val2)}\par
01973 {\cf21 #endif}\par
01974 \par
01975 {\cf21 #if !GTEST_DONT_DEFINE_ASSERT_GT}\par
01976 {\cf21 # define ASSERT_GT(val1, val2) GTEST_ASSERT_GT(val1, val2)}\par
01977 {\cf21 #endif}\par
01978 \par
01979 {\cf20 // C-string Comparisons.  All tests treat NULL and any non-NULL string}\par
01980 {\cf20 // as different.  Two NULLs are equal.}\par
01981 {\cf20 //}\par
01982 {\cf20 //    * \{ASSERT|EXPECT\}_STREQ(s1, s2):     Tests that s1 == s2}\par
01983 {\cf20 //    * \{ASSERT|EXPECT\}_STRNE(s1, s2):     Tests that s1 != s2}\par
01984 {\cf20 //    * \{ASSERT|EXPECT\}_STRCASEEQ(s1, s2): Tests that s1 == s2, ignoring case}\par
01985 {\cf20 //    * \{ASSERT|EXPECT\}_STRCASENE(s1, s2): Tests that s1 != s2, ignoring case}\par
01986 {\cf20 //}\par
01987 {\cf20 // For wide or narrow string objects, you can use the}\par
01988 {\cf20 // \{ASSERT|EXPECT\}_??() macros.}\par
01989 {\cf20 //}\par
01990 {\cf20 // Don't depend on the order in which the arguments are evaluated,}\par
01991 {\cf20 // which is undefined.}\par
01992 {\cf20 //}\par
01993 {\cf20 // These macros evaluate their arguments exactly once.}\par
01994 \par
01995 {\cf21 #define EXPECT_STREQ(s1, s2) \\}\par
01996 {\cf21   EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)}\par
01997 {\cf21 #define EXPECT_STRNE(s1, s2) \\}\par
01998 {\cf21   EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)}\par
01999 {\cf21 #define EXPECT_STRCASEEQ(s1, s2) \\}\par
02000 {\cf21   EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)}\par
02001 {\cf21 #define EXPECT_STRCASENE(s1, s2)\\}\par
02002 {\cf21   EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)}\par
02003 \par
02004 {\cf21 #define ASSERT_STREQ(s1, s2) \\}\par
02005 {\cf21   ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)}\par
02006 {\cf21 #define ASSERT_STRNE(s1, s2) \\}\par
02007 {\cf21   ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)}\par
02008 {\cf21 #define ASSERT_STRCASEEQ(s1, s2) \\}\par
02009 {\cf21   ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)}\par
02010 {\cf21 #define ASSERT_STRCASENE(s1, s2)\\}\par
02011 {\cf21   ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)}\par
02012 \par
02013 {\cf20 // Macros for comparing floating-point numbers.}\par
02014 {\cf20 //}\par
02015 {\cf20 //    * \{ASSERT|EXPECT\}_FLOAT_EQ(val1, val2):}\par
02016 {\cf20 //         Tests that two float values are almost equal.}\par
02017 {\cf20 //    * \{ASSERT|EXPECT\}_DOUBLE_EQ(val1, val2):}\par
02018 {\cf20 //         Tests that two double values are almost equal.}\par
02019 {\cf20 //    * \{ASSERT|EXPECT\}_NEAR(v1, v2, abs_error):}\par
02020 {\cf20 //         Tests that v1 and v2 are within the given distance to each other.}\par
02021 {\cf20 //}\par
02022 {\cf20 // Google Test uses ULP-based comparison to automatically pick a default}\par
02023 {\cf20 // error bound that is appropriate for the operands.  See the}\par
02024 {\cf20 // FloatingPoint template class in gtest-internal.h if you are}\par
02025 {\cf20 // interested in the implementation details.}\par
02026 \par
02027 {\cf21 #define EXPECT_FLOAT_EQ(val1, val2)\\}\par
02028 {\cf21   EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\}\par
02029 {\cf21                       val1, val2)}\par
02030 \par
02031 {\cf21 #define EXPECT_DOUBLE_EQ(val1, val2)\\}\par
02032 {\cf21   EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\}\par
02033 {\cf21                       val1, val2)}\par
02034 \par
02035 {\cf21 #define ASSERT_FLOAT_EQ(val1, val2)\\}\par
02036 {\cf21   ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\}\par
02037 {\cf21                       val1, val2)}\par
02038 \par
02039 {\cf21 #define ASSERT_DOUBLE_EQ(val1, val2)\\}\par
02040 {\cf21   ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\}\par
02041 {\cf21                       val1, val2)}\par
02042 \par
02043 {\cf21 #define EXPECT_NEAR(val1, val2, abs_error)\\}\par
02044 {\cf21   EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\}\par
02045 {\cf21                       val1, val2, abs_error)}\par
02046 \par
02047 {\cf21 #define ASSERT_NEAR(val1, val2, abs_error)\\}\par
02048 {\cf21   ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\}\par
02049 {\cf21                       val1, val2, abs_error)}\par
02050 \par
02051 {\cf20 // These predicate format functions work on floating-point values, and}\par
02052 {\cf20 // can be used in \{ASSERT|EXPECT\}_PRED_FORMAT2*(), e.g.}\par
02053 {\cf20 //}\par
02054 {\cf20 //   EXPECT_PRED_FORMAT2(testing::DoubleLE, Foo(), 5.0);}\par
02055 \par
02056 {\cf20 // Asserts that val1 is less than, or almost equal to, val2.  Fails}\par
02057 {\cf20 // otherwise.  In particular, it fails if either val1 or val2 is NaN.}\par
02058 GTEST_API_ AssertionResult FloatLE({\cf17 const} {\cf18 char}* expr1, {\cf17 const} {\cf18 char}* expr2,\par
02059                                    {\cf18 float} val1, {\cf18 float} val2);\par
02060 GTEST_API_ AssertionResult DoubleLE({\cf17 const} {\cf18 char}* expr1, {\cf17 const} {\cf18 char}* expr2,\par
02061                                     {\cf18 double} val1, {\cf18 double} val2);\par
02062 \par
02063 \par
02064 {\cf21 #if GTEST_OS_WINDOWS}\par
02065 \par
02066 {\cf20 // Macros that test for HRESULT failure and success, these are only useful}\par
02067 {\cf20 // on Windows, and rely on Windows SDK macros and APIs to compile.}\par
02068 {\cf20 //}\par
02069 {\cf20 //    * \{ASSERT|EXPECT\}_HRESULT_\{SUCCEEDED|FAILED\}(expr)}\par
02070 {\cf20 //}\par
02071 {\cf20 // When expr unexpectedly fails or succeeds, Google Test prints the}\par
02072 {\cf20 // expected result and the actual result with both a human-readable}\par
02073 {\cf20 // string representation of the error, if available, as well as the}\par
02074 {\cf20 // hex result code.}\par
02075 {\cf21 # define EXPECT_HRESULT_SUCCEEDED(expr) \\}\par
02076 {\cf21     EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))}\par
02077 \par
02078 {\cf21 # define ASSERT_HRESULT_SUCCEEDED(expr) \\}\par
02079 {\cf21     ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))}\par
02080 \par
02081 {\cf21 # define EXPECT_HRESULT_FAILED(expr) \\}\par
02082 {\cf21     EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))}\par
02083 \par
02084 {\cf21 # define ASSERT_HRESULT_FAILED(expr) \\}\par
02085 {\cf21     ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))}\par
02086 \par
02087 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
02088 \par
02089 {\cf20 // Macros that execute statement and check that it doesn't generate new fatal}\par
02090 {\cf20 // failures in the current thread.}\par
02091 {\cf20 //}\par
02092 {\cf20 //   * \{ASSERT|EXPECT\}_NO_FATAL_FAILURE(statement);}\par
02093 {\cf20 //}\par
02094 {\cf20 // Examples:}\par
02095 {\cf20 //}\par
02096 {\cf20 //   EXPECT_NO_FATAL_FAILURE(Process());}\par
02097 {\cf20 //   ASSERT_NO_FATAL_FAILURE(Process()) << "Process() failed";}\par
02098 {\cf20 //}\par
02099 {\cf21 #define ASSERT_NO_FATAL_FAILURE(statement) \\}\par
02100 {\cf21     GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_FATAL_FAILURE_)}\par
02101 {\cf21 #define EXPECT_NO_FATAL_FAILURE(statement) \\}\par
02102 {\cf21     GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_NONFATAL_FAILURE_)}\par
02103 \par
02104 {\cf20 // Causes a trace (including the source file path, the current line}\par
02105 {\cf20 // number, and the given message) to be included in every test failure}\par
02106 {\cf20 // message generated by code in the current scope.  The effect is}\par
02107 {\cf20 // undone when the control leaves the current scope.}\par
02108 {\cf20 //}\par
02109 {\cf20 // The message argument can be anything streamable to std::ostream.}\par
02110 {\cf20 //}\par
02111 {\cf20 // In the implementation, we include the current line number as part}\par
02112 {\cf20 // of the dummy variable name, thus allowing multiple SCOPED_TRACE()s}\par
02113 {\cf20 // to appear in the same block - as long as they are on different}\par
02114 {\cf20 // lines.}\par
02115 {\cf21 #define SCOPED_TRACE(message) \\}\par
02116 {\cf21   ::testing::internal::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)(\\}\par
02117 {\cf21     __FILE__, __LINE__, ::testing::Message() << (message))}\par
02118 \par
02119 {\cf20 // Compile-time assertion for type equality.}\par
02120 {\cf20 // StaticAssertTypeEq<type1, type2>() compiles iff type1 and type2 are}\par
02121 {\cf20 // the same type.  The value it returns is not interesting.}\par
02122 {\cf20 //}\par
02123 {\cf20 // Instead of making StaticAssertTypeEq a class template, we make it a}\par
02124 {\cf20 // function template that invokes a helper class template.  This}\par
02125 {\cf20 // prevents a user from misusing StaticAssertTypeEq<T1, T2> by}\par
02126 {\cf20 // defining objects of that type.}\par
02127 {\cf20 //}\par
02128 {\cf20 // CAVEAT:}\par
02129 {\cf20 //}\par
02130 {\cf20 // When used inside a method of a class template,}\par
02131 {\cf20 // StaticAssertTypeEq<T1, T2>() is effective ONLY IF the method is}\par
02132 {\cf20 // instantiated.  For example, given:}\par
02133 {\cf20 //}\par
02134 {\cf20 //   template <typename T> class Foo \{}\par
02135 {\cf20 //    public:}\par
02136 {\cf20 //     void Bar() \{ testing::StaticAssertTypeEq<int, T>(); \}}\par
02137 {\cf20 //   \};}\par
02138 {\cf20 //}\par
02139 {\cf20 // the code:}\par
02140 {\cf20 //}\par
02141 {\cf20 //   void Test1() \{ Foo<bool> foo; \}}\par
02142 {\cf20 //}\par
02143 {\cf20 // will NOT generate a compiler error, as Foo<bool>::Bar() is never}\par
02144 {\cf20 // actually instantiated.  Instead, you need:}\par
02145 {\cf20 //}\par
02146 {\cf20 //   void Test2() \{ Foo<bool> foo; foo.Bar(); \}}\par
02147 {\cf20 //}\par
02148 {\cf20 // to cause a compiler error.}\par
02149 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
02150 {\cf18 bool} StaticAssertTypeEq() \{\par
02151   (void)internal::StaticAssertTypeEqHelper<T1, T2>();\par
02152   {\cf19 return} {\cf17 true};\par
02153 \}\par
02154 \par
02155 {\cf20 // Defines a test.}\par
02156 {\cf20 //}\par
02157 {\cf20 // The first parameter is the name of the test case, and the second}\par
02158 {\cf20 // parameter is the name of the test within the test case.}\par
02159 {\cf20 //}\par
02160 {\cf20 // The convention is to end the test case name with "Test".  For}\par
02161 {\cf20 // example, a test case for the Foo class can be named FooTest.}\par
02162 {\cf20 //}\par
02163 {\cf20 // Test code should appear between braces after an invocation of}\par
02164 {\cf20 // this macro.  Example:}\par
02165 {\cf20 //}\par
02166 {\cf20 //   TEST(FooTest, InitializesCorrectly) \{}\par
02167 {\cf20 //     Foo foo;}\par
02168 {\cf20 //     EXPECT_TRUE(foo.StatusIsOK());}\par
02169 {\cf20 //   \}}\par
02170 \par
02171 {\cf20 // Note that we call GetTestTypeId() instead of GetTypeId<}\par
02172 {\cf20 // ::testing::Test>() here to get the type ID of testing::Test.  This}\par
02173 {\cf20 // is to work around a suspected linker bug when using Google Test as}\par
02174 {\cf20 // a framework on Mac OS X.  The bug causes GetTypeId<}\par
02175 {\cf20 // ::testing::Test>() to return different values depending on whether}\par
02176 {\cf20 // the call is from the Google Test framework itself or from user test}\par
02177 {\cf20 // code.  GetTestTypeId() is guaranteed to always return the same}\par
02178 {\cf20 // value, as it always calls GetTypeId<>() from the Google Test}\par
02179 {\cf20 // framework.}\par
02180 {\cf21 #define GTEST_TEST(test_case_name, test_name)\\}\par
02181 {\cf21   GTEST_TEST_(test_case_name, test_name, \\}\par
02182 {\cf21               ::testing::Test, ::testing::internal::GetTestTypeId())}\par
02183 \par
02184 {\cf20 // Define this macro to 1 to omit the definition of TEST(), which}\par
02185 {\cf20 // is a generic name and clashes with some other libraries.}\par
02186 {\cf21 #if !GTEST_DONT_DEFINE_TEST}\par
02187 {\cf21 # define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)}\par
02188 {\cf21 #endif}\par
02189 \par
02190 {\cf20 // Defines a test that uses a test fixture.}\par
02191 {\cf20 //}\par
02192 {\cf20 // The first parameter is the name of the test fixture class, which}\par
02193 {\cf20 // also doubles as the test case name.  The second parameter is the}\par
02194 {\cf20 // name of the test within the test case.}\par
02195 {\cf20 //}\par
02196 {\cf20 // A test fixture class must be declared earlier.  The user should put}\par
02197 {\cf20 // the test code between braces after using this macro.  Example:}\par
02198 {\cf20 //}\par
02199 {\cf20 //   class FooTest : public testing::Test \{}\par
02200 {\cf20 //    protected:}\par
02201 {\cf20 //     virtual void SetUp() \{ b_.AddElement(3); \}}\par
02202 {\cf20 //}\par
02203 {\cf20 //     Foo a_;}\par
02204 {\cf20 //     Foo b_;}\par
02205 {\cf20 //   \};}\par
02206 {\cf20 //}\par
02207 {\cf20 //   TEST_F(FooTest, InitializesCorrectly) \{}\par
02208 {\cf20 //     EXPECT_TRUE(a_.StatusIsOK());}\par
02209 {\cf20 //   \}}\par
02210 {\cf20 //}\par
02211 {\cf20 //   TEST_F(FooTest, ReturnsElementCountCorrectly) \{}\par
02212 {\cf20 //     EXPECT_EQ(0, a_.size());}\par
02213 {\cf20 //     EXPECT_EQ(1, b_.size());}\par
02214 {\cf20 //   \}}\par
02215 \par
02216 {\cf21 #define TEST_F(test_fixture, test_name)\\}\par
02217 {\cf21   GTEST_TEST_(test_fixture, test_name, test_fixture, \\}\par
02218 {\cf21               ::testing::internal::GetTypeId<test_fixture>())}\par
02219 \par
02220 {\cf20 // Returns a path to temporary directory.}\par
02221 {\cf20 // Tries to determine an appropriate directory for the platform.}\par
02222 GTEST_API_ std::string TempDir();\par
02223 \par
02224 \}  {\cf20 // namespace testing}\par
02225 \par
02226 {\cf20 // Use this function in main() to run all tests.  It returns 0 if all}\par
02227 {\cf20 // tests are successful, or 1 otherwise.}\par
02228 {\cf20 //}\par
02229 {\cf20 // RUN_ALL_TESTS() should be invoked after the command line has been}\par
02230 {\cf20 // parsed by InitGoogleTest().}\par
02231 {\cf20 //}\par
02232 {\cf20 // This function was formerly a macro; thus, it is in the global}\par
02233 {\cf20 // namespace and has an all-caps name.}\par
02234 {\cf18 int} RUN_ALL_TESTS() GTEST_MUST_USE_RESULT_;\par
02235 \par
02236 inline {\cf18 int} RUN_ALL_TESTS() \{\par
02237   return ::testing::UnitTest::GetInstance()->Run();\par
02238 \}\par
02239 \par
02240 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_GTEST_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/internal/custom/gtest.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/custom/gtest.h}
{\xe \v gtest/include/gtest/internal/custom/gtest.h}
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/custom/gtest.h}
{\xe \v gtest/include/gtest/internal/custom/gtest.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2015, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Injection point for custom user configurations.}\par
00031 {\cf20 // The following macros can be defined:}\par
00032 {\cf20 //}\par
00033 {\cf20 // GTEST_OS_STACK_TRACE_GETTER_  - The name of an implementation of}\par
00034 {\cf20 //                                 OsStackTraceGetterInterface.}\par
00035 {\cf20 //}\par
00036 {\cf20 // GTEST_CUSTOM_TEMPDIR_FUNCTION_ - An override for testing::TempDir().}\par
00037 {\cf20 //                                  See testing::TempDir for semantics and}\par
00038 {\cf20 //                                  signature.}\par
00039 {\cf20 // }\par
00040 {\cf20 // ** Custom implementation starts here **}\par
00041 \par
00042 {\cf21 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_H_}\par
00043 {\cf21 #define GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_H_}\par
00044 \par
00045 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/gtest_pred_impl.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest_pred_impl.h}
{\xe \v gtest/include/gtest/gtest_pred_impl.h}
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ASSERT_}(expression,  on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_PRED_FORMAT1_}(pred_format,  v1,  on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_PRED1_}(pred,  v1,  on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_PRED_FORMAT1}(pred_format,  v1)\~   {\b GTEST_PRED_FORMAT1_}(pred_format, v1, {\b GTEST_NONFATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_PRED1}(pred,  v1)\~   {\b GTEST_PRED1_}(pred, v1, {\b GTEST_NONFATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_PRED_FORMAT1}(pred_format,  v1)\~   {\b GTEST_PRED_FORMAT1_}(pred_format, v1, {\b GTEST_FATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_PRED1}(pred,  v1)\~   {\b GTEST_PRED1_}(pred, v1, {\b GTEST_FATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_PRED_FORMAT2_}(pred_format,  v1,  v2,  on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_PRED2_}(pred,  v1,  v2,  on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_PRED_FORMAT2}(pred_format,  v1,  v2)\~   {\b GTEST_PRED_FORMAT2_}(pred_format, v1, v2, {\b GTEST_NONFATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_PRED2}(pred,  v1,  v2)\~   {\b GTEST_PRED2_}(pred, v1, v2, {\b GTEST_NONFATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_PRED_FORMAT2}(pred_format,  v1,  v2)\~   {\b GTEST_PRED_FORMAT2_}(pred_format, v1, v2, {\b GTEST_FATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_PRED2}(pred,  v1,  v2)\~   {\b GTEST_PRED2_}(pred, v1, v2, {\b GTEST_FATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_PRED_FORMAT3_}(pred_format,  v1,  v2,  v3,  on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_PRED3_}(pred,  v1,  v2,  v3,  on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_PRED_FORMAT3}(pred_format,  v1,  v2,  v3)\~   {\b GTEST_PRED_FORMAT3_}(pred_format, v1, v2, v3, {\b GTEST_NONFATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_PRED3}(pred,  v1,  v2,  v3)\~   {\b GTEST_PRED3_}(pred, v1, v2, v3, {\b GTEST_NONFATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_PRED_FORMAT3}(pred_format,  v1,  v2,  v3)\~   {\b GTEST_PRED_FORMAT3_}(pred_format, v1, v2, v3, {\b GTEST_FATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_PRED3}(pred,  v1,  v2,  v3)\~   {\b GTEST_PRED3_}(pred, v1, v2, v3, {\b GTEST_FATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_PRED_FORMAT4_}(pred_format,  v1,  v2,  v3,  v4,  on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_PRED4_}(pred,  v1,  v2,  v3,  v4,  on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_PRED_FORMAT4}(pred_format,  v1,  v2,  v3,  v4)\~   {\b GTEST_PRED_FORMAT4_}(pred_format, v1, v2, v3, v4, {\b GTEST_NONFATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_PRED4}(pred,  v1,  v2,  v3,  v4)\~   {\b GTEST_PRED4_}(pred, v1, v2, v3, v4, {\b GTEST_NONFATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_PRED_FORMAT4}(pred_format,  v1,  v2,  v3,  v4)\~   {\b GTEST_PRED_FORMAT4_}(pred_format, v1, v2, v3, v4, {\b GTEST_FATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_PRED4}(pred,  v1,  v2,  v3,  v4)\~   {\b GTEST_PRED4_}(pred, v1, v2, v3, v4, {\b GTEST_FATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_PRED_FORMAT5_}(pred_format,  v1,  v2,  v3,  v4,  v5,  on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_PRED5_}(pred,  v1,  v2,  v3,  v4,  v5,  on_failure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_PRED_FORMAT5}(pred_format,  v1,  v2,  v3,  v4,  v5)\~   {\b GTEST_PRED_FORMAT5_}(pred_format, v1, v2, v3, v4, v5, {\b GTEST_NONFATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPECT_PRED5}(pred,  v1,  v2,  v3,  v4,  v5)\~   {\b GTEST_PRED5_}(pred, v1, v2, v3, v4, v5, {\b GTEST_NONFATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_PRED_FORMAT5}(pred_format,  v1,  v2,  v3,  v4,  v5)\~   {\b GTEST_PRED_FORMAT5_}(pred_format, v1, v2, v3, v4, v5, {\b GTEST_FATAL_FAILURE_})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ASSERT_PRED5}(pred,  v1,  v2,  v3,  v4,  v5)\~   {\b GTEST_PRED5_}(pred, v1, v2, v3, v4, v5, {\b GTEST_FATAL_FAILURE_})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Pred , typename T1 > AssertionResult {\b AssertPred1Helper} (const char *pred_text, const char *e1, Pred pred, const T1 &v1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Pred , typename T1 , typename T2 > AssertionResult {\b AssertPred2Helper} (const char *pred_text, const char *e1, const char *e2, Pred pred, const T1 &v1, const T2 &v2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Pred , typename T1 , typename T2 , typename T3 > AssertionResult {\b AssertPred3Helper} (const char *pred_text, const char *e1, const char *e2, const char *e3, Pred pred, const T1 &v1, const T2 &v2, const T3 &v3)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Pred , typename T1 , typename T2 , typename T3 , typename T4 > AssertionResult {\b AssertPred4Helper} (const char *pred_text, const char *e1, const char *e2, const char *e3, const char *e4, Pred pred, const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Pred , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > AssertionResult {\b AssertPred5Helper} (const char *pred_text, const char *e1, const char *e2, const char *e3, const char *e4, const char *e5, Pred pred, const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v ASSERT_PRED1\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:ASSERT_PRED1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_PRED1( pred,  v1)\~   {\b GTEST_PRED1_}(pred, v1, {\b GTEST_FATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 119}}\par
}
{\xe \v ASSERT_PRED2\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:ASSERT_PRED2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_PRED2( pred,  v1,  v2)\~   {\b GTEST_PRED2_}(pred, v1, v2, {\b GTEST_FATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 167}}\par
}
{\xe \v ASSERT_PRED3\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:ASSERT_PRED3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_PRED3( pred,  v1,  v2,  v3)\~   {\b GTEST_PRED3_}(pred, v1, v2, v3, {\b GTEST_FATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 222}}\par
}
{\xe \v ASSERT_PRED4\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:ASSERT_PRED4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_PRED4( pred,  v1,  v2,  v3,  v4)\~   {\b GTEST_PRED4_}(pred, v1, v2, v3, v4, {\b GTEST_FATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 284}}\par
}
{\xe \v ASSERT_PRED5\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:ASSERT_PRED5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_PRED5( pred,  v1,  v2,  v3,  v4,  v5)\~   {\b GTEST_PRED5_}(pred, v1, v2, v3, v4, v5, {\b GTEST_FATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 353}}\par
}
{\xe \v ASSERT_PRED_FORMAT1\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:ASSERT_PRED_FORMAT1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_PRED_FORMAT1( pred_format,  v1)\~   {\b GTEST_PRED_FORMAT1_}(pred_format, v1, {\b GTEST_FATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 117}}\par
}
{\xe \v ASSERT_PRED_FORMAT2\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:ASSERT_PRED_FORMAT2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_PRED_FORMAT2( pred_format,  v1,  v2)\~   {\b GTEST_PRED_FORMAT2_}(pred_format, v1, v2, {\b GTEST_FATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 165}}\par
}
{\xe \v ASSERT_PRED_FORMAT3\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:ASSERT_PRED_FORMAT3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_PRED_FORMAT3( pred_format,  v1,  v2,  v3)\~   {\b GTEST_PRED_FORMAT3_}(pred_format, v1, v2, v3, {\b GTEST_FATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 220}}\par
}
{\xe \v ASSERT_PRED_FORMAT4\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:ASSERT_PRED_FORMAT4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_PRED_FORMAT4( pred_format,  v1,  v2,  v3,  v4)\~   {\b GTEST_PRED_FORMAT4_}(pred_format, v1, v2, v3, v4, {\b GTEST_FATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 282}}\par
}
{\xe \v ASSERT_PRED_FORMAT5\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:ASSERT_PRED_FORMAT5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ASSERT_PRED_FORMAT5( pred_format,  v1,  v2,  v3,  v4,  v5)\~   {\b GTEST_PRED_FORMAT5_}(pred_format, v1, v2, v3, v4, v5, {\b GTEST_FATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 351}}\par
}
{\xe \v EXPECT_PRED1\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:EXPECT_PRED1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_PRED1( pred,  v1)\~   {\b GTEST_PRED1_}(pred, v1, {\b GTEST_NONFATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 115}}\par
}
{\xe \v EXPECT_PRED2\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:EXPECT_PRED2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_PRED2( pred,  v1,  v2)\~   {\b GTEST_PRED2_}(pred, v1, v2, {\b GTEST_NONFATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 163}}\par
}
{\xe \v EXPECT_PRED3\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:EXPECT_PRED3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_PRED3( pred,  v1,  v2,  v3)\~   {\b GTEST_PRED3_}(pred, v1, v2, v3, {\b GTEST_NONFATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 218}}\par
}
{\xe \v EXPECT_PRED4\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:EXPECT_PRED4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_PRED4( pred,  v1,  v2,  v3,  v4)\~   {\b GTEST_PRED4_}(pred, v1, v2, v3, v4, {\b GTEST_NONFATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 280}}\par
}
{\xe \v EXPECT_PRED5\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:EXPECT_PRED5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_PRED5( pred,  v1,  v2,  v3,  v4,  v5)\~   {\b GTEST_PRED5_}(pred, v1, v2, v3, v4, v5, {\b GTEST_NONFATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 349}}\par
}
{\xe \v EXPECT_PRED_FORMAT1\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:EXPECT_PRED_FORMAT1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_PRED_FORMAT1( pred_format,  v1)\~   {\b GTEST_PRED_FORMAT1_}(pred_format, v1, {\b GTEST_NONFATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 113}}\par
}
{\xe \v EXPECT_PRED_FORMAT2\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:EXPECT_PRED_FORMAT2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_PRED_FORMAT2( pred_format,  v1,  v2)\~   {\b GTEST_PRED_FORMAT2_}(pred_format, v1, v2, {\b GTEST_NONFATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 161}}\par
}
{\xe \v EXPECT_PRED_FORMAT3\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:EXPECT_PRED_FORMAT3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_PRED_FORMAT3( pred_format,  v1,  v2,  v3)\~   {\b GTEST_PRED_FORMAT3_}(pred_format, v1, v2, v3, {\b GTEST_NONFATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 216}}\par
}
{\xe \v EXPECT_PRED_FORMAT4\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:EXPECT_PRED_FORMAT4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_PRED_FORMAT4( pred_format,  v1,  v2,  v3,  v4)\~   {\b GTEST_PRED_FORMAT4_}(pred_format, v1, v2, v3, v4, {\b GTEST_NONFATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 278}}\par
}
{\xe \v EXPECT_PRED_FORMAT5\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:EXPECT_PRED_FORMAT5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPECT_PRED_FORMAT5( pred_format,  v1,  v2,  v3,  v4,  v5)\~   {\b GTEST_PRED_FORMAT5_}(pred_format, v1, v2, v3, v4, v5, {\b GTEST_NONFATAL_FAILURE_})}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 347}}\par
}
{\xe \v GTEST_ASSERT_\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:GTEST_ASSERT_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ASSERT_( expression,  on_failure)}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\par
  if (const ::testing::AssertionResult gtest_ar = (expression)) \\\par
    ; \\\par
  else \\\par
    on_failure(gtest_ar.failure_message())\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 75}}\par
}
{\xe \v GTEST_PRED1_\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:GTEST_PRED1_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_PRED1_( pred,  v1,  on_failure)}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_ASSERT_(::testing::AssertPred1Helper(#pred, \\\par
                                             #v1, \\\par
                                             pred, \\\par
                                             v1), on_failure)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 106}}\par
}
{\xe \v GTEST_PRED2_\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:GTEST_PRED2_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_PRED2_( pred,  v1,  v2,  on_failure)}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_ASSERT_(::testing::AssertPred2Helper(#pred, \\\par
                                             #v1, \\\par
                                             #v2, \\\par
                                             pred, \\\par
                                             v1, \\\par
                                             v2), on_failure)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 152}}\par
}
{\xe \v GTEST_PRED3_\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:GTEST_PRED3_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_PRED3_( pred,  v1,  v2,  v3,  on_failure)}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_ASSERT_(::testing::AssertPred3Helper(#pred, \\\par
                                             #v1, \\\par
                                             #v2, \\\par
                                             #v3, \\\par
                                             pred, \\\par
                                             v1, \\\par
                                             v2, \\\par
                                             v3), on_failure)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 205}}\par
}
{\xe \v GTEST_PRED4_\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:GTEST_PRED4_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_PRED4_( pred,  v1,  v2,  v3,  v4,  on_failure)}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_ASSERT_(::testing::AssertPred4Helper(#pred, \\\par
                                             #v1, \\\par
                                             #v2, \\\par
                                             #v3, \\\par
                                             #v4, \\\par
                                             pred, \\\par
                                             v1, \\\par
                                             v2, \\\par
                                             v3, \\\par
                                             v4), on_failure)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 265}}\par
}
{\xe \v GTEST_PRED5_\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:GTEST_PRED5_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_PRED5_( pred,  v1,  v2,  v3,  v4,  v5,  on_failure)}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_ASSERT_(::testing::AssertPred5Helper(#pred, \\\par
                                             #v1, \\\par
                                             #v2, \\\par
                                             #v3, \\\par
                                             #v4, \\\par
                                             #v5, \\\par
                                             pred, \\\par
                                             v1, \\\par
                                             v2, \\\par
                                             v3, \\\par
                                             v4, \\\par
                                             v5), on_failure)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 332}}\par
}
{\xe \v GTEST_PRED_FORMAT1_\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:GTEST_PRED_FORMAT1_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_PRED_FORMAT1_( pred_format,  v1,  on_failure)}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_ASSERT_(pred_format(#v1, v1), \\\par
                on_failure)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 100}}\par
}
{\xe \v GTEST_PRED_FORMAT2_\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:GTEST_PRED_FORMAT2_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_PRED_FORMAT2_( pred_format,  v1,  v2,  on_failure)}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), \\\par
                on_failure)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 146}}\par
}
{\xe \v GTEST_PRED_FORMAT3_\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:GTEST_PRED_FORMAT3_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_PRED_FORMAT3_( pred_format,  v1,  v2,  v3,  on_failure)}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_ASSERT_(pred_format(#v1, #v2, #v3, v1, v2, v3), \\\par
                on_failure)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 199}}\par
}
{\xe \v GTEST_PRED_FORMAT4_\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:GTEST_PRED_FORMAT4_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_PRED_FORMAT4_( pred_format,  v1,  v2,  v3,  v4,  on_failure)}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_ASSERT_(pred_format(#v1, #v2, #v3, #v4, v1, v2, v3, v4), \\\par
                on_failure)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 259}}\par
}
{\xe \v GTEST_PRED_FORMAT5_\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:GTEST_PRED_FORMAT5_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_PRED_FORMAT5_( pred_format,  v1,  v2,  v3,  v4,  v5,  on_failure)}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_ASSERT_(pred_format(#v1, #v2, #v3, #v4, #v5, v1, v2, v3, v4, v5), \\\par
                on_failure)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 326}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 
{\xe \v AssertPred1Helper\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:AssertPred1Helper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Pred , typename T1 > AssertionResult AssertPred1Helper (const char *  {\i pred_text}, const char *  {\i e1}, Pred  {\i pred}, const T1 &  {\i v1})}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 87}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00090                                                 \{\par
00091   {\cf19 if} (pred(v1)) {\cf19 return} AssertionSuccess();\par
00092 \par
00093   {\cf19 return} AssertionFailure() << pred_text << {\cf22 "("}\par
00094                             << e1 << {\cf22 ") evaluates to false, where"}\par
00095                             << {\cf22 "\\n"} << e1 << {\cf22 " evaluates to "} << v1;\par
00096 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionFailure()} \'E8 {\b testing::AssertionSuccess()}.}\par
}
{\xe \v AssertPred2Helper\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:AssertPred2Helper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Pred , typename T1 , typename T2 > AssertionResult AssertPred2Helper (const char *  {\i pred_text}, const char *  {\i e1}, const char *  {\i e2}, Pred  {\i pred}, const T1 &  {\i v1}, const T2 &  {\i v2})}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 129}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00134                                                 \{\par
00135   {\cf19 if} (pred(v1, v2)) {\cf19 return} AssertionSuccess();\par
00136 \par
00137   {\cf19 return} AssertionFailure() << pred_text << {\cf22 "("}\par
00138                             << e1 << {\cf22 ", "}\par
00139                             << e2 << {\cf22 ") evaluates to false, where"}\par
00140                             << {\cf22 "\\n"} << e1 << {\cf22 " evaluates to "} << v1\par
00141                             << {\cf22 "\\n"} << e2 << {\cf22 " evaluates to "} << v2;\par
00142 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionFailure()} \'E8 {\b testing::AssertionSuccess()}.}\par
}
{\xe \v AssertPred3Helper\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:AssertPred3Helper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Pred , typename T1 , typename T2 , typename T3 > AssertionResult AssertPred3Helper (const char *  {\i pred_text}, const char *  {\i e1}, const char *  {\i e2}, const char *  {\i e3}, Pred  {\i pred}, const T1 &  {\i v1}, const T2 &  {\i v2}, const T3 &  {\i v3})}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 178}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00185                                                 \{\par
00186   {\cf19 if} (pred(v1, v2, v3)) {\cf19 return} AssertionSuccess();\par
00187 \par
00188   {\cf19 return} AssertionFailure() << pred_text << {\cf22 "("}\par
00189                             << e1 << {\cf22 ", "}\par
00190                             << e2 << {\cf22 ", "}\par
00191                             << e3 << {\cf22 ") evaluates to false, where"}\par
00192                             << {\cf22 "\\n"} << e1 << {\cf22 " evaluates to "} << v1\par
00193                             << {\cf22 "\\n"} << e2 << {\cf22 " evaluates to "} << v2\par
00194                             << {\cf22 "\\n"} << e3 << {\cf22 " evaluates to "} << v3;\par
00195 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionFailure()} \'E8 {\b testing::AssertionSuccess()}.}\par
}
{\xe \v AssertPred4Helper\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:AssertPred4Helper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Pred , typename T1 , typename T2 , typename T3 , typename T4 > AssertionResult AssertPred4Helper (const char *  {\i pred_text}, const char *  {\i e1}, const char *  {\i e2}, const char *  {\i e3}, const char *  {\i e4}, Pred  {\i pred}, const T1 &  {\i v1}, const T2 &  {\i v2}, const T3 &  {\i v3}, const T4 &  {\i v4})}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 234}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00243                                                 \{\par
00244   {\cf19 if} (pred(v1, v2, v3, v4)) {\cf19 return} AssertionSuccess();\par
00245 \par
00246   {\cf19 return} AssertionFailure() << pred_text << {\cf22 "("}\par
00247                             << e1 << {\cf22 ", "}\par
00248                             << e2 << {\cf22 ", "}\par
00249                             << e3 << {\cf22 ", "}\par
00250                             << e4 << {\cf22 ") evaluates to false, where"}\par
00251                             << {\cf22 "\\n"} << e1 << {\cf22 " evaluates to "} << v1\par
00252                             << {\cf22 "\\n"} << e2 << {\cf22 " evaluates to "} << v2\par
00253                             << {\cf22 "\\n"} << e3 << {\cf22 " evaluates to "} << v3\par
00254                             << {\cf22 "\\n"} << e4 << {\cf22 " evaluates to "} << v4;\par
00255 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionFailure()} \'E8 {\b testing::AssertionSuccess()}.}\par
}
{\xe \v AssertPred5Helper\:gtest_pred_impl.h}
{\xe \v gtest_pred_impl.h\:AssertPred5Helper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Pred , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > AssertionResult AssertPred5Helper (const char *  {\i pred_text}, const char *  {\i e1}, const char *  {\i e2}, const char *  {\i e3}, const char *  {\i e4}, const char *  {\i e5}, Pred  {\i pred}, const T1 &  {\i v1}, const T2 &  {\i v2}, const T3 &  {\i v3}, const T4 &  {\i v4}, const T5 &  {\i v5})}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_pred_impl.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 297}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00308                                                 \{\par
00309   {\cf19 if} (pred(v1, v2, v3, v4, v5)) {\cf19 return} AssertionSuccess();\par
00310 \par
00311   {\cf19 return} AssertionFailure() << pred_text << {\cf22 "("}\par
00312                             << e1 << {\cf22 ", "}\par
00313                             << e2 << {\cf22 ", "}\par
00314                             << e3 << {\cf22 ", "}\par
00315                             << e4 << {\cf22 ", "}\par
00316                             << e5 << {\cf22 ") evaluates to false, where"}\par
00317                             << {\cf22 "\\n"} << e1 << {\cf22 " evaluates to "} << v1\par
00318                             << {\cf22 "\\n"} << e2 << {\cf22 " evaluates to "} << v2\par
00319                             << {\cf22 "\\n"} << e3 << {\cf22 " evaluates to "} << v3\par
00320                             << {\cf22 "\\n"} << e4 << {\cf22 " evaluates to "} << v4\par
00321                             << {\cf22 "\\n"} << e5 << {\cf22 " evaluates to "} << v5;\par
00322 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::AssertionFailure()} \'E8 {\b testing::AssertionSuccess()}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest_pred_impl.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest_pred_impl.h}
{\xe \v gtest/include/gtest/gtest_pred_impl.h}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2006, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 \par
00030 {\cf20 // This file is AUTOMATICALLY GENERATED on 10/31/2011 by command}\par
00031 {\cf20 // 'gen_gtest_pred_impl.py 5'.  DO NOT EDIT BY HAND!}\par
00032 {\cf20 //}\par
00033 {\cf20 // Implements a family of generic predicate assertion macros.}\par
00034 \par
00035 {\cf21 #ifndef GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_}\par
00036 {\cf21 #define GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_}\par
00037 \par
00038 {\cf20 // Makes sure this header is not included before gtest.h.}\par
00039 {\cf21 #ifndef GTEST_INCLUDE_GTEST_GTEST_H_}\par
00040 {\cf21 # error Do not include gtest_pred_impl.h directly.  Include gtest.h instead.}\par
00041 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_GTEST_H_}\par
00042 \par
00043 {\cf20 // This header implements a family of generic predicate assertion}\par
00044 {\cf20 // macros:}\par
00045 {\cf20 //}\par
00046 {\cf20 //   ASSERT_PRED_FORMAT1(pred_format, v1)}\par
00047 {\cf20 //   ASSERT_PRED_FORMAT2(pred_format, v1, v2)}\par
00048 {\cf20 //   ...}\par
00049 {\cf20 //}\par
00050 {\cf20 // where pred_format is a function or functor that takes n (in the}\par
00051 {\cf20 // case of ASSERT_PRED_FORMATn) values and their source expression}\par
00052 {\cf20 // text, and returns a testing::AssertionResult.  See the definition}\par
00053 {\cf20 // of ASSERT_EQ in gtest.h for an example.}\par
00054 {\cf20 //}\par
00055 {\cf20 // If you don't care about formatting, you can use the more}\par
00056 {\cf20 // restrictive version:}\par
00057 {\cf20 //}\par
00058 {\cf20 //   ASSERT_PRED1(pred, v1)}\par
00059 {\cf20 //   ASSERT_PRED2(pred, v1, v2)}\par
00060 {\cf20 //   ...}\par
00061 {\cf20 //}\par
00062 {\cf20 // where pred is an n-ary function or functor that returns bool,}\par
00063 {\cf20 // and the values v1, v2, ..., must support the << operator for}\par
00064 {\cf20 // streaming to std::ostream.}\par
00065 {\cf20 //}\par
00066 {\cf20 // We also define the EXPECT_* variations.}\par
00067 {\cf20 //}\par
00068 {\cf20 // For now we only support predicates whose arity is at most 5.}\par
00069 {\cf20 // Please email googletestframework@googlegroups.com if you need}\par
00070 {\cf20 // support for higher arities.}\par
00071 \par
00072 {\cf20 // GTEST_ASSERT_ is the basic statement to which all of the assertions}\par
00073 {\cf20 // in this file reduce.  Don't use this in your code.}\par
00074 \par
00075 {\cf21 #define GTEST_ASSERT_(expression, on_failure) \\}\par
00076 {\cf21   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\}\par
00077 {\cf21   if (const ::testing::AssertionResult gtest_ar = (expression)) \\}\par
00078 {\cf21     ; \\}\par
00079 {\cf21   else \\}\par
00080 {\cf21     on_failure(gtest_ar.failure_message())}\par
00081 \par
00082 \par
00083 {\cf20 // Helper function for implementing \{EXPECT|ASSERT\}_PRED1.  Don't use}\par
00084 {\cf20 // this in your code.}\par
00085 {\cf17 template} <{\cf17 typename} Pred,\par
00086           {\cf17 typename} T1>\par
00087 AssertionResult AssertPred1Helper({\cf17 const} {\cf18 char}* pred_text,\par
00088                                   {\cf17 const} {\cf18 char}* e1,\par
00089                                   Pred pred,\par
00090                                   {\cf17 const} T1& v1) \{\par
00091   {\cf19 if} (pred(v1)) {\cf19 return} AssertionSuccess();\par
00092 \par
00093   {\cf19 return} AssertionFailure() << pred_text << {\cf22 "("}\par
00094                             << e1 << {\cf22 ") evaluates to false, where"}\par
00095                             << {\cf22 "\\n"} << e1 << {\cf22 " evaluates to "} << v1;\par
00096 \}\par
00097 \par
00098 {\cf20 // Internal macro for implementing \{EXPECT|ASSERT\}_PRED_FORMAT1.}\par
00099 {\cf20 // Don't use this in your code.}\par
00100 {\cf21 #define GTEST_PRED_FORMAT1_(pred_format, v1, on_failure)\\}\par
00101 {\cf21   GTEST_ASSERT_(pred_format(#v1, v1), \\}\par
00102 {\cf21                 on_failure)}\par
00103 \par
00104 {\cf20 // Internal macro for implementing \{EXPECT|ASSERT\}_PRED1.  Don't use}\par
00105 {\cf20 // this in your code.}\par
00106 {\cf21 #define GTEST_PRED1_(pred, v1, on_failure)\\}\par
00107 {\cf21   GTEST_ASSERT_(::testing::AssertPred1Helper(#pred, \\}\par
00108 {\cf21                                              #v1, \\}\par
00109 {\cf21                                              pred, \\}\par
00110 {\cf21                                              v1), on_failure)}\par
00111 \par
00112 {\cf20 // Unary predicate assertion macros.}\par
00113 {\cf21 #define EXPECT_PRED_FORMAT1(pred_format, v1) \\}\par
00114 {\cf21   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)}\par
00115 {\cf21 #define EXPECT_PRED1(pred, v1) \\}\par
00116 {\cf21   GTEST_PRED1_(pred, v1, GTEST_NONFATAL_FAILURE_)}\par
00117 {\cf21 #define ASSERT_PRED_FORMAT1(pred_format, v1) \\}\par
00118 {\cf21   GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_FATAL_FAILURE_)}\par
00119 {\cf21 #define ASSERT_PRED1(pred, v1) \\}\par
00120 {\cf21   GTEST_PRED1_(pred, v1, GTEST_FATAL_FAILURE_)}\par
00121 \par
00122 \par
00123 \par
00124 {\cf20 // Helper function for implementing \{EXPECT|ASSERT\}_PRED2.  Don't use}\par
00125 {\cf20 // this in your code.}\par
00126 {\cf17 template} <{\cf17 typename} Pred,\par
00127           {\cf17 typename} T1,\par
00128           {\cf17 typename} T2>\par
00129 AssertionResult AssertPred2Helper({\cf17 const} {\cf18 char}* pred_text,\par
00130                                   {\cf17 const} {\cf18 char}* e1,\par
00131                                   {\cf17 const} {\cf18 char}* e2,\par
00132                                   Pred pred,\par
00133                                   {\cf17 const} T1& v1,\par
00134                                   {\cf17 const} T2& v2) \{\par
00135   {\cf19 if} (pred(v1, v2)) {\cf19 return} AssertionSuccess();\par
00136 \par
00137   {\cf19 return} AssertionFailure() << pred_text << {\cf22 "("}\par
00138                             << e1 << {\cf22 ", "}\par
00139                             << e2 << {\cf22 ") evaluates to false, where"}\par
00140                             << {\cf22 "\\n"} << e1 << {\cf22 " evaluates to "} << v1\par
00141                             << {\cf22 "\\n"} << e2 << {\cf22 " evaluates to "} << v2;\par
00142 \}\par
00143 \par
00144 {\cf20 // Internal macro for implementing \{EXPECT|ASSERT\}_PRED_FORMAT2.}\par
00145 {\cf20 // Don't use this in your code.}\par
00146 {\cf21 #define GTEST_PRED_FORMAT2_(pred_format, v1, v2, on_failure)\\}\par
00147 {\cf21   GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), \\}\par
00148 {\cf21                 on_failure)}\par
00149 \par
00150 {\cf20 // Internal macro for implementing \{EXPECT|ASSERT\}_PRED2.  Don't use}\par
00151 {\cf20 // this in your code.}\par
00152 {\cf21 #define GTEST_PRED2_(pred, v1, v2, on_failure)\\}\par
00153 {\cf21   GTEST_ASSERT_(::testing::AssertPred2Helper(#pred, \\}\par
00154 {\cf21                                              #v1, \\}\par
00155 {\cf21                                              #v2, \\}\par
00156 {\cf21                                              pred, \\}\par
00157 {\cf21                                              v1, \\}\par
00158 {\cf21                                              v2), on_failure)}\par
00159 \par
00160 {\cf20 // Binary predicate assertion macros.}\par
00161 {\cf21 #define EXPECT_PRED_FORMAT2(pred_format, v1, v2) \\}\par
00162 {\cf21   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_NONFATAL_FAILURE_)}\par
00163 {\cf21 #define EXPECT_PRED2(pred, v1, v2) \\}\par
00164 {\cf21   GTEST_PRED2_(pred, v1, v2, GTEST_NONFATAL_FAILURE_)}\par
00165 {\cf21 #define ASSERT_PRED_FORMAT2(pred_format, v1, v2) \\}\par
00166 {\cf21   GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)}\par
00167 {\cf21 #define ASSERT_PRED2(pred, v1, v2) \\}\par
00168 {\cf21   GTEST_PRED2_(pred, v1, v2, GTEST_FATAL_FAILURE_)}\par
00169 \par
00170 \par
00171 \par
00172 {\cf20 // Helper function for implementing \{EXPECT|ASSERT\}_PRED3.  Don't use}\par
00173 {\cf20 // this in your code.}\par
00174 {\cf17 template} <{\cf17 typename} Pred,\par
00175           {\cf17 typename} T1,\par
00176           {\cf17 typename} T2,\par
00177           {\cf17 typename} T3>\par
00178 AssertionResult AssertPred3Helper({\cf17 const} {\cf18 char}* pred_text,\par
00179                                   {\cf17 const} {\cf18 char}* e1,\par
00180                                   {\cf17 const} {\cf18 char}* e2,\par
00181                                   {\cf17 const} {\cf18 char}* e3,\par
00182                                   Pred pred,\par
00183                                   {\cf17 const} T1& v1,\par
00184                                   {\cf17 const} T2& v2,\par
00185                                   {\cf17 const} T3& v3) \{\par
00186   {\cf19 if} (pred(v1, v2, v3)) {\cf19 return} AssertionSuccess();\par
00187 \par
00188   {\cf19 return} AssertionFailure() << pred_text << {\cf22 "("}\par
00189                             << e1 << {\cf22 ", "}\par
00190                             << e2 << {\cf22 ", "}\par
00191                             << e3 << {\cf22 ") evaluates to false, where"}\par
00192                             << {\cf22 "\\n"} << e1 << {\cf22 " evaluates to "} << v1\par
00193                             << {\cf22 "\\n"} << e2 << {\cf22 " evaluates to "} << v2\par
00194                             << {\cf22 "\\n"} << e3 << {\cf22 " evaluates to "} << v3;\par
00195 \}\par
00196 \par
00197 {\cf20 // Internal macro for implementing \{EXPECT|ASSERT\}_PRED_FORMAT3.}\par
00198 {\cf20 // Don't use this in your code.}\par
00199 {\cf21 #define GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, on_failure)\\}\par
00200 {\cf21   GTEST_ASSERT_(pred_format(#v1, #v2, #v3, v1, v2, v3), \\}\par
00201 {\cf21                 on_failure)}\par
00202 \par
00203 {\cf20 // Internal macro for implementing \{EXPECT|ASSERT\}_PRED3.  Don't use}\par
00204 {\cf20 // this in your code.}\par
00205 {\cf21 #define GTEST_PRED3_(pred, v1, v2, v3, on_failure)\\}\par
00206 {\cf21   GTEST_ASSERT_(::testing::AssertPred3Helper(#pred, \\}\par
00207 {\cf21                                              #v1, \\}\par
00208 {\cf21                                              #v2, \\}\par
00209 {\cf21                                              #v3, \\}\par
00210 {\cf21                                              pred, \\}\par
00211 {\cf21                                              v1, \\}\par
00212 {\cf21                                              v2, \\}\par
00213 {\cf21                                              v3), on_failure)}\par
00214 \par
00215 {\cf20 // Ternary predicate assertion macros.}\par
00216 {\cf21 #define EXPECT_PRED_FORMAT3(pred_format, v1, v2, v3) \\}\par
00217 {\cf21   GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_NONFATAL_FAILURE_)}\par
00218 {\cf21 #define EXPECT_PRED3(pred, v1, v2, v3) \\}\par
00219 {\cf21   GTEST_PRED3_(pred, v1, v2, v3, GTEST_NONFATAL_FAILURE_)}\par
00220 {\cf21 #define ASSERT_PRED_FORMAT3(pred_format, v1, v2, v3) \\}\par
00221 {\cf21   GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_FATAL_FAILURE_)}\par
00222 {\cf21 #define ASSERT_PRED3(pred, v1, v2, v3) \\}\par
00223 {\cf21   GTEST_PRED3_(pred, v1, v2, v3, GTEST_FATAL_FAILURE_)}\par
00224 \par
00225 \par
00226 \par
00227 {\cf20 // Helper function for implementing \{EXPECT|ASSERT\}_PRED4.  Don't use}\par
00228 {\cf20 // this in your code.}\par
00229 {\cf17 template} <{\cf17 typename} Pred,\par
00230           {\cf17 typename} T1,\par
00231           {\cf17 typename} T2,\par
00232           {\cf17 typename} T3,\par
00233           {\cf17 typename} T4>\par
00234 AssertionResult AssertPred4Helper({\cf17 const} {\cf18 char}* pred_text,\par
00235                                   {\cf17 const} {\cf18 char}* e1,\par
00236                                   {\cf17 const} {\cf18 char}* e2,\par
00237                                   {\cf17 const} {\cf18 char}* e3,\par
00238                                   {\cf17 const} {\cf18 char}* e4,\par
00239                                   Pred pred,\par
00240                                   {\cf17 const} T1& v1,\par
00241                                   {\cf17 const} T2& v2,\par
00242                                   {\cf17 const} T3& v3,\par
00243                                   {\cf17 const} T4& v4) \{\par
00244   {\cf19 if} (pred(v1, v2, v3, v4)) {\cf19 return} AssertionSuccess();\par
00245 \par
00246   {\cf19 return} AssertionFailure() << pred_text << {\cf22 "("}\par
00247                             << e1 << {\cf22 ", "}\par
00248                             << e2 << {\cf22 ", "}\par
00249                             << e3 << {\cf22 ", "}\par
00250                             << e4 << {\cf22 ") evaluates to false, where"}\par
00251                             << {\cf22 "\\n"} << e1 << {\cf22 " evaluates to "} << v1\par
00252                             << {\cf22 "\\n"} << e2 << {\cf22 " evaluates to "} << v2\par
00253                             << {\cf22 "\\n"} << e3 << {\cf22 " evaluates to "} << v3\par
00254                             << {\cf22 "\\n"} << e4 << {\cf22 " evaluates to "} << v4;\par
00255 \}\par
00256 \par
00257 {\cf20 // Internal macro for implementing \{EXPECT|ASSERT\}_PRED_FORMAT4.}\par
00258 {\cf20 // Don't use this in your code.}\par
00259 {\cf21 #define GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, on_failure)\\}\par
00260 {\cf21   GTEST_ASSERT_(pred_format(#v1, #v2, #v3, #v4, v1, v2, v3, v4), \\}\par
00261 {\cf21                 on_failure)}\par
00262 \par
00263 {\cf20 // Internal macro for implementing \{EXPECT|ASSERT\}_PRED4.  Don't use}\par
00264 {\cf20 // this in your code.}\par
00265 {\cf21 #define GTEST_PRED4_(pred, v1, v2, v3, v4, on_failure)\\}\par
00266 {\cf21   GTEST_ASSERT_(::testing::AssertPred4Helper(#pred, \\}\par
00267 {\cf21                                              #v1, \\}\par
00268 {\cf21                                              #v2, \\}\par
00269 {\cf21                                              #v3, \\}\par
00270 {\cf21                                              #v4, \\}\par
00271 {\cf21                                              pred, \\}\par
00272 {\cf21                                              v1, \\}\par
00273 {\cf21                                              v2, \\}\par
00274 {\cf21                                              v3, \\}\par
00275 {\cf21                                              v4), on_failure)}\par
00276 \par
00277 {\cf20 // 4-ary predicate assertion macros.}\par
00278 {\cf21 #define EXPECT_PRED_FORMAT4(pred_format, v1, v2, v3, v4) \\}\par
00279 {\cf21   GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, GTEST_NONFATAL_FAILURE_)}\par
00280 {\cf21 #define EXPECT_PRED4(pred, v1, v2, v3, v4) \\}\par
00281 {\cf21   GTEST_PRED4_(pred, v1, v2, v3, v4, GTEST_NONFATAL_FAILURE_)}\par
00282 {\cf21 #define ASSERT_PRED_FORMAT4(pred_format, v1, v2, v3, v4) \\}\par
00283 {\cf21   GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, GTEST_FATAL_FAILURE_)}\par
00284 {\cf21 #define ASSERT_PRED4(pred, v1, v2, v3, v4) \\}\par
00285 {\cf21   GTEST_PRED4_(pred, v1, v2, v3, v4, GTEST_FATAL_FAILURE_)}\par
00286 \par
00287 \par
00288 \par
00289 {\cf20 // Helper function for implementing \{EXPECT|ASSERT\}_PRED5.  Don't use}\par
00290 {\cf20 // this in your code.}\par
00291 {\cf17 template} <{\cf17 typename} Pred,\par
00292           {\cf17 typename} T1,\par
00293           {\cf17 typename} T2,\par
00294           {\cf17 typename} T3,\par
00295           {\cf17 typename} T4,\par
00296           {\cf17 typename} T5>\par
00297 AssertionResult AssertPred5Helper({\cf17 const} {\cf18 char}* pred_text,\par
00298                                   {\cf17 const} {\cf18 char}* e1,\par
00299                                   {\cf17 const} {\cf18 char}* e2,\par
00300                                   {\cf17 const} {\cf18 char}* e3,\par
00301                                   {\cf17 const} {\cf18 char}* e4,\par
00302                                   {\cf17 const} {\cf18 char}* e5,\par
00303                                   Pred pred,\par
00304                                   {\cf17 const} T1& v1,\par
00305                                   {\cf17 const} T2& v2,\par
00306                                   {\cf17 const} T3& v3,\par
00307                                   {\cf17 const} T4& v4,\par
00308                                   {\cf17 const} T5& v5) \{\par
00309   {\cf19 if} (pred(v1, v2, v3, v4, v5)) {\cf19 return} AssertionSuccess();\par
00310 \par
00311   {\cf19 return} AssertionFailure() << pred_text << {\cf22 "("}\par
00312                             << e1 << {\cf22 ", "}\par
00313                             << e2 << {\cf22 ", "}\par
00314                             << e3 << {\cf22 ", "}\par
00315                             << e4 << {\cf22 ", "}\par
00316                             << e5 << {\cf22 ") evaluates to false, where"}\par
00317                             << {\cf22 "\\n"} << e1 << {\cf22 " evaluates to "} << v1\par
00318                             << {\cf22 "\\n"} << e2 << {\cf22 " evaluates to "} << v2\par
00319                             << {\cf22 "\\n"} << e3 << {\cf22 " evaluates to "} << v3\par
00320                             << {\cf22 "\\n"} << e4 << {\cf22 " evaluates to "} << v4\par
00321                             << {\cf22 "\\n"} << e5 << {\cf22 " evaluates to "} << v5;\par
00322 \}\par
00323 \par
00324 {\cf20 // Internal macro for implementing \{EXPECT|ASSERT\}_PRED_FORMAT5.}\par
00325 {\cf20 // Don't use this in your code.}\par
00326 {\cf21 #define GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, on_failure)\\}\par
00327 {\cf21   GTEST_ASSERT_(pred_format(#v1, #v2, #v3, #v4, #v5, v1, v2, v3, v4, v5), \\}\par
00328 {\cf21                 on_failure)}\par
00329 \par
00330 {\cf20 // Internal macro for implementing \{EXPECT|ASSERT\}_PRED5.  Don't use}\par
00331 {\cf20 // this in your code.}\par
00332 {\cf21 #define GTEST_PRED5_(pred, v1, v2, v3, v4, v5, on_failure)\\}\par
00333 {\cf21   GTEST_ASSERT_(::testing::AssertPred5Helper(#pred, \\}\par
00334 {\cf21                                              #v1, \\}\par
00335 {\cf21                                              #v2, \\}\par
00336 {\cf21                                              #v3, \\}\par
00337 {\cf21                                              #v4, \\}\par
00338 {\cf21                                              #v5, \\}\par
00339 {\cf21                                              pred, \\}\par
00340 {\cf21                                              v1, \\}\par
00341 {\cf21                                              v2, \\}\par
00342 {\cf21                                              v3, \\}\par
00343 {\cf21                                              v4, \\}\par
00344 {\cf21                                              v5), on_failure)}\par
00345 \par
00346 {\cf20 // 5-ary predicate assertion macros.}\par
00347 {\cf21 #define EXPECT_PRED_FORMAT5(pred_format, v1, v2, v3, v4, v5) \\}\par
00348 {\cf21   GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, GTEST_NONFATAL_FAILURE_)}\par
00349 {\cf21 #define EXPECT_PRED5(pred, v1, v2, v3, v4, v5) \\}\par
00350 {\cf21   GTEST_PRED5_(pred, v1, v2, v3, v4, v5, GTEST_NONFATAL_FAILURE_)}\par
00351 {\cf21 #define ASSERT_PRED_FORMAT5(pred_format, v1, v2, v3, v4, v5) \\}\par
00352 {\cf21   GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, GTEST_FATAL_FAILURE_)}\par
00353 {\cf21 #define ASSERT_PRED5(pred, v1, v2, v3, v4, v5) \\}\par
00354 {\cf21   GTEST_PRED5_(pred, v1, v2, v3, v4, v5, GTEST_FATAL_FAILURE_)}\par
00355 \par
00356 \par
00357 \par
00358 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/gtest_prod.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest_prod.h}
{\xe \v gtest/include/gtest/gtest_prod.h}
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FRIEND_TEST}(test_case_name,  test_name)\~ friend class test_case_name##_##test_name##_Test\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v FRIEND_TEST\:gtest_prod.h}
{\xe \v gtest_prod.h\:FRIEND_TEST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FRIEND_TEST( test_case_name,  test_name)\~ friend class test_case_name##_##test_name##_Test}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_prod.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 55}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest_prod.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/gtest_prod.h}
{\xe \v gtest/include/gtest/gtest_prod.h}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2006, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: wan@google.com (Zhanyong Wan)}\par
00031 {\cf20 //}\par
00032 {\cf20 // Google C++ Testing Framework definitions useful in production code.}\par
00033 \par
00034 {\cf21 #ifndef GTEST_INCLUDE_GTEST_GTEST_PROD_H_}\par
00035 {\cf21 #define GTEST_INCLUDE_GTEST_GTEST_PROD_H_}\par
00036 \par
00037 {\cf20 // When you need to test the private or protected members of a class,}\par
00038 {\cf20 // use the FRIEND_TEST macro to declare your tests as friends of the}\par
00039 {\cf20 // class.  For example:}\par
00040 {\cf20 //}\par
00041 {\cf20 // class MyClass \{}\par
00042 {\cf20 //  private:}\par
00043 {\cf20 //   void MyMethod();}\par
00044 {\cf20 //   FRIEND_TEST(MyClassTest, MyMethod);}\par
00045 {\cf20 // \};}\par
00046 {\cf20 //}\par
00047 {\cf20 // class MyClassTest : public testing::Test \{}\par
00048 {\cf20 //   // ...}\par
00049 {\cf20 // \};}\par
00050 {\cf20 //}\par
00051 {\cf20 // TEST_F(MyClassTest, MyMethod) \{}\par
00052 {\cf20 //   // Can call MyClass::MyMethod() here.}\par
00053 {\cf20 // \}}\par
00054 \par
00055 {\cf21 #define FRIEND_TEST(test_case_name, test_name)\\}\par
00056 {\cf21 friend class test_case_name##_##test_name##_Test}\par
00057 \par
00058 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_GTEST_PROD_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/internal/custom/gtest-port.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/custom/gtest-port.h}
{\xe \v gtest/include/gtest/internal/custom/gtest-port.h}
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-port.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/custom/gtest-port.h}
{\xe \v gtest/include/gtest/internal/custom/gtest-port.h}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2015, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Injection point for custom user configurations.}\par
00031 {\cf20 // The following macros can be defined:}\par
00032 {\cf20 //}\par
00033 {\cf20 //   Flag related macros:}\par
00034 {\cf20 //     GTEST_FLAG(flag_name)}\par
00035 {\cf20 //     GTEST_USE_OWN_FLAGFILE_FLAG_  - Define to 0 when the system provides its}\par
00036 {\cf20 //                                     own flagfile flag parsing.}\par
00037 {\cf20 //     GTEST_DECLARE_bool_(name)}\par
00038 {\cf20 //     GTEST_DECLARE_int32_(name)}\par
00039 {\cf20 //     GTEST_DECLARE_string_(name)}\par
00040 {\cf20 //     GTEST_DEFINE_bool_(name, default_val, doc)}\par
00041 {\cf20 //     GTEST_DEFINE_int32_(name, default_val, doc)}\par
00042 {\cf20 //     GTEST_DEFINE_string_(name, default_val, doc)}\par
00043 {\cf20 //}\par
00044 {\cf20 //   Test filtering:}\par
00045 {\cf20 //     GTEST_TEST_FILTER_ENV_VAR_ - The name of an environment variable that}\par
00046 {\cf20 //                                  will be used if --GTEST_FLAG(test_filter)}\par
00047 {\cf20 //                                  is not provided.}\par
00048 {\cf20 //}\par
00049 {\cf20 //   Logging:}\par
00050 {\cf20 //     GTEST_LOG_(severity)}\par
00051 {\cf20 //     GTEST_CHECK_(condition)}\par
00052 {\cf20 //     Functions LogToStderr() and FlushInfoLog() have to be provided too.}\par
00053 {\cf20 //}\par
00054 {\cf20 //   Threading:}\par
00055 {\cf20 //     GTEST_HAS_NOTIFICATION_ - Enabled if Notification is already provided.}\par
00056 {\cf20 //     GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ - Enabled if Mutex and ThreadLocal are}\par
00057 {\cf20 //                                         already provided.}\par
00058 {\cf20 //     Must also provide GTEST_DECLARE_STATIC_MUTEX_(mutex) and}\par
00059 {\cf20 //     GTEST_DEFINE_STATIC_MUTEX_(mutex)}\par
00060 {\cf20 //}\par
00061 {\cf20 //     GTEST_EXCLUSIVE_LOCK_REQUIRED_(locks)}\par
00062 {\cf20 //     GTEST_LOCK_EXCLUDED_(locks)}\par
00063 {\cf20 //}\par
00064 {\cf20 //   Exporting API symbols:}\par
00065 {\cf20 //     GTEST_API_ - Specifier for exported symbols.}\par
00066 {\cf20 //}\par
00067 {\cf20 // ** Custom implementation starts here **}\par
00068 \par
00069 {\cf21 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_}\par
00070 {\cf21 #define GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_}\par
00071 \par
00072 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/internal/gtest-port.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-port.h}
{\xe \v gtest/include/gtest/internal/gtest-port.h}
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <ctype.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <iostream>}\par
{\f2 #include <sstream>}\par
{\f2 #include <string>}\par
{\f2 #include <utility>}\par
{\f2 #include <vector>}\par
{\f2 #include "gtest/internal/gtest-port-arch.h"}\par
{\f2 #include "gtest/internal/custom/gtest-port.h"}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <strings.h>}\par
{\f2 #include <regex.h>}\par
{\f2 #include <typeinfo>}\par
{\f2 #include "gtest/internal/gtest-tuple.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::CompileAssert< bool >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::StaticAssertTypeEqHelper< T, T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::scoped_ptr< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::RE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::GTestLog}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::Mutex}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::GTestMutexLock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::ThreadLocal< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::bool_constant< bool_value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::is_pointer< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::is_pointer< T * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::IteratorTraits< Iterator >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::IteratorTraits< T * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::IteratorTraits< const T * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::TypeWithSize< size >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::TypeWithSize< 4 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::TypeWithSize< 8 >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal::posix}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_DEV_EMAIL_}\~ "googletestframework@@googlegroups.com"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_FLAG_PREFIX_}\~ "gtest_"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_FLAG_PREFIX_DASH_}\~ "gtest-"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_FLAG_PREFIX_UPPER_}\~ "GTEST_"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_NAME_}\~ "Google Test"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_PROJECT_URL_}\~ "https://github.com/google/googletest/"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_INIT_GOOGLE_TEST_NAME_}\~ "testing::InitGoogleTest"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_DISABLE_MSC_WARNINGS_PUSH_}(warnings)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_DISABLE_MSC_WARNINGS_POP_}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_LANG_CXX11}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_POSIX_RE}\~ (!GTEST_OS_WINDOWS)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_USES_POSIX_RE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_EXCEPTIONS}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_STD_STRING}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_GLOBAL_STRING}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_STD_WSTRING}\~     (!(GTEST_OS_LINUX_ANDROID || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_GLOBAL_WSTRING}\~     ({\b GTEST_HAS_STD_WSTRING} && {\b GTEST_HAS_GLOBAL_STRING})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_RTTI}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_PTHREAD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_TR1_TUPLE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_USE_OWN_TR1_TUPLE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_TUPLE_NAMESPACE_}\~ ::std::tr1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_CLONE}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_STREAM_REDIRECTION}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_PARAM_TEST}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_COMBINE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_WIDE_STRING_USES_UTF16_}\~     (GTEST_OS_WINDOWS || GTEST_OS_CYGWIN || GTEST_OS_SYMBIAN || GTEST_OS_AIX)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_AMBIGUOUS_ELSE_BLOCKER_}\~ switch (0) case 0: default:\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ATTRIBUTE_UNUSED_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ATTRIBUTE_PRINTF_}(string_index,  first_to_check)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_DISALLOW_ASSIGN_}(type)\~   void operator=(type const &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_DISALLOW_COPY_AND_ASSIGN_}(type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_MUST_USE_RESULT_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_INTENTIONAL_CONST_COND_PUSH_}()\~     {\b GTEST_DISABLE_MSC_WARNINGS_PUSH_}(4127)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_INTENTIONAL_CONST_COND_POP_}()\~     {\b GTEST_DISABLE_MSC_WARNINGS_POP_}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_SEH}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_IS_THREADSAFE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_API_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_NO_INLINE_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_CXXABI_H_}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_COMPILE_ASSERT_}(expr,  msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ARRAY_SIZE_}(array)\~ (sizeof(array) / sizeof(array[0]))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_LOG_}(severity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_CHECK_}(condition)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_CHECK_POSIX_SUCCESS_}(posix_call)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_DECLARE_STATIC_MUTEX_}(mutex)\~   extern {\b ::testing::internal::Mutex} mutex\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_DEFINE_STATIC_MUTEX_}(mutex)\~ {\b ::testing::internal::Mutex} mutex\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_CAN_COMPARE_NULL}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_PATH_SEP_}\~ "/"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_ALT_PATH_SEP_}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_SNPRINTF_}\~ snprintf\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_FLAG}(name)\~ FLAGS_gtest_##name\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_USE_OWN_FLAGFILE_FLAG_}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_FLAG_SAVER_}\~ {\b ::testing::internal::GTestFlagSaver}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_DECLARE_bool_}(name)\~ {\b GTEST_API_} extern bool {\b GTEST_FLAG}(name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_DECLARE_int32_}(name)\~     {\b GTEST_API_} extern {\b ::testing::internal::Int32} {\b GTEST_FLAG}(name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_DECLARE_string_}(name)\~     {\b GTEST_API_} extern ::std::string {\b GTEST_FLAG}(name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_DEFINE_bool_}(name,  default_val,  doc)\~     {\b GTEST_API_} bool {\b GTEST_FLAG}(name) = (default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_DEFINE_int32_}(name,  default_val,  doc)\~     {\b GTEST_API_} {\b ::testing::internal::Int32} {\b GTEST_FLAG}(name) = (default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_DEFINE_string_}(name,  default_val,  doc)\~     {\b GTEST_API_} ::std::string {\b GTEST_FLAG}(name) = (default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_EXCLUSIVE_LOCK_REQUIRED_}(locks)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_LOCK_EXCLUDED_}(locks)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef ::std::string {\b testing::internal::string}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef ::std::wstring {\b testing::internal::wstring}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef GTestMutexLock {\b testing::internal::MutexLock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef bool_constant< false > {\b testing::internal::false_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef bool_constant< true > {\b testing::internal::true_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef long long {\b testing::internal::BiggestInt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct stat {\b testing::internal::posix::StatStruct}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef TypeWithSize< 4 >::Int {\b testing::internal::Int32}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef TypeWithSize< 4 >::UInt {\b testing::internal::UInt32}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef TypeWithSize< 8 >::Int {\b testing::internal::Int64}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef TypeWithSize< 8 >::UInt {\b testing::internal::UInt64}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef TypeWithSize< 8 >::Int {\b testing::internal::TimeInMillis}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b testing::internal::GTestLogSeverity} \{ {\b testing::internal::GTEST_INFO}
, {\b testing::internal::GTEST_WARNING}
, {\b testing::internal::GTEST_ERROR}
, {\b testing::internal::GTEST_FATAL}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::IsTrue} (bool condition)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GTEST_API_::std::string {\b testing::internal::FormatFileLocation} (const char *file, int line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GTEST_API_::std::string {\b testing::internal::FormatCompilerIndependentFileLocation} (const char *file, int line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::LogToStderr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::FlushInfoLog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > const T & {\b testing::internal::move} (const T &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename To > To {\b testing::internal::ImplicitCast_} (To x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename To , typename From > To {\b testing::internal::DownCast_} (From *f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Derived , class Base > Derived * {\b testing::internal::CheckedDowncastToActualType} (Base *base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::CaptureStdout} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::GetCapturedStdout} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::CaptureStderr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::GetCapturedStderr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} size_t {\b testing::internal::GetFileSize} (FILE *file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::ReadEntireFile} (FILE *file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} const ::std::vector< {\b testing::internal::string} > & {\b testing::internal::GetArgvs} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} size_t {\b testing::internal::GetThreadCount} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::IsAlpha} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::IsAlNum} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::IsDigit} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::IsLower} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::IsSpace} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::IsUpper} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::IsXDigit} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::IsXDigit} (wchar_t ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b testing::internal::ToLower} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b testing::internal::ToUpper} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b testing::internal::StripTrailingSpaces} (std::string str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b testing::internal::posix::FileNo} (FILE *file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b testing::internal::posix::IsATTY} (int fd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b testing::internal::posix::Stat} (const char *path, StatStruct *buf)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b testing::internal::posix::StrCaseCmp} (const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b testing::internal::posix::StrDup} (const char *src)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b testing::internal::posix::RmDir} (const char *dir)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::posix::IsDir} (const StatStruct &st)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b testing::internal::posix::StrNCpy} (char *dest, const char *src, size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b testing::internal::posix::ChDir} (const char *dir)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FILE * {\b testing::internal::posix::FOpen} (const char *path, const char *mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FILE * {\b testing::internal::posix::FReopen} (const char *path, const char *mode, FILE *stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FILE * {\b testing::internal::posix::FDOpen} (int fd, const char *mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b testing::internal::posix::FClose} (FILE *fp)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b testing::internal::posix::Read} (int fd, void *buf, unsigned int count)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b testing::internal::posix::Write} (int fd, const void *buf, unsigned int count)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b testing::internal::posix::Close} (int fd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b testing::internal::posix::StrError} (int errnum)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b testing::internal::posix::GetEnv} (const char *name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::posix::Abort} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::ParseInt32} (const Message &src_text, const char *str, Int32 *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::BoolFromGTestEnv} (const char *flag, bool default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} Int32 {\b testing::internal::Int32FromGTestEnv} (const char *flag, Int32 default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b testing::internal::StringFromGTestEnv} (const char *flag, const char *default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::TempDir} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const BiggestInt {\b testing::internal::kMaxBiggestInt}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v GTEST_AMBIGUOUS_ELSE_BLOCKER_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_AMBIGUOUS_ELSE_BLOCKER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_AMBIGUOUS_ELSE_BLOCKER_\~ switch (0) case 0: default:}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 853}}\par
}
{\xe \v GTEST_API_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_API_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_API_}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 969}}\par
}
{\xe \v GTEST_ARRAY_SIZE_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_ARRAY_SIZE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ARRAY_SIZE_( array)\~ (sizeof(array) / sizeof(array[0]))}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1127}}\par
}
{\xe \v GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1008}}\par
}
{\xe \v GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 996}}\par
}
{\xe \v GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1020}}\par
}
{\xe \v GTEST_ATTRIBUTE_PRINTF_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_ATTRIBUTE_PRINTF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ATTRIBUTE_PRINTF_( string_index,  first_to_check)}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 892}}\par
}
{\xe \v GTEST_ATTRIBUTE_UNUSED_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_ATTRIBUTE_UNUSED_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ATTRIBUTE_UNUSED_}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 875}}\par
}
{\xe \v GTEST_CAN_COMPARE_NULL\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_CAN_COMPARE_NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_CAN_COMPARE_NULL\~ 1}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2223}}\par
}
{\xe \v GTEST_CHECK_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_CHECK_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_CHECK_( condition)}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\par
    if (::testing::internal::IsTrue(condition)) \\\par
      ; \\\par
    else \\\par
      GTEST_LOG_(FATAL) << {\cf22 "Condition "} #condition {\cf22 " failed. "}\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1330}}\par
}
{\xe \v GTEST_CHECK_POSIX_SUCCESS_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_CHECK_POSIX_SUCCESS_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_CHECK_POSIX_SUCCESS_( posix_call)}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   {\cf19 if} ({\cf17 const} {\cf18 int} gtest_error = (posix_call)) \\\par
    GTEST_LOG_(FATAL) << #posix_call << {\cf22 "failed with error "} \\\par
                      << gtest_error\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1343}}\par
}
{\xe \v GTEST_COMPILE_ASSERT_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_COMPILE_ASSERT_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_COMPILE_ASSERT_( expr,  msg)}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   typedef ::testing::internal::CompileAssert<(static_cast<bool>(expr))> \\\par
      msg[{\cf17 static_cast<}{\cf18 bool}{\cf17 >}(expr) ? 1 : -1] GTEST_ATTRIBUTE_UNUSED_\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1067}}\par
}
{\xe \v GTEST_DECLARE_bool_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_DECLARE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_DECLARE_bool_( name)\~ {\b GTEST_API_} extern bool {\b GTEST_FLAG}(name)}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2547}}\par
}
{\xe \v GTEST_DECLARE_int32_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_DECLARE_int32_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_DECLARE_int32_( name)\~     {\b GTEST_API_} extern {\b ::testing::internal::Int32} {\b GTEST_FLAG}(name)}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2548}}\par
}
{\xe \v GTEST_DECLARE_STATIC_MUTEX_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_DECLARE_STATIC_MUTEX_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_DECLARE_STATIC_MUTEX_( mutex)\~   extern {\b ::testing::internal::Mutex} mutex}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2176}}\par
}
{\xe \v GTEST_DECLARE_string_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_DECLARE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_DECLARE_string_( name)\~     {\b GTEST_API_} extern ::std::string {\b GTEST_FLAG}(name)}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2550}}\par
}
{\xe \v GTEST_DEFINE_bool_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_DEFINE_bool_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_DEFINE_bool_( name,  default_val,  doc)\~     {\b GTEST_API_} bool {\b GTEST_FLAG}(name) = (default_val)}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2554}}\par
}
{\xe \v GTEST_DEFINE_int32_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_DEFINE_int32_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_DEFINE_int32_( name,  default_val,  doc)\~     {\b GTEST_API_} {\b ::testing::internal::Int32} {\b GTEST_FLAG}(name) = (default_val)}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2556}}\par
}
{\xe \v GTEST_DEFINE_STATIC_MUTEX_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_DEFINE_STATIC_MUTEX_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_DEFINE_STATIC_MUTEX_( mutex)\~ {\b ::testing::internal::Mutex} mutex}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2179}}\par
}
{\xe \v GTEST_DEFINE_string_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_DEFINE_string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_DEFINE_string_( name,  default_val,  doc)\~     {\b GTEST_API_} ::std::string {\b GTEST_FLAG}(name) = (default_val)}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2558}}\par
}
{\xe \v GTEST_DEV_EMAIL_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_DEV_EMAIL_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_DEV_EMAIL_\~ "googletestframework@@googlegroups.com"}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 286}}\par
}
{\xe \v GTEST_DISABLE_MSC_WARNINGS_POP_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_DISABLE_MSC_WARNINGS_POP_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_DISABLE_MSC_WARNINGS_POP_()}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 319}}\par
}
{\xe \v GTEST_DISABLE_MSC_WARNINGS_PUSH_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_DISABLE_MSC_WARNINGS_PUSH_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_DISABLE_MSC_WARNINGS_PUSH_( warnings)}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 318}}\par
}
{\xe \v GTEST_DISALLOW_ASSIGN_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_DISALLOW_ASSIGN_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_DISALLOW_ASSIGN_( type)\~   void operator=(type const &)}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 897}}\par
}
{\xe \v GTEST_DISALLOW_COPY_AND_ASSIGN_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_DISALLOW_COPY_AND_ASSIGN_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_DISALLOW_COPY_AND_ASSIGN_( type)}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   type(type {\cf17 const} &);\\\par
  GTEST_DISALLOW_ASSIGN_(type)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 902}}\par
}
{\xe \v GTEST_EXCLUSIVE_LOCK_REQUIRED_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_EXCLUSIVE_LOCK_REQUIRED_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_EXCLUSIVE_LOCK_REQUIRED_( locks)}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2565}}\par
}
{\xe \v GTEST_FLAG\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_FLAG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_FLAG( name)\~ FLAGS_gtest_##name}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2536}}\par
}
{\xe \v GTEST_FLAG_PREFIX_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_FLAG_PREFIX_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_FLAG_PREFIX_\~ "gtest_"}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 287}}\par
}
{\xe \v GTEST_FLAG_PREFIX_DASH_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_FLAG_PREFIX_DASH_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_FLAG_PREFIX_DASH_\~ "gtest-"}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 288}}\par
}
{\xe \v GTEST_FLAG_PREFIX_UPPER_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_FLAG_PREFIX_UPPER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_FLAG_PREFIX_UPPER_\~ "GTEST_"}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 289}}\par
}
{\xe \v GTEST_FLAG_SAVER_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_FLAG_SAVER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_FLAG_SAVER_\~ {\b ::testing::internal::GTestFlagSaver}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2544}}\par
}
{\xe \v GTEST_HAS_ALT_PATH_SEP_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_ALT_PATH_SEP_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_ALT_PATH_SEP_\~ 0}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2272}}\par
}
{\xe \v GTEST_HAS_CLONE\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_CLONE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_CLONE\~ 0}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 778}}\par
}
{\xe \v GTEST_HAS_COMBINE\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_COMBINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_COMBINE\~ 1}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 828}}\par
}
{\xe \v GTEST_HAS_CXXABI_H_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_CXXABI_H_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_CXXABI_H_\~ 0}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 983}}\par
}
{\xe \v GTEST_HAS_EXCEPTIONS\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_EXCEPTIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_EXCEPTIONS\~ 0}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 498}}\par
}
{\xe \v GTEST_HAS_GLOBAL_STRING\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_GLOBAL_STRING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_GLOBAL_STRING\~ 0}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 515}}\par
}
{\xe \v GTEST_HAS_GLOBAL_WSTRING\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_GLOBAL_WSTRING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_GLOBAL_WSTRING\~     ({\b GTEST_HAS_STD_WSTRING} && {\b GTEST_HAS_GLOBAL_STRING})}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 536}}\par
}
{\xe \v GTEST_HAS_PARAM_TEST\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_PARAM_TEST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_PARAM_TEST\~ 1}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 811}}\par
}
{\xe \v GTEST_HAS_POSIX_RE\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_POSIX_RE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_POSIX_RE\~ (!GTEST_OS_WINDOWS)}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 429}}\par
}
{\xe \v GTEST_HAS_PTHREAD\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_PTHREAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_PTHREAD}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_HPUX \\\par
    || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NACL || GTEST_OS_NETBSD)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 610}}\par
}
{\xe \v GTEST_HAS_RTTI\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_RTTI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_RTTI\~ 1}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 591}}\par
}
{\xe \v GTEST_HAS_SEH\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_SEH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_SEH\~ 0}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 941}}\par
}
{\xe \v GTEST_HAS_STD_STRING\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_STD_STRING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_STD_STRING\~ 1}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 505}}\par
}
{\xe \v GTEST_HAS_STD_WSTRING\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_STD_WSTRING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_STD_WSTRING\~     (!(GTEST_OS_LINUX_ANDROID || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS))}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 528}}\par
}
{\xe \v GTEST_HAS_STREAM_REDIRECTION\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_STREAM_REDIRECTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_STREAM_REDIRECTION\~ 1}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 792}}\par
}
{\xe \v GTEST_HAS_TR1_TUPLE\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_HAS_TR1_TUPLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_TR1_TUPLE\~ 1}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 641}}\par
}
{\xe \v GTEST_INIT_GOOGLE_TEST_NAME_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_INIT_GOOGLE_TEST_NAME_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_INIT_GOOGLE_TEST_NAME_\~ "testing::InitGoogleTest"}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 295}}\par
}
{\xe \v GTEST_INTENTIONAL_CONST_COND_POP_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_INTENTIONAL_CONST_COND_POP_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_INTENTIONAL_CONST_COND_POP_()\~     {\b GTEST_DISABLE_MSC_WARNINGS_POP_}()}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 927}}\par
}
{\xe \v GTEST_INTENTIONAL_CONST_COND_PUSH_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_INTENTIONAL_CONST_COND_PUSH_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_INTENTIONAL_CONST_COND_PUSH_()\~     {\b GTEST_DISABLE_MSC_WARNINGS_PUSH_}(4127)}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 925}}\par
}
{\xe \v GTEST_IS_THREADSAFE\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_IS_THREADSAFE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_IS_THREADSAFE}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     (GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ \\\par
     || (GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT) \\\par
     || GTEST_HAS_PTHREAD)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 944}}\par
}
{\xe \v GTEST_LANG_CXX11\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_LANG_CXX11}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_LANG_CXX11\~ 0}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 331}}\par
}
{\xe \v GTEST_LOCK_EXCLUDED_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_LOCK_EXCLUDED_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_LOCK_EXCLUDED_( locks)}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2566}}\par
}
{\xe \v GTEST_LOG_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_LOG_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_LOG_( severity)}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     ::testing::internal::GTestLog(::testing::internal::GTEST_##severity, \\\par
                                  __FILE__, __LINE__).GetStream()\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1306}}\par
}
{\xe \v GTEST_MUST_USE_RESULT_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_MUST_USE_RESULT_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_MUST_USE_RESULT_}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 914}}\par
}
{\xe \v GTEST_NAME_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_NAME_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_NAME_\~ "Google Test"}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 290}}\par
}
{\xe \v GTEST_NO_INLINE_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_NO_INLINE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_NO_INLINE_}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 976}}\par
}
{\xe \v GTEST_PATH_SEP_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_PATH_SEP_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_PATH_SEP_\~ "/"}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2271}}\par
}
{\xe \v GTEST_PROJECT_URL_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_PROJECT_URL_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_PROJECT_URL_\~ "https://github.com/google/googletest/"}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 291}}\par
}
{\xe \v GTEST_SNPRINTF_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_SNPRINTF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_SNPRINTF_\~ snprintf}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2461}}\par
}
{\xe \v GTEST_TUPLE_NAMESPACE_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_TUPLE_NAMESPACE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_TUPLE_NAMESPACE_\~ ::std::tr1}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 692}}\par
}
{\xe \v GTEST_USE_OWN_FLAGFILE_FLAG_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_USE_OWN_FLAGFILE_FLAG_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_USE_OWN_FLAGFILE_FLAG_\~ 1}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 2540}}\par
}
{\xe \v GTEST_USE_OWN_TR1_TUPLE\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_USE_OWN_TR1_TUPLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_USE_OWN_TR1_TUPLE\~ 1}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 675}}\par
}
{\xe \v GTEST_USES_POSIX_RE\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_USES_POSIX_RE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_USES_POSIX_RE\~ 1}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 444}}\par
}
{\xe \v GTEST_WIDE_STRING_USES_UTF16_\:gtest-port.h}
{\xe \v gtest-port.h\:GTEST_WIDE_STRING_USES_UTF16_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_WIDE_STRING_USES_UTF16_\~     (GTEST_OS_WINDOWS || GTEST_OS_CYGWIN || GTEST_OS_SYMBIAN || GTEST_OS_AIX)}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 832}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-port.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-port.h}
{\xe \v gtest/include/gtest/internal/gtest-port.h}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2005, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Authors: wan@google.com (Zhanyong Wan)}\par
00031 {\cf20 //}\par
00032 {\cf20 // Low-level types and utilities for porting Google Test to various}\par
00033 {\cf20 // platforms.  All macros ending with _ and symbols defined in an}\par
00034 {\cf20 // internal namespace are subject to change without notice.  Code}\par
00035 {\cf20 // outside Google Test MUST NOT USE THEM DIRECTLY.  Macros that don't}\par
00036 {\cf20 // end with _ are part of Google Test's public API and can be used by}\par
00037 {\cf20 // code outside Google Test.}\par
00038 {\cf20 //}\par
00039 {\cf20 // This file is fundamental to Google Test.  All other Google Test source}\par
00040 {\cf20 // files are expected to #include this.  Therefore, it cannot #include}\par
00041 {\cf20 // any other Google Test header.}\par
00042 \par
00043 {\cf21 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_}\par
00044 {\cf21 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_}\par
00045 \par
00046 {\cf20 // Environment-describing macros}\par
00047 {\cf20 // -----------------------------}\par
00048 {\cf20 //}\par
00049 {\cf20 // Google Test can be used in many different environments.  Macros in}\par
00050 {\cf20 // this section tell Google Test what kind of environment it is being}\par
00051 {\cf20 // used in, such that Google Test can provide environment-specific}\par
00052 {\cf20 // features and implementations.}\par
00053 {\cf20 //}\par
00054 {\cf20 // Google Test tries to automatically detect the properties of its}\par
00055 {\cf20 // environment, so users usually don't need to worry about these}\par
00056 {\cf20 // macros.  However, the automatic detection is not perfect.}\par
00057 {\cf20 // Sometimes it's necessary for a user to define some of the following}\par
00058 {\cf20 // macros in the build script to override Google Test's decisions.}\par
00059 {\cf20 //}\par
00060 {\cf20 // If the user doesn't define a macro in the list, Google Test will}\par
00061 {\cf20 // provide a default definition.  After this header is #included, all}\par
00062 {\cf20 // macros in this list will be defined to either 1 or 0.}\par
00063 {\cf20 //}\par
00064 {\cf20 // Notes to maintainers:}\par
00065 {\cf20 //   - Each macro here is a user-tweakable knob; do not grow the list}\par
00066 {\cf20 //     lightly.}\par
00067 {\cf20 //   - Use #if to key off these macros.  Don't use #ifdef or "#if}\par
00068 {\cf20 //     defined(...)", which will not work as these macros are ALWAYS}\par
00069 {\cf20 //     defined.}\par
00070 {\cf20 //}\par
00071 {\cf20 //   GTEST_HAS_CLONE          - Define it to 1/0 to indicate that clone(2)}\par
00072 {\cf20 //                              is/isn't available.}\par
00073 {\cf20 //   GTEST_HAS_EXCEPTIONS     - Define it to 1/0 to indicate that exceptions}\par
00074 {\cf20 //                              are enabled.}\par
00075 {\cf20 //   GTEST_HAS_GLOBAL_STRING  - Define it to 1/0 to indicate that ::string}\par
00076 {\cf20 //                              is/isn't available (some systems define}\par
00077 {\cf20 //                              ::string, which is different to std::string).}\par
00078 {\cf20 //   GTEST_HAS_GLOBAL_WSTRING - Define it to 1/0 to indicate that ::string}\par
00079 {\cf20 //                              is/isn't available (some systems define}\par
00080 {\cf20 //                              ::wstring, which is different to std::wstring).}\par
00081 {\cf20 //   GTEST_HAS_POSIX_RE       - Define it to 1/0 to indicate that POSIX regular}\par
00082 {\cf20 //                              expressions are/aren't available.}\par
00083 {\cf20 //   GTEST_HAS_PTHREAD        - Define it to 1/0 to indicate that <pthread.h>}\par
00084 {\cf20 //                              is/isn't available.}\par
00085 {\cf20 //   GTEST_HAS_RTTI           - Define it to 1/0 to indicate that RTTI is/isn't}\par
00086 {\cf20 //                              enabled.}\par
00087 {\cf20 //   GTEST_HAS_STD_WSTRING    - Define it to 1/0 to indicate that}\par
00088 {\cf20 //                              std::wstring does/doesn't work (Google Test can}\par
00089 {\cf20 //                              be used where std::wstring is unavailable).}\par
00090 {\cf20 //   GTEST_HAS_TR1_TUPLE      - Define it to 1/0 to indicate tr1::tuple}\par
00091 {\cf20 //                              is/isn't available.}\par
00092 {\cf20 //   GTEST_HAS_SEH            - Define it to 1/0 to indicate whether the}\par
00093 {\cf20 //                              compiler supports Microsoft's "Structured}\par
00094 {\cf20 //                              Exception Handling".}\par
00095 {\cf20 //   GTEST_HAS_STREAM_REDIRECTION}\par
00096 {\cf20 //                            - Define it to 1/0 to indicate whether the}\par
00097 {\cf20 //                              platform supports I/O stream redirection using}\par
00098 {\cf20 //                              dup() and dup2().}\par
00099 {\cf20 //   GTEST_USE_OWN_TR1_TUPLE  - Define it to 1/0 to indicate whether Google}\par
00100 {\cf20 //                              Test's own tr1 tuple implementation should be}\par
00101 {\cf20 //                              used.  Unused when the user sets}\par
00102 {\cf20 //                              GTEST_HAS_TR1_TUPLE to 0.}\par
00103 {\cf20 //   GTEST_LANG_CXX11         - Define it to 1/0 to indicate that Google Test}\par
00104 {\cf20 //                              is building in C++11/C++98 mode.}\par
00105 {\cf20 //   GTEST_LINKED_AS_SHARED_LIBRARY}\par
00106 {\cf20 //                            - Define to 1 when compiling tests that use}\par
00107 {\cf20 //                              Google Test as a shared library (known as}\par
00108 {\cf20 //                              DLL on Windows).}\par
00109 {\cf20 //   GTEST_CREATE_SHARED_LIBRARY}\par
00110 {\cf20 //                            - Define to 1 when compiling Google Test itself}\par
00111 {\cf20 //                              as a shared library.}\par
00112 \par
00113 {\cf20 // Platform-indicating macros}\par
00114 {\cf20 // --------------------------}\par
00115 {\cf20 //}\par
00116 {\cf20 // Macros indicating the platform on which Google Test is being used}\par
00117 {\cf20 // (a macro is defined to 1 if compiled on the given platform;}\par
00118 {\cf20 // otherwise UNDEFINED -- it's never defined to 0.).  Google Test}\par
00119 {\cf20 // defines these macros automatically.  Code outside Google Test MUST}\par
00120 {\cf20 // NOT define them.}\par
00121 {\cf20 //}\par
00122 {\cf20 //   GTEST_OS_AIX      - IBM AIX}\par
00123 {\cf20 //   GTEST_OS_CYGWIN   - Cygwin}\par
00124 {\cf20 //   GTEST_OS_FREEBSD  - FreeBSD}\par
00125 {\cf20 //   GTEST_OS_HPUX     - HP-UX}\par
00126 {\cf20 //   GTEST_OS_LINUX    - Linux}\par
00127 {\cf20 //     GTEST_OS_LINUX_ANDROID - Google Android}\par
00128 {\cf20 //   GTEST_OS_MAC      - Mac OS X}\par
00129 {\cf20 //     GTEST_OS_IOS    - iOS}\par
00130 {\cf20 //   GTEST_OS_NACL     - Google Native Client (NaCl)}\par
00131 {\cf20 //   GTEST_OS_NETBSD   - NetBSD}\par
00132 {\cf20 //   GTEST_OS_OPENBSD  - OpenBSD}\par
00133 {\cf20 //   GTEST_OS_QNX      - QNX}\par
00134 {\cf20 //   GTEST_OS_SOLARIS  - Sun Solaris}\par
00135 {\cf20 //   GTEST_OS_SYMBIAN  - Symbian}\par
00136 {\cf20 //   GTEST_OS_WINDOWS  - Windows (Desktop, MinGW, or Mobile)}\par
00137 {\cf20 //     GTEST_OS_WINDOWS_DESKTOP  - Windows Desktop}\par
00138 {\cf20 //     GTEST_OS_WINDOWS_MINGW    - MinGW}\par
00139 {\cf20 //     GTEST_OS_WINDOWS_MOBILE   - Windows Mobile}\par
00140 {\cf20 //     GTEST_OS_WINDOWS_PHONE    - Windows Phone}\par
00141 {\cf20 //     GTEST_OS_WINDOWS_RT       - Windows Store App/WinRT}\par
00142 {\cf20 //   GTEST_OS_ZOS      - z/OS}\par
00143 {\cf20 //}\par
00144 {\cf20 // Among the platforms, Cygwin, Linux, Max OS X, and Windows have the}\par
00145 {\cf20 // most stable support.  Since core members of the Google Test project}\par
00146 {\cf20 // don't have access to other platforms, support for them may be less}\par
00147 {\cf20 // stable.  If you notice any problems on your platform, please notify}\par
00148 {\cf20 // googletestframework@googlegroups.com (patches for fixing them are}\par
00149 {\cf20 // even more welcome!).}\par
00150 {\cf20 //}\par
00151 {\cf20 // It is possible that none of the GTEST_OS_* macros are defined.}\par
00152 \par
00153 {\cf20 // Feature-indicating macros}\par
00154 {\cf20 // -------------------------}\par
00155 {\cf20 //}\par
00156 {\cf20 // Macros indicating which Google Test features are available (a macro}\par
00157 {\cf20 // is defined to 1 if the corresponding feature is supported;}\par
00158 {\cf20 // otherwise UNDEFINED -- it's never defined to 0.).  Google Test}\par
00159 {\cf20 // defines these macros automatically.  Code outside Google Test MUST}\par
00160 {\cf20 // NOT define them.}\par
00161 {\cf20 //}\par
00162 {\cf20 // These macros are public so that portable tests can be written.}\par
00163 {\cf20 // Such tests typically surround code using a feature with an #if}\par
00164 {\cf20 // which controls that code.  For example:}\par
00165 {\cf20 //}\par
00166 {\cf20 // #if GTEST_HAS_DEATH_TEST}\par
00167 {\cf20 //   EXPECT_DEATH(DoSomethingDeadly());}\par
00168 {\cf20 // #endif}\par
00169 {\cf20 //}\par
00170 {\cf20 //   GTEST_HAS_COMBINE      - the Combine() function (for value-parameterized}\par
00171 {\cf20 //                            tests)}\par
00172 {\cf20 //   GTEST_HAS_DEATH_TEST   - death tests}\par
00173 {\cf20 //   GTEST_HAS_PARAM_TEST   - value-parameterized tests}\par
00174 {\cf20 //   GTEST_HAS_TYPED_TEST   - typed tests}\par
00175 {\cf20 //   GTEST_HAS_TYPED_TEST_P - type-parameterized tests}\par
00176 {\cf20 //   GTEST_IS_THREADSAFE    - Google Test is thread-safe.}\par
00177 {\cf20 //   GTEST_USES_POSIX_RE    - enhanced POSIX regex is used. Do not confuse with}\par
00178 {\cf20 //                            GTEST_HAS_POSIX_RE (see above) which users can}\par
00179 {\cf20 //                            define themselves.}\par
00180 {\cf20 //   GTEST_USES_SIMPLE_RE   - our own simple regex is used;}\par
00181 {\cf20 //                            the above two are mutually exclusive.}\par
00182 {\cf20 //   GTEST_CAN_COMPARE_NULL - accepts untyped NULL in EXPECT_EQ().}\par
00183 \par
00184 {\cf20 // Misc public macros}\par
00185 {\cf20 // ------------------}\par
00186 {\cf20 //}\par
00187 {\cf20 //   GTEST_FLAG(flag_name)  - references the variable corresponding to}\par
00188 {\cf20 //                            the given Google Test flag.}\par
00189 \par
00190 {\cf20 // Internal utilities}\par
00191 {\cf20 // ------------------}\par
00192 {\cf20 //}\par
00193 {\cf20 // The following macros and utilities are for Google Test's INTERNAL}\par
00194 {\cf20 // use only.  Code outside Google Test MUST NOT USE THEM DIRECTLY.}\par
00195 {\cf20 //}\par
00196 {\cf20 // Macros for basic C++ coding:}\par
00197 {\cf20 //   GTEST_AMBIGUOUS_ELSE_BLOCKER_ - for disabling a gcc warning.}\par
00198 {\cf20 //   GTEST_ATTRIBUTE_UNUSED_  - declares that a class' instances or a}\par
00199 {\cf20 //                              variable don't have to be used.}\par
00200 {\cf20 //   GTEST_DISALLOW_ASSIGN_   - disables operator=.}\par
00201 {\cf20 //   GTEST_DISALLOW_COPY_AND_ASSIGN_ - disables copy ctor and operator=.}\par
00202 {\cf20 //   GTEST_MUST_USE_RESULT_   - declares that a function's result must be used.}\par
00203 {\cf20 //   GTEST_INTENTIONAL_CONST_COND_PUSH_ - start code section where MSVC C4127 is}\par
00204 {\cf20 //                                        suppressed (constant conditional).}\par
00205 {\cf20 //   GTEST_INTENTIONAL_CONST_COND_POP_  - finish code section where MSVC C4127}\par
00206 {\cf20 //                                        is suppressed.}\par
00207 {\cf20 //}\par
00208 {\cf20 // C++11 feature wrappers:}\par
00209 {\cf20 //}\par
00210 {\cf20 //   testing::internal::move  - portability wrapper for std::move.}\par
00211 {\cf20 //}\par
00212 {\cf20 // Synchronization:}\par
00213 {\cf20 //   Mutex, MutexLock, ThreadLocal, GetThreadCount()}\par
00214 {\cf20 //                            - synchronization primitives.}\par
00215 {\cf20 //}\par
00216 {\cf20 // Template meta programming:}\par
00217 {\cf20 //   is_pointer     - as in TR1; needed on Symbian and IBM XL C/C++ only.}\par
00218 {\cf20 //   IteratorTraits - partial implementation of std::iterator_traits, which}\par
00219 {\cf20 //                    is not available in libCstd when compiled with Sun C++.}\par
00220 {\cf20 //}\par
00221 {\cf20 // Smart pointers:}\par
00222 {\cf20 //   scoped_ptr     - as in TR2.}\par
00223 {\cf20 //}\par
00224 {\cf20 // Regular expressions:}\par
00225 {\cf20 //   RE             - a simple regular expression class using the POSIX}\par
00226 {\cf20 //                    Extended Regular Expression syntax on UNIX-like}\par
00227 {\cf20 //                    platforms, or a reduced regular exception syntax on}\par
00228 {\cf20 //                    other platforms, including Windows.}\par
00229 {\cf20 //}\par
00230 {\cf20 // Logging:}\par
00231 {\cf20 //   GTEST_LOG_()   - logs messages at the specified severity level.}\par
00232 {\cf20 //   LogToStderr()  - directs all log messages to stderr.}\par
00233 {\cf20 //   FlushInfoLog() - flushes informational log messages.}\par
00234 {\cf20 //}\par
00235 {\cf20 // Stdout and stderr capturing:}\par
00236 {\cf20 //   CaptureStdout()     - starts capturing stdout.}\par
00237 {\cf20 //   GetCapturedStdout() - stops capturing stdout and returns the captured}\par
00238 {\cf20 //                         string.}\par
00239 {\cf20 //   CaptureStderr()     - starts capturing stderr.}\par
00240 {\cf20 //   GetCapturedStderr() - stops capturing stderr and returns the captured}\par
00241 {\cf20 //                         string.}\par
00242 {\cf20 //}\par
00243 {\cf20 // Integer types:}\par
00244 {\cf20 //   TypeWithSize   - maps an integer to a int type.}\par
00245 {\cf20 //   Int32, UInt32, Int64, UInt64, TimeInMillis}\par
00246 {\cf20 //                  - integers of known sizes.}\par
00247 {\cf20 //   BiggestInt     - the biggest signed integer type.}\par
00248 {\cf20 //}\par
00249 {\cf20 // Command-line utilities:}\par
00250 {\cf20 //   GTEST_DECLARE_*()  - declares a flag.}\par
00251 {\cf20 //   GTEST_DEFINE_*()   - defines a flag.}\par
00252 {\cf20 //   GetInjectableArgvs() - returns the command line as a vector of strings.}\par
00253 {\cf20 //}\par
00254 {\cf20 // Environment variable utilities:}\par
00255 {\cf20 //   GetEnv()             - gets the value of an environment variable.}\par
00256 {\cf20 //   BoolFromGTestEnv()   - parses a bool environment variable.}\par
00257 {\cf20 //   Int32FromGTestEnv()  - parses an Int32 environment variable.}\par
00258 {\cf20 //   StringFromGTestEnv() - parses a string environment variable.}\par
00259 \par
00260 {\cf21 #include <ctype.h>}   {\cf20 // for isspace, etc}\par
00261 {\cf21 #include <stddef.h>}  {\cf20 // for ptrdiff_t}\par
00262 {\cf21 #include <stdlib.h>}\par
00263 {\cf21 #include <stdio.h>}\par
00264 {\cf21 #include <string.h>}\par
00265 {\cf21 #ifndef _WIN32_WCE}\par
00266 {\cf21 # include <sys/types.h>}\par
00267 {\cf21 # include <sys/stat.h>}\par
00268 {\cf21 #endif  }{\cf20 // !_WIN32_WCE}\par
00269 \par
00270 {\cf21 #if defined __APPLE__}\par
00271 {\cf21 # include <AvailabilityMacros.h>}\par
00272 {\cf21 # include <TargetConditionals.h>}\par
00273 {\cf21 #endif}\par
00274 \par
00275 {\cf21 #include <algorithm>}  {\cf20 // NOLINT}\par
00276 {\cf21 #include <iostream>}  {\cf20 // NOLINT}\par
00277 {\cf21 #include <sstream>}  {\cf20 // NOLINT}\par
00278 {\cf21 #include <string>}  {\cf20 // NOLINT}\par
00279 {\cf21 #include <utility>}\par
00280 {\cf21 #include <vector>}  {\cf20 // NOLINT}\par
00281 \par
00282 {\cf21 #include "gtest/internal/gtest-port-arch.h"}\par
00283 {\cf21 #include "gtest/internal/custom/gtest-port.h"}\par
00284 \par
00285 {\cf21 #if !defined(GTEST_DEV_EMAIL_)}\par
00286 {\cf21 # define GTEST_DEV_EMAIL_ "googletestframework@@googlegroups.com"}\par
00287 {\cf21 # define GTEST_FLAG_PREFIX_ "gtest_"}\par
00288 {\cf21 # define GTEST_FLAG_PREFIX_DASH_ "gtest-"}\par
00289 {\cf21 # define GTEST_FLAG_PREFIX_UPPER_ "GTEST_"}\par
00290 {\cf21 # define GTEST_NAME_ "Google Test"}\par
00291 {\cf21 # define GTEST_PROJECT_URL_ "https://github.com/google/googletest/"}\par
00292 {\cf21 #endif  }{\cf20 // !defined(GTEST_DEV_EMAIL_)}\par
00293 \par
00294 {\cf21 #if !defined(GTEST_INIT_GOOGLE_TEST_NAME_)}\par
00295 {\cf21 # define GTEST_INIT_GOOGLE_TEST_NAME_ "testing::InitGoogleTest"}\par
00296 {\cf21 #endif  }{\cf20 // !defined(GTEST_INIT_GOOGLE_TEST_NAME_)}\par
00297 \par
00298 {\cf20 // Determines the version of gcc that is used to compile this.}\par
00299 {\cf21 #ifdef __GNUC__}\par
00300 {\cf20 // 40302 means version 4.3.2.}\par
00301 {\cf21 # define GTEST_GCC_VER_ \\}\par
00302 {\cf21     (__GNUC__*10000 + __GNUC_MINOR__*100 + __GNUC_PATCHLEVEL__)}\par
00303 {\cf21 #endif  }{\cf20 // __GNUC__}\par
00304 \par
00305 {\cf20 // Macros for disabling Microsoft Visual C++ warnings.}\par
00306 {\cf20 //}\par
00307 {\cf20 //   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 4385)}\par
00308 {\cf20 //   /* code that triggers warnings C4800 and C4385 */}\par
00309 {\cf20 //   GTEST_DISABLE_MSC_WARNINGS_POP_()}\par
00310 {\cf21 #if _MSC_VER >= 1500}\par
00311 {\cf21 # define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings) \\}\par
00312 {\cf21     __pragma(warning(push))                        \\}\par
00313 {\cf21     __pragma(warning(disable: warnings))}\par
00314 {\cf21 # define GTEST_DISABLE_MSC_WARNINGS_POP_()          \\}\par
00315 {\cf21     __pragma(warning(pop))}\par
00316 {\cf21 #else}\par
00317 {\cf20 // Older versions of MSVC don't have __pragma.}\par
00318 {\cf21 # define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings)}\par
00319 {\cf21 # define GTEST_DISABLE_MSC_WARNINGS_POP_()}\par
00320 {\cf21 #endif}\par
00321 \par
00322 {\cf21 #ifndef GTEST_LANG_CXX11}\par
00323 {\cf20 // gcc and clang define __GXX_EXPERIMENTAL_CXX0X__ when}\par
00324 {\cf20 // -std=\{c,gnu\}++\{0x,11\} is passed.  The C++11 standard specifies a}\par
00325 {\cf20 // value for __cplusplus, and recent versions of clang, gcc, and}\par
00326 {\cf20 // probably other compilers set that too in C++11 mode.}\par
00327 {\cf21 # if __GXX_EXPERIMENTAL_CXX0X__ || __cplusplus >= 201103L}\par
00328 {\cf20 // Compiling in at least C++11 mode.}\par
00329 {\cf21 #  define GTEST_LANG_CXX11 1}\par
00330 {\cf21 # else}\par
00331 {\cf21 #  define GTEST_LANG_CXX11 0}\par
00332 {\cf21 # endif}\par
00333 {\cf21 #endif}\par
00334 \par
00335 {\cf20 // Distinct from C++11 language support, some environments don't provide}\par
00336 {\cf20 // proper C++11 library support. Notably, it's possible to build in}\par
00337 {\cf20 // C++11 mode when targeting Mac OS X 10.6, which has an old libstdc++}\par
00338 {\cf20 // with no C++11 support.}\par
00339 {\cf20 //}\par
00340 {\cf20 // libstdc++ has sufficient C++11 support as of GCC 4.6.0, __GLIBCXX__}\par
00341 {\cf20 // 20110325, but maintenance releases in the 4.4 and 4.5 series followed}\par
00342 {\cf20 // this date, so check for those versions by their date stamps.}\par
00343 {\cf20 // https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html#abi.versioning}\par
00344 {\cf21 #if GTEST_LANG_CXX11 && \\}\par
00345 {\cf21     (!defined(__GLIBCXX__) || ( \\}\par
00346 {\cf21         __GLIBCXX__ >= 20110325ul &&  }{\cf20 /* GCC >= 4.6.0 */}{\cf21  \\}\par
00347 {\cf21         }{\cf20 /* Blacklist of patch releases of older branches: */}{\cf21  \\}\par
00348 {\cf21         __GLIBCXX__ != 20110416ul &&  }{\cf20 /* GCC 4.4.6 */}{\cf21  \\}\par
00349 {\cf21         __GLIBCXX__ != 20120313ul &&  }{\cf20 /* GCC 4.4.7 */}{\cf21  \\}\par
00350 {\cf21         __GLIBCXX__ != 20110428ul &&  }{\cf20 /* GCC 4.5.3 */}{\cf21  \\}\par
00351 {\cf21         __GLIBCXX__ != 20120702ul))   }{\cf20 /* GCC 4.5.4 */}{\cf21 }\par
00352 {\cf21 # define GTEST_STDLIB_CXX11 1}\par
00353 {\cf21 #endif}\par
00354 \par
00355 {\cf20 // Only use C++11 library features if the library provides them.}\par
00356 {\cf21 #if GTEST_STDLIB_CXX11}\par
00357 {\cf21 # define GTEST_HAS_STD_BEGIN_AND_END_ 1}\par
00358 {\cf21 # define GTEST_HAS_STD_FORWARD_LIST_ 1}\par
00359 {\cf21 # define GTEST_HAS_STD_FUNCTION_ 1}\par
00360 {\cf21 # define GTEST_HAS_STD_INITIALIZER_LIST_ 1}\par
00361 {\cf21 # define GTEST_HAS_STD_MOVE_ 1}\par
00362 {\cf21 # define GTEST_HAS_STD_SHARED_PTR_ 1}\par
00363 {\cf21 # define GTEST_HAS_STD_TYPE_TRAITS_ 1}\par
00364 {\cf21 # define GTEST_HAS_STD_UNIQUE_PTR_ 1}\par
00365 {\cf21 #endif}\par
00366 \par
00367 {\cf20 // C++11 specifies that <tuple> provides std::tuple.}\par
00368 {\cf20 // Some platforms still might not have it, however.}\par
00369 {\cf21 #if GTEST_LANG_CXX11}\par
00370 {\cf21 # define GTEST_HAS_STD_TUPLE_ 1}\par
00371 {\cf21 # if defined(__clang__)}\par
00372 {\cf20 // Inspired by http://clang.llvm.org/docs/LanguageExtensions.html#__has_include}\par
00373 {\cf21 #  if defined(__has_include) && !__has_include(<tuple>)}\par
00374 {\cf21 #   undef GTEST_HAS_STD_TUPLE_}\par
00375 {\cf21 #  endif}\par
00376 {\cf21 # elif defined(_MSC_VER)}\par
00377 {\cf20 // Inspired by boost/config/stdlib/dinkumware.hpp}\par
00378 {\cf21 #  if defined(_CPPLIB_VER) && _CPPLIB_VER < 520}\par
00379 {\cf21 #   undef GTEST_HAS_STD_TUPLE_}\par
00380 {\cf21 #  endif}\par
00381 {\cf21 # elif defined(__GLIBCXX__)}\par
00382 {\cf20 // Inspired by boost/config/stdlib/libstdcpp3.hpp,}\par
00383 {\cf20 // http://gcc.gnu.org/gcc-4.2/changes.html and}\par
00384 {\cf20 // http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt01ch01.html#manual.intro.status.standard.200x}\par
00385 {\cf21 #  if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 2)}\par
00386 {\cf21 #   undef GTEST_HAS_STD_TUPLE_}\par
00387 {\cf21 #  endif}\par
00388 {\cf21 # endif}\par
00389 {\cf21 #endif}\par
00390 \par
00391 {\cf20 // Brings in definitions for functions used in the testing::internal::posix}\par
00392 {\cf20 // namespace (read, write, close, chdir, isatty, stat). We do not currently}\par
00393 {\cf20 // use them on Windows Mobile.}\par
00394 {\cf21 #if GTEST_OS_WINDOWS}\par
00395 {\cf21 # if !GTEST_OS_WINDOWS_MOBILE}\par
00396 {\cf21 #  include <direct.h>}\par
00397 {\cf21 #  include <io.h>}\par
00398 {\cf21 # endif}\par
00399 {\cf20 // In order to avoid having to include <windows.h>, use forward declaration}\par
00400 {\cf21 #if GTEST_OS_WINDOWS_MINGW && !defined(__MINGW64_VERSION_MAJOR)}\par
00401 {\cf20 // MinGW defined _CRITICAL_SECTION and _RTL_CRITICAL_SECTION as two}\par
00402 {\cf20 // separate (equivalent) structs, instead of using typedef}\par
00403 {\cf17 typedef} {\cf17 struct }_CRITICAL_SECTION GTEST_CRITICAL_SECTION;\par
00404 {\cf21 #else}\par
00405 {\cf20 // Assume CRITICAL_SECTION is a typedef of _RTL_CRITICAL_SECTION.}\par
00406 {\cf20 // This assumption is verified by}\par
00407 {\cf20 // WindowsTypesTest.CRITICAL_SECTIONIs_RTL_CRITICAL_SECTION.}\par
00408 {\cf17 typedef} {\cf17 struct }_RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;\par
00409 {\cf21 #endif}\par
00410 {\cf21 #else}\par
00411 {\cf20 // This assumes that non-Windows OSes provide unistd.h. For OSes where this}\par
00412 {\cf20 // is not the case, we need to include headers that provide the functions}\par
00413 {\cf20 // mentioned above.}\par
00414 {\cf21 # include <unistd.h>}\par
00415 {\cf21 # include <strings.h>}\par
00416 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
00417 \par
00418 {\cf21 #if GTEST_OS_LINUX_ANDROID}\par
00419 {\cf20 // Used to define __ANDROID_API__ matching the target NDK API level.}\par
00420 {\cf21 #  include <android/api-level.h>}  {\cf20 // NOLINT}\par
00421 {\cf21 #endif}\par
00422 \par
00423 {\cf20 // Defines this to true iff Google Test can use POSIX regular expressions.}\par
00424 {\cf21 #ifndef GTEST_HAS_POSIX_RE}\par
00425 {\cf21 # if GTEST_OS_LINUX_ANDROID}\par
00426 {\cf20 // On Android, <regex.h> is only available starting with Gingerbread.}\par
00427 {\cf21 #  define GTEST_HAS_POSIX_RE (__ANDROID_API__ >= 9)}\par
00428 {\cf21 # else}\par
00429 {\cf21 #  define GTEST_HAS_POSIX_RE (!GTEST_OS_WINDOWS)}\par
00430 {\cf21 # endif}\par
00431 {\cf21 #endif}\par
00432 \par
00433 {\cf21 #if GTEST_USES_PCRE}\par
00434 {\cf20 // The appropriate headers have already been included.}\par
00435 \par
00436 {\cf21 #elif GTEST_HAS_POSIX_RE}\par
00437 \par
00438 {\cf20 // On some platforms, <regex.h> needs someone to define size_t, and}\par
00439 {\cf20 // won't compile otherwise.  We can #include it here as we already}\par
00440 {\cf20 // included <stdlib.h>, which is guaranteed to define size_t through}\par
00441 {\cf20 // <stddef.h>.}\par
00442 {\cf21 # include <regex.h>}  {\cf20 // NOLINT}\par
00443 \par
00444 {\cf21 # define GTEST_USES_POSIX_RE 1}\par
00445 \par
00446 {\cf21 #elif GTEST_OS_WINDOWS}\par
00447 \par
00448 {\cf20 // <regex.h> is not available on Windows.  Use our own simple regex}\par
00449 {\cf20 // implementation instead.}\par
00450 {\cf21 # define GTEST_USES_SIMPLE_RE 1}\par
00451 \par
00452 {\cf21 #else}\par
00453 \par
00454 {\cf20 // <regex.h> may not be available on this platform.  Use our own}\par
00455 {\cf20 // simple regex implementation instead.}\par
00456 {\cf21 # define GTEST_USES_SIMPLE_RE 1}\par
00457 \par
00458 {\cf21 #endif  }{\cf20 // GTEST_USES_PCRE}\par
00459 \par
00460 {\cf21 #ifndef GTEST_HAS_EXCEPTIONS}\par
00461 {\cf20 // The user didn't tell us whether exceptions are enabled, so we need}\par
00462 {\cf20 // to figure it out.}\par
00463 {\cf21 # if defined(_MSC_VER) || defined(__BORLANDC__)}\par
00464 {\cf20 // MSVC's and C++Builder's implementations of the STL use the _HAS_EXCEPTIONS}\par
00465 {\cf20 // macro to enable exceptions, so we'll do the same.}\par
00466 {\cf20 // Assumes that exceptions are enabled by default.}\par
00467 {\cf21 #  ifndef _HAS_EXCEPTIONS}\par
00468 {\cf21 #   define _HAS_EXCEPTIONS 1}\par
00469 {\cf21 #  endif  }{\cf20 // _HAS_EXCEPTIONS}\par
00470 {\cf21 #  define GTEST_HAS_EXCEPTIONS _HAS_EXCEPTIONS}\par
00471 {\cf21 # elif defined(__clang__)}\par
00472 {\cf20 // clang defines __EXCEPTIONS iff exceptions are enabled before clang 220714,}\par
00473 {\cf20 // but iff cleanups are enabled after that. In Obj-C++ files, there can be}\par
00474 {\cf20 // cleanups for ObjC exceptions which also need cleanups, even if C++ exceptions}\par
00475 {\cf20 // are disabled. clang has __has_feature(cxx_exceptions) which checks for C++}\par
00476 {\cf20 // exceptions starting at clang r206352, but which checked for cleanups prior to}\par
00477 {\cf20 // that. To reliably check for C++ exception availability with clang, check for}\par
00478 {\cf20 // __EXCEPTIONS && __has_feature(cxx_exceptions).}\par
00479 {\cf21 #  define GTEST_HAS_EXCEPTIONS (__EXCEPTIONS && __has_feature(cxx_exceptions))}\par
00480 {\cf21 # elif defined(__GNUC__) && __EXCEPTIONS}\par
00481 {\cf20 // gcc defines __EXCEPTIONS to 1 iff exceptions are enabled.}\par
00482 {\cf21 #  define GTEST_HAS_EXCEPTIONS 1}\par
00483 {\cf21 # elif defined(__SUNPRO_CC)}\par
00484 {\cf20 // Sun Pro CC supports exceptions.  However, there is no compile-time way of}\par
00485 {\cf20 // detecting whether they are enabled or not.  Therefore, we assume that}\par
00486 {\cf20 // they are enabled unless the user tells us otherwise.}\par
00487 {\cf21 #  define GTEST_HAS_EXCEPTIONS 1}\par
00488 {\cf21 # elif defined(__IBMCPP__) && __EXCEPTIONS}\par
00489 {\cf20 // xlC defines __EXCEPTIONS to 1 iff exceptions are enabled.}\par
00490 {\cf21 #  define GTEST_HAS_EXCEPTIONS 1}\par
00491 {\cf21 # elif defined(__HP_aCC)}\par
00492 {\cf20 // Exception handling is in effect by default in HP aCC compiler. It has to}\par
00493 {\cf20 // be turned of by +noeh compiler option if desired.}\par
00494 {\cf21 #  define GTEST_HAS_EXCEPTIONS 1}\par
00495 {\cf21 # else}\par
00496 {\cf20 // For other compilers, we assume exceptions are disabled to be}\par
00497 {\cf20 // conservative.}\par
00498 {\cf21 #  define GTEST_HAS_EXCEPTIONS 0}\par
00499 {\cf21 # endif  }{\cf20 // defined(_MSC_VER) || defined(__BORLANDC__)}\par
00500 {\cf21 #endif  }{\cf20 // GTEST_HAS_EXCEPTIONS}\par
00501 \par
00502 {\cf21 #if !defined(GTEST_HAS_STD_STRING)}\par
00503 {\cf20 // Even though we don't use this macro any longer, we keep it in case}\par
00504 {\cf20 // some clients still depend on it.}\par
00505 {\cf21 # define GTEST_HAS_STD_STRING 1}\par
00506 {\cf21 #elif !GTEST_HAS_STD_STRING}\par
00507 {\cf20 // The user told us that ::std::string isn't available.}\par
00508 {\cf21 # error "Google Test cannot be used where ::std::string isn't available."}\par
00509 {\cf21 #endif  }{\cf20 // !defined(GTEST_HAS_STD_STRING)}\par
00510 \par
00511 {\cf21 #ifndef GTEST_HAS_GLOBAL_STRING}\par
00512 {\cf20 // The user didn't tell us whether ::string is available, so we need}\par
00513 {\cf20 // to figure it out.}\par
00514 \par
00515 {\cf21 # define GTEST_HAS_GLOBAL_STRING 0}\par
00516 \par
00517 {\cf21 #endif  }{\cf20 // GTEST_HAS_GLOBAL_STRING}\par
00518 \par
00519 {\cf21 #ifndef GTEST_HAS_STD_WSTRING}\par
00520 {\cf20 // The user didn't tell us whether ::std::wstring is available, so we need}\par
00521 {\cf20 // to figure it out.}\par
00522 {\cf20 // TODO(wan@google.com): uses autoconf to detect whether ::std::wstring}\par
00523 {\cf20 //   is available.}\par
00524 \par
00525 {\cf20 // Cygwin 1.7 and below doesn't support ::std::wstring.}\par
00526 {\cf20 // Solaris' libc++ doesn't support it either.  Android has}\par
00527 {\cf20 // no support for it at least as recent as Froyo (2.2).}\par
00528 {\cf21 # define GTEST_HAS_STD_WSTRING \\}\par
00529 {\cf21     (!(GTEST_OS_LINUX_ANDROID || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS))}\par
00530 \par
00531 {\cf21 #endif  }{\cf20 // GTEST_HAS_STD_WSTRING}\par
00532 \par
00533 {\cf21 #ifndef GTEST_HAS_GLOBAL_WSTRING}\par
00534 {\cf20 // The user didn't tell us whether ::wstring is available, so we need}\par
00535 {\cf20 // to figure it out.}\par
00536 {\cf21 # define GTEST_HAS_GLOBAL_WSTRING \\}\par
00537 {\cf21     (GTEST_HAS_STD_WSTRING && GTEST_HAS_GLOBAL_STRING)}\par
00538 {\cf21 #endif  }{\cf20 // GTEST_HAS_GLOBAL_WSTRING}\par
00539 \par
00540 {\cf20 // Determines whether RTTI is available.}\par
00541 {\cf21 #ifndef GTEST_HAS_RTTI}\par
00542 {\cf20 // The user didn't tell us whether RTTI is enabled, so we need to}\par
00543 {\cf20 // figure it out.}\par
00544 \par
00545 {\cf21 # ifdef _MSC_VER}\par
00546 \par
00547 {\cf21 #  ifdef _CPPRTTI  }{\cf20 // MSVC defines this macro iff RTTI is enabled.}\par
00548 {\cf21 #   define GTEST_HAS_RTTI 1}\par
00549 {\cf21 #  else}\par
00550 {\cf21 #   define GTEST_HAS_RTTI 0}\par
00551 {\cf21 #  endif}\par
00552 \par
00553 {\cf20 // Starting with version 4.3.2, gcc defines __GXX_RTTI iff RTTI is enabled.}\par
00554 {\cf21 # elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40302)}\par
00555 \par
00556 {\cf21 #  ifdef __GXX_RTTI}\par
00557 {\cf20 // When building against STLport with the Android NDK and with}\par
00558 {\cf20 // -frtti -fno-exceptions, the build fails at link time with undefined}\par
00559 {\cf20 // references to __cxa_bad_typeid. Note sure if STL or toolchain bug,}\par
00560 {\cf20 // so disable RTTI when detected.}\par
00561 {\cf21 #   if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR) && \\}\par
00562 {\cf21        !defined(__EXCEPTIONS)}\par
00563 {\cf21 #    define GTEST_HAS_RTTI 0}\par
00564 {\cf21 #   else}\par
00565 {\cf21 #    define GTEST_HAS_RTTI 1}\par
00566 {\cf21 #   endif  }{\cf20 // GTEST_OS_LINUX_ANDROID && __STLPORT_MAJOR && !__EXCEPTIONS}\par
00567 {\cf21 #  else}\par
00568 {\cf21 #   define GTEST_HAS_RTTI 0}\par
00569 {\cf21 #  endif  }{\cf20 // __GXX_RTTI}\par
00570 \par
00571 {\cf20 // Clang defines __GXX_RTTI starting with version 3.0, but its manual recommends}\par
00572 {\cf20 // using has_feature instead. has_feature(cxx_rtti) is supported since 2.7, the}\par
00573 {\cf20 // first version with C++ support.}\par
00574 {\cf21 # elif defined(__clang__)}\par
00575 \par
00576 {\cf21 #  define GTEST_HAS_RTTI __has_feature(cxx_rtti)}\par
00577 \par
00578 {\cf20 // Starting with version 9.0 IBM Visual Age defines __RTTI_ALL__ to 1 if}\par
00579 {\cf20 // both the typeid and dynamic_cast features are present.}\par
00580 {\cf21 # elif defined(__IBMCPP__) && (__IBMCPP__ >= 900)}\par
00581 \par
00582 {\cf21 #  ifdef __RTTI_ALL__}\par
00583 {\cf21 #   define GTEST_HAS_RTTI 1}\par
00584 {\cf21 #  else}\par
00585 {\cf21 #   define GTEST_HAS_RTTI 0}\par
00586 {\cf21 #  endif}\par
00587 \par
00588 {\cf21 # else}\par
00589 \par
00590 {\cf20 // For all other compilers, we assume RTTI is enabled.}\par
00591 {\cf21 #  define GTEST_HAS_RTTI 1}\par
00592 \par
00593 {\cf21 # endif  }{\cf20 // _MSC_VER}\par
00594 \par
00595 {\cf21 #endif  }{\cf20 // GTEST_HAS_RTTI}\par
00596 \par
00597 {\cf20 // It's this header's responsibility to #include <typeinfo> when RTTI}\par
00598 {\cf20 // is enabled.}\par
00599 {\cf21 #if GTEST_HAS_RTTI}\par
00600 {\cf21 # include <typeinfo>}\par
00601 {\cf21 #endif}\par
00602 \par
00603 {\cf20 // Determines whether Google Test can use the pthreads library.}\par
00604 {\cf21 #ifndef GTEST_HAS_PTHREAD}\par
00605 {\cf20 // The user didn't tell us explicitly, so we make reasonable assumptions about}\par
00606 {\cf20 // which platforms have pthreads support.}\par
00607 {\cf20 //}\par
00608 {\cf20 // To disable threading support in Google Test, add -DGTEST_HAS_PTHREAD=0}\par
00609 {\cf20 // to your compiler flags.}\par
00610 {\cf21 # define GTEST_HAS_PTHREAD (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_HPUX \\}\par
00611 {\cf21     || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NACL || GTEST_OS_NETBSD)}\par
00612 {\cf21 #endif  }{\cf20 // GTEST_HAS_PTHREAD}\par
00613 \par
00614 {\cf21 #if GTEST_HAS_PTHREAD}\par
00615 {\cf20 // gtest-port.h guarantees to #include <pthread.h> when GTEST_HAS_PTHREAD is}\par
00616 {\cf20 // true.}\par
00617 {\cf21 # include <pthread.h>}  {\cf20 // NOLINT}\par
00618 \par
00619 {\cf20 // For timespec and nanosleep, used below.}\par
00620 {\cf21 # include <time.h>}  {\cf20 // NOLINT}\par
00621 {\cf21 #endif}\par
00622 \par
00623 {\cf20 // Determines if hash_map/hash_set are available.}\par
00624 {\cf20 // Only used for testing against those containers.}\par
00625 {\cf21 #if !defined(GTEST_HAS_HASH_MAP_)}\par
00626 {\cf21 # if defined(_MSC_VER) && (_MSC_VER < 1900)}\par
00627 {\cf21 #  define GTEST_HAS_HASH_MAP_ 1  }{\cf20 // Indicates that hash_map is available.}\par
00628 {\cf21 #  define GTEST_HAS_HASH_SET_ 1  }{\cf20 // Indicates that hash_set is available.}\par
00629 {\cf21 # endif  }{\cf20 // _MSC_VER}\par
00630 {\cf21 #endif  }{\cf20 // !defined(GTEST_HAS_HASH_MAP_)}\par
00631 \par
00632 {\cf20 // Determines whether Google Test can use tr1/tuple.  You can define}\par
00633 {\cf20 // this macro to 0 to prevent Google Test from using tuple (any}\par
00634 {\cf20 // feature depending on tuple with be disabled in this mode).}\par
00635 {\cf21 #ifndef GTEST_HAS_TR1_TUPLE}\par
00636 {\cf21 # if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR)}\par
00637 {\cf20 // STLport, provided with the Android NDK, has neither <tr1/tuple> or <tuple>.}\par
00638 {\cf21 #  define GTEST_HAS_TR1_TUPLE 0}\par
00639 {\cf21 # else}\par
00640 {\cf20 // The user didn't tell us not to do it, so we assume it's OK.}\par
00641 {\cf21 #  define GTEST_HAS_TR1_TUPLE 1}\par
00642 {\cf21 # endif}\par
00643 {\cf21 #endif  }{\cf20 // GTEST_HAS_TR1_TUPLE}\par
00644 \par
00645 {\cf20 // Determines whether Google Test's own tr1 tuple implementation}\par
00646 {\cf20 // should be used.}\par
00647 {\cf21 #ifndef GTEST_USE_OWN_TR1_TUPLE}\par
00648 {\cf20 // The user didn't tell us, so we need to figure it out.}\par
00649 \par
00650 {\cf20 // We use our own TR1 tuple if we aren't sure the user has an}\par
00651 {\cf20 // implementation of it already.  At this time, libstdc++ 4.0.0+ and}\par
00652 {\cf20 // MSVC 2010 are the only mainstream standard libraries that come}\par
00653 {\cf20 // with a TR1 tuple implementation.  NVIDIA's CUDA NVCC compiler}\par
00654 {\cf20 // pretends to be GCC by defining __GNUC__ and friends, but cannot}\par
00655 {\cf20 // compile GCC's tuple implementation.  MSVC 2008 (9.0) provides TR1}\par
00656 {\cf20 // tuple in a 323 MB Feature Pack download, which we cannot assume the}\par
00657 {\cf20 // user has.  QNX's QCC compiler is a modified GCC but it doesn't}\par
00658 {\cf20 // support TR1 tuple.  libc++ only provides std::tuple, in C++11 mode,}\par
00659 {\cf20 // and it can be used with some compilers that define __GNUC__.}\par
00660 {\cf21 # if (defined(__GNUC__) && !defined(__CUDACC__) && (GTEST_GCC_VER_ >= 40000) \\}\par
00661 {\cf21       && !GTEST_OS_QNX && !defined(_LIBCPP_VERSION)) || _MSC_VER >= 1600}\par
00662 {\cf21 #  define GTEST_ENV_HAS_TR1_TUPLE_ 1}\par
00663 {\cf21 # endif}\par
00664 \par
00665 {\cf20 // C++11 specifies that <tuple> provides std::tuple. Use that if gtest is used}\par
00666 {\cf20 // in C++11 mode and libstdc++ isn't very old (binaries targeting OS X 10.6}\par
00667 {\cf20 // can build with clang but need to use gcc4.2's libstdc++).}\par
00668 {\cf21 # if GTEST_LANG_CXX11 && (!defined(__GLIBCXX__) || __GLIBCXX__ > 20110325)}\par
00669 {\cf21 #  define GTEST_ENV_HAS_STD_TUPLE_ 1}\par
00670 {\cf21 # endif}\par
00671 \par
00672 {\cf21 # if GTEST_ENV_HAS_TR1_TUPLE_ || GTEST_ENV_HAS_STD_TUPLE_}\par
00673 {\cf21 #  define GTEST_USE_OWN_TR1_TUPLE 0}\par
00674 {\cf21 # else}\par
00675 {\cf21 #  define GTEST_USE_OWN_TR1_TUPLE 1}\par
00676 {\cf21 # endif}\par
00677 \par
00678 {\cf21 #endif  }{\cf20 // GTEST_USE_OWN_TR1_TUPLE}\par
00679 \par
00680 {\cf20 // To avoid conditional compilation everywhere, we make it}\par
00681 {\cf20 // gtest-port.h's responsibility to #include the header implementing}\par
00682 {\cf20 // tuple.}\par
00683 {\cf21 #if GTEST_HAS_STD_TUPLE_}\par
00684 {\cf21 # include <tuple>}  {\cf20 // IWYU pragma: export}\par
00685 {\cf21 # define GTEST_TUPLE_NAMESPACE_ ::std}\par
00686 {\cf21 #endif  }{\cf20 // GTEST_HAS_STD_TUPLE_}\par
00687 \par
00688 {\cf20 // We include tr1::tuple even if std::tuple is available to define printers for}\par
00689 {\cf20 // them.}\par
00690 {\cf21 #if GTEST_HAS_TR1_TUPLE}\par
00691 {\cf21 # ifndef GTEST_TUPLE_NAMESPACE_}\par
00692 {\cf21 #  define GTEST_TUPLE_NAMESPACE_ ::std::tr1}\par
00693 {\cf21 # endif  }{\cf20 // GTEST_TUPLE_NAMESPACE_}\par
00694 \par
00695 {\cf21 # if GTEST_USE_OWN_TR1_TUPLE}\par
00696 {\cf21 #  include "gtest/internal/gtest-tuple.h"}  {\cf20 // IWYU pragma: export  // NOLINT}\par
00697 {\cf21 # elif GTEST_ENV_HAS_STD_TUPLE_}\par
00698 {\cf21 #  include <tuple>}\par
00699 {\cf20 // C++11 puts its tuple into the ::std namespace rather than}\par
00700 {\cf20 // ::std::tr1.  gtest expects tuple to live in ::std::tr1, so put it there.}\par
00701 {\cf20 // This causes undefined behavior, but supported compilers react in}\par
00702 {\cf20 // the way we intend.}\par
00703 {\cf17 namespace }std \{\par
00704 {\cf17 namespace }tr1 \{\par
00705 using ::std::get;\par
00706 using ::std::make_tuple;\par
00707 using ::std::tuple;\par
00708 using ::std::tuple_element;\par
00709 using ::std::tuple_size;\par
00710 \}\par
00711 \}\par
00712 \par
00713 {\cf21 # elif GTEST_OS_SYMBIAN}\par
00714 \par
00715 {\cf20 // On Symbian, BOOST_HAS_TR1_TUPLE causes Boost's TR1 tuple library to}\par
00716 {\cf20 // use STLport's tuple implementation, which unfortunately doesn't}\par
00717 {\cf20 // work as the copy of STLport distributed with Symbian is incomplete.}\par
00718 {\cf20 // By making sure BOOST_HAS_TR1_TUPLE is undefined, we force Boost to}\par
00719 {\cf20 // use its own tuple implementation.}\par
00720 {\cf21 #  ifdef BOOST_HAS_TR1_TUPLE}\par
00721 {\cf21 #   undef BOOST_HAS_TR1_TUPLE}\par
00722 {\cf21 #  endif  }{\cf20 // BOOST_HAS_TR1_TUPLE}\par
00723 \par
00724 {\cf20 // This prevents <boost/tr1/detail/config.hpp>, which defines}\par
00725 {\cf20 // BOOST_HAS_TR1_TUPLE, from being #included by Boost's <tuple>.}\par
00726 {\cf21 #  define BOOST_TR1_DETAIL_CONFIG_HPP_INCLUDED}\par
00727 {\cf21 #  include <tuple>}  {\cf20 // IWYU pragma: export  // NOLINT}\par
00728 \par
00729 {\cf21 # elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40000)}\par
00730 {\cf20 // GCC 4.0+ implements tr1/tuple in the <tr1/tuple> header.  This does}\par
00731 {\cf20 // not conform to the TR1 spec, which requires the header to be <tuple>.}\par
00732 \par
00733 {\cf21 #  if !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302}\par
00734 {\cf20 // Until version 4.3.2, gcc has a bug that causes <tr1/functional>,}\par
00735 {\cf20 // which is #included by <tr1/tuple>, to not compile when RTTI is}\par
00736 {\cf20 // disabled.  _TR1_FUNCTIONAL is the header guard for}\par
00737 {\cf20 // <tr1/functional>.  Hence the following #define is a hack to prevent}\par
00738 {\cf20 // <tr1/functional> from being included.}\par
00739 {\cf21 #   define _TR1_FUNCTIONAL 1}\par
00740 {\cf21 #   include <tr1/tuple>}\par
00741 {\cf21 #   undef _TR1_FUNCTIONAL  }{\cf20 // Allows the user to #include}\par
00742                         {\cf20 // <tr1/functional> if he chooses to.}\par
00743 {\cf21 #  else}\par
00744 {\cf21 #   include <tr1/tuple>}  {\cf20 // NOLINT}\par
00745 {\cf21 #  endif  }{\cf20 // !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302}\par
00746 \par
00747 {\cf21 # else}\par
00748 {\cf20 // If the compiler is not GCC 4.0+, we assume the user is using a}\par
00749 {\cf20 // spec-conforming TR1 implementation.}\par
00750 {\cf21 #  include <tuple>}  {\cf20 // IWYU pragma: export  // NOLINT}\par
00751 {\cf21 # endif  }{\cf20 // GTEST_USE_OWN_TR1_TUPLE}\par
00752 \par
00753 {\cf21 #endif  }{\cf20 // GTEST_HAS_TR1_TUPLE}\par
00754 \par
00755 {\cf20 // Determines whether clone(2) is supported.}\par
00756 {\cf20 // Usually it will only be available on Linux, excluding}\par
00757 {\cf20 // Linux on the Itanium architecture.}\par
00758 {\cf20 // Also see http://linux.die.net/man/2/clone.}\par
00759 {\cf21 #ifndef GTEST_HAS_CLONE}\par
00760 {\cf20 // The user didn't tell us, so we need to figure it out.}\par
00761 \par
00762 {\cf21 # if GTEST_OS_LINUX && !defined(__ia64__)}\par
00763 {\cf21 #  if GTEST_OS_LINUX_ANDROID}\par
00764 {\cf20 // On Android, clone() became available at different API levels for each 32-bit}\par
00765 {\cf20 // architecture.}\par
00766 {\cf21 #    if defined(__LP64__) || \\}\par
00767 {\cf21         (defined(__arm__) && __ANDROID_API__ >= 9) || \\}\par
00768 {\cf21         (defined(__mips__) && __ANDROID_API__ >= 12) || \\}\par
00769 {\cf21         (defined(__i386__) && __ANDROID_API__ >= 17)}\par
00770 {\cf21 #     define GTEST_HAS_CLONE 1}\par
00771 {\cf21 #    else}\par
00772 {\cf21 #     define GTEST_HAS_CLONE 0}\par
00773 {\cf21 #    endif}\par
00774 {\cf21 #  else}\par
00775 {\cf21 #   define GTEST_HAS_CLONE 1}\par
00776 {\cf21 #  endif}\par
00777 {\cf21 # else}\par
00778 {\cf21 #  define GTEST_HAS_CLONE 0}\par
00779 {\cf21 # endif  }{\cf20 // GTEST_OS_LINUX && !defined(__ia64__)}\par
00780 \par
00781 {\cf21 #endif  }{\cf20 // GTEST_HAS_CLONE}\par
00782 \par
00783 {\cf20 // Determines whether to support stream redirection. This is used to test}\par
00784 {\cf20 // output correctness and to implement death tests.}\par
00785 {\cf21 #ifndef GTEST_HAS_STREAM_REDIRECTION}\par
00786 {\cf20 // By default, we assume that stream redirection is supported on all}\par
00787 {\cf20 // platforms except known mobile ones.}\par
00788 {\cf21 # if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || \\}\par
00789 {\cf21     GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT}\par
00790 {\cf21 #  define GTEST_HAS_STREAM_REDIRECTION 0}\par
00791 {\cf21 # else}\par
00792 {\cf21 #  define GTEST_HAS_STREAM_REDIRECTION 1}\par
00793 {\cf21 # endif  }{\cf20 // !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_SYMBIAN}\par
00794 {\cf21 #endif  }{\cf20 // GTEST_HAS_STREAM_REDIRECTION}\par
00795 \par
00796 {\cf20 // Determines whether to support death tests.}\par
00797 {\cf20 // Google Test does not support death tests for VC 7.1 and earlier as}\par
00798 {\cf20 // abort() in a VC 7.1 application compiled as GUI in debug config}\par
00799 {\cf20 // pops up a dialog window that cannot be suppressed programmatically.}\par
00800 {\cf21 #if (GTEST_OS_LINUX || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || \\}\par
00801 {\cf21      (GTEST_OS_MAC && !GTEST_OS_IOS) || \\}\par
00802 {\cf21      (GTEST_OS_WINDOWS_DESKTOP && _MSC_VER >= 1400) || \\}\par
00803 {\cf21      GTEST_OS_WINDOWS_MINGW || GTEST_OS_AIX || GTEST_OS_HPUX || \\}\par
00804 {\cf21      GTEST_OS_OPENBSD || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NETBSD)}\par
00805 {\cf21 # define GTEST_HAS_DEATH_TEST 1}\par
00806 {\cf21 #endif}\par
00807 \par
00808 {\cf20 // We don't support MSVC 7.1 with exceptions disabled now.  Therefore}\par
00809 {\cf20 // all the compilers we care about are adequate for supporting}\par
00810 {\cf20 // value-parameterized tests.}\par
00811 {\cf21 #define GTEST_HAS_PARAM_TEST 1}\par
00812 \par
00813 {\cf20 // Determines whether to support type-driven tests.}\par
00814 \par
00815 {\cf20 // Typed tests need <typeinfo> and variadic macros, which GCC, VC++ 8.0,}\par
00816 {\cf20 // Sun Pro CC, IBM Visual Age, and HP aCC support.}\par
00817 {\cf21 #if defined(__GNUC__) || (_MSC_VER >= 1400) || defined(__SUNPRO_CC) || \\}\par
00818 {\cf21     defined(__IBMCPP__) || defined(__HP_aCC)}\par
00819 {\cf21 # define GTEST_HAS_TYPED_TEST 1}\par
00820 {\cf21 # define GTEST_HAS_TYPED_TEST_P 1}\par
00821 {\cf21 #endif}\par
00822 \par
00823 {\cf20 // Determines whether to support Combine(). This only makes sense when}\par
00824 {\cf20 // value-parameterized tests are enabled.  The implementation doesn't}\par
00825 {\cf20 // work on Sun Studio since it doesn't understand templated conversion}\par
00826 {\cf20 // operators.}\par
00827 {\cf21 #if GTEST_HAS_PARAM_TEST && GTEST_HAS_TR1_TUPLE && !defined(__SUNPRO_CC)}\par
00828 {\cf21 # define GTEST_HAS_COMBINE 1}\par
00829 {\cf21 #endif}\par
00830 \par
00831 {\cf20 // Determines whether the system compiler uses UTF-16 for encoding wide strings.}\par
00832 {\cf21 #define GTEST_WIDE_STRING_USES_UTF16_ \\}\par
00833 {\cf21     (GTEST_OS_WINDOWS || GTEST_OS_CYGWIN || GTEST_OS_SYMBIAN || GTEST_OS_AIX)}\par
00834 \par
00835 {\cf20 // Determines whether test results can be streamed to a socket.}\par
00836 {\cf21 #if GTEST_OS_LINUX}\par
00837 {\cf21 # define GTEST_CAN_STREAM_RESULTS_ 1}\par
00838 {\cf21 #endif}\par
00839 \par
00840 {\cf20 // Defines some utility macros.}\par
00841 \par
00842 {\cf20 // The GNU compiler emits a warning if nested "if" statements are followed by}\par
00843 {\cf20 // an "else" statement and braces are not used to explicitly disambiguate the}\par
00844 {\cf20 // "else" binding.  This leads to problems with code like:}\par
00845 {\cf20 //}\par
00846 {\cf20 //   if (gate)}\par
00847 {\cf20 //     ASSERT_*(condition) << "Some message";}\par
00848 {\cf20 //}\par
00849 {\cf20 // The "switch (0) case 0:" idiom is used to suppress this.}\par
00850 {\cf21 #ifdef __INTEL_COMPILER}\par
00851 {\cf21 # define GTEST_AMBIGUOUS_ELSE_BLOCKER_}\par
00852 {\cf21 #else}\par
00853 {\cf21 # define GTEST_AMBIGUOUS_ELSE_BLOCKER_ switch (0) case 0: default:  }{\cf20 // NOLINT}\par
00854 {\cf21 #endif}\par
00855 \par
00856 {\cf20 // Use this annotation at the end of a struct/class definition to}\par
00857 {\cf20 // prevent the compiler from optimizing away instances that are never}\par
00858 {\cf20 // used.  This is useful when all interesting logic happens inside the}\par
00859 {\cf20 // c'tor and / or d'tor.  Example:}\par
00860 {\cf20 //}\par
00861 {\cf20 //   struct Foo \{}\par
00862 {\cf20 //     Foo() \{ ... \}}\par
00863 {\cf20 //   \} GTEST_ATTRIBUTE_UNUSED_;}\par
00864 {\cf20 //}\par
00865 {\cf20 // Also use it after a variable or parameter declaration to tell the}\par
00866 {\cf20 // compiler the variable/parameter does not have to be used.}\par
00867 {\cf21 #if defined(__GNUC__) && !defined(COMPILER_ICC)}\par
00868 {\cf21 # define GTEST_ATTRIBUTE_UNUSED_ __attribute__ ((unused))}\par
00869 {\cf21 #elif defined(__clang__)}\par
00870 {\cf21 # if __has_attribute(unused)}\par
00871 {\cf21 #  define GTEST_ATTRIBUTE_UNUSED_ __attribute__ ((unused))}\par
00872 {\cf21 # endif}\par
00873 {\cf21 #endif}\par
00874 {\cf21 #ifndef GTEST_ATTRIBUTE_UNUSED_}\par
00875 {\cf21 # define GTEST_ATTRIBUTE_UNUSED_}\par
00876 {\cf21 #endif}\par
00877 \par
00878 {\cf20 // Use this annotation before a function that takes a printf format string.}\par
00879 {\cf21 #if defined(__GNUC__) && !defined(COMPILER_ICC)}\par
00880 {\cf21 # if defined(__MINGW_PRINTF_FORMAT)}\par
00881 {\cf20 // MinGW has two different printf implementations. Ensure the format macro}\par
00882 {\cf20 // matches the selected implementation. See}\par
00883 {\cf20 // https://sourceforge.net/p/mingw-w64/wiki2/gnu%20printf/.}\par
00884 {\cf21 #  define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check) \\}\par
00885 {\cf21        __attribute__((__format__(__MINGW_PRINTF_FORMAT, string_index, \\}\par
00886 {\cf21                                  first_to_check)))}\par
00887 {\cf21 # else}\par
00888 {\cf21 #  define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check) \\}\par
00889 {\cf21        __attribute__((__format__(__printf__, string_index, first_to_check)))}\par
00890 {\cf21 # endif}\par
00891 {\cf21 #else}\par
00892 {\cf21 # define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check)}\par
00893 {\cf21 #endif}\par
00894 \par
00895 {\cf20 // A macro to disallow operator=}\par
00896 {\cf20 // This should be used in the private: declarations for a class.}\par
00897 {\cf21 #define GTEST_DISALLOW_ASSIGN_(type)\\}\par
00898 {\cf21   void operator=(type const &)}\par
00899 \par
00900 {\cf20 // A macro to disallow copy constructor and operator=}\par
00901 {\cf20 // This should be used in the private: declarations for a class.}\par
00902 {\cf21 #define GTEST_DISALLOW_COPY_AND_ASSIGN_(type)\\}\par
00903 {\cf21   type(type const &);\\}\par
00904 {\cf21   GTEST_DISALLOW_ASSIGN_(type)}\par
00905 \par
00906 {\cf20 // Tell the compiler to warn about unused return values for functions declared}\par
00907 {\cf20 // with this macro.  The macro should be used on function declarations}\par
00908 {\cf20 // following the argument list:}\par
00909 {\cf20 //}\par
00910 {\cf20 //   Sprocket* AllocateSprocket() GTEST_MUST_USE_RESULT_;}\par
00911 {\cf21 #if defined(__GNUC__) && (GTEST_GCC_VER_ >= 30400) && !defined(COMPILER_ICC)}\par
00912 {\cf21 # define GTEST_MUST_USE_RESULT_ __attribute__ ((warn_unused_result))}\par
00913 {\cf21 #else}\par
00914 {\cf21 # define GTEST_MUST_USE_RESULT_}\par
00915 {\cf21 #endif  }{\cf20 // __GNUC__ && (GTEST_GCC_VER_ >= 30400) && !COMPILER_ICC}\par
00916 \par
00917 {\cf20 // MS C++ compiler emits warning when a conditional expression is compile time}\par
00918 {\cf20 // constant. In some contexts this warning is false positive and needs to be}\par
00919 {\cf20 // suppressed. Use the following two macros in such cases:}\par
00920 {\cf20 //}\par
00921 {\cf20 // GTEST_INTENTIONAL_CONST_COND_PUSH_()}\par
00922 {\cf20 // while (true) \{}\par
00923 {\cf20 // GTEST_INTENTIONAL_CONST_COND_POP_()}\par
00924 {\cf20 // \}}\par
00925 {\cf21 # define GTEST_INTENTIONAL_CONST_COND_PUSH_() \\}\par
00926 {\cf21     GTEST_DISABLE_MSC_WARNINGS_PUSH_(4127)}\par
00927 {\cf21 # define GTEST_INTENTIONAL_CONST_COND_POP_() \\}\par
00928 {\cf21     GTEST_DISABLE_MSC_WARNINGS_POP_()}\par
00929 \par
00930 {\cf20 // Determine whether the compiler supports Microsoft's Structured Exception}\par
00931 {\cf20 // Handling.  This is supported by several Windows compilers but generally}\par
00932 {\cf20 // does not exist on any other system.}\par
00933 {\cf21 #ifndef GTEST_HAS_SEH}\par
00934 {\cf20 // The user didn't tell us, so we need to figure it out.}\par
00935 \par
00936 {\cf21 # if defined(_MSC_VER) || defined(__BORLANDC__)}\par
00937 {\cf20 // These two compilers are known to support SEH.}\par
00938 {\cf21 #  define GTEST_HAS_SEH 1}\par
00939 {\cf21 # else}\par
00940 {\cf20 // Assume no SEH.}\par
00941 {\cf21 #  define GTEST_HAS_SEH 0}\par
00942 {\cf21 # endif}\par
00943 \par
00944 {\cf21 #define GTEST_IS_THREADSAFE \\}\par
00945 {\cf21     (GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ \\}\par
00946 {\cf21      || (GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT) \\}\par
00947 {\cf21      || GTEST_HAS_PTHREAD)}\par
00948 \par
00949 {\cf21 #endif  }{\cf20 // GTEST_HAS_SEH}\par
00950 \par
00951 {\cf20 // GTEST_API_ qualifies all symbols that must be exported. The definitions below}\par
00952 {\cf20 // are guarded by #ifndef to give embedders a chance to define GTEST_API_ in}\par
00953 {\cf20 // gtest/internal/custom/gtest-port.h}\par
00954 {\cf21 #ifndef GTEST_API_}\par
00955 \par
00956 {\cf21 #ifdef _MSC_VER}\par
00957 {\cf21 # if GTEST_LINKED_AS_SHARED_LIBRARY}\par
00958 {\cf21 #  define GTEST_API_ __declspec(dllimport)}\par
00959 {\cf21 # elif GTEST_CREATE_SHARED_LIBRARY}\par
00960 {\cf21 #  define GTEST_API_ __declspec(dllexport)}\par
00961 {\cf21 # endif}\par
00962 {\cf21 #elif __GNUC__ >= 4 || defined(__clang__)}\par
00963 {\cf21 # define GTEST_API_ __attribute__((visibility ("default"})))\par
00964 {\cf21 #endif }{\cf20 // _MSC_VER}\par
00965 \par
00966 {\cf21 #endif }{\cf20 // GTEST_API_}\par
00967 \par
00968 {\cf21 #ifndef GTEST_API_}\par
00969 {\cf21 # define GTEST_API_}\par
00970 {\cf21 #endif }{\cf20 // GTEST_API_}\par
00971 \par
00972 {\cf21 #ifdef __GNUC__}\par
00973 {\cf20 // Ask the compiler to never inline a given function.}\par
00974 {\cf21 # define GTEST_NO_INLINE_ __attribute__((noinline))}\par
00975 {\cf21 #else}\par
00976 {\cf21 # define GTEST_NO_INLINE_}\par
00977 {\cf21 #endif}\par
00978 \par
00979 {\cf20 // _LIBCPP_VERSION is defined by the libc++ library from the LLVM project.}\par
00980 {\cf21 #if defined(__GLIBCXX__) || defined(_LIBCPP_VERSION)}\par
00981 {\cf21 # define GTEST_HAS_CXXABI_H_ 1}\par
00982 {\cf21 #else}\par
00983 {\cf21 # define GTEST_HAS_CXXABI_H_ 0}\par
00984 {\cf21 #endif}\par
00985 \par
00986 {\cf20 // A function level attribute to disable checking for use of uninitialized}\par
00987 {\cf20 // memory when built with MemorySanitizer.}\par
00988 {\cf21 #if defined(__clang__)}\par
00989 {\cf21 # if __has_feature(memory_sanitizer)}\par
00990 {\cf21 #  define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ \\}\par
00991 {\cf21        __attribute__((no_sanitize_memory))}\par
00992 {\cf21 # else}\par
00993 {\cf21 #  define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_}\par
00994 {\cf21 # endif  }{\cf20 // __has_feature(memory_sanitizer)}\par
00995 {\cf21 #else}\par
00996 {\cf21 # define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_}\par
00997 {\cf21 #endif  }{\cf20 // __clang__}\par
00998 \par
00999 {\cf20 // A function level attribute to disable AddressSanitizer instrumentation.}\par
01000 {\cf21 #if defined(__clang__)}\par
01001 {\cf21 # if __has_feature(address_sanitizer)}\par
01002 {\cf21 #  define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_ \\}\par
01003 {\cf21        __attribute__((no_sanitize_address))}\par
01004 {\cf21 # else}\par
01005 {\cf21 #  define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_}\par
01006 {\cf21 # endif  }{\cf20 // __has_feature(address_sanitizer)}\par
01007 {\cf21 #else}\par
01008 {\cf21 # define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_}\par
01009 {\cf21 #endif  }{\cf20 // __clang__}\par
01010 \par
01011 {\cf20 // A function level attribute to disable ThreadSanitizer instrumentation.}\par
01012 {\cf21 #if defined(__clang__)}\par
01013 {\cf21 # if __has_feature(thread_sanitizer)}\par
01014 {\cf21 #  define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_ \\}\par
01015 {\cf21        __attribute__((no_sanitize_thread))}\par
01016 {\cf21 # else}\par
01017 {\cf21 #  define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_}\par
01018 {\cf21 # endif  }{\cf20 // __has_feature(thread_sanitizer)}\par
01019 {\cf21 #else}\par
01020 {\cf21 # define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_}\par
01021 {\cf21 #endif  }{\cf20 // __clang__}\par
01022 \par
01023 {\cf17 namespace }testing \{\par
01024 \par
01025 {\cf17 class }Message;\par
01026 \par
01027 {\cf21 #if defined(GTEST_TUPLE_NAMESPACE_)}\par
01028 {\cf20 // Import tuple and friends into the ::testing namespace.}\par
01029 {\cf20 // It is part of our interface, having them in ::testing allows us to change}\par
01030 {\cf20 // their types as needed.}\par
01031 {\cf17 using} GTEST_TUPLE_NAMESPACE_::get;\par
01032 {\cf17 using} GTEST_TUPLE_NAMESPACE_::make_tuple;\par
01033 {\cf17 using} GTEST_TUPLE_NAMESPACE_::tuple;\par
01034 {\cf17 using} GTEST_TUPLE_NAMESPACE_::tuple_size;\par
01035 {\cf17 using} GTEST_TUPLE_NAMESPACE_::tuple_element;\par
01036 {\cf21 #endif  }{\cf20 // defined(GTEST_TUPLE_NAMESPACE_)}\par
01037 \par
01038 {\cf17 namespace }internal \{\par
01039 \par
01040 {\cf20 // A secret type that Google Test users don't know about.  It has no}\par
01041 {\cf20 // definition on purpose.  Therefore it's impossible to create a}\par
01042 {\cf20 // Secret object, which is what we want.}\par
01043 {\cf17 class }Secret;\par
01044 \par
01045 {\cf20 // The GTEST_COMPILE_ASSERT_ macro can be used to verify that a compile time}\par
01046 {\cf20 // expression is true. For example, you could use it to verify the}\par
01047 {\cf20 // size of a static array:}\par
01048 {\cf20 //}\par
01049 {\cf20 //   GTEST_COMPILE_ASSERT_(GTEST_ARRAY_SIZE_(names) == NUM_NAMES,}\par
01050 {\cf20 //                         names_incorrect_size);}\par
01051 {\cf20 //}\par
01052 {\cf20 // or to make sure a struct is smaller than a certain size:}\par
01053 {\cf20 //}\par
01054 {\cf20 //   GTEST_COMPILE_ASSERT_(sizeof(foo) < 128, foo_too_large);}\par
01055 {\cf20 //}\par
01056 {\cf20 // The second argument to the macro is the name of the variable. If}\par
01057 {\cf20 // the expression is false, most compilers will issue a warning/error}\par
01058 {\cf20 // containing the name of the variable.}\par
01059 \par
01060 {\cf21 #if GTEST_LANG_CXX11}\par
01061 {\cf21 # define GTEST_COMPILE_ASSERT_(expr, msg) static_assert(expr, #msg)}\par
01062 {\cf21 #else  }{\cf20 // !GTEST_LANG_CXX11}\par
01063 {\cf17 template} <{\cf18 bool}>\par
01064   {\cf17 struct }CompileAssert \{\par
01065 \};\par
01066 \par
01067 {\cf21 # define GTEST_COMPILE_ASSERT_(expr, msg) \\}\par
01068 {\cf21   typedef ::testing::internal::CompileAssert<(static_cast<bool>(expr))> \\}\par
01069 {\cf21       msg[static_cast<bool>(expr) ? 1 : -1] GTEST_ATTRIBUTE_UNUSED_}\par
01070 {\cf21 #endif  }{\cf20 // !GTEST_LANG_CXX11}\par
01071 \par
01072 {\cf20 // Implementation details of GTEST_COMPILE_ASSERT_:}\par
01073 {\cf20 //}\par
01074 {\cf20 // (In C++11, we simply use static_assert instead of the following)}\par
01075 {\cf20 //}\par
01076 {\cf20 // - GTEST_COMPILE_ASSERT_ works by defining an array type that has -1}\par
01077 {\cf20 //   elements (and thus is invalid) when the expression is false.}\par
01078 {\cf20 //}\par
01079 {\cf20 // - The simpler definition}\par
01080 {\cf20 //}\par
01081 {\cf20 //    #define GTEST_COMPILE_ASSERT_(expr, msg) typedef char msg[(expr) ? 1 : -1]}\par
01082 {\cf20 //}\par
01083 {\cf20 //   does not work, as gcc supports variable-length arrays whose sizes}\par
01084 {\cf20 //   are determined at run-time (this is gcc's extension and not part}\par
01085 {\cf20 //   of the C++ standard).  As a result, gcc fails to reject the}\par
01086 {\cf20 //   following code with the simple definition:}\par
01087 {\cf20 //}\par
01088 {\cf20 //     int foo;}\par
01089 {\cf20 //     GTEST_COMPILE_ASSERT_(foo, msg); // not supposed to compile as foo is}\par
01090 {\cf20 //                                      // not a compile-time constant.}\par
01091 {\cf20 //}\par
01092 {\cf20 // - By using the type CompileAssert<(bool(expr))>, we ensures that}\par
01093 {\cf20 //   expr is a compile-time constant.  (Template arguments must be}\par
01094 {\cf20 //   determined at compile-time.)}\par
01095 {\cf20 //}\par
01096 {\cf20 // - The outter parentheses in CompileAssert<(bool(expr))> are necessary}\par
01097 {\cf20 //   to work around a bug in gcc 3.4.4 and 4.0.1.  If we had written}\par
01098 {\cf20 //}\par
01099 {\cf20 //     CompileAssert<bool(expr)>}\par
01100 {\cf20 //}\par
01101 {\cf20 //   instead, these compilers will refuse to compile}\par
01102 {\cf20 //}\par
01103 {\cf20 //     GTEST_COMPILE_ASSERT_(5 > 0, some_message);}\par
01104 {\cf20 //}\par
01105 {\cf20 //   (They seem to think the ">" in "5 > 0" marks the end of the}\par
01106 {\cf20 //   template argument list.)}\par
01107 {\cf20 //}\par
01108 {\cf20 // - The array size is (bool(expr) ? 1 : -1), instead of simply}\par
01109 {\cf20 //}\par
01110 {\cf20 //     ((expr) ? 1 : -1).}\par
01111 {\cf20 //}\par
01112 {\cf20 //   This is to avoid running into a bug in MS VC 7.1, which}\par
01113 {\cf20 //   causes ((0.0) ? 1 : -1) to incorrectly evaluate to 1.}\par
01114 \par
01115 {\cf20 // StaticAssertTypeEqHelper is used by StaticAssertTypeEq defined in gtest.h.}\par
01116 {\cf20 //}\par
01117 {\cf20 // This template is declared, but intentionally undefined.}\par
01118 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
01119 {\cf17 struct }StaticAssertTypeEqHelper;\par
01120 \par
01121 {\cf17 template} <{\cf17 typename} T>\par
01122 {\cf17 struct }StaticAssertTypeEqHelper<T, T> \{\par
01123   {\cf17 enum} \{ value = {\cf17 true} \};\par
01124 \};\par
01125 \par
01126 {\cf20 // Evaluates to the number of elements in 'array'.}\par
01127 {\cf21 #define GTEST_ARRAY_SIZE_(array) (sizeof(array) / sizeof(array[0]))}\par
01128 \par
01129 {\cf21 #if GTEST_HAS_GLOBAL_STRING}\par
01130 {\cf17 typedef} ::string string;\par
01131 {\cf21 #else}\par
01132 {\cf17 typedef} ::std::string string;\par
01133 {\cf21 #endif  }{\cf20 // GTEST_HAS_GLOBAL_STRING}\par
01134 \par
01135 {\cf21 #if GTEST_HAS_GLOBAL_WSTRING}\par
01136 {\cf17 typedef} ::wstring wstring;\par
01137 {\cf21 #elif GTEST_HAS_STD_WSTRING}\par
01138 {\cf17 typedef} ::std::wstring wstring;\par
01139 {\cf21 #endif  }{\cf20 // GTEST_HAS_GLOBAL_WSTRING}\par
01140 \par
01141 {\cf20 // A helper for suppressing warnings on constant condition.  It just}\par
01142 {\cf20 // returns 'condition'.}\par
01143 GTEST_API_ {\cf18 bool} IsTrue({\cf18 bool} condition);\par
01144 \par
01145 {\cf20 // Defines scoped_ptr.}\par
01146 \par
01147 {\cf20 // This implementation of scoped_ptr is PARTIAL - it only contains}\par
01148 {\cf20 // enough stuff to satisfy Google Test's need.}\par
01149 {\cf17 template} <{\cf17 typename} T>\par
01150 {\cf17 class }scoped_ptr \{\par
01151  {\cf17 public}:\par
01152   {\cf17 typedef} T element_type;\par
01153 \par
01154   {\cf17 explicit} scoped_ptr(T* p = NULL) : ptr_(p) \{\}\par
01155   ~scoped_ptr() \{ reset(); \}\par
01156 \par
01157   T& operator*(){\cf17  const }\{ {\cf19 return} *ptr_; \}\par
01158   T* operator->(){\cf17  const }\{ {\cf19 return} ptr_; \}\par
01159   T* get(){\cf17  const }\{ {\cf19 return} ptr_; \}\par
01160 \par
01161   T* release() \{\par
01162     T* {\cf17 const} ptr = ptr_;\par
01163     ptr_ = NULL;\par
01164     {\cf19 return} ptr;\par
01165   \}\par
01166 \par
01167   {\cf18 void} reset(T* p = NULL) \{\par
01168     {\cf19 if} (p != ptr_) \{\par
01169       {\cf19 if} (IsTrue({\cf17 sizeof}(T) > 0)) \{  {\cf20 // Makes sure T is a complete type.}\par
01170         {\cf17 delete} ptr_;\par
01171       \}\par
01172       ptr_ = p;\par
01173     \}\par
01174   \}\par
01175 \par
01176   {\cf17 friend} {\cf18 void} swap(scoped_ptr& a, scoped_ptr& b) \{\par
01177     {\cf17 using} std::swap;\par
01178     swap(a.ptr_, b.ptr_);\par
01179   \}\par
01180 \par
01181  {\cf17 private}:\par
01182   T* ptr_;\par
01183 \par
01184   GTEST_DISALLOW_COPY_AND_ASSIGN_(scoped_ptr);\par
01185 \};\par
01186 \par
01187 {\cf20 // Defines RE.}\par
01188 \par
01189 {\cf20 // A simple C++ wrapper for <regex.h>.  It uses the POSIX Extended}\par
01190 {\cf20 // Regular Expression syntax.}\par
01191 {\cf17 class }GTEST_API_ RE \{\par
01192  {\cf17 public}:\par
01193   {\cf20 // A copy constructor is required by the Standard to initialize object}\par
01194   {\cf20 // references from r-values.}\par
01195   RE({\cf17 const} RE& other) \{ Init(other.pattern()); \}\par
01196 \par
01197   {\cf20 // Constructs an RE from a string.}\par
01198   RE(const ::std::string& regex) \{ Init(regex.c_str()); \}  {\cf20 // NOLINT}\par
01199 \par
01200 {\cf21 #if GTEST_HAS_GLOBAL_STRING}\par
01201 \par
01202   RE(const ::string& regex) \{ Init(regex.c_str()); \}  {\cf20 // NOLINT}\par
01203 \par
01204 {\cf21 #endif  }{\cf20 // GTEST_HAS_GLOBAL_STRING}\par
01205 \par
01206   RE({\cf17 const} {\cf18 char}* regex) \{ Init(regex); \}  {\cf20 // NOLINT}\par
01207   ~RE();\par
01208 \par
01209   {\cf20 // Returns the string representation of the regex.}\par
01210   {\cf17 const} {\cf18 char}* pattern(){\cf17  const }\{ {\cf19 return} pattern_; \}\par
01211 \par
01212   {\cf20 // FullMatch(str, re) returns true iff regular expression re matches}\par
01213   {\cf20 // the entire str.}\par
01214   {\cf20 // PartialMatch(str, re) returns true iff regular expression re}\par
01215   {\cf20 // matches a substring of str (including str itself).}\par
01216   {\cf20 //}\par
01217   {\cf20 // TODO(wan@google.com): make FullMatch() and PartialMatch() work}\par
01218   {\cf20 // when str contains NUL characters.}\par
01219   {\cf17 static} {\cf18 bool} FullMatch(const ::std::string& str, {\cf17 const} RE& re) \{\par
01220     {\cf19 return} FullMatch(str.c_str(), re);\par
01221   \}\par
01222   {\cf17 static} {\cf18 bool} PartialMatch(const ::std::string& str, {\cf17 const} RE& re) \{\par
01223     {\cf19 return} PartialMatch(str.c_str(), re);\par
01224   \}\par
01225 \par
01226 {\cf21 #if GTEST_HAS_GLOBAL_STRING}\par
01227 \par
01228   {\cf17 static} {\cf18 bool} FullMatch(const ::string& str, {\cf17 const} RE& re) \{\par
01229     {\cf19 return} FullMatch(str.c_str(), re);\par
01230   \}\par
01231   {\cf17 static} {\cf18 bool} PartialMatch(const ::string& str, {\cf17 const} RE& re) \{\par
01232     {\cf19 return} PartialMatch(str.c_str(), re);\par
01233   \}\par
01234 \par
01235 {\cf21 #endif  }{\cf20 // GTEST_HAS_GLOBAL_STRING}\par
01236 \par
01237   {\cf17 static} {\cf18 bool} FullMatch({\cf17 const} {\cf18 char}* str, {\cf17 const} RE& re);\par
01238   {\cf17 static} {\cf18 bool} PartialMatch({\cf17 const} {\cf18 char}* str, {\cf17 const} RE& re);\par
01239 \par
01240  {\cf17 private}:\par
01241   {\cf18 void} Init({\cf17 const} {\cf18 char}* regex);\par
01242 \par
01243   {\cf20 // We use a const char* instead of an std::string, as Google Test used to be}\par
01244   {\cf20 // used where std::string is not available.  TODO(wan@google.com): change to}\par
01245   {\cf20 // std::string.}\par
01246   {\cf17 const} {\cf18 char}* pattern_;\par
01247   {\cf18 bool} is_valid_;\par
01248 \par
01249 {\cf21 #if GTEST_USES_POSIX_RE}\par
01250 \par
01251   regex_t full_regex_;     {\cf20 // For FullMatch().}\par
01252   regex_t partial_regex_;  {\cf20 // For PartialMatch().}\par
01253 \par
01254 {\cf21 #else  }{\cf20 // GTEST_USES_SIMPLE_RE}\par
01255 \par
01256   {\cf17 const} {\cf18 char}* full_pattern_;  {\cf20 // For FullMatch();}\par
01257 \par
01258 {\cf21 #endif}\par
01259 \par
01260   GTEST_DISALLOW_ASSIGN_(RE);\par
01261 \};\par
01262 \par
01263 {\cf20 // Formats a source file path and a line number as they would appear}\par
01264 {\cf20 // in an error message from the compiler used to compile this code.}\par
01265 GTEST_API_ ::std::string FormatFileLocation({\cf17 const} {\cf18 char}* file, {\cf18 int} line);\par
01266 \par
01267 {\cf20 // Formats a file location for compiler-independent XML output.}\par
01268 {\cf20 // Although this function is not platform dependent, we put it next to}\par
01269 {\cf20 // FormatFileLocation in order to contrast the two functions.}\par
01270 GTEST_API_ ::std::string FormatCompilerIndependentFileLocation({\cf17 const} {\cf18 char}* file,\par
01271                                                                {\cf18 int} line);\par
01272 \par
01273 {\cf20 // Defines logging utilities:}\par
01274 {\cf20 //   GTEST_LOG_(severity) - logs messages at the specified severity level. The}\par
01275 {\cf20 //                          message itself is streamed into the macro.}\par
01276 {\cf20 //   LogToStderr()  - directs all log messages to stderr.}\par
01277 {\cf20 //   FlushInfoLog() - flushes informational log messages.}\par
01278 \par
01279 {\cf17 enum} GTestLogSeverity \{\par
01280   GTEST_INFO,\par
01281   GTEST_WARNING,\par
01282   GTEST_ERROR,\par
01283   GTEST_FATAL\par
01284 \};\par
01285 \par
01286 {\cf20 // Formats log entry severity, provides a stream object for streaming the}\par
01287 {\cf20 // log message, and terminates the message with a newline when going out of}\par
01288 {\cf20 // scope.}\par
01289 {\cf17 class }GTEST_API_ GTestLog \{\par
01290  {\cf17 public}:\par
01291   GTestLog(GTestLogSeverity severity, {\cf17 const} {\cf18 char}* file, {\cf18 int} line);\par
01292 \par
01293   {\cf20 // Flushes the buffers and, if severity is GTEST_FATAL, aborts the program.}\par
01294   ~GTestLog();\par
01295 \par
01296   ::std::ostream& GetStream() \{ return ::std::cerr; \}\par
01297 \par
01298  {\cf17 private}:\par
01299   {\cf17 const} GTestLogSeverity severity_;\par
01300 \par
01301   GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestLog);\par
01302 \};\par
01303 \par
01304 {\cf21 #if !defined(GTEST_LOG_)}\par
01305 \par
01306 {\cf21 # define GTEST_LOG_(severity) \\}\par
01307 {\cf21     ::testing::internal::GTestLog(::testing::internal::GTEST_##severity, \\}\par
01308 {\cf21                                   __FILE__, __LINE__).GetStream()}\par
01309 \par
01310 {\cf17 inline} {\cf18 void} LogToStderr() \{\}\par
01311 {\cf17 inline} {\cf18 void} FlushInfoLog() \{ fflush(NULL); \}\par
01312 \par
01313 {\cf21 #endif  }{\cf20 // !defined(GTEST_LOG_)}\par
01314 \par
01315 {\cf21 #if !defined(GTEST_CHECK_)}\par
01316 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE.}\par
01317 {\cf20 //}\par
01318 {\cf20 // GTEST_CHECK_ is an all-mode assert. It aborts the program if the condition}\par
01319 {\cf20 // is not satisfied.}\par
01320 {\cf20 //  Synopsys:}\par
01321 {\cf20 //    GTEST_CHECK_(boolean_condition);}\par
01322 {\cf20 //     or}\par
01323 {\cf20 //    GTEST_CHECK_(boolean_condition) << "Additional message";}\par
01324 {\cf20 //}\par
01325 {\cf20 //    This checks the condition and if the condition is not satisfied}\par
01326 {\cf20 //    it prints message about the condition violation, including the}\par
01327 {\cf20 //    condition itself, plus additional message streamed into it, if any,}\par
01328 {\cf20 //    and then it aborts the program. It aborts the program irrespective of}\par
01329 {\cf20 //    whether it is built in the debug mode or not.}\par
01330 {\cf21 # define GTEST_CHECK_(condition) \\}\par
01331 {\cf21     GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\}\par
01332 {\cf21     if (::testing::internal::IsTrue(condition)) \\}\par
01333 {\cf21       ; \\}\par
01334 {\cf21     else \\}\par
01335 {\cf21       GTEST_LOG_(FATAL) << "Condition "} #condition " failed. "\par
01336 {\cf21 #endif  }{\cf20 // !defined(GTEST_CHECK_)}\par
01337 \par
01338 {\cf20 // An all-mode assert to verify that the given POSIX-style function}\par
01339 {\cf20 // call returns 0 (indicating success).  Known limitation: this}\par
01340 {\cf20 // doesn't expand to a balanced 'if' statement, so enclose the macro}\par
01341 {\cf20 // in \{\} if you need to use it as the only statement in an 'if'}\par
01342 {\cf20 // branch.}\par
01343 {\cf21 #define GTEST_CHECK_POSIX_SUCCESS_(posix_call) \\}\par
01344 {\cf21   if (const int gtest_error = (posix_call)) \\}\par
01345 {\cf21     GTEST_LOG_(FATAL) << #posix_call << "failed with error "} \\\par
01346                       << gtest_error\par
01347 \par
01348 {\cf21 #if GTEST_HAS_STD_MOVE_}\par
01349 {\cf17 using} std::move;\par
01350 {\cf21 #else  }{\cf20 // GTEST_HAS_STD_MOVE_}\par
01351 {\cf17 template} <{\cf17 typename} T>\par
01352 {\cf17 const} T& move({\cf17 const} T& t) \{\par
01353   {\cf19 return} t;\par
01354 \}\par
01355 {\cf21 #endif  }{\cf20 // GTEST_HAS_STD_MOVE_}\par
01356 \par
01357 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
01358 {\cf20 //}\par
01359 {\cf20 // Use ImplicitCast_ as a safe version of static_cast for upcasting in}\par
01360 {\cf20 // the type hierarchy (e.g. casting a Foo* to a SuperclassOfFoo* or a}\par
01361 {\cf20 // const Foo*).  When you use ImplicitCast_, the compiler checks that}\par
01362 {\cf20 // the cast is safe.  Such explicit ImplicitCast_s are necessary in}\par
01363 {\cf20 // surprisingly many situations where C++ demands an exact type match}\par
01364 {\cf20 // instead of an argument type convertable to a target type.}\par
01365 {\cf20 //}\par
01366 {\cf20 // The syntax for using ImplicitCast_ is the same as for static_cast:}\par
01367 {\cf20 //}\par
01368 {\cf20 //   ImplicitCast_<ToType>(expr)}\par
01369 {\cf20 //}\par
01370 {\cf20 // ImplicitCast_ would have been part of the C++ standard library,}\par
01371 {\cf20 // but the proposal was submitted too late.  It will probably make}\par
01372 {\cf20 // its way into the language in the future.}\par
01373 {\cf20 //}\par
01374 {\cf20 // This relatively ugly name is intentional. It prevents clashes with}\par
01375 {\cf20 // similar functions users may have (e.g., implicit_cast). The internal}\par
01376 {\cf20 // namespace alone is not enough because the function can be found by ADL.}\par
01377 {\cf17 template}<{\cf17 typename} To>\par
01378 {\cf17 inline} To ImplicitCast_(To x) \{ {\cf19 return} x; \}\par
01379 \par
01380 {\cf20 // When you upcast (that is, cast a pointer from type Foo to type}\par
01381 {\cf20 // SuperclassOfFoo), it's fine to use ImplicitCast_<>, since upcasts}\par
01382 {\cf20 // always succeed.  When you downcast (that is, cast a pointer from}\par
01383 {\cf20 // type Foo to type SubclassOfFoo), static_cast<> isn't safe, because}\par
01384 {\cf20 // how do you know the pointer is really of type SubclassOfFoo?  It}\par
01385 {\cf20 // could be a bare Foo, or of type DifferentSubclassOfFoo.  Thus,}\par
01386 {\cf20 // when you downcast, you should use this macro.  In debug mode, we}\par
01387 {\cf20 // use dynamic_cast<> to double-check the downcast is legal (we die}\par
01388 {\cf20 // if it's not).  In normal mode, we do the efficient static_cast<>}\par
01389 {\cf20 // instead.  Thus, it's important to test in debug mode to make sure}\par
01390 {\cf20 // the cast is legal!}\par
01391 {\cf20 //    This is the only place in the code we should use dynamic_cast<>.}\par
01392 {\cf20 // In particular, you SHOULDN'T be using dynamic_cast<> in order to}\par
01393 {\cf20 // do RTTI (eg code like this:}\par
01394 {\cf20 //    if (dynamic_cast<Subclass1>(foo)) HandleASubclass1Object(foo);}\par
01395 {\cf20 //    if (dynamic_cast<Subclass2>(foo)) HandleASubclass2Object(foo);}\par
01396 {\cf20 // You should design the code some other way not to need this.}\par
01397 {\cf20 //}\par
01398 {\cf20 // This relatively ugly name is intentional. It prevents clashes with}\par
01399 {\cf20 // similar functions users may have (e.g., down_cast). The internal}\par
01400 {\cf20 // namespace alone is not enough because the function can be found by ADL.}\par
01401 {\cf17 template}<{\cf17 typename} To, {\cf17 typename} From>  {\cf20 // use like this: DownCast_<T*>(foo);}\par
01402 {\cf17 inline} To DownCast_(From* f) \{  {\cf20 // so we only accept pointers}\par
01403   {\cf20 // Ensures that To is a sub-type of From *.  This test is here only}\par
01404   {\cf20 // for compile-time type checking, and has no overhead in an}\par
01405   {\cf20 // optimized build at run-time, as it will be optimized away}\par
01406   {\cf20 // completely.}\par
01407   GTEST_INTENTIONAL_CONST_COND_PUSH_()\par
01408   {\cf19 if} ({\cf17 false}) \{\par
01409   GTEST_INTENTIONAL_CONST_COND_POP_()\par
01410     {\cf17 const} To to = NULL;\par
01411     ::testing::internal::ImplicitCast_<From*>(to);\par
01412   \}\par
01413 \par
01414 {\cf21 #if GTEST_HAS_RTTI}\par
01415   {\cf20 // RTTI: debug mode only!}\par
01416   GTEST_CHECK_(f == NULL || {\cf17 dynamic_cast<}To{\cf17 >}(f) != NULL);\par
01417 {\cf21 #endif}\par
01418   {\cf19 return} {\cf17 static_cast<}To{\cf17 >}(f);\par
01419 \}\par
01420 \par
01421 {\cf20 // Downcasts the pointer of type Base to Derived.}\par
01422 {\cf20 // Derived must be a subclass of Base. The parameter MUST}\par
01423 {\cf20 // point to a class of type Derived, not any subclass of it.}\par
01424 {\cf20 // When RTTI is available, the function performs a runtime}\par
01425 {\cf20 // check to enforce this.}\par
01426 {\cf17 template} <{\cf17 class} Derived, {\cf17 class} Base>\par
01427 Derived* CheckedDowncastToActualType(Base* base) \{\par
01428 {\cf21 #if GTEST_HAS_RTTI}\par
01429   GTEST_CHECK_({\cf17 typeid}(*base) == {\cf17 typeid}(Derived));\par
01430 {\cf21 #endif}\par
01431 \par
01432 {\cf21 #if GTEST_HAS_DOWNCAST_}\par
01433   return ::down_cast<Derived*>(base);\par
01434 {\cf21 #elif GTEST_HAS_RTTI}\par
01435   {\cf19 return} {\cf17 dynamic_cast<}Derived*{\cf17 >}(base);  {\cf20 // NOLINT}\par
01436 {\cf21 #else}\par
01437   {\cf19 return} {\cf17 static_cast<}Derived*{\cf17 >}(base);  {\cf20 // Poor man's downcast.}\par
01438 {\cf21 #endif}\par
01439 \}\par
01440 \par
01441 {\cf21 #if GTEST_HAS_STREAM_REDIRECTION}\par
01442 \par
01443 {\cf20 // Defines the stderr capturer:}\par
01444 {\cf20 //   CaptureStdout     - starts capturing stdout.}\par
01445 {\cf20 //   GetCapturedStdout - stops capturing stdout and returns the captured string.}\par
01446 {\cf20 //   CaptureStderr     - starts capturing stderr.}\par
01447 {\cf20 //   GetCapturedStderr - stops capturing stderr and returns the captured string.}\par
01448 {\cf20 //}\par
01449 GTEST_API_ {\cf18 void} CaptureStdout();\par
01450 GTEST_API_ std::string GetCapturedStdout();\par
01451 GTEST_API_ {\cf18 void} CaptureStderr();\par
01452 GTEST_API_ std::string GetCapturedStderr();\par
01453 \par
01454 {\cf21 #endif  }{\cf20 // GTEST_HAS_STREAM_REDIRECTION}\par
01455 \par
01456 {\cf20 // Returns the size (in bytes) of a file.}\par
01457 GTEST_API_ {\cf18 size_t} GetFileSize(FILE* file);\par
01458 \par
01459 {\cf20 // Reads the entire content of a file as a string.}\par
01460 GTEST_API_ std::string ReadEntireFile(FILE* file);\par
01461 \par
01462 {\cf20 // All command line arguments.}\par
01463 GTEST_API_ const ::std::vector<testing::internal::string>& GetArgvs();\par
01464 \par
01465 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
01466 \par
01467 const ::std::vector<testing::internal::string>& GetInjectableArgvs();\par
01468 {\cf18 void} SetInjectableArgvs(const ::std::vector<testing::internal::string>*\par
01469                              new_argvs);\par
01470 \par
01471 \par
01472 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
01473 \par
01474 {\cf20 // Defines synchronization primitives.}\par
01475 {\cf21 #if GTEST_IS_THREADSAFE}\par
01476 {\cf21 # if GTEST_HAS_PTHREAD}\par
01477 {\cf20 // Sleeps for (roughly) n milliseconds.  This function is only for testing}\par
01478 {\cf20 // Google Test's own constructs.  Don't use it in user tests, either}\par
01479 {\cf20 // directly or indirectly.}\par
01480 {\cf17 inline} {\cf18 void} SleepMilliseconds({\cf18 int} n) \{\par
01481   {\cf17 const} timespec time = \{\par
01482     0,                  {\cf20 // 0 seconds.}\par
01483     n * 1000L * 1000L,  {\cf20 // And n ms.}\par
01484   \};\par
01485   nanosleep(&time, NULL);\par
01486 \}\par
01487 {\cf21 # endif  }{\cf20 // GTEST_HAS_PTHREAD}\par
01488 \par
01489 {\cf21 # if GTEST_HAS_NOTIFICATION_}\par
01490 {\cf20 // Notification has already been imported into the namespace.}\par
01491 {\cf20 // Nothing to do here.}\par
01492 \par
01493 {\cf21 # elif GTEST_HAS_PTHREAD}\par
01494 {\cf20 // Allows a controller thread to pause execution of newly created}\par
01495 {\cf20 // threads until notified.  Instances of this class must be created}\par
01496 {\cf20 // and destroyed in the controller thread.}\par
01497 {\cf20 //}\par
01498 {\cf20 // This class is only for testing Google Test's own constructs. Do not}\par
01499 {\cf20 // use it in user tests, either directly or indirectly.}\par
01500 {\cf17 class }Notification \{\par
01501  {\cf17 public}:\par
01502   Notification() : notified_(false) \{\par
01503     GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));\par
01504   \}\par
01505   ~Notification() \{\par
01506     pthread_mutex_destroy(&mutex_);\par
01507   \}\par
01508 \par
01509   {\cf20 // Notifies all threads created with this notification to start. Must}\par
01510   {\cf20 // be called from the controller thread.}\par
01511   {\cf18 void} Notify() \{\par
01512     pthread_mutex_lock(&mutex_);\par
01513     notified_ = {\cf17 true};\par
01514     pthread_mutex_unlock(&mutex_);\par
01515   \}\par
01516 \par
01517   {\cf20 // Blocks until the controller thread notifies. Must be called from a test}\par
01518   {\cf20 // thread.}\par
01519   {\cf18 void} WaitForNotification() \{\par
01520     {\cf19 for} (;;) \{\par
01521       pthread_mutex_lock(&mutex_);\par
01522       {\cf17 const} {\cf18 bool} notified = notified_;\par
01523       pthread_mutex_unlock(&mutex_);\par
01524       {\cf19 if} (notified)\par
01525         {\cf19 break};\par
01526       SleepMilliseconds(10);\par
01527     \}\par
01528   \}\par
01529 \par
01530  {\cf17 private}:\par
01531   pthread_mutex_t mutex_;\par
01532   {\cf18 bool} notified_;\par
01533 \par
01534   GTEST_DISALLOW_COPY_AND_ASSIGN_(Notification);\par
01535 \};\par
01536 \par
01537 {\cf21 # elif GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT}\par
01538 \par
01539 GTEST_API_ {\cf18 void} SleepMilliseconds({\cf18 int} n);\par
01540 \par
01541 {\cf20 // Provides leak-safe Windows kernel handle ownership.}\par
01542 {\cf20 // Used in death tests and in threading support.}\par
01543 {\cf17 class }GTEST_API_ AutoHandle \{\par
01544  {\cf17 public}:\par
01545   {\cf20 // Assume that Win32 HANDLE type is equivalent to void*. Doing so allows us to}\par
01546   {\cf20 // avoid including <windows.h> in this header file. Including <windows.h> is}\par
01547   {\cf20 // undesirable because it defines a lot of symbols and macros that tend to}\par
01548   {\cf20 // conflict with client code. This assumption is verified by}\par
01549   {\cf20 // WindowsTypesTest.HANDLEIsVoidStar.}\par
01550   {\cf17 typedef} {\cf18 void}* Handle;\par
01551   AutoHandle();\par
01552   {\cf17 explicit} AutoHandle(Handle handle);\par
01553 \par
01554   ~AutoHandle();\par
01555 \par
01556   Handle Get() {\cf17 const};\par
01557   {\cf18 void} Reset();\par
01558   {\cf18 void} Reset(Handle handle);\par
01559 \par
01560  {\cf17 private}:\par
01561   {\cf20 // Returns true iff the handle is a valid handle object that can be closed.}\par
01562   {\cf18 bool} IsCloseable() {\cf17 const};\par
01563 \par
01564   Handle handle_;\par
01565 \par
01566   GTEST_DISALLOW_COPY_AND_ASSIGN_(AutoHandle);\par
01567 \};\par
01568 \par
01569 {\cf20 // Allows a controller thread to pause execution of newly created}\par
01570 {\cf20 // threads until notified.  Instances of this class must be created}\par
01571 {\cf20 // and destroyed in the controller thread.}\par
01572 {\cf20 //}\par
01573 {\cf20 // This class is only for testing Google Test's own constructs. Do not}\par
01574 {\cf20 // use it in user tests, either directly or indirectly.}\par
01575 {\cf17 class }GTEST_API_ Notification \{\par
01576  {\cf17 public}:\par
01577   Notification();\par
01578   {\cf18 void} Notify();\par
01579   {\cf18 void} WaitForNotification();\par
01580 \par
01581  {\cf17 private}:\par
01582   AutoHandle event_;\par
01583 \par
01584   GTEST_DISALLOW_COPY_AND_ASSIGN_(Notification);\par
01585 \};\par
01586 {\cf21 # endif  }{\cf20 // GTEST_HAS_NOTIFICATION_}\par
01587 \par
01588 {\cf20 // On MinGW, we can have both GTEST_OS_WINDOWS and GTEST_HAS_PTHREAD}\par
01589 {\cf20 // defined, but we don't want to use MinGW's pthreads implementation, which}\par
01590 {\cf20 // has conformance problems with some versions of the POSIX standard.}\par
01591 {\cf21 # if GTEST_HAS_PTHREAD && !GTEST_OS_WINDOWS_MINGW}\par
01592 \par
01593 {\cf20 // As a C-function, ThreadFuncWithCLinkage cannot be templated itself.}\par
01594 {\cf20 // Consequently, it cannot select a correct instantiation of ThreadWithParam}\par
01595 {\cf20 // in order to call its Run(). Introducing ThreadWithParamBase as a}\par
01596 {\cf20 // non-templated base class for ThreadWithParam allows us to bypass this}\par
01597 {\cf20 // problem.}\par
01598 {\cf17 class }ThreadWithParamBase \{\par
01599  {\cf17 public}:\par
01600   {\cf17 virtual} ~ThreadWithParamBase() \{\}\par
01601   {\cf17 virtual} {\cf18 void} Run() = 0;\par
01602 \};\par
01603 \par
01604 {\cf20 // pthread_create() accepts a pointer to a function type with the C linkage.}\par
01605 {\cf20 // According to the Standard (7.5/1), function types with different linkages}\par
01606 {\cf20 // are different even if they are otherwise identical.  Some compilers (for}\par
01607 {\cf20 // example, SunStudio) treat them as different types.  Since class methods}\par
01608 {\cf20 // cannot be defined with C-linkage we need to define a free C-function to}\par
01609 {\cf20 // pass into pthread_create().}\par
01610 {\cf17 extern} {\cf22 "C"} {\cf17 inline} {\cf18 void}* ThreadFuncWithCLinkage({\cf18 void}* thread) \{\par
01611   {\cf17 static_cast<}ThreadWithParamBase*{\cf17 >}(thread)->Run();\par
01612   {\cf19 return} NULL;\par
01613 \}\par
01614 \par
01615 {\cf20 // Helper class for testing Google Test's multi-threading constructs.}\par
01616 {\cf20 // To use it, write:}\par
01617 {\cf20 //}\par
01618 {\cf20 //   void ThreadFunc(int param) \{ /* Do things with param */ \}}\par
01619 {\cf20 //   Notification thread_can_start;}\par
01620 {\cf20 //   ...}\par
01621 {\cf20 //   // The thread_can_start parameter is optional; you can supply NULL.}\par
01622 {\cf20 //   ThreadWithParam<int> thread(&ThreadFunc, 5, &thread_can_start);}\par
01623 {\cf20 //   thread_can_start.Notify();}\par
01624 {\cf20 //}\par
01625 {\cf20 // These classes are only for testing Google Test's own constructs. Do}\par
01626 {\cf20 // not use them in user tests, either directly or indirectly.}\par
01627 {\cf17 template} <{\cf17 typename} T>\par
01628 {\cf17 class }ThreadWithParam : {\cf17 public} ThreadWithParamBase \{\par
01629  {\cf17 public}:\par
01630   {\cf17 typedef} {\cf18 void} UserThreadFunc(T);\par
01631 \par
01632   ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\par
01633       : func_(func),\par
01634         param_(param),\par
01635         thread_can_start_(thread_can_start),\par
01636         finished_(false) \{\par
01637     ThreadWithParamBase* {\cf17 const} base = {\cf17 this};\par
01638     {\cf20 // The thread can be created only after all fields except thread_}\par
01639     {\cf20 // have been initialized.}\par
01640     GTEST_CHECK_POSIX_SUCCESS_(\par
01641         pthread_create(&thread_, 0, &ThreadFuncWithCLinkage, base));\par
01642   \}\par
01643   ~ThreadWithParam() \{ Join(); \}\par
01644 \par
01645   {\cf18 void} Join() \{\par
01646     {\cf19 if} (!finished_) \{\par
01647       GTEST_CHECK_POSIX_SUCCESS_(pthread_join(thread_, 0));\par
01648       finished_ = {\cf17 true};\par
01649     \}\par
01650   \}\par
01651 \par
01652   {\cf17 virtual} {\cf18 void} Run() \{\par
01653     {\cf19 if} (thread_can_start_ != NULL)\par
01654       thread_can_start_->WaitForNotification();\par
01655     func_(param_);\par
01656   \}\par
01657 \par
01658  {\cf17 private}:\par
01659   UserThreadFunc* {\cf17 const} func_;  {\cf20 // User-supplied thread function.}\par
01660   {\cf17 const} T param_;  {\cf20 // User-supplied parameter to the thread function.}\par
01661   {\cf20 // When non-NULL, used to block execution until the controller thread}\par
01662   {\cf20 // notifies.}\par
01663   Notification* {\cf17 const} thread_can_start_;\par
01664   {\cf18 bool} finished_;  {\cf20 // true iff we know that the thread function has finished.}\par
01665   pthread_t thread_;  {\cf20 // The native thread object.}\par
01666 \par
01667   GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParam);\par
01668 \};\par
01669 {\cf21 # endif  }{\cf20 // !GTEST_OS_WINDOWS && GTEST_HAS_PTHREAD ||}\par
01670          {\cf20 // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_}\par
01671 \par
01672 {\cf21 # if GTEST_HAS_MUTEX_AND_THREAD_LOCAL_}\par
01673 {\cf20 // Mutex and ThreadLocal have already been imported into the namespace.}\par
01674 {\cf20 // Nothing to do here.}\par
01675 \par
01676 {\cf21 # elif GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT}\par
01677 \par
01678 {\cf20 // Mutex implements mutex on Windows platforms.  It is used in conjunction}\par
01679 {\cf20 // with class MutexLock:}\par
01680 {\cf20 //}\par
01681 {\cf20 //   Mutex mutex;}\par
01682 {\cf20 //   ...}\par
01683 {\cf20 //   MutexLock lock(&mutex);  // Acquires the mutex and releases it at the}\par
01684 {\cf20 //                            // end of the current scope.}\par
01685 {\cf20 //}\par
01686 {\cf20 // A static Mutex *must* be defined or declared using one of the following}\par
01687 {\cf20 // macros:}\par
01688 {\cf20 //   GTEST_DEFINE_STATIC_MUTEX_(g_some_mutex);}\par
01689 {\cf20 //   GTEST_DECLARE_STATIC_MUTEX_(g_some_mutex);}\par
01690 {\cf20 //}\par
01691 {\cf20 // (A non-static Mutex is defined/declared in the usual way).}\par
01692 {\cf17 class }GTEST_API_ Mutex \{\par
01693  {\cf17 public}:\par
01694   {\cf17 enum} MutexType \{ kStatic = 0, kDynamic = 1 \};\par
01695   {\cf20 // We rely on kStaticMutex being 0 as it is to what the linker initializes}\par
01696   {\cf20 // type_ in static mutexes.  critical_section_ will be initialized lazily}\par
01697   {\cf20 // in ThreadSafeLazyInit().}\par
01698   {\cf17 enum} StaticConstructorSelector \{ kStaticMutex = 0 \};\par
01699 \par
01700   {\cf20 // This constructor intentionally does nothing.  It relies on type_ being}\par
01701   {\cf20 // statically initialized to 0 (effectively setting it to kStatic) and on}\par
01702   {\cf20 // ThreadSafeLazyInit() to lazily initialize the rest of the members.}\par
01703   {\cf17 explicit} Mutex(StaticConstructorSelector {\cf20 /*dummy*/}) \{\}\par
01704 \par
01705   Mutex();\par
01706   ~Mutex();\par
01707 \par
01708   {\cf18 void} Lock();\par
01709 \par
01710   {\cf18 void} Unlock();\par
01711 \par
01712   {\cf20 // Does nothing if the current thread holds the mutex. Otherwise, crashes}\par
01713   {\cf20 // with high probability.}\par
01714   {\cf18 void} AssertHeld();\par
01715 \par
01716  {\cf17 private}:\par
01717   {\cf20 // Initializes owner_thread_id_ and critical_section_ in static mutexes.}\par
01718   {\cf18 void} ThreadSafeLazyInit();\par
01719 \par
01720   {\cf20 // Per http://blogs.msdn.com/b/oldnewthing/archive/2004/02/23/78395.aspx,}\par
01721   {\cf20 // we assume that 0 is an invalid value for thread IDs.}\par
01722   {\cf18 unsigned} {\cf18 int} owner_thread_id_;\par
01723 \par
01724   {\cf20 // For static mutexes, we rely on these members being initialized to zeros}\par
01725   {\cf20 // by the linker.}\par
01726   MutexType type_;\par
01727   {\cf18 long} critical_section_init_phase_;  {\cf20 // NOLINT}\par
01728   GTEST_CRITICAL_SECTION* critical_section_;\par
01729 \par
01730   GTEST_DISALLOW_COPY_AND_ASSIGN_(Mutex);\par
01731 \};\par
01732 \par
01733 {\cf21 # define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\}\par
01734 {\cf21     extern ::testing::internal::Mutex mutex}\par
01735 \par
01736 {\cf21 # define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\}\par
01737 {\cf21     ::testing::internal::Mutex mutex(::testing::internal::Mutex::kStaticMutex)}\par
01738 \par
01739 {\cf20 // We cannot name this class MutexLock because the ctor declaration would}\par
01740 {\cf20 // conflict with a macro named MutexLock, which is defined on some}\par
01741 {\cf20 // platforms. That macro is used as a defensive measure to prevent against}\par
01742 {\cf20 // inadvertent misuses of MutexLock like "MutexLock(&mu)" rather than}\par
01743 {\cf20 // "MutexLock l(&mu)".  Hence the typedef trick below.}\par
01744 {\cf17 class }GTestMutexLock \{\par
01745  {\cf17 public}:\par
01746   {\cf17 explicit} GTestMutexLock(Mutex* mutex)\par
01747       : mutex_(mutex) \{ mutex_->Lock(); \}\par
01748 \par
01749   ~GTestMutexLock() \{ mutex_->Unlock(); \}\par
01750 \par
01751  {\cf17 private}:\par
01752   Mutex* {\cf17 const} mutex_;\par
01753 \par
01754   GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestMutexLock);\par
01755 \};\par
01756 \par
01757 {\cf17 typedef} GTestMutexLock MutexLock;\par
01758 \par
01759 {\cf20 // Base class for ValueHolder<T>.  Allows a caller to hold and delete a value}\par
01760 {\cf20 // without knowing its type.}\par
01761 {\cf17 class }ThreadLocalValueHolderBase \{\par
01762  {\cf17 public}:\par
01763   {\cf17 virtual} ~ThreadLocalValueHolderBase() \{\}\par
01764 \};\par
01765 \par
01766 {\cf20 // Provides a way for a thread to send notifications to a ThreadLocal}\par
01767 {\cf20 // regardless of its parameter type.}\par
01768 {\cf17 class }ThreadLocalBase \{\par
01769  {\cf17 public}:\par
01770   {\cf20 // Creates a new ValueHolder<T> object holding a default value passed to}\par
01771   {\cf20 // this ThreadLocal<T>'s constructor and returns it.  It is the caller's}\par
01772   {\cf20 // responsibility not to call this when the ThreadLocal<T> instance already}\par
01773   {\cf20 // has a value on the current thread.}\par
01774   {\cf17 virtual} ThreadLocalValueHolderBase* NewValueForCurrentThread() {\cf17 const} = 0;\par
01775 \par
01776  {\cf17 protected}:\par
01777   ThreadLocalBase() \{\}\par
01778   {\cf17 virtual} ~ThreadLocalBase() \{\}\par
01779 \par
01780  {\cf17 private}:\par
01781   GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocalBase);\par
01782 \};\par
01783 \par
01784 {\cf20 // Maps a thread to a set of ThreadLocals that have values instantiated on that}\par
01785 {\cf20 // thread and notifies them when the thread exits.  A ThreadLocal instance is}\par
01786 {\cf20 // expected to persist until all threads it has values on have terminated.}\par
01787 {\cf17 class }GTEST_API_ ThreadLocalRegistry \{\par
01788  {\cf17 public}:\par
01789   {\cf20 // Registers thread_local_instance as having value on the current thread.}\par
01790   {\cf20 // Returns a value that can be used to identify the thread from other threads.}\par
01791   {\cf17 static} ThreadLocalValueHolderBase* GetValueOnCurrentThread(\par
01792       {\cf17 const} ThreadLocalBase* thread_local_instance);\par
01793 \par
01794   {\cf20 // Invoked when a ThreadLocal instance is destroyed.}\par
01795   {\cf17 static} {\cf18 void} OnThreadLocalDestroyed(\par
01796       {\cf17 const} ThreadLocalBase* thread_local_instance);\par
01797 \};\par
01798 \par
01799 {\cf17 class }GTEST_API_ ThreadWithParamBase \{\par
01800  {\cf17 public}:\par
01801   {\cf18 void} Join();\par
01802 \par
01803  {\cf17 protected}:\par
01804   {\cf17 class }Runnable \{\par
01805    {\cf17 public}:\par
01806     {\cf17 virtual} ~Runnable() \{\}\par
01807     {\cf17 virtual} {\cf18 void} Run() = 0;\par
01808   \};\par
01809 \par
01810   ThreadWithParamBase(Runnable *runnable, Notification* thread_can_start);\par
01811   {\cf17 virtual} ~ThreadWithParamBase();\par
01812 \par
01813  {\cf17 private}:\par
01814   AutoHandle thread_;\par
01815 \};\par
01816 \par
01817 {\cf20 // Helper class for testing Google Test's multi-threading constructs.}\par
01818 {\cf17 template} <{\cf17 typename} T>\par
01819 {\cf17 class }ThreadWithParam : {\cf17 public} ThreadWithParamBase \{\par
01820  {\cf17 public}:\par
01821   {\cf17 typedef} {\cf18 void} UserThreadFunc(T);\par
01822 \par
01823   ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\par
01824       : ThreadWithParamBase(new RunnableImpl(func, param), thread_can_start) \{\par
01825   \}\par
01826   {\cf17 virtual} ~ThreadWithParam() \{\}\par
01827 \par
01828  {\cf17 private}:\par
01829   {\cf17 class }RunnableImpl : {\cf17 public} Runnable \{\par
01830    {\cf17 public}:\par
01831     RunnableImpl(UserThreadFunc* func, T param)\par
01832         : func_(func),\par
01833           param_(param) \{\par
01834     \}\par
01835     {\cf17 virtual} ~RunnableImpl() \{\}\par
01836     {\cf17 virtual} {\cf18 void} Run() \{\par
01837       func_(param_);\par
01838     \}\par
01839 \par
01840    {\cf17 private}:\par
01841     UserThreadFunc* {\cf17 const} func_;\par
01842     {\cf17 const} T param_;\par
01843 \par
01844     GTEST_DISALLOW_COPY_AND_ASSIGN_(RunnableImpl);\par
01845   \};\par
01846 \par
01847   GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParam);\par
01848 \};\par
01849 \par
01850 {\cf20 // Implements thread-local storage on Windows systems.}\par
01851 {\cf20 //}\par
01852 {\cf20 //   // Thread 1}\par
01853 {\cf20 //   ThreadLocal<int> tl(100);  // 100 is the default value for each thread.}\par
01854 {\cf20 //}\par
01855 {\cf20 //   // Thread 2}\par
01856 {\cf20 //   tl.set(150);  // Changes the value for thread 2 only.}\par
01857 {\cf20 //   EXPECT_EQ(150, tl.get());}\par
01858 {\cf20 //}\par
01859 {\cf20 //   // Thread 1}\par
01860 {\cf20 //   EXPECT_EQ(100, tl.get());  // In thread 1, tl has the original value.}\par
01861 {\cf20 //   tl.set(200);}\par
01862 {\cf20 //   EXPECT_EQ(200, tl.get());}\par
01863 {\cf20 //}\par
01864 {\cf20 // The template type argument T must have a public copy constructor.}\par
01865 {\cf20 // In addition, the default ThreadLocal constructor requires T to have}\par
01866 {\cf20 // a public default constructor.}\par
01867 {\cf20 //}\par
01868 {\cf20 // The users of a TheadLocal instance have to make sure that all but one}\par
01869 {\cf20 // threads (including the main one) using that instance have exited before}\par
01870 {\cf20 // destroying it. Otherwise, the per-thread objects managed for them by the}\par
01871 {\cf20 // ThreadLocal instance are not guaranteed to be destroyed on all platforms.}\par
01872 {\cf20 //}\par
01873 {\cf20 // Google Test only uses global ThreadLocal objects.  That means they}\par
01874 {\cf20 // will die after main() has returned.  Therefore, no per-thread}\par
01875 {\cf20 // object managed by Google Test will be leaked as long as all threads}\par
01876 {\cf20 // using Google Test have exited when main() returns.}\par
01877 {\cf17 template} <{\cf17 typename} T>\par
01878 {\cf17 class }ThreadLocal : {\cf17 public} ThreadLocalBase \{\par
01879  {\cf17 public}:\par
01880   ThreadLocal() : default_factory_(new DefaultValueHolderFactory()) \{\}\par
01881   {\cf17 explicit} ThreadLocal({\cf17 const} T& value)\par
01882       : default_factory_(new InstanceValueHolderFactory(value)) \{\}\par
01883 \par
01884   ~ThreadLocal() \{ ThreadLocalRegistry::OnThreadLocalDestroyed({\cf17 this}); \}\par
01885 \par
01886   T* pointer() \{ {\cf19 return} GetOrCreateValue(); \}\par
01887   {\cf17 const} T* pointer(){\cf17  const }\{ {\cf19 return} GetOrCreateValue(); \}\par
01888   {\cf17 const} T& get(){\cf17  const }\{ {\cf19 return} *pointer(); \}\par
01889   {\cf18 void} set({\cf17 const} T& value) \{ *pointer() = value; \}\par
01890 \par
01891  {\cf17 private}:\par
01892   {\cf20 // Holds a value of T.  Can be deleted via its base class without the caller}\par
01893   {\cf20 // knowing the type of T.}\par
01894   {\cf17 class }ValueHolder : {\cf17 public} ThreadLocalValueHolderBase \{\par
01895    {\cf17 public}:\par
01896     ValueHolder() : value_() \{\}\par
01897     {\cf17 explicit} ValueHolder({\cf17 const} T& value) : value_(value) \{\}\par
01898 \par
01899     T* pointer() \{ {\cf19 return} &value_; \}\par
01900 \par
01901    {\cf17 private}:\par
01902     T value_;\par
01903     GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolder);\par
01904   \};\par
01905 \par
01906 \par
01907   T* GetOrCreateValue(){\cf17  const }\{\par
01908     {\cf19 return} {\cf17 static_cast<}ValueHolder*{\cf17 >}(\par
01909         ThreadLocalRegistry::GetValueOnCurrentThread({\cf17 this}))->pointer();\par
01910   \}\par
01911 \par
01912   {\cf17 virtual} ThreadLocalValueHolderBase* NewValueForCurrentThread(){\cf17  const }\{\par
01913     {\cf19 return} default_factory_->MakeNewHolder();\par
01914   \}\par
01915 \par
01916   {\cf17 class }ValueHolderFactory \{\par
01917    {\cf17 public}:\par
01918     ValueHolderFactory() \{\}\par
01919     {\cf17 virtual} ~ValueHolderFactory() \{\}\par
01920     {\cf17 virtual} ValueHolder* MakeNewHolder() {\cf17 const} = 0;\par
01921 \par
01922    {\cf17 private}:\par
01923     GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolderFactory);\par
01924   \};\par
01925 \par
01926   {\cf17 class }DefaultValueHolderFactory : {\cf17 public} ValueHolderFactory \{\par
01927    {\cf17 public}:\par
01928     DefaultValueHolderFactory() \{\}\par
01929     {\cf17 virtual} ValueHolder* MakeNewHolder(){\cf17  const }\{ {\cf19 return} {\cf17 new} ValueHolder(); \}\par
01930 \par
01931    {\cf17 private}:\par
01932     GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultValueHolderFactory);\par
01933   \};\par
01934 \par
01935   {\cf17 class }InstanceValueHolderFactory : {\cf17 public} ValueHolderFactory \{\par
01936    {\cf17 public}:\par
01937     {\cf17 explicit} InstanceValueHolderFactory({\cf17 const} T& value) : value_(value) \{\}\par
01938     {\cf17 virtual} ValueHolder* MakeNewHolder(){\cf17  const }\{\par
01939       {\cf19 return} {\cf17 new} ValueHolder(value_);\par
01940     \}\par
01941 \par
01942    {\cf17 private}:\par
01943     {\cf17 const} T value_;  {\cf20 // The value for each thread.}\par
01944 \par
01945     GTEST_DISALLOW_COPY_AND_ASSIGN_(InstanceValueHolderFactory);\par
01946   \};\par
01947 \par
01948   scoped_ptr<ValueHolderFactory> default_factory_;\par
01949 \par
01950   GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocal);\par
01951 \};\par
01952 \par
01953 {\cf21 # elif GTEST_HAS_PTHREAD}\par
01954 \par
01955 {\cf20 // MutexBase and Mutex implement mutex on pthreads-based platforms.}\par
01956 {\cf17 class }MutexBase \{\par
01957  {\cf17 public}:\par
01958   {\cf20 // Acquires this mutex.}\par
01959   {\cf18 void} Lock() \{\par
01960     GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_lock(&mutex_));\par
01961     owner_ = pthread_self();\par
01962     has_owner_ = {\cf17 true};\par
01963   \}\par
01964 \par
01965   {\cf20 // Releases this mutex.}\par
01966   {\cf18 void} Unlock() \{\par
01967     {\cf20 // Since the lock is being released the owner_ field should no longer be}\par
01968     {\cf20 // considered valid. We don't protect writing to has_owner_ here, as it's}\par
01969     {\cf20 // the caller's responsibility to ensure that the current thread holds the}\par
01970     {\cf20 // mutex when this is called.}\par
01971     has_owner_ = {\cf17 false};\par
01972     GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_unlock(&mutex_));\par
01973   \}\par
01974 \par
01975   {\cf20 // Does nothing if the current thread holds the mutex. Otherwise, crashes}\par
01976   {\cf20 // with high probability.}\par
01977   {\cf18 void} AssertHeld(){\cf17  const }\{\par
01978     GTEST_CHECK_(has_owner_ && pthread_equal(owner_, pthread_self()))\par
01979         << {\cf22 "The current thread is not holding the mutex @"} << {\cf17 this};\par
01980   \}\par
01981 \par
01982   {\cf20 // A static mutex may be used before main() is entered.  It may even}\par
01983   {\cf20 // be used before the dynamic initialization stage.  Therefore we}\par
01984   {\cf20 // must be able to initialize a static mutex object at link time.}\par
01985   {\cf20 // This means MutexBase has to be a POD and its member variables}\par
01986   {\cf20 // have to be public.}\par
01987  {\cf17 public}:\par
01988   pthread_mutex_t mutex_;  {\cf20 // The underlying pthread mutex.}\par
01989   {\cf20 // has_owner_ indicates whether the owner_ field below contains a valid thread}\par
01990   {\cf20 // ID and is therefore safe to inspect (e.g., to use in pthread_equal()). All}\par
01991   {\cf20 // accesses to the owner_ field should be protected by a check of this field.}\par
01992   {\cf20 // An alternative might be to memset() owner_ to all zeros, but there's no}\par
01993   {\cf20 // guarantee that a zero'd pthread_t is necessarily invalid or even different}\par
01994   {\cf20 // from pthread_self().}\par
01995   {\cf18 bool} has_owner_;\par
01996   pthread_t owner_;  {\cf20 // The thread holding the mutex.}\par
01997 \};\par
01998 \par
01999 {\cf20 // Forward-declares a static mutex.}\par
02000 {\cf21 #  define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\}\par
02001 {\cf21      extern ::testing::internal::MutexBase mutex}\par
02002 \par
02003 {\cf20 // Defines and statically (i.e. at link time) initializes a static mutex.}\par
02004 {\cf21 #  define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\}\par
02005 {\cf21      ::testing::internal::MutexBase mutex = \{ PTHREAD_MUTEX_INITIALIZER, false, pthread_t() \}}\par
02006 \par
02007 {\cf20 // The Mutex class can only be used for mutexes created at runtime. It}\par
02008 {\cf20 // shares its API with MutexBase otherwise.}\par
02009 {\cf17 class }Mutex : {\cf17 public} MutexBase \{\par
02010  {\cf17 public}:\par
02011   Mutex() \{\par
02012     GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));\par
02013     has_owner_ = {\cf17 false};\par
02014   \}\par
02015   ~Mutex() \{\par
02016     GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_destroy(&mutex_));\par
02017   \}\par
02018 \par
02019  {\cf17 private}:\par
02020   GTEST_DISALLOW_COPY_AND_ASSIGN_(Mutex);\par
02021 \};\par
02022 \par
02023 {\cf20 // We cannot name this class MutexLock because the ctor declaration would}\par
02024 {\cf20 // conflict with a macro named MutexLock, which is defined on some}\par
02025 {\cf20 // platforms. That macro is used as a defensive measure to prevent against}\par
02026 {\cf20 // inadvertent misuses of MutexLock like "MutexLock(&mu)" rather than}\par
02027 {\cf20 // "MutexLock l(&mu)".  Hence the typedef trick below.}\par
02028 {\cf17 class }GTestMutexLock \{\par
02029  {\cf17 public}:\par
02030   {\cf17 explicit} GTestMutexLock(MutexBase* mutex)\par
02031       : mutex_(mutex) \{ mutex_->Lock(); \}\par
02032 \par
02033   ~GTestMutexLock() \{ mutex_->Unlock(); \}\par
02034 \par
02035  {\cf17 private}:\par
02036   MutexBase* {\cf17 const} mutex_;\par
02037 \par
02038   GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestMutexLock);\par
02039 \};\par
02040 \par
02041 {\cf17 typedef} GTestMutexLock MutexLock;\par
02042 \par
02043 {\cf20 // Helpers for ThreadLocal.}\par
02044 \par
02045 {\cf20 // pthread_key_create() requires DeleteThreadLocalValue() to have}\par
02046 {\cf20 // C-linkage.  Therefore it cannot be templatized to access}\par
02047 {\cf20 // ThreadLocal<T>.  Hence the need for class}\par
02048 {\cf20 // ThreadLocalValueHolderBase.}\par
02049 {\cf17 class }ThreadLocalValueHolderBase \{\par
02050  {\cf17 public}:\par
02051   {\cf17 virtual} ~ThreadLocalValueHolderBase() \{\}\par
02052 \};\par
02053 \par
02054 {\cf20 // Called by pthread to delete thread-local data stored by}\par
02055 {\cf20 // pthread_setspecific().}\par
02056 {\cf17 extern} {\cf22 "C"} {\cf17 inline} {\cf18 void} DeleteThreadLocalValue({\cf18 void}* value_holder) \{\par
02057   {\cf17 delete} {\cf17 static_cast<}ThreadLocalValueHolderBase*{\cf17 >}(value_holder);\par
02058 \}\par
02059 \par
02060 {\cf20 // Implements thread-local storage on pthreads-based systems.}\par
02061 {\cf17 template} <{\cf17 typename} T>\par
02062 {\cf17 class }ThreadLocal \{\par
02063  {\cf17 public}:\par
02064   ThreadLocal()\par
02065       : key_(CreateKey()), default_factory_(new DefaultValueHolderFactory()) \{\}\par
02066   {\cf17 explicit} ThreadLocal({\cf17 const} T& value)\par
02067       : key_(CreateKey()),\par
02068         default_factory_(new InstanceValueHolderFactory(value)) \{\}\par
02069 \par
02070   ~ThreadLocal() \{\par
02071     {\cf20 // Destroys the managed object for the current thread, if any.}\par
02072     DeleteThreadLocalValue(pthread_getspecific(key_));\par
02073 \par
02074     {\cf20 // Releases resources associated with the key.  This will *not*}\par
02075     {\cf20 // delete managed objects for other threads.}\par
02076     GTEST_CHECK_POSIX_SUCCESS_(pthread_key_delete(key_));\par
02077   \}\par
02078 \par
02079   T* pointer() \{ {\cf19 return} GetOrCreateValue(); \}\par
02080   {\cf17 const} T* pointer(){\cf17  const }\{ {\cf19 return} GetOrCreateValue(); \}\par
02081   {\cf17 const} T& get(){\cf17  const }\{ {\cf19 return} *pointer(); \}\par
02082   {\cf18 void} set({\cf17 const} T& value) \{ *pointer() = value; \}\par
02083 \par
02084  {\cf17 private}:\par
02085   {\cf20 // Holds a value of type T.}\par
02086   {\cf17 class }ValueHolder : {\cf17 public} ThreadLocalValueHolderBase \{\par
02087    {\cf17 public}:\par
02088     ValueHolder() : value_() \{\}\par
02089     {\cf17 explicit} ValueHolder({\cf17 const} T& value) : value_(value) \{\}\par
02090 \par
02091     T* pointer() \{ {\cf19 return} &value_; \}\par
02092 \par
02093    {\cf17 private}:\par
02094     T value_;\par
02095     GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolder);\par
02096   \};\par
02097 \par
02098   {\cf17 static} pthread_key_t CreateKey() \{\par
02099     pthread_key_t key;\par
02100     {\cf20 // When a thread exits, DeleteThreadLocalValue() will be called on}\par
02101     {\cf20 // the object managed for that thread.}\par
02102     GTEST_CHECK_POSIX_SUCCESS_(\par
02103         pthread_key_create(&key, &DeleteThreadLocalValue));\par
02104     {\cf19 return} key;\par
02105   \}\par
02106 \par
02107   T* GetOrCreateValue(){\cf17  const }\{\par
02108     ThreadLocalValueHolderBase* {\cf17 const} holder =\par
02109         {\cf17 static_cast<}ThreadLocalValueHolderBase*{\cf17 >}(pthread_getspecific(key_));\par
02110     {\cf19 if} (holder != NULL) \{\par
02111       {\cf19 return} CheckedDowncastToActualType<ValueHolder>(holder)->pointer();\par
02112     \}\par
02113 \par
02114     ValueHolder* {\cf17 const} new_holder = default_factory_->MakeNewHolder();\par
02115     ThreadLocalValueHolderBase* {\cf17 const} holder_base = new_holder;\par
02116     GTEST_CHECK_POSIX_SUCCESS_(pthread_setspecific(key_, holder_base));\par
02117     {\cf19 return} new_holder->pointer();\par
02118   \}\par
02119 \par
02120   {\cf17 class }ValueHolderFactory \{\par
02121    {\cf17 public}:\par
02122     ValueHolderFactory() \{\}\par
02123     {\cf17 virtual} ~ValueHolderFactory() \{\}\par
02124     {\cf17 virtual} ValueHolder* MakeNewHolder() {\cf17 const} = 0;\par
02125 \par
02126    {\cf17 private}:\par
02127     GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolderFactory);\par
02128   \};\par
02129 \par
02130   {\cf17 class }DefaultValueHolderFactory : {\cf17 public} ValueHolderFactory \{\par
02131    {\cf17 public}:\par
02132     DefaultValueHolderFactory() \{\}\par
02133     {\cf17 virtual} ValueHolder* MakeNewHolder(){\cf17  const }\{ {\cf19 return} {\cf17 new} ValueHolder(); \}\par
02134 \par
02135    {\cf17 private}:\par
02136     GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultValueHolderFactory);\par
02137   \};\par
02138 \par
02139   {\cf17 class }InstanceValueHolderFactory : {\cf17 public} ValueHolderFactory \{\par
02140    {\cf17 public}:\par
02141     {\cf17 explicit} InstanceValueHolderFactory({\cf17 const} T& value) : value_(value) \{\}\par
02142     {\cf17 virtual} ValueHolder* MakeNewHolder(){\cf17  const }\{\par
02143       {\cf19 return} {\cf17 new} ValueHolder(value_);\par
02144     \}\par
02145 \par
02146    {\cf17 private}:\par
02147     {\cf17 const} T value_;  {\cf20 // The value for each thread.}\par
02148 \par
02149     GTEST_DISALLOW_COPY_AND_ASSIGN_(InstanceValueHolderFactory);\par
02150   \};\par
02151 \par
02152   {\cf20 // A key pthreads uses for looking up per-thread values.}\par
02153   {\cf17 const} pthread_key_t key_;\par
02154   scoped_ptr<ValueHolderFactory> default_factory_;\par
02155 \par
02156   GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocal);\par
02157 \};\par
02158 \par
02159 {\cf21 # endif  }{\cf20 // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_}\par
02160 \par
02161 {\cf21 #else  }{\cf20 // GTEST_IS_THREADSAFE}\par
02162 \par
02163 {\cf20 // A dummy implementation of synchronization primitives (mutex, lock,}\par
02164 {\cf20 // and thread-local variable).  Necessary for compiling Google Test where}\par
02165 {\cf20 // mutex is not supported - using Google Test in multiple threads is not}\par
02166 {\cf20 // supported on such platforms.}\par
02167 \par
02168 {\cf17 class }Mutex \{\par
02169  {\cf17 public}:\par
02170   Mutex() \{\}\par
02171   {\cf18 void} Lock() \{\}\par
02172   {\cf18 void} Unlock() \{\}\par
02173   {\cf18 void} AssertHeld(){\cf17  const }\{\}\par
02174 \};\par
02175 \par
02176 {\cf21 # define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\}\par
02177 {\cf21   extern ::testing::internal::Mutex mutex}\par
02178 \par
02179 {\cf21 # define GTEST_DEFINE_STATIC_MUTEX_(mutex) ::testing::internal::Mutex mutex}\par
02180 \par
02181 {\cf20 // We cannot name this class MutexLock because the ctor declaration would}\par
02182 {\cf20 // conflict with a macro named MutexLock, which is defined on some}\par
02183 {\cf20 // platforms. That macro is used as a defensive measure to prevent against}\par
02184 {\cf20 // inadvertent misuses of MutexLock like "MutexLock(&mu)" rather than}\par
02185 {\cf20 // "MutexLock l(&mu)".  Hence the typedef trick below.}\par
02186 {\cf17 class }GTestMutexLock \{\par
02187  {\cf17 public}:\par
02188   {\cf17 explicit} GTestMutexLock(Mutex*) \{\}  {\cf20 // NOLINT}\par
02189 \};\par
02190 \par
02191 {\cf17 typedef} GTestMutexLock MutexLock;\par
02192 \par
02193 {\cf17 template} <{\cf17 typename} T>\par
02194 {\cf17 class }ThreadLocal \{\par
02195  {\cf17 public}:\par
02196   ThreadLocal() : value_() \{\}\par
02197   {\cf17 explicit} ThreadLocal({\cf17 const} T& value) : value_(value) \{\}\par
02198   T* pointer() \{ {\cf19 return} &value_; \}\par
02199   {\cf17 const} T* pointer(){\cf17  const }\{ {\cf19 return} &value_; \}\par
02200   {\cf17 const} T& get(){\cf17  const }\{ {\cf19 return} value_; \}\par
02201   {\cf18 void} set({\cf17 const} T& value) \{ value_ = value; \}\par
02202  {\cf17 private}:\par
02203   T value_;\par
02204 \};\par
02205 \par
02206 {\cf21 #endif  }{\cf20 // GTEST_IS_THREADSAFE}\par
02207 \par
02208 {\cf20 // Returns the number of threads running in the process, or 0 to indicate that}\par
02209 {\cf20 // we cannot detect it.}\par
02210 GTEST_API_ {\cf18 size_t} GetThreadCount();\par
02211 \par
02212 {\cf20 // Passing non-POD classes through ellipsis (...) crashes the ARM}\par
02213 {\cf20 // compiler and generates a warning in Sun Studio.  The Nokia Symbian}\par
02214 {\cf20 // and the IBM XL C/C++ compiler try to instantiate a copy constructor}\par
02215 {\cf20 // for objects passed through ellipsis (...), failing for uncopyable}\par
02216 {\cf20 // objects.  We define this to ensure that only POD is passed through}\par
02217 {\cf20 // ellipsis on these systems.}\par
02218 {\cf21 #if defined(__SYMBIAN32__) || defined(__IBMCPP__) || defined(__SUNPRO_CC)}\par
02219 {\cf20 // We lose support for NULL detection where the compiler doesn't like}\par
02220 {\cf20 // passing non-POD classes through ellipsis (...).}\par
02221 {\cf21 # define GTEST_ELLIPSIS_NEEDS_POD_ 1}\par
02222 {\cf21 #else}\par
02223 {\cf21 # define GTEST_CAN_COMPARE_NULL 1}\par
02224 {\cf21 #endif}\par
02225 \par
02226 {\cf20 // The Nokia Symbian and IBM XL C/C++ compilers cannot decide between}\par
02227 {\cf20 // const T& and const T* in a function template.  These compilers}\par
02228 {\cf20 // _can_ decide between class template specializations for T and T*,}\par
02229 {\cf20 // so a tr1::type_traits-like is_pointer works.}\par
02230 {\cf21 #if defined(__SYMBIAN32__) || defined(__IBMCPP__)}\par
02231 {\cf21 # define GTEST_NEEDS_IS_POINTER_ 1}\par
02232 {\cf21 #endif}\par
02233 \par
02234 {\cf17 template} <{\cf18 bool} {\cf18 bool}_value>\par
02235 {\cf17 struct }bool_constant \{\par
02236   {\cf17 typedef} bool_constant<bool_value> type;\par
02237   {\cf17 static} {\cf17 const} {\cf18 bool} value = bool_value;\par
02238 \};\par
02239 {\cf17 template} <{\cf18 bool} {\cf18 bool}_value> {\cf17 const} {\cf18 bool} bool_constant<bool_value>::value;\par
02240 \par
02241 {\cf17 typedef} bool_constant<false> false_type;\par
02242 {\cf17 typedef} bool_constant<true> true_type;\par
02243 \par
02244 {\cf17 template} <{\cf17 typename} T>\par
02245 {\cf17 struct }is_pointer : {\cf17 public} false_type \{\};\par
02246 \par
02247 {\cf17 template} <{\cf17 typename} T>\par
02248 {\cf17 struct }is_pointer<T*> : {\cf17 public} true_type \{\};\par
02249 \par
02250 {\cf17 template} <{\cf17 typename} Iterator>\par
02251 {\cf17 struct }IteratorTraits \{\par
02252   {\cf17 typedef} {\cf17 typename} Iterator::value_type value_type;\par
02253 \};\par
02254 \par
02255 {\cf17 template} <{\cf17 typename} T>\par
02256 {\cf17 struct }IteratorTraits<T*> \{\par
02257   {\cf17 typedef} T value_type;\par
02258 \};\par
02259 \par
02260 {\cf17 template} <{\cf17 typename} T>\par
02261 {\cf17 struct }IteratorTraits<const T*> \{\par
02262   {\cf17 typedef} T value_type;\par
02263 \};\par
02264 \par
02265 {\cf21 #if GTEST_OS_WINDOWS}\par
02266 {\cf21 # define GTEST_PATH_SEP_ "\\\\"}\par
02267 {\cf21 # define GTEST_HAS_ALT_PATH_SEP_ 1}\par
02268 {\cf20 // The biggest signed integer type the compiler supports.}\par
02269 {\cf17 typedef} __int64 BiggestInt;\par
02270 {\cf21 #else}\par
02271 {\cf21 # define GTEST_PATH_SEP_ "/"}\par
02272 {\cf21 # define GTEST_HAS_ALT_PATH_SEP_ 0}\par
02273 {\cf17 typedef} {\cf18 long} {\cf18 long} BiggestInt;  {\cf20 // NOLINT}\par
02274 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
02275 \par
02276 {\cf20 // Utilities for char.}\par
02277 \par
02278 {\cf20 // isspace(int ch) and friends accept an unsigned char or EOF.  char}\par
02279 {\cf20 // may be signed, depending on the compiler (or compiler flags).}\par
02280 {\cf20 // Therefore we need to cast a char to unsigned char before calling}\par
02281 {\cf20 // isspace(), etc.}\par
02282 \par
02283 {\cf17 inline} {\cf18 bool} IsAlpha({\cf18 char} ch) \{\par
02284   {\cf19 return} isalpha({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
02285 \}\par
02286 {\cf17 inline} {\cf18 bool} IsAlNum({\cf18 char} ch) \{\par
02287   {\cf19 return} isalnum({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
02288 \}\par
02289 {\cf17 inline} {\cf18 bool} IsDigit({\cf18 char} ch) \{\par
02290   {\cf19 return} isdigit({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
02291 \}\par
02292 {\cf17 inline} {\cf18 bool} IsLower({\cf18 char} ch) \{\par
02293   {\cf19 return} islower({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
02294 \}\par
02295 {\cf17 inline} {\cf18 bool} IsSpace({\cf18 char} ch) \{\par
02296   {\cf19 return} isspace({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
02297 \}\par
02298 {\cf17 inline} {\cf18 bool} IsUpper({\cf18 char} ch) \{\par
02299   {\cf19 return} isupper({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
02300 \}\par
02301 {\cf17 inline} {\cf18 bool} IsXDigit({\cf18 char} ch) \{\par
02302   {\cf19 return} isxdigit({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)) != 0;\par
02303 \}\par
02304 {\cf17 inline} {\cf18 bool} IsXDigit({\cf18 wchar_t} ch) \{\par
02305   {\cf17 const} {\cf18 unsigned} {\cf18 char} low_byte = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch);\par
02306   {\cf19 return} ch == low_byte && isxdigit(low_byte) != 0;\par
02307 \}\par
02308 \par
02309 {\cf17 inline} {\cf18 char} ToLower({\cf18 char} ch) \{\par
02310   {\cf19 return} {\cf17 static_cast<}{\cf18 char}{\cf17 >}(tolower({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)));\par
02311 \}\par
02312 {\cf17 inline} {\cf18 char} ToUpper({\cf18 char} ch) \{\par
02313   {\cf19 return} {\cf17 static_cast<}{\cf18 char}{\cf17 >}(toupper({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)));\par
02314 \}\par
02315 \par
02316 {\cf17 inline} std::string StripTrailingSpaces(std::string str) \{\par
02317   std::string::iterator it = str.end();\par
02318   {\cf19 while} (it != str.begin() && IsSpace(*--it))\par
02319     it = str.erase(it);\par
02320   {\cf19 return} str;\par
02321 \}\par
02322 \par
02323 {\cf20 // The testing::internal::posix namespace holds wrappers for common}\par
02324 {\cf20 // POSIX functions.  These wrappers hide the differences between}\par
02325 {\cf20 // Windows/MSVC and POSIX systems.  Since some compilers define these}\par
02326 {\cf20 // standard functions as macros, the wrapper cannot have the same name}\par
02327 {\cf20 // as the wrapped function.}\par
02328 \par
02329 {\cf17 namespace }posix \{\par
02330 \par
02331 {\cf20 // Functions with a different name on Windows.}\par
02332 \par
02333 {\cf21 #if GTEST_OS_WINDOWS}\par
02334 \par
02335 {\cf17 typedef} {\cf17 struct }_stat StatStruct;\par
02336 \par
02337 {\cf21 # ifdef __BORLANDC__}\par
02338 {\cf17 inline} {\cf18 int} IsATTY({\cf18 int} fd) \{ {\cf19 return} isatty(fd); \}\par
02339 {\cf17 inline} {\cf18 int} StrCaseCmp({\cf17 const} {\cf18 char}* s1, {\cf17 const} {\cf18 char}* s2) \{\par
02340   {\cf19 return} stricmp(s1, s2);\par
02341 \}\par
02342 {\cf17 inline} {\cf18 char}* StrDup({\cf17 const} {\cf18 char}* src) \{ {\cf19 return} strdup(src); \}\par
02343 {\cf21 # else  }{\cf20 // !__BORLANDC__}\par
02344 {\cf21 #  if GTEST_OS_WINDOWS_MOBILE}\par
02345 {\cf17 inline} {\cf18 int} IsATTY({\cf18 int} {\cf20 /* fd */}) \{ {\cf19 return} 0; \}\par
02346 {\cf21 #  else}\par
02347 {\cf17 inline} {\cf18 int} IsATTY({\cf18 int} fd) \{ {\cf19 return} _isatty(fd); \}\par
02348 {\cf21 #  endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
02349 {\cf17 inline} {\cf18 int} StrCaseCmp({\cf17 const} {\cf18 char}* s1, {\cf17 const} {\cf18 char}* s2) \{\par
02350   {\cf19 return} _stricmp(s1, s2);\par
02351 \}\par
02352 {\cf17 inline} {\cf18 char}* StrDup({\cf17 const} {\cf18 char}* src) \{ {\cf19 return} _strdup(src); \}\par
02353 {\cf21 # endif  }{\cf20 // __BORLANDC__}\par
02354 \par
02355 {\cf21 # if GTEST_OS_WINDOWS_MOBILE}\par
02356 {\cf17 inline} {\cf18 int} FileNo(FILE* file) \{ {\cf19 return} {\cf17 reinterpret_cast<}{\cf18 int}{\cf17 >}(_fileno(file)); \}\par
02357 {\cf20 // Stat(), RmDir(), and IsDir() are not needed on Windows CE at this}\par
02358 {\cf20 // time and thus not defined there.}\par
02359 {\cf21 # else}\par
02360 {\cf17 inline} {\cf18 int} FileNo(FILE* file) \{ {\cf19 return} _fileno(file); \}\par
02361 {\cf17 inline} {\cf18 int} Stat({\cf17 const} {\cf18 char}* path, StatStruct* buf) \{ {\cf19 return} _stat(path, buf); \}\par
02362 {\cf17 inline} {\cf18 int} RmDir({\cf17 const} {\cf18 char}* dir) \{ {\cf19 return} _rmdir(dir); \}\par
02363 {\cf17 inline} {\cf18 bool} IsDir({\cf17 const} StatStruct& st) \{\par
02364   {\cf19 return} (_S_IFDIR & st.st_mode) != 0;\par
02365 \}\par
02366 {\cf21 # endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
02367 \par
02368 {\cf21 #else}\par
02369 \par
02370 {\cf17 typedef} {\cf17 struct }stat StatStruct;\par
02371 \par
02372 {\cf17 inline} {\cf18 int} FileNo(FILE* file) \{ {\cf19 return} fileno(file); \}\par
02373 {\cf17 inline} {\cf18 int} IsATTY({\cf18 int} fd) \{ {\cf19 return} isatty(fd); \}\par
02374 {\cf17 inline} {\cf18 int} Stat({\cf17 const} {\cf18 char}* path, StatStruct* buf) \{ {\cf19 return} stat(path, buf); \}\par
02375 {\cf17 inline} {\cf18 int} StrCaseCmp({\cf17 const} {\cf18 char}* s1, {\cf17 const} {\cf18 char}* s2) \{\par
02376   {\cf19 return} strcasecmp(s1, s2);\par
02377 \}\par
02378 {\cf17 inline} {\cf18 char}* StrDup({\cf17 const} {\cf18 char}* src) \{ {\cf19 return} strdup(src); \}\par
02379 {\cf17 inline} {\cf18 int} RmDir({\cf17 const} {\cf18 char}* dir) \{ {\cf19 return} rmdir(dir); \}\par
02380 {\cf17 inline} {\cf18 bool} IsDir({\cf17 const} StatStruct& st) \{ {\cf19 return} S_ISDIR(st.st_mode); \}\par
02381 \par
02382 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
02383 \par
02384 {\cf20 // Functions deprecated by MSVC 8.0.}\par
02385 \par
02386 GTEST_DISABLE_MSC_WARNINGS_PUSH_(4996 {\cf20 /* deprecated function */})\par
02387 \par
02388 inline const {\cf18 char}* StrNCpy({\cf18 char}* dest, const {\cf18 char}* src, {\cf18 size_t} n) \{\par
02389   {\cf19 return} strncpy(dest, src, n);\par
02390 \}\par
02391 \par
02392 {\cf20 // ChDir(), FReopen(), FDOpen(), Read(), Write(), Close(), and}\par
02393 {\cf20 // StrError() aren't needed on Windows CE at this time and thus not}\par
02394 {\cf20 // defined there.}\par
02395 \par
02396 {\cf21 #if !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT}\par
02397 {\cf17 inline} {\cf18 int} ChDir({\cf17 const} {\cf18 char}* dir) \{ {\cf19 return} chdir(dir); \}\par
02398 {\cf21 #endif}\par
02399 {\cf17 inline} FILE* FOpen({\cf17 const} {\cf18 char}* path, {\cf17 const} {\cf18 char}* mode) \{\par
02400   {\cf19 return} fopen(path, mode);\par
02401 \}\par
02402 {\cf21 #if !GTEST_OS_WINDOWS_MOBILE}\par
02403 {\cf17 inline} FILE *FReopen({\cf17 const} {\cf18 char}* path, {\cf17 const} {\cf18 char}* mode, FILE* stream) \{\par
02404   {\cf19 return} freopen(path, mode, stream);\par
02405 \}\par
02406 {\cf17 inline} FILE* FDOpen({\cf18 int} fd, {\cf17 const} {\cf18 char}* mode) \{ {\cf19 return} fdopen(fd, mode); \}\par
02407 {\cf21 #endif}\par
02408 {\cf17 inline} {\cf18 int} FClose(FILE* fp) \{ {\cf19 return} fclose(fp); \}\par
02409 {\cf21 #if !GTEST_OS_WINDOWS_MOBILE}\par
02410 {\cf17 inline} {\cf18 int} Read({\cf18 int} fd, {\cf18 void}* buf, {\cf18 unsigned} {\cf18 int} count) \{\par
02411   {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(read(fd, buf, count));\par
02412 \}\par
02413 {\cf17 inline} {\cf18 int} Write({\cf18 int} fd, {\cf17 const} {\cf18 void}* buf, {\cf18 unsigned} {\cf18 int} count) \{\par
02414   {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(write(fd, buf, count));\par
02415 \}\par
02416 {\cf17 inline} {\cf18 int} Close({\cf18 int} fd) \{ {\cf19 return} close(fd); \}\par
02417 {\cf17 inline} {\cf17 const} {\cf18 char}* StrError({\cf18 int} errnum) \{ {\cf19 return} strerror(errnum); \}\par
02418 {\cf21 #endif}\par
02419 {\cf17 inline} {\cf17 const} {\cf18 char}* GetEnv({\cf17 const} {\cf18 char}* name) \{\par
02420 {\cf21 #if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE | GTEST_OS_WINDOWS_RT}\par
02421   {\cf20 // We are on Windows CE, which has no environment variables.}\par
02422   {\cf17 static_cast<}{\cf18 void}{\cf17 >}(name);  {\cf20 // To prevent 'unused argument' warning.}\par
02423   {\cf19 return} NULL;\par
02424 {\cf21 #elif defined(__BORLANDC__) || defined(__SunOS_5_8) || defined(__SunOS_5_9)}\par
02425   {\cf20 // Environment variables which we programmatically clear will be set to the}\par
02426   {\cf20 // empty string rather than unset (NULL).  Handle that case.}\par
02427   {\cf17 const} {\cf18 char}* {\cf17 const} env = getenv(name);\par
02428   {\cf19 return} (env != NULL && env[0] != {\cf23 '\\0'}) ? env : NULL;\par
02429 {\cf21 #else}\par
02430   {\cf19 return} getenv(name);\par
02431 {\cf21 #endif}\par
02432 \}\par
02433 \par
02434 GTEST_DISABLE_MSC_WARNINGS_POP_()\par
02435 \par
02436 {\cf21 #if GTEST_OS_WINDOWS_MOBILE}\par
02437 {\cf20 // Windows CE has no C library. The abort() function is used in}\par
02438 {\cf20 // several places in Google Test. This implementation provides a reasonable}\par
02439 {\cf20 // imitation of standard behaviour.}\par
02440 {\cf18 void} Abort();\par
02441 {\cf21 #else}\par
02442 {\cf17 inline} {\cf18 void} Abort() \{ abort(); \}\par
02443 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
02444 \par
02445 \}  {\cf20 // namespace posix}\par
02446 \par
02447 {\cf20 // MSVC "deprecates" snprintf and issues warnings wherever it is used.  In}\par
02448 {\cf20 // order to avoid these warnings, we need to use _snprintf or _snprintf_s on}\par
02449 {\cf20 // MSVC-based platforms.  We map the GTEST_SNPRINTF_ macro to the appropriate}\par
02450 {\cf20 // function in order to achieve that.  We use macro definition here because}\par
02451 {\cf20 // snprintf is a variadic function.}\par
02452 {\cf21 #if _MSC_VER >= 1400 && !GTEST_OS_WINDOWS_MOBILE}\par
02453 {\cf20 // MSVC 2005 and above support variadic macros.}\par
02454 {\cf21 # define GTEST_SNPRINTF_(buffer, size, format, ...) \\}\par
02455 {\cf21      _snprintf_s(buffer, size, size, format, __VA_ARGS__)}\par
02456 {\cf21 #elif defined(_MSC_VER)}\par
02457 {\cf20 // Windows CE does not define _snprintf_s and MSVC prior to 2005 doesn't}\par
02458 {\cf20 // complain about _snprintf.}\par
02459 {\cf21 # define GTEST_SNPRINTF_ _snprintf}\par
02460 {\cf21 #else}\par
02461 {\cf21 # define GTEST_SNPRINTF_ snprintf}\par
02462 {\cf21 #endif}\par
02463 \par
02464 {\cf20 // The maximum number a BiggestInt can represent.  This definition}\par
02465 {\cf20 // works no matter BiggestInt is represented in one's complement or}\par
02466 {\cf20 // two's complement.}\par
02467 {\cf20 //}\par
02468 {\cf20 // We cannot rely on numeric_limits in STL, as __int64 and long long}\par
02469 {\cf20 // are not part of standard C++ and numeric_limits doesn't need to be}\par
02470 {\cf20 // defined for them.}\par
02471 {\cf17 const} BiggestInt kMaxBiggestInt =\par
02472     ~({\cf17 static_cast<}BiggestInt{\cf17 >}(1) << (8*{\cf17 sizeof}(BiggestInt) - 1));\par
02473 \par
02474 {\cf20 // This template class serves as a compile-time function from size to}\par
02475 {\cf20 // type.  It maps a size in bytes to a primitive type with that}\par
02476 {\cf20 // size. e.g.}\par
02477 {\cf20 //}\par
02478 {\cf20 //   TypeWithSize<4>::UInt}\par
02479 {\cf20 //}\par
02480 {\cf20 // is typedef-ed to be unsigned int (unsigned integer made up of 4}\par
02481 {\cf20 // bytes).}\par
02482 {\cf20 //}\par
02483 {\cf20 // Such functionality should belong to STL, but I cannot find it}\par
02484 {\cf20 // there.}\par
02485 {\cf20 //}\par
02486 {\cf20 // Google Test uses this class in the implementation of floating-point}\par
02487 {\cf20 // comparison.}\par
02488 {\cf20 //}\par
02489 {\cf20 // For now it only handles UInt (unsigned int) as that's all Google Test}\par
02490 {\cf20 // needs.  Other types can be easily added in the future if need}\par
02491 {\cf20 // arises.}\par
02492 {\cf17 template} <{\cf18 size_t} size>\par
02493 {\cf17 class }TypeWithSize \{\par
02494  {\cf17 public}:\par
02495   {\cf20 // This prevents the user from using TypeWithSize<N> with incorrect}\par
02496   {\cf20 // values of N.}\par
02497   {\cf17 typedef} {\cf18 void} UInt;\par
02498 \};\par
02499 \par
02500 {\cf20 // The specialization for size 4.}\par
02501 {\cf17 template} <>\par
02502 {\cf17 class }TypeWithSize<4> \{\par
02503  {\cf17 public}:\par
02504   {\cf20 // unsigned int has size 4 in both gcc and MSVC.}\par
02505   {\cf20 //}\par
02506   {\cf20 // As base/basictypes.h doesn't compile on Windows, we cannot use}\par
02507   {\cf20 // uint32, uint64, and etc here.}\par
02508   {\cf17 typedef} {\cf18 int} Int;\par
02509   {\cf17 typedef} {\cf18 unsigned} {\cf18 int} UInt;\par
02510 \};\par
02511 \par
02512 {\cf20 // The specialization for size 8.}\par
02513 {\cf17 template} <>\par
02514 {\cf17 class }TypeWithSize<8> \{\par
02515  {\cf17 public}:\par
02516 {\cf21 #if GTEST_OS_WINDOWS}\par
02517   {\cf17 typedef} __int64 Int;\par
02518   {\cf17 typedef} {\cf18 unsigned} __int64 UInt;\par
02519 {\cf21 #else}\par
02520   {\cf17 typedef} {\cf18 long} {\cf18 long} Int;  {\cf20 // NOLINT}\par
02521   {\cf17 typedef} {\cf18 unsigned} {\cf18 long} {\cf18 long} UInt;  {\cf20 // NOLINT}\par
02522 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
02523 \};\par
02524 \par
02525 {\cf20 // Integer types of known sizes.}\par
02526 {\cf17 typedef} TypeWithSize<4>::Int Int32;\par
02527 {\cf17 typedef} TypeWithSize<4>::UInt UInt32;\par
02528 {\cf17 typedef} TypeWithSize<8>::Int Int64;\par
02529 {\cf17 typedef} TypeWithSize<8>::UInt UInt64;\par
02530 {\cf17 typedef} TypeWithSize<8>::Int TimeInMillis;  {\cf20 // Represents time in milliseconds.}\par
02531 \par
02532 {\cf20 // Utilities for command line flags and environment variables.}\par
02533 \par
02534 {\cf20 // Macro for referencing flags.}\par
02535 {\cf21 #if !defined(GTEST_FLAG)}\par
02536 {\cf21 # define GTEST_FLAG(name) FLAGS_gtest_##name}\par
02537 {\cf21 #endif  }{\cf20 // !defined(GTEST_FLAG)}\par
02538 \par
02539 {\cf21 #if !defined(GTEST_USE_OWN_FLAGFILE_FLAG_)}\par
02540 {\cf21 # define GTEST_USE_OWN_FLAGFILE_FLAG_ 1}\par
02541 {\cf21 #endif  }{\cf20 // !defined(GTEST_USE_OWN_FLAGFILE_FLAG_)}\par
02542 \par
02543 {\cf21 #if !defined(GTEST_DECLARE_bool_)}\par
02544 {\cf21 # define GTEST_FLAG_SAVER_ ::testing::internal::GTestFlagSaver}\par
02545 \par
02546 {\cf20 // Macros for declaring flags.}\par
02547 {\cf21 # define GTEST_DECLARE_bool_(name) GTEST_API_ extern bool GTEST_FLAG(name)}\par
02548 {\cf21 # define GTEST_DECLARE_int32_(name) \\}\par
02549 {\cf21     GTEST_API_ extern ::testing::internal::Int32 GTEST_FLAG(name)}\par
02550 {\cf21 #define GTEST_DECLARE_string_(name) \\}\par
02551 {\cf21     GTEST_API_ extern ::std::string GTEST_FLAG(name)}\par
02552 \par
02553 {\cf20 // Macros for defining flags.}\par
02554 {\cf21 #define GTEST_DEFINE_bool_(name, default_val, doc) \\}\par
02555 {\cf21     GTEST_API_ bool GTEST_FLAG(name) = (default_val)}\par
02556 {\cf21 #define GTEST_DEFINE_int32_(name, default_val, doc) \\}\par
02557 {\cf21     GTEST_API_ ::testing::internal::Int32 GTEST_FLAG(name) = (default_val)}\par
02558 {\cf21 #define GTEST_DEFINE_string_(name, default_val, doc) \\}\par
02559 {\cf21     GTEST_API_ ::std::string GTEST_FLAG(name) = (default_val)}\par
02560 \par
02561 {\cf21 #endif  }{\cf20 // !defined(GTEST_DECLARE_bool_)}\par
02562 \par
02563 {\cf20 // Thread annotations}\par
02564 {\cf21 #if !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)}\par
02565 {\cf21 # define GTEST_EXCLUSIVE_LOCK_REQUIRED_(locks)}\par
02566 {\cf21 # define GTEST_LOCK_EXCLUDED_(locks)}\par
02567 {\cf21 #endif  }{\cf20 // !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)}\par
02568 \par
02569 {\cf20 // Parses 'str' for a 32-bit signed integer.  If successful, writes the result}\par
02570 {\cf20 // to *value and returns true; otherwise leaves *value unchanged and returns}\par
02571 {\cf20 // false.}\par
02572 {\cf20 // TODO(chandlerc): Find a better way to refactor flag and environment parsing}\par
02573 {\cf20 // out of both gtest-port.cc and gtest.cc to avoid exporting this utility}\par
02574 {\cf20 // function.}\par
02575 {\cf18 bool} ParseInt32({\cf17 const} Message& src_text, {\cf17 const} {\cf18 char}* str, Int32* value);\par
02576 \par
02577 {\cf20 // Parses a bool/Int32/string from the environment variable}\par
02578 {\cf20 // corresponding to the given Google Test flag.}\par
02579 {\cf18 bool} BoolFromGTestEnv({\cf17 const} {\cf18 char}* flag, {\cf18 bool} default_val);\par
02580 GTEST_API_ Int32 Int32FromGTestEnv({\cf17 const} {\cf18 char}* flag, Int32 default_val);\par
02581 std::string StringFromGTestEnv({\cf17 const} {\cf18 char}* flag, {\cf17 const} {\cf18 char}* default_val);\par
02582 \par
02583 \}  {\cf20 // namespace internal}\par
02584 \par
02585 {\cf20 // Returns a path to temporary directory.}\par
02586 {\cf20 // Tries to determine an appropriate directory for the platform.}\par
02587 GTEST_API_ std::string TempDir();\par
02588 \par
02589 \}  {\cf20 // namespace testing}\par
02590 \par
02591 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/internal/gtest-death-test-internal.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-death-test-internal.h}
{\xe \v gtest/include/gtest/internal/gtest-death-test-internal.h}
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/internal/gtest-internal.h"}\par
{\f2 #include <stdio.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_UNSUPPORTED_DEATH_TEST_}(statement,  regex,  terminator)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::internal::GTEST_DECLARE_string_} (internal_run_death_test)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kDeathTestStyleFlag} [] = "death_test_style"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kDeathTestUseFork} [] = "death_test_use_fork"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kInternalRunDeathTestFlag} [] = "internal_run_death_test"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v GTEST_UNSUPPORTED_DEATH_TEST_\:gtest-death-test-internal.h}
{\xe \v gtest-death-test-internal.h\:GTEST_UNSUPPORTED_DEATH_TEST_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_UNSUPPORTED_DEATH_TEST_( statement,  regex,  terminator)}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\par
    if (::testing::internal::AlwaysTrue()) \{ \\\par
      GTEST_LOG_(WARNING) \\\par
          << {\cf22 "Death tests are not supported on this platform.\\n"} \\\par
          << {\cf22 "Statement '"} #statement {\cf22 "' cannot be verified."}; \\\par
    \} {\cf19 else} {\cf19 if} (::testing::internal::AlwaysFalse()) \{ \\\par
      ::testing::internal::RE::PartialMatch({\cf22 ".*"}, (regex)); \\\par
      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\par
      terminator; \\\par
    \} else \\\par
      ::testing::Message()\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-death-test-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 301}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-death-test-internal.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-death-test-internal.h}
{\xe \v gtest/include/gtest/internal/gtest-death-test-internal.h}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2005, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)}\par
00031 {\cf20 //}\par
00032 {\cf20 // The Google C++ Testing Framework (Google Test)}\par
00033 {\cf20 //}\par
00034 {\cf20 // This header file defines internal utilities needed for implementing}\par
00035 {\cf20 // death tests.  They are subject to change without notice.}\par
00036 \par
00037 {\cf21 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_}\par
00038 {\cf21 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_}\par
00039 \par
00040 {\cf21 #include "gtest/internal/gtest-internal.h"}\par
00041 \par
00042 {\cf21 #include <stdio.h>}\par
00043 \par
00044 {\cf17 namespace }testing \{\par
00045 {\cf17 namespace }internal \{\par
00046 \par
00047 GTEST_DECLARE_string_(internal_run_death_test);\par
00048 \par
00049 {\cf20 // Names of the flags (needed for parsing Google Test flags).}\par
00050 {\cf17 const} {\cf18 char} kDeathTestStyleFlag[] = {\cf22 "death_test_style"};\par
00051 {\cf17 const} {\cf18 char} kDeathTestUseFork[] = {\cf22 "death_test_use_fork"};\par
00052 {\cf17 const} {\cf18 char} kInternalRunDeathTestFlag[] = {\cf22 "internal_run_death_test"};\par
00053 \par
00054 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
00055 \par
00056 {\cf20 // DeathTest is a class that hides much of the complexity of the}\par
00057 {\cf20 // GTEST_DEATH_TEST_ macro.  It is abstract; its static Create method}\par
00058 {\cf20 // returns a concrete class that depends on the prevailing death test}\par
00059 {\cf20 // style, as defined by the --gtest_death_test_style and/or}\par
00060 {\cf20 // --gtest_internal_run_death_test flags.}\par
00061 \par
00062 {\cf20 // In describing the results of death tests, these terms are used with}\par
00063 {\cf20 // the corresponding definitions:}\par
00064 {\cf20 //}\par
00065 {\cf20 // exit status:  The integer exit information in the format specified}\par
00066 {\cf20 //               by wait(2)}\par
00067 {\cf20 // exit code:    The integer code passed to exit(3), _exit(2), or}\par
00068 {\cf20 //               returned from main()}\par
00069 {\cf17 class }GTEST_API_ DeathTest \{\par
00070  {\cf17 public}:\par
00071   {\cf20 // Create returns false if there was an error determining the}\par
00072   {\cf20 // appropriate action to take for the current death test; for example,}\par
00073   {\cf20 // if the gtest_death_test_style flag is set to an invalid value.}\par
00074   {\cf20 // The LastMessage method will return a more detailed message in that}\par
00075   {\cf20 // case.  Otherwise, the DeathTest pointer pointed to by the "test"}\par
00076   {\cf20 // argument is set.  If the death test should be skipped, the pointer}\par
00077   {\cf20 // is set to NULL; otherwise, it is set to the address of a new concrete}\par
00078   {\cf20 // DeathTest object that controls the execution of the current test.}\par
00079   {\cf17 static} {\cf18 bool} Create({\cf17 const} {\cf18 char}* statement, {\cf17 const} RE* regex,\par
00080                      {\cf17 const} {\cf18 char}* file, {\cf18 int} line, DeathTest** test);\par
00081   DeathTest();\par
00082   {\cf17 virtual} ~DeathTest() \{ \}\par
00083 \par
00084   {\cf20 // A helper class that aborts a death test when it's deleted.}\par
00085   {\cf17 class }ReturnSentinel \{\par
00086    {\cf17 public}:\par
00087     {\cf17 explicit} ReturnSentinel(DeathTest* test) : test_(test) \{ \}\par
00088     ~ReturnSentinel() \{ test_->Abort(TEST_ENCOUNTERED_RETURN_STATEMENT); \}\par
00089    {\cf17 private}:\par
00090     DeathTest* {\cf17 const} test_;\par
00091     GTEST_DISALLOW_COPY_AND_ASSIGN_(ReturnSentinel);\par
00092   \} GTEST_ATTRIBUTE_UNUSED_;\par
00093 \par
00094   {\cf20 // An enumeration of possible roles that may be taken when a death}\par
00095   {\cf20 // test is encountered.  EXECUTE means that the death test logic should}\par
00096   {\cf20 // be executed immediately.  OVERSEE means that the program should prepare}\par
00097   {\cf20 // the appropriate environment for a child process to execute the death}\par
00098   {\cf20 // test, then wait for it to complete.}\par
00099   {\cf17 enum} TestRole \{ OVERSEE_TEST, EXECUTE_TEST \};\par
00100 \par
00101   {\cf20 // An enumeration of the three reasons that a test might be aborted.}\par
00102   {\cf17 enum} AbortReason \{\par
00103     TEST_ENCOUNTERED_RETURN_STATEMENT,\par
00104     TEST_THREW_EXCEPTION,\par
00105     TEST_DID_NOT_DIE\par
00106   \};\par
00107 \par
00108   {\cf20 // Assumes one of the above roles.}\par
00109   {\cf17 virtual} TestRole AssumeRole() = 0;\par
00110 \par
00111   {\cf20 // Waits for the death test to finish and returns its status.}\par
00112   {\cf17 virtual} {\cf18 int} Wait() = 0;\par
00113 \par
00114   {\cf20 // Returns true if the death test passed; that is, the test process}\par
00115   {\cf20 // exited during the test, its exit status matches a user-supplied}\par
00116   {\cf20 // predicate, and its stderr output matches a user-supplied regular}\par
00117   {\cf20 // expression.}\par
00118   {\cf20 // The user-supplied predicate may be a macro expression rather}\par
00119   {\cf20 // than a function pointer or functor, or else Wait and Passed could}\par
00120   {\cf20 // be combined.}\par
00121   {\cf17 virtual} {\cf18 bool} Passed({\cf18 bool} exit_status_ok) = 0;\par
00122 \par
00123   {\cf20 // Signals that the death test did not die as expected.}\par
00124   {\cf17 virtual} {\cf18 void} Abort(AbortReason reason) = 0;\par
00125 \par
00126   {\cf20 // Returns a human-readable outcome message regarding the outcome of}\par
00127   {\cf20 // the last death test.}\par
00128   {\cf17 static} {\cf17 const} {\cf18 char}* LastMessage();\par
00129 \par
00130   {\cf17 static} {\cf18 void} set_last_death_test_message({\cf17 const} std::string& message);\par
00131 \par
00132  {\cf17 private}:\par
00133   {\cf20 // A string containing a description of the outcome of the last death test.}\par
00134   {\cf17 static} std::string last_death_test_message_;\par
00135 \par
00136   GTEST_DISALLOW_COPY_AND_ASSIGN_(DeathTest);\par
00137 \};\par
00138 \par
00139 {\cf20 // Factory interface for death tests.  May be mocked out for testing.}\par
00140 {\cf17 class }DeathTestFactory \{\par
00141  {\cf17 public}:\par
00142   {\cf17 virtual} ~DeathTestFactory() \{ \}\par
00143   {\cf17 virtual} {\cf18 bool} Create({\cf17 const} {\cf18 char}* statement, {\cf17 const} RE* regex,\par
00144                       {\cf17 const} {\cf18 char}* file, {\cf18 int} line, DeathTest** test) = 0;\par
00145 \};\par
00146 \par
00147 {\cf20 // A concrete DeathTestFactory implementation for normal use.}\par
00148 {\cf17 class }DefaultDeathTestFactory : {\cf17 public} DeathTestFactory \{\par
00149  {\cf17 public}:\par
00150   {\cf17 virtual} {\cf18 bool} Create({\cf17 const} {\cf18 char}* statement, {\cf17 const} RE* regex,\par
00151                       {\cf17 const} {\cf18 char}* file, {\cf18 int} line, DeathTest** test);\par
00152 \};\par
00153 \par
00154 {\cf20 // Returns true if exit_status describes a process that was terminated}\par
00155 {\cf20 // by a signal, or exited normally with a nonzero exit code.}\par
00156 GTEST_API_ {\cf18 bool} ExitedUnsuccessfully({\cf18 int} exit_status);\par
00157 \par
00158 {\cf20 // Traps C++ exceptions escaping statement and reports them as test}\par
00159 {\cf20 // failures. Note that trapping SEH exceptions is not implemented here.}\par
00160 {\cf21 # if GTEST_HAS_EXCEPTIONS}\par
00161 {\cf21 #  define GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, death_test) \\}\par
00162 {\cf21   try \{ \\}\par
00163 {\cf21     GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\}\par
00164 {\cf21   \} catch (const ::std::exception& gtest_exception) \{ \\}\par
00165 {\cf21     fprintf(\\}\par
00166 {\cf21         stderr, \\}\par
00167 {\cf21         "\\n%s: Caught std::exception-derived exception escaping the "} \\\par
00168         "death test statement. Exception message: %s\\n", \\\par
00169         ::testing::internal::FormatFileLocation(__FILE__, __LINE__).c_str(), \\\par
00170         gtest_exception.what()); \\\par
00171     fflush(stderr); \\\par
00172     death_test->Abort(::testing::internal::DeathTest::TEST_THREW_EXCEPTION); \\\par
00173   \} catch (...) \{ \\\par
00174     death_test->Abort(::testing::internal::DeathTest::TEST_THREW_EXCEPTION); \\\par
00175   \}\par
00176 \par
00177 {\cf21 # else}\par
00178 {\cf21 #  define GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, death_test) \\}\par
00179 {\cf21   GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement)}\par
00180 \par
00181 {\cf21 # endif}\par
00182 \par
00183 {\cf20 // This macro is for implementing ASSERT_DEATH*, EXPECT_DEATH*,}\par
00184 {\cf20 // ASSERT_EXIT*, and EXPECT_EXIT*.}\par
00185 {\cf21 # define GTEST_DEATH_TEST_(statement, predicate, regex, fail) \\}\par
00186 {\cf21   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\}\par
00187 {\cf21   if (::testing::internal::AlwaysTrue()) \{ \\}\par
00188 {\cf21     const ::testing::internal::RE& gtest_regex = (regex); \\}\par
00189 {\cf21     ::testing::internal::DeathTest* gtest_dt; \\}\par
00190 {\cf21     if (!::testing::internal::DeathTest::Create(#statement, &gtest_regex, \\}\par
00191 {\cf21         __FILE__, __LINE__, &gtest_dt)) \{ \\}\par
00192 {\cf21       goto GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__); \\}\par
00193 {\cf21     \} \\}\par
00194 {\cf21     if (gtest_dt != NULL) \{ \\}\par
00195 {\cf21       ::testing::internal::scoped_ptr< ::testing::internal::DeathTest> \\}\par
00196 {\cf21           gtest_dt_ptr(gtest_dt); \\}\par
00197 {\cf21       switch (gtest_dt->AssumeRole()) \{ \\}\par
00198 {\cf21         case ::testing::internal::DeathTest::OVERSEE_TEST: \\}\par
00199 {\cf21           if (!gtest_dt->Passed(predicate(gtest_dt->Wait()))) \{ \\}\par
00200 {\cf21             goto GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__); \\}\par
00201 {\cf21           \} \\}\par
00202 {\cf21           break; \\}\par
00203 {\cf21         case ::testing::internal::DeathTest::EXECUTE_TEST: \{ \\}\par
00204 {\cf21           ::testing::internal::DeathTest::ReturnSentinel \\}\par
00205 {\cf21               gtest_sentinel(gtest_dt); \\}\par
00206 {\cf21           GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, gtest_dt); \\}\par
00207 {\cf21           gtest_dt->Abort(::testing::internal::DeathTest::TEST_DID_NOT_DIE); \\}\par
00208 {\cf21           break; \\}\par
00209 {\cf21         \} \\}\par
00210 {\cf21         default: \\}\par
00211 {\cf21           break; \\}\par
00212 {\cf21       \} \\}\par
00213 {\cf21     \} \\}\par
00214 {\cf21   \} else \\}\par
00215 {\cf21     GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__): \\}\par
00216 {\cf21       fail(::testing::internal::DeathTest::LastMessage())}\par
00217 {\cf20 // The symbol "fail" here expands to something into which a message}\par
00218 {\cf20 // can be streamed.}\par
00219 \par
00220 {\cf20 // This macro is for implementing ASSERT/EXPECT_DEBUG_DEATH when compiled in}\par
00221 {\cf20 // NDEBUG mode. In this case we need the statements to be executed, the regex is}\par
00222 {\cf20 // ignored, and the macro must accept a streamed message even though the message}\par
00223 {\cf20 // is never printed.}\par
00224 {\cf21 # define GTEST_EXECUTE_STATEMENT_(statement, regex) \\}\par
00225 {\cf21   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\}\par
00226 {\cf21   if (::testing::internal::AlwaysTrue()) \{ \\}\par
00227 {\cf21      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\}\par
00228 {\cf21   \} else \\}\par
00229 {\cf21     ::testing::Message()}\par
00230 \par
00231 {\cf20 // A class representing the parsed contents of the}\par
00232 {\cf20 // --gtest_internal_run_death_test flag, as it existed when}\par
00233 {\cf20 // RUN_ALL_TESTS was called.}\par
00234 {\cf17 class }InternalRunDeathTestFlag \{\par
00235  {\cf17 public}:\par
00236   InternalRunDeathTestFlag({\cf17 const} std::string& a_file,\par
00237                            {\cf18 int} a_line,\par
00238                            {\cf18 int} an_index,\par
00239                            {\cf18 int} a_write_fd)\par
00240       : file_(a_file), line_(a_line), index_(an_index),\par
00241         write_fd_(a_write_fd) \{\}\par
00242 \par
00243   ~InternalRunDeathTestFlag() \{\par
00244     {\cf19 if} (write_fd_ >= 0)\par
00245       posix::Close(write_fd_);\par
00246   \}\par
00247 \par
00248   {\cf17 const} std::string& file(){\cf17  const }\{ {\cf19 return} file_; \}\par
00249   {\cf18 int} line(){\cf17  const }\{ {\cf19 return} line_; \}\par
00250   {\cf18 int} index(){\cf17  const }\{ {\cf19 return} index_; \}\par
00251   {\cf18 int} write_fd(){\cf17  const }\{ {\cf19 return} write_fd_; \}\par
00252 \par
00253  {\cf17 private}:\par
00254   std::string file_;\par
00255   {\cf18 int} line_;\par
00256   {\cf18 int} index_;\par
00257   {\cf18 int} write_fd_;\par
00258 \par
00259   GTEST_DISALLOW_COPY_AND_ASSIGN_(InternalRunDeathTestFlag);\par
00260 \};\par
00261 \par
00262 {\cf20 // Returns a newly created InternalRunDeathTestFlag object with fields}\par
00263 {\cf20 // initialized from the GTEST_FLAG(internal_run_death_test) flag if}\par
00264 {\cf20 // the flag is specified; otherwise returns NULL.}\par
00265 InternalRunDeathTestFlag* ParseInternalRunDeathTestFlag();\par
00266 \par
00267 {\cf21 #else  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
00268 \par
00269 {\cf20 // This macro is used for implementing macros such as}\par
00270 {\cf20 // EXPECT_DEATH_IF_SUPPORTED and ASSERT_DEATH_IF_SUPPORTED on systems where}\par
00271 {\cf20 // death tests are not supported. Those macros must compile on such systems}\par
00272 {\cf20 // iff EXPECT_DEATH and ASSERT_DEATH compile with the same parameters on}\par
00273 {\cf20 // systems that support death tests. This allows one to write such a macro}\par
00274 {\cf20 // on a system that does not support death tests and be sure that it will}\par
00275 {\cf20 // compile on a death-test supporting system.}\par
00276 {\cf20 //}\par
00277 {\cf20 // Parameters:}\par
00278 {\cf20 //   statement -  A statement that a macro such as EXPECT_DEATH would test}\par
00279 {\cf20 //                for program termination. This macro has to make sure this}\par
00280 {\cf20 //                statement is compiled but not executed, to ensure that}\par
00281 {\cf20 //                EXPECT_DEATH_IF_SUPPORTED compiles with a certain}\par
00282 {\cf20 //                parameter iff EXPECT_DEATH compiles with it.}\par
00283 {\cf20 //   regex     -  A regex that a macro such as EXPECT_DEATH would use to test}\par
00284 {\cf20 //                the output of statement.  This parameter has to be}\par
00285 {\cf20 //                compiled but not evaluated by this macro, to ensure that}\par
00286 {\cf20 //                this macro only accepts expressions that a macro such as}\par
00287 {\cf20 //                EXPECT_DEATH would accept.}\par
00288 {\cf20 //   terminator - Must be an empty statement for EXPECT_DEATH_IF_SUPPORTED}\par
00289 {\cf20 //                and a return statement for ASSERT_DEATH_IF_SUPPORTED.}\par
00290 {\cf20 //                This ensures that ASSERT_DEATH_IF_SUPPORTED will not}\par
00291 {\cf20 //                compile inside functions where ASSERT_DEATH doesn't}\par
00292 {\cf20 //                compile.}\par
00293 {\cf20 //}\par
00294 {\cf20 //  The branch that has an always false condition is used to ensure that}\par
00295 {\cf20 //  statement and regex are compiled (and thus syntactically correct) but}\par
00296 {\cf20 //  never executed. The unreachable code macro protects the terminator}\par
00297 {\cf20 //  statement from generating an 'unreachable code' warning in case}\par
00298 {\cf20 //  statement unconditionally returns or throws. The Message constructor at}\par
00299 {\cf20 //  the end allows the syntax of streaming additional messages into the}\par
00300 {\cf20 //  macro, for compilational compatibility with EXPECT_DEATH/ASSERT_DEATH.}\par
00301 {\cf21 # define GTEST_UNSUPPORTED_DEATH_TEST_(statement, regex, terminator) \\}\par
00302 {\cf21     GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\}\par
00303 {\cf21     if (::testing::internal::AlwaysTrue()) \{ \\}\par
00304 {\cf21       GTEST_LOG_(WARNING) \\}\par
00305 {\cf21           << "Death tests are not supported on this platform.\\n"} \\\par
00306           << "Statement '" #statement "' cannot be verified."; \\\par
00307     \} else if (::testing::internal::AlwaysFalse()) \{ \\\par
00308       ::testing::internal::RE::PartialMatch(".*", (regex)); \\\par
00309       GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\par
00310       terminator; \\\par
00311     \} else \\\par
00312       ::testing::Message()\par
00313 \par
00314 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
00315 \par
00316 \}  {\cf20 // namespace internal}\par
00317 \}  {\cf20 // namespace testing}\par
00318 \par
00319 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/internal/gtest-filepath.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-filepath.h}
{\xe \v gtest/include/gtest/internal/gtest-filepath.h}
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/internal/gtest-string.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::FilePath}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-filepath.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-filepath.h}
{\xe \v gtest/include/gtest/internal/gtest-filepath.h}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2008, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: keith.ray@gmail.com (Keith Ray)}\par
00031 {\cf20 //}\par
00032 {\cf20 // Google Test filepath utilities}\par
00033 {\cf20 //}\par
00034 {\cf20 // This header file declares classes and functions used internally by}\par
00035 {\cf20 // Google Test.  They are subject to change without notice.}\par
00036 {\cf20 //}\par
00037 {\cf20 // This file is #included in <gtest/internal/gtest-internal.h>.}\par
00038 {\cf20 // Do not include this header file separately!}\par
00039 \par
00040 {\cf21 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_}\par
00041 {\cf21 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_}\par
00042 \par
00043 {\cf21 #include "gtest/internal/gtest-string.h"}\par
00044 \par
00045 {\cf17 namespace }testing \{\par
00046 {\cf17 namespace }internal \{\par
00047 \par
00048 {\cf20 // FilePath - a class for file and directory pathname manipulation which}\par
00049 {\cf20 // handles platform-specific conventions (like the pathname separator).}\par
00050 {\cf20 // Used for helper functions for naming files in a directory for xml output.}\par
00051 {\cf20 // Except for Set methods, all methods are const or static, which provides an}\par
00052 {\cf20 // "immutable value object" -- useful for peace of mind.}\par
00053 {\cf20 // A FilePath with a value ending in a path separator ("like/this/") represents}\par
00054 {\cf20 // a directory, otherwise it is assumed to represent a file. In either case,}\par
00055 {\cf20 // it may or may not represent an actual file or directory in the file system.}\par
00056 {\cf20 // Names are NOT checked for syntax correctness -- no checking for illegal}\par
00057 {\cf20 // characters, malformed paths, etc.}\par
00058 \par
00059 {\cf17 class }GTEST_API_ FilePath \{\par
00060  {\cf17 public}:\par
00061   FilePath() : pathname_({\cf22 ""}) \{ \}\par
00062   FilePath({\cf17 const} FilePath& rhs) : pathname_(rhs.pathname_) \{ \}\par
00063 \par
00064   {\cf17 explicit} FilePath({\cf17 const} std::string& pathname) : pathname_(pathname) \{\par
00065     Normalize();\par
00066   \}\par
00067 \par
00068   FilePath& operator=({\cf17 const} FilePath& rhs) \{\par
00069     Set(rhs);\par
00070     {\cf19 return} *{\cf17 this};\par
00071   \}\par
00072 \par
00073   {\cf18 void} Set({\cf17 const} FilePath& rhs) \{\par
00074     pathname_ = rhs.pathname_;\par
00075   \}\par
00076 \par
00077   {\cf17 const} std::string& string(){\cf17  const }\{ {\cf19 return} pathname_; \}\par
00078   {\cf17 const} {\cf18 char}* c_str(){\cf17  const }\{ {\cf19 return} pathname_.c_str(); \}\par
00079 \par
00080   {\cf20 // Returns the current working directory, or "" if unsuccessful.}\par
00081   {\cf17 static} FilePath GetCurrentDir();\par
00082 \par
00083   {\cf20 // Given directory = "dir", base_name = "test", number = 0,}\par
00084   {\cf20 // extension = "xml", returns "dir/test.xml". If number is greater}\par
00085   {\cf20 // than zero (e.g., 12), returns "dir/test_12.xml".}\par
00086   {\cf20 // On Windows platform, uses \\ as the separator rather than /.}\par
00087   {\cf17 static} FilePath MakeFileName({\cf17 const} FilePath& directory,\par
00088                                {\cf17 const} FilePath& base_name,\par
00089                                {\cf18 int} number,\par
00090                                {\cf17 const} {\cf18 char}* extension);\par
00091 \par
00092   {\cf20 // Given directory = "dir", relative_path = "test.xml",}\par
00093   {\cf20 // returns "dir/test.xml".}\par
00094   {\cf20 // On Windows, uses \\ as the separator rather than /.}\par
00095   {\cf17 static} FilePath ConcatPaths({\cf17 const} FilePath& directory,\par
00096                               {\cf17 const} FilePath& relative_path);\par
00097 \par
00098   {\cf20 // Returns a pathname for a file that does not currently exist. The pathname}\par
00099   {\cf20 // will be directory/base_name.extension or}\par
00100   {\cf20 // directory/base_name_<number>.extension if directory/base_name.extension}\par
00101   {\cf20 // already exists. The number will be incremented until a pathname is found}\par
00102   {\cf20 // that does not already exist.}\par
00103   {\cf20 // Examples: 'dir/foo_test.xml' or 'dir/foo_test_1.xml'.}\par
00104   {\cf20 // There could be a race condition if two or more processes are calling this}\par
00105   {\cf20 // function at the same time -- they could both pick the same filename.}\par
00106   {\cf17 static} FilePath GenerateUniqueFileName({\cf17 const} FilePath& directory,\par
00107                                          {\cf17 const} FilePath& base_name,\par
00108                                          {\cf17 const} {\cf18 char}* extension);\par
00109 \par
00110   {\cf20 // Returns true iff the path is "".}\par
00111   {\cf18 bool} IsEmpty(){\cf17  const }\{ {\cf19 return} pathname_.empty(); \}\par
00112 \par
00113   {\cf20 // If input name has a trailing separator character, removes it and returns}\par
00114   {\cf20 // the name, otherwise return the name string unmodified.}\par
00115   {\cf20 // On Windows platform, uses \\ as the separator, other platforms use /.}\par
00116   FilePath RemoveTrailingPathSeparator() {\cf17 const};\par
00117 \par
00118   {\cf20 // Returns a copy of the FilePath with the directory part removed.}\par
00119   {\cf20 // Example: FilePath("path/to/file").RemoveDirectoryName() returns}\par
00120   {\cf20 // FilePath("file"). If there is no directory part ("just_a_file"), it returns}\par
00121   {\cf20 // the FilePath unmodified. If there is no file part ("just_a_dir/") it}\par
00122   {\cf20 // returns an empty FilePath ("").}\par
00123   {\cf20 // On Windows platform, '\\' is the path separator, otherwise it is '/'.}\par
00124   FilePath RemoveDirectoryName() {\cf17 const};\par
00125 \par
00126   {\cf20 // RemoveFileName returns the directory path with the filename removed.}\par
00127   {\cf20 // Example: FilePath("path/to/file").RemoveFileName() returns "path/to/".}\par
00128   {\cf20 // If the FilePath is "a_file" or "/a_file", RemoveFileName returns}\par
00129   {\cf20 // FilePath("./") or, on Windows, FilePath(".\\\\"). If the filepath does}\par
00130   {\cf20 // not have a file, like "just/a/dir/", it returns the FilePath unmodified.}\par
00131   {\cf20 // On Windows platform, '\\' is the path separator, otherwise it is '/'.}\par
00132   FilePath RemoveFileName() {\cf17 const};\par
00133 \par
00134   {\cf20 // Returns a copy of the FilePath with the case-insensitive extension removed.}\par
00135   {\cf20 // Example: FilePath("dir/file.exe").RemoveExtension("EXE") returns}\par
00136   {\cf20 // FilePath("dir/file"). If a case-insensitive extension is not}\par
00137   {\cf20 // found, returns a copy of the original FilePath.}\par
00138   FilePath RemoveExtension({\cf17 const} {\cf18 char}* extension) {\cf17 const};\par
00139 \par
00140   {\cf20 // Creates directories so that path exists. Returns true if successful or if}\par
00141   {\cf20 // the directories already exist; returns false if unable to create}\par
00142   {\cf20 // directories for any reason. Will also return false if the FilePath does}\par
00143   {\cf20 // not represent a directory (that is, it doesn't end with a path separator).}\par
00144   {\cf18 bool} CreateDirectoriesRecursively() {\cf17 const};\par
00145 \par
00146   {\cf20 // Create the directory so that path exists. Returns true if successful or}\par
00147   {\cf20 // if the directory already exists; returns false if unable to create the}\par
00148   {\cf20 // directory for any reason, including if the parent directory does not}\par
00149   {\cf20 // exist. Not named "CreateDirectory" because that's a macro on Windows.}\par
00150   {\cf18 bool} CreateFolder() {\cf17 const};\par
00151 \par
00152   {\cf20 // Returns true if FilePath describes something in the file-system,}\par
00153   {\cf20 // either a file, directory, or whatever, and that something exists.}\par
00154   {\cf18 bool} FileOrDirectoryExists() {\cf17 const};\par
00155 \par
00156   {\cf20 // Returns true if pathname describes a directory in the file-system}\par
00157   {\cf20 // that exists.}\par
00158   {\cf18 bool} DirectoryExists() {\cf17 const};\par
00159 \par
00160   {\cf20 // Returns true if FilePath ends with a path separator, which indicates that}\par
00161   {\cf20 // it is intended to represent a directory. Returns false otherwise.}\par
00162   {\cf20 // This does NOT check that a directory (or file) actually exists.}\par
00163   {\cf18 bool} IsDirectory() {\cf17 const};\par
00164 \par
00165   {\cf20 // Returns true if pathname describes a root directory. (Windows has one}\par
00166   {\cf20 // root directory per disk drive.)}\par
00167   {\cf18 bool} IsRootDirectory() {\cf17 const};\par
00168 \par
00169   {\cf20 // Returns true if pathname describes an absolute path.}\par
00170   {\cf18 bool} IsAbsolutePath() {\cf17 const};\par
00171 \par
00172  {\cf17 private}:\par
00173   {\cf20 // Replaces multiple consecutive separators with a single separator.}\par
00174   {\cf20 // For example, "bar///foo" becomes "bar/foo". Does not eliminate other}\par
00175   {\cf20 // redundancies that might be in a pathname involving "." or "..".}\par
00176   {\cf20 //}\par
00177   {\cf20 // A pathname with multiple consecutive separators may occur either through}\par
00178   {\cf20 // user error or as a result of some scripts or APIs that generate a pathname}\par
00179   {\cf20 // with a trailing separator. On other platforms the same API or script}\par
00180   {\cf20 // may NOT generate a pathname with a trailing "/". Then elsewhere that}\par
00181   {\cf20 // pathname may have another "/" and pathname components added to it,}\par
00182   {\cf20 // without checking for the separator already being there.}\par
00183   {\cf20 // The script language and operating system may allow paths like "foo//bar"}\par
00184   {\cf20 // but some of the functions in FilePath will not handle that correctly. In}\par
00185   {\cf20 // particular, RemoveTrailingPathSeparator() only removes one separator, and}\par
00186   {\cf20 // it is called in CreateDirectoriesRecursively() assuming that it will change}\par
00187   {\cf20 // a pathname from directory syntax (trailing separator) to filename syntax.}\par
00188   {\cf20 //}\par
00189   {\cf20 // On Windows this method also replaces the alternate path separator '/' with}\par
00190   {\cf20 // the primary path separator '\\\\', so that for example "bar\\\\/\\\\foo" becomes}\par
00191   {\cf20 // "bar\\\\foo".}\par
00192 \par
00193   {\cf18 void} Normalize();\par
00194 \par
00195   {\cf20 // Returns a pointer to the last occurence of a valid path separator in}\par
00196   {\cf20 // the FilePath. On Windows, for example, both '/' and '\\' are valid path}\par
00197   {\cf20 // separators. Returns NULL if no path separator was found.}\par
00198   {\cf17 const} {\cf18 char}* FindLastPathSeparator() {\cf17 const};\par
00199 \par
00200   std::string pathname_;\par
00201 \};  {\cf20 // class FilePath}\par
00202 \par
00203 \}  {\cf20 // namespace internal}\par
00204 \}  {\cf20 // namespace testing}\par
00205 \par
00206 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/internal/gtest-internal.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-internal.h}
{\xe \v gtest/include/gtest/internal/gtest-internal.h}
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/internal/gtest-port.h"}\par
{\f2 #include <ctype.h>}\par
{\f2 #include <float.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <iomanip>}\par
{\f2 #include <limits>}\par
{\f2 #include <map>}\par
{\f2 #include <set>}\par
{\f2 #include <string>}\par
{\f2 #include <vector>}\par
{\f2 #include "gtest/gtest-message.h"}\par
{\f2 #include "gtest/internal/gtest-string.h"}\par
{\f2 #include "gtest/internal/gtest-filepath.h"}\par
{\f2 #include "gtest/internal/gtest-type-util.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::ScopedTrace}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::FloatingPoint< RawType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::TypeIdHelper< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::TestFactoryBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::TestFactoryImpl< TestClass >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::CodeLocation}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::ConstCharPtr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::Random}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::CompileAssertTypesEqual< T, T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::RemoveReference< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::RemoveReference< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::RemoveConst< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::RemoveConst< const T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::RemoveConst< const T[N]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::AddReference< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::AddReference< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::ImplicitlyConvertible< From, To >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::IsAProtocolMessage< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::EnableIf< true >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::RelationToSourceReference}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::RelationToSourceCopy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::NativeArray< Element >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b proto2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal::edit_distance}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_CONCAT_TOKEN_}(foo,  bar)\~ {\b GTEST_CONCAT_TOKEN_IMPL_}(foo, bar)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_CONCAT_TOKEN_IMPL_}(foo,  bar)\~ foo ## bar\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_IS_NULL_LITERAL_}(x)\~     (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_REMOVE_REFERENCE_}(T)\~     typename {\b ::testing::internal::RemoveReference}<T>::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_REMOVE_CONST_}(T)\~     typename {\b ::testing::internal::RemoveConst}<T>::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_REMOVE_REFERENCE_AND_CONST_}(T)\~     {\b GTEST_REMOVE_CONST_}({\b GTEST_REMOVE_REFERENCE_}(T))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ADD_REFERENCE_}(T)\~     typename {\b ::testing::internal::AddReference}<T>::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_REFERENCE_TO_CONST_}(T)\~     {\b GTEST_ADD_REFERENCE_}(const {\b GTEST_REMOVE_REFERENCE_}(T))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_MESSAGE_AT_}(file,  line,  message,  result_type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_MESSAGE_}(message,  result_type)\~   {\b GTEST_MESSAGE_AT_}(__FILE__, __LINE__, message, result_type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_FATAL_FAILURE_}(message)\~   return {\b GTEST_MESSAGE_}(message, {\b ::testing::TestPartResult::kFatalFailure})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_NONFATAL_FAILURE_}(message)\~   {\b GTEST_MESSAGE_}(message, {\b ::testing::TestPartResult::kNonFatalFailure})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_SUCCESS_}(message)\~   {\b GTEST_MESSAGE_}(message, {\b ::testing::TestPartResult::kSuccess})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_}(statement)\~   if (::testing::internal::AlwaysTrue()) \{ statement; \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_TEST_THROW_}(statement,  expected_exception,  fail)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_TEST_NO_THROW_}(statement,  fail)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_TEST_ANY_THROW_}(statement,  fail)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_TEST_BOOLEAN_}(expression,  text,  actual,  expected,  fail)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_TEST_NO_FATAL_FAILURE_}(statement,  fail)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_TEST_CLASS_NAME_}(test_case_name,  test_name)\~   test_case_name##_##test_name##_Test\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_TEST_}(test_case_name,  test_name,  parent_class,  parent_id)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'FF \'F2\'E8\'EF\'EE\'E2\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef FloatingPoint< float > {\b testing::internal::Float}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef FloatingPoint< double > {\b testing::internal::Double}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef const void * {\b testing::internal::TypeId}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b testing::internal::SetUpTestCaseFunc}) ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b testing::internal::TearDownTestCaseFunc}) ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef int {\b testing::internal::IsContainer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef char {\b testing::internal::IsNotContainer}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b testing::internal::edit_distance::EditType} \{ {\b testing::internal::edit_distance::kMatch}
, {\b testing::internal::edit_distance::kAdd}
, {\b testing::internal::edit_distance::kRemove}
, {\b testing::internal::edit_distance::kReplace}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > ::std::string {\b testing::PrintToString} (const T &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b testing::internal::IsNullLiteralHelper} (Secret *p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char(& {\b testing::internal::IsNullLiteralHelper} (...))[2]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::AppendUserMessage} (const std::string &gtest_msg, const Message &user_msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::vector< EditType > {\b testing::internal::edit_distance::CalculateOptimalEdits} (const std::vector< size_t > &left, const std::vector< size_t > &right)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::vector< EditType > {\b testing::internal::edit_distance::CalculateOptimalEdits} (const std::vector< std::string > &left, const std::vector< std::string > &right)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::edit_distance::CreateUnifiedDiff} (const std::vector< std::string > &left, const std::vector< std::string > &right, size_t context=2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::DiffStrings} (const std::string &left, const std::string &right, size_t *total_line_count)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::EqFailure} (const char *expected_expression, const char *actual_expression, const std::string &expected_value, const std::string &actual_value, bool ignoring_case)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::GetBoolAssertionFailureMessage} (const AssertionResult &assertion_result, const char *expression_text, const char *actual_predicate_value, const char *expected_predicate_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > TypeId {\b testing::internal::GetTypeId} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} TypeId {\b testing::internal::GetTestTypeId} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} TestInfo * {\b testing::internal::MakeAndRegisterTestInfo} (const char *test_case_name, const char *name, const char *type_param, const char *value_param, CodeLocation code_location, TypeId fixture_class_id, SetUpTestCaseFunc set_up_tc, TearDownTestCaseFunc tear_down_tc, TestFactoryBase *factory)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::SkipPrefix} (const char *prefix, const char **pstr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::GetCurrentOsStackTraceExceptTop} (UnitTest *unit_test, int skip_count)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::AlwaysTrue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::AlwaysFalse} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class C > IsContainer {\b testing::internal::IsContainerTest} (int, typename C::iterator *=NULL, typename C::const_iterator *=NULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class C > IsNotContainer {\b testing::internal::IsContainerTest} (long)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U > bool {\b testing::internal::ArrayEq} (const T *lhs, size_t size, const U *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U > bool {\b testing::internal::ArrayEq} (const T &lhs, const U &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U , size_t N> bool {\b testing::internal::ArrayEq} (const T(&lhs)[N], const U(&rhs)[N])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Iter , typename Element > Iter {\b testing::internal::ArrayAwareFind} (Iter begin, Iter end, const Element &elem)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U > void {\b testing::internal::CopyArray} (const T *from, size_t size, U *to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U > void {\b testing::internal::CopyArray} (const T &from, U *to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U , size_t N> void {\b testing::internal::CopyArray} (const T(&from)[N], U(*to)[N])\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} const char {\b testing::internal::kStackTraceMarker} [] = "\\nStack trace:\\n"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GTEST_API_} {\b testing::internal::ScopedTrace} {\b testing::internal::GTEST_ATTRIBUTE_UNUSED_}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v GTEST_ADD_REFERENCE_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_ADD_REFERENCE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ADD_REFERENCE_( T)\~     typename {\b ::testing::internal::AddReference}<T>::type}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 837}}\par
}
{\xe \v GTEST_CONCAT_TOKEN_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_CONCAT_TOKEN_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_CONCAT_TOKEN_( foo,  bar)\~ {\b GTEST_CONCAT_TOKEN_IMPL_}(foo, bar)}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 76}}\par
}
{\xe \v GTEST_CONCAT_TOKEN_IMPL_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_CONCAT_TOKEN_IMPL_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_CONCAT_TOKEN_IMPL_( foo,  bar)\~ foo ## bar}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 77}}\par
}
{\xe \v GTEST_FATAL_FAILURE_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_FATAL_FAILURE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_FATAL_FAILURE_( message)\~   return {\b GTEST_MESSAGE_}(message, {\b ::testing::TestPartResult::kFatalFailure})}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1110}}\par
}
{\xe \v GTEST_IS_NULL_LITERAL_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_IS_NULL_LITERAL_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_IS_NULL_LITERAL_( x)\~     (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 132}}\par
}
{\xe \v GTEST_MESSAGE_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_MESSAGE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_MESSAGE_( message,  result_type)\~   {\b GTEST_MESSAGE_AT_}(__FILE__, __LINE__, message, result_type)}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1107}}\par
}
{\xe \v GTEST_MESSAGE_AT_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_MESSAGE_AT_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_MESSAGE_AT_( file,  line,  message,  result_type)}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   ::testing::internal::AssertHelper(result_type, file, line, message) \\\par
    = ::testing::Message()\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1103}}\par
}
{\xe \v GTEST_NONFATAL_FAILURE_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_NONFATAL_FAILURE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_NONFATAL_FAILURE_( message)\~   {\b GTEST_MESSAGE_}(message, {\b ::testing::TestPartResult::kNonFatalFailure})}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1113}}\par
}
{\xe \v GTEST_REFERENCE_TO_CONST_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_REFERENCE_TO_CONST_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_REFERENCE_TO_CONST_( T)\~     {\b GTEST_ADD_REFERENCE_}(const {\b GTEST_REMOVE_REFERENCE_}(T))}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 849}}\par
}
{\xe \v GTEST_REMOVE_CONST_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_REMOVE_CONST_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_REMOVE_CONST_( T)\~     typename {\b ::testing::internal::RemoveConst}<T>::type}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 820}}\par
}
{\xe \v GTEST_REMOVE_REFERENCE_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_REMOVE_REFERENCE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_REMOVE_REFERENCE_( T)\~     typename {\b ::testing::internal::RemoveReference}<T>::type}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 789}}\par
}
{\xe \v GTEST_REMOVE_REFERENCE_AND_CONST_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_REMOVE_REFERENCE_AND_CONST_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_REMOVE_REFERENCE_AND_CONST_( T)\~     {\b GTEST_REMOVE_CONST_}({\b GTEST_REMOVE_REFERENCE_}(T))}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 824}}\par
}
{\xe \v GTEST_SUCCESS_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_SUCCESS_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_SUCCESS_( message)\~   {\b GTEST_MESSAGE_}(message, {\b ::testing::TestPartResult::kSuccess})}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1116}}\par
}
{\xe \v GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_( statement)\~   if (::testing::internal::AlwaysTrue()) \{ statement; \}}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1122}}\par
}
{\xe \v GTEST_TEST_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_TEST_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_TEST_( test_case_name,  test_name,  parent_class,  parent_id)}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 class }GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : {\cf17 public} parent_class \{\\\par
 public:\\\par
  GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() \{\}\\\par
 private:\\\par
  virtual {\cf18 void} TestBody();\\\par
  static ::testing::TestInfo* {\cf17 const} test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\par
  GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\par
      GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\par
\};\\\par
\\\par
::testing::TestInfo* {\cf17 const} GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\par
  ::test_info_ =\\\par
    ::testing::internal::MakeAndRegisterTestInfo(\\\par
        #test_case_name, #test_name, NULL, NULL, \\\par
        ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\par
        (parent_id), \\\par
        parent_class::SetUpTestCase, \\\par
        parent_class::TearDownTestCase, \\\par
        new ::testing::internal::TestFactoryImpl<\\\par
            GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\par
void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1215}}\par
}
{\xe \v GTEST_TEST_ANY_THROW_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_TEST_ANY_THROW_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_TEST_ANY_THROW_( statement,  fail)}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\par
  if (::testing::internal::AlwaysTrue()) \{ \\\par
    bool gtest_caught_any = {\cf17 false}; \\\par
    try \{ \\\par
      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\par
    \} \\\par
    catch (...) \{ \\\par
      gtest_caught_any = {\cf17 true}; \\\par
    \} \\\par
    if (!gtest_caught_any) \{ \\\par
      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \\\par
    \} \\\par
  \} else \\\par
    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \\\par
      fail({\cf22 "Expected: "} #statement {\cf22 " throws an exception.\\n"} \\\par
           {\cf22 "  Actual: it doesn't."})\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1165}}\par
}
{\xe \v GTEST_TEST_BOOLEAN_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_TEST_BOOLEAN_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_TEST_BOOLEAN_( expression,  text,  actual,  expected,  fail)}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\par
  if (const ::testing::AssertionResult gtest_ar_ = \\\par
      ::testing::AssertionResult(expression)) \\\par
    ; \\\par
  else \\\par
    fail(::testing::internal::GetBoolAssertionFailureMessage(\\\par
        gtest_ar_, text, #actual, #expected).c_str())\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1187}}\par
}
{\xe \v GTEST_TEST_CLASS_NAME_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_TEST_CLASS_NAME_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_TEST_CLASS_NAME_( test_case_name,  test_name)\~   test_case_name##_##test_name##_Test}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1211}}\par
}
{\xe \v GTEST_TEST_NO_FATAL_FAILURE_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_TEST_NO_FATAL_FAILURE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_TEST_NO_FATAL_FAILURE_( statement,  fail)}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\par
  if (::testing::internal::AlwaysTrue()) \{ \\\par
    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \\\par
    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\par
    if (gtest_fatal_failure_checker.has_new_fatal_failure()) \{ \\\par
      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \\\par
    \} \\\par
  \} else \\\par
    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \\\par
      fail({\cf22 "Expected: "} #statement {\cf22 " doesn't generate new fatal "} \\\par
           {\cf22 "failures in the current thread.\\n"} \\\par
           {\cf22 "  Actual: it does."})\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1196}}\par
}
{\xe \v GTEST_TEST_NO_THROW_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_TEST_NO_THROW_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_TEST_NO_THROW_( statement,  fail)}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\par
  if (::testing::internal::AlwaysTrue()) \{ \\\par
    try \{ \\\par
      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\par
    \} \\\par
    catch (...) \{ \\\par
      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \\\par
    \} \\\par
  \} else \\\par
    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \\\par
      fail({\cf22 "Expected: "} #statement {\cf22 " doesn't throw an exception.\\n"} \\\par
           {\cf22 "  Actual: it throws."})\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1151}}\par
}
{\xe \v GTEST_TEST_THROW_\:gtest-internal.h}
{\xe \v gtest-internal.h\:GTEST_TEST_THROW_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_TEST_THROW_( statement,  expected_exception,  fail)}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\par
  if (::testing::internal::ConstCharPtr gtest_msg = {\cf22 ""}) \{ \\\par
    bool gtest_caught_expected = {\cf17 false}; \\\par
    try \{ \\\par
      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\par
    \} \\\par
    catch (expected_exception {\cf17 const}&) \{ \\\par
      gtest_caught_expected = {\cf17 true}; \\\par
    \} \\\par
    catch (...) \{ \\\par
      gtest_msg.value = \\\par
          {\cf22 "Expected: "} #statement {\cf22 " throws an exception of type "} \\\par
{\cf21           #expected_exception ".\\n  Actual: it throws a different type."}; \\\par
      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\par
    \} \\\par
    if (!gtest_caught_expected) \{ \\\par
      gtest_msg.value = \\\par
          "Expected: " #statement " throws an exception of type " \\\par
          #expected_exception ".\\n  Actual: it throws nothing."; \\\par
      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\par
    \} \\\par
  \} else \\\par
    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \\\par
      fail(gtest_msg.value)\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-internal.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1125}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-internal.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-internal.h}
{\xe \v gtest/include/gtest/internal/gtest-internal.h}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2005, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)}\par
00031 {\cf20 //}\par
00032 {\cf20 // The Google C++ Testing Framework (Google Test)}\par
00033 {\cf20 //}\par
00034 {\cf20 // This header file declares functions and macros used internally by}\par
00035 {\cf20 // Google Test.  They are subject to change without notice.}\par
00036 \par
00037 {\cf21 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_}\par
00038 {\cf21 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_}\par
00039 \par
00040 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00041 \par
00042 {\cf21 #if GTEST_OS_LINUX}\par
00043 {\cf21 # include <stdlib.h>}\par
00044 {\cf21 # include <sys/types.h>}\par
00045 {\cf21 # include <sys/wait.h>}\par
00046 {\cf21 # include <unistd.h>}\par
00047 {\cf21 #endif  }{\cf20 // GTEST_OS_LINUX}\par
00048 \par
00049 {\cf21 #if GTEST_HAS_EXCEPTIONS}\par
00050 {\cf21 # include <stdexcept>}\par
00051 {\cf21 #endif}\par
00052 \par
00053 {\cf21 #include <ctype.h>}\par
00054 {\cf21 #include <float.h>}\par
00055 {\cf21 #include <string.h>}\par
00056 {\cf21 #include <iomanip>}\par
00057 {\cf21 #include <limits>}\par
00058 {\cf21 #include <map>}\par
00059 {\cf21 #include <set>}\par
00060 {\cf21 #include <string>}\par
00061 {\cf21 #include <vector>}\par
00062 \par
00063 {\cf21 #include "gtest/gtest-message.h"}\par
00064 {\cf21 #include "gtest/internal/gtest-string.h"}\par
00065 {\cf21 #include "gtest/internal/gtest-filepath.h"}\par
00066 {\cf21 #include "gtest/internal/gtest-type-util.h"}\par
00067 \par
00068 {\cf20 // Due to C++ preprocessor weirdness, we need double indirection to}\par
00069 {\cf20 // concatenate two tokens when one of them is __LINE__.  Writing}\par
00070 {\cf20 //}\par
00071 {\cf20 //   foo ## __LINE__}\par
00072 {\cf20 //}\par
00073 {\cf20 // will result in the token foo__LINE__, instead of foo followed by}\par
00074 {\cf20 // the current line number.  For more details, see}\par
00075 {\cf20 // http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6}\par
00076 {\cf21 #define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)}\par
00077 {\cf21 #define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar}\par
00078 \par
00079 {\cf17 class }ProtocolMessage;\par
00080 {\cf17 namespace }proto2 \{ {\cf17 class }Message; \}\par
00081 \par
00082 {\cf17 namespace }testing \{\par
00083 \par
00084 {\cf20 // Forward declarations.}\par
00085 \par
00086 {\cf17 class }AssertionResult;                 {\cf20 // Result of an assertion.}\par
00087 {\cf17 class }Message;                         {\cf20 // Represents a failure message.}\par
00088 {\cf17 class }Test;                            {\cf20 // Represents a test.}\par
00089 {\cf17 class }TestInfo;                        {\cf20 // Information about a test.}\par
00090 {\cf17 class }TestPartResult;                  {\cf20 // Result of a test part.}\par
00091 {\cf17 class }UnitTest;                        {\cf20 // A collection of test cases.}\par
00092 \par
00093 {\cf17 template} <{\cf17 typename} T>\par
00094 ::std::string PrintToString({\cf17 const} T& value);\par
00095 \par
00096 {\cf17 namespace }internal \{\par
00097 \par
00098 {\cf17 struct }TraceInfo;                      {\cf20 // Information about a trace point.}\par
00099 {\cf17 class }ScopedTrace;                     {\cf20 // Implements scoped trace.}\par
00100 {\cf17 class }TestInfoImpl;                    {\cf20 // Opaque implementation of TestInfo}\par
00101 {\cf17 class }UnitTestImpl;                    {\cf20 // Opaque implementation of UnitTest}\par
00102 \par
00103 {\cf20 // The text used in failure messages to indicate the start of the}\par
00104 {\cf20 // stack trace.}\par
00105 GTEST_API_ {\cf17 extern} {\cf17 const} {\cf18 char} kStackTraceMarker[];\par
00106 \par
00107 {\cf20 // Two overloaded helpers for checking at compile time whether an}\par
00108 {\cf20 // expression is a null pointer literal (i.e. NULL or any 0-valued}\par
00109 {\cf20 // compile-time integral constant).  Their return values have}\par
00110 {\cf20 // different sizes, so we can use sizeof() to test which version is}\par
00111 {\cf20 // picked by the compiler.  These helpers have no implementations, as}\par
00112 {\cf20 // we only need their signatures.}\par
00113 {\cf20 //}\par
00114 {\cf20 // Given IsNullLiteralHelper(x), the compiler will pick the first}\par
00115 {\cf20 // version if x can be implicitly converted to Secret*, and pick the}\par
00116 {\cf20 // second version otherwise.  Since Secret is a secret and incomplete}\par
00117 {\cf20 // type, the only expression a user can write that has type Secret* is}\par
00118 {\cf20 // a null pointer literal.  Therefore, we know that x is a null}\par
00119 {\cf20 // pointer literal if and only if the first version is picked by the}\par
00120 {\cf20 // compiler.}\par
00121 {\cf18 char} IsNullLiteralHelper(Secret* p);\par
00122 char (&IsNullLiteralHelper(...))[2];  {\cf20 // NOLINT}\par
00123 \par
00124 {\cf20 // A compile-time bool constant that is true if and only if x is a}\par
00125 {\cf20 // null pointer literal (i.e. NULL or any 0-valued compile-time}\par
00126 {\cf20 // integral constant).}\par
00127 {\cf21 #ifdef GTEST_ELLIPSIS_NEEDS_POD_}\par
00128 {\cf20 // We lose support for NULL detection where the compiler doesn't like}\par
00129 {\cf20 // passing non-POD classes through ellipsis (...).}\par
00130 {\cf21 # define GTEST_IS_NULL_LITERAL_(x) false}\par
00131 {\cf21 #else}\par
00132 {\cf21 # define GTEST_IS_NULL_LITERAL_(x) \\}\par
00133 {\cf21     (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)}\par
00134 {\cf21 #endif  }{\cf20 // GTEST_ELLIPSIS_NEEDS_POD_}\par
00135 \par
00136 {\cf20 // Appends the user-supplied message to the Google-Test-generated message.}\par
00137 GTEST_API_ std::string AppendUserMessage(\par
00138     {\cf17 const} std::string& gtest_msg, {\cf17 const} Message& user_msg);\par
00139 \par
00140 {\cf21 #if GTEST_HAS_EXCEPTIONS}\par
00141 \par
00142 {\cf20 // This exception is thrown by (and only by) a failed Google Test}\par
00143 {\cf20 // assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions}\par
00144 {\cf20 // are enabled).  We derive it from std::runtime_error, which is for}\par
00145 {\cf20 // errors presumably detectable only at run time.  Since}\par
00146 {\cf20 // std::runtime_error inherits from std::exception, many testing}\par
00147 {\cf20 // frameworks know how to extract and print the message inside it.}\par
00148 {\cf17 class }GTEST_API_ GoogleTestFailureException : {\cf17 public} ::std::runtime_error \{\par
00149  {\cf17 public}:\par
00150   {\cf17 explicit} GoogleTestFailureException({\cf17 const} TestPartResult& failure);\par
00151 \};\par
00152 \par
00153 {\cf21 #endif  }{\cf20 // GTEST_HAS_EXCEPTIONS}\par
00154 \par
00155 {\cf20 // A helper class for creating scoped traces in user programs.}\par
00156 {\cf17 class }GTEST_API_ ScopedTrace \{\par
00157  {\cf17 public}:\par
00158   {\cf20 // The c'tor pushes the given source file location and message onto}\par
00159   {\cf20 // a trace stack maintained by Google Test.}\par
00160   ScopedTrace({\cf17 const} {\cf18 char}* file, {\cf18 int} line, {\cf17 const} Message& message);\par
00161 \par
00162   {\cf20 // The d'tor pops the info pushed by the c'tor.}\par
00163   {\cf20 //}\par
00164   {\cf20 // Note that the d'tor is not virtual in order to be efficient.}\par
00165   {\cf20 // Don't inherit from ScopedTrace!}\par
00166   ~ScopedTrace();\par
00167 \par
00168  {\cf17 private}:\par
00169   GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);\par
00170 \} GTEST_ATTRIBUTE_UNUSED_;  {\cf20 // A ScopedTrace object does its job in its}\par
00171                             {\cf20 // c'tor and d'tor.  Therefore it doesn't}\par
00172                             {\cf20 // need to be used otherwise.}\par
00173 \par
00174 {\cf17 namespace }edit_distance \{\par
00175 {\cf20 // Returns the optimal edits to go from 'left' to 'right'.}\par
00176 {\cf20 // All edits cost the same, with replace having lower priority than}\par
00177 {\cf20 // add/remove.}\par
00178 {\cf20 // Simple implementation of the Wagner-Fischer algorithm.}\par
00179 {\cf20 // See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm}\par
00180 {\cf17 enum} EditType \{ kMatch, kAdd, kRemove, kReplace \};\par
00181 GTEST_API_ std::vector<EditType> CalculateOptimalEdits(\par
00182     {\cf17 const} std::vector<size_t>& left, {\cf17 const} std::vector<size_t>& right);\par
00183 \par
00184 {\cf20 // Same as above, but the input is represented as strings.}\par
00185 GTEST_API_ std::vector<EditType> CalculateOptimalEdits(\par
00186     {\cf17 const} std::vector<std::string>& left,\par
00187     {\cf17 const} std::vector<std::string>& right);\par
00188 \par
00189 {\cf20 // Create a diff of the input strings in Unified diff format.}\par
00190 GTEST_API_ std::string CreateUnifiedDiff({\cf17 const} std::vector<std::string>& left,\par
00191                                          {\cf17 const} std::vector<std::string>& right,\par
00192                                          {\cf18 size_t} context = 2);\par
00193 \par
00194 \}  {\cf20 // namespace edit_distance}\par
00195 \par
00196 {\cf20 // Calculate the diff between 'left' and 'right' and return it in unified diff}\par
00197 {\cf20 // format.}\par
00198 {\cf20 // If not null, stores in 'total_line_count' the total number of lines found}\par
00199 {\cf20 // in left + right.}\par
00200 GTEST_API_ std::string DiffStrings({\cf17 const} std::string& left,\par
00201                                    {\cf17 const} std::string& right,\par
00202                                    {\cf18 size_t}* total_line_count);\par
00203 \par
00204 {\cf20 // Constructs and returns the message for an equality assertion}\par
00205 {\cf20 // (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.}\par
00206 {\cf20 //}\par
00207 {\cf20 // The first four parameters are the expressions used in the assertion}\par
00208 {\cf20 // and their values, as strings.  For example, for ASSERT_EQ(foo, bar)}\par
00209 {\cf20 // where foo is 5 and bar is 6, we have:}\par
00210 {\cf20 //}\par
00211 {\cf20 //   expected_expression: "foo"}\par
00212 {\cf20 //   actual_expression:   "bar"}\par
00213 {\cf20 //   expected_value:      "5"}\par
00214 {\cf20 //   actual_value:        "6"}\par
00215 {\cf20 //}\par
00216 {\cf20 // The ignoring_case parameter is true iff the assertion is a}\par
00217 {\cf20 // *_STRCASEEQ*.  When it's true, the string " (ignoring case)" will}\par
00218 {\cf20 // be inserted into the message.}\par
00219 GTEST_API_ AssertionResult EqFailure({\cf17 const} {\cf18 char}* expected_expression,\par
00220                                      {\cf17 const} {\cf18 char}* actual_expression,\par
00221                                      {\cf17 const} std::string& expected_value,\par
00222                                      {\cf17 const} std::string& actual_value,\par
00223                                      {\cf18 bool} ignoring_case);\par
00224 \par
00225 {\cf20 // Constructs a failure message for Boolean assertions such as EXPECT_TRUE.}\par
00226 GTEST_API_ std::string GetBoolAssertionFailureMessage(\par
00227     {\cf17 const} AssertionResult& assertion_result,\par
00228     {\cf17 const} {\cf18 char}* expression_text,\par
00229     {\cf17 const} {\cf18 char}* actual_predicate_value,\par
00230     {\cf17 const} {\cf18 char}* expected_predicate_value);\par
00231 \par
00232 {\cf20 // This template class represents an IEEE floating-point number}\par
00233 {\cf20 // (either single-precision or double-precision, depending on the}\par
00234 {\cf20 // template parameters).}\par
00235 {\cf20 //}\par
00236 {\cf20 // The purpose of this class is to do more sophisticated number}\par
00237 {\cf20 // comparison.  (Due to round-off error, etc, it's very unlikely that}\par
00238 {\cf20 // two floating-points will be equal exactly.  Hence a naive}\par
00239 {\cf20 // comparison by the == operation often doesn't work.)}\par
00240 {\cf20 //}\par
00241 {\cf20 // Format of IEEE floating-point:}\par
00242 {\cf20 //}\par
00243 {\cf20 //   The most-significant bit being the leftmost, an IEEE}\par
00244 {\cf20 //   floating-point looks like}\par
00245 {\cf20 //}\par
00246 {\cf20 //     sign_bit exponent_bits fraction_bits}\par
00247 {\cf20 //}\par
00248 {\cf20 //   Here, sign_bit is a single bit that designates the sign of the}\par
00249 {\cf20 //   number.}\par
00250 {\cf20 //}\par
00251 {\cf20 //   For float, there are 8 exponent bits and 23 fraction bits.}\par
00252 {\cf20 //}\par
00253 {\cf20 //   For double, there are 11 exponent bits and 52 fraction bits.}\par
00254 {\cf20 //}\par
00255 {\cf20 //   More details can be found at}\par
00256 {\cf20 //   http://en.wikipedia.org/wiki/IEEE_floating-point_standard.}\par
00257 {\cf20 //}\par
00258 {\cf20 // Template parameter:}\par
00259 {\cf20 //}\par
00260 {\cf20 //   RawType: the raw floating-point type (either float or double)}\par
00261 {\cf17 template} <{\cf17 typename} RawType>\par
00262 {\cf17 class }FloatingPoint \{\par
00263  {\cf17 public}:\par
00264   {\cf20 // Defines the unsigned integer type that has the same size as the}\par
00265   {\cf20 // floating point number.}\par
00266   {\cf17 typedef} {\cf17 typename} TypeWithSize<{\cf17 sizeof}(RawType)>::UInt Bits;\par
00267 \par
00268   {\cf20 // Constants.}\par
00269 \par
00270   {\cf20 // # of bits in a number.}\par
00271   {\cf17 static} {\cf17 const} {\cf18 size_t} kBitCount = 8*{\cf17 sizeof}(RawType);\par
00272 \par
00273   {\cf20 // # of fraction bits in a number.}\par
00274   {\cf17 static} {\cf17 const} {\cf18 size_t} kFractionBitCount =\par
00275     std::numeric_limits<RawType>::digits - 1;\par
00276 \par
00277   {\cf20 // # of exponent bits in a number.}\par
00278   {\cf17 static} {\cf17 const} {\cf18 size_t} kExponentBitCount = kBitCount - 1 - kFractionBitCount;\par
00279 \par
00280   {\cf20 // The mask for the sign bit.}\par
00281   {\cf17 static} {\cf17 const} Bits kSignBitMask = {\cf17 static_cast<}Bits{\cf17 >}(1) << (kBitCount - 1);\par
00282 \par
00283   {\cf20 // The mask for the fraction bits.}\par
00284   {\cf17 static} {\cf17 const} Bits kFractionBitMask =\par
00285     ~static_cast<Bits>(0) >> (kExponentBitCount + 1);\par
00286 \par
00287   {\cf20 // The mask for the exponent bits.}\par
00288   {\cf17 static} {\cf17 const} Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);\par
00289 \par
00290   {\cf20 // How many ULP's (Units in the Last Place) we want to tolerate when}\par
00291   {\cf20 // comparing two numbers.  The larger the value, the more error we}\par
00292   {\cf20 // allow.  A 0 value means that two numbers must be exactly the same}\par
00293   {\cf20 // to be considered equal.}\par
00294   {\cf20 //}\par
00295   {\cf20 // The maximum error of a single floating-point operation is 0.5}\par
00296   {\cf20 // units in the last place.  On Intel CPU's, all floating-point}\par
00297   {\cf20 // calculations are done with 80-bit precision, while double has 64}\par
00298   {\cf20 // bits.  Therefore, 4 should be enough for ordinary use.}\par
00299   {\cf20 //}\par
00300   {\cf20 // See the following article for more details on ULP:}\par
00301   {\cf20 // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/}\par
00302   {\cf17 static} {\cf17 const} {\cf18 size_t} kMaxUlps = 4;\par
00303 \par
00304   {\cf20 // Constructs a FloatingPoint from a raw floating-point number.}\par
00305   {\cf20 //}\par
00306   {\cf20 // On an Intel CPU, passing a non-normalized NAN (Not a Number)}\par
00307   {\cf20 // around may change its bits, although the new value is guaranteed}\par
00308   {\cf20 // to be also a NAN.  Therefore, don't expect this constructor to}\par
00309   {\cf20 // preserve the bits in x when x is a NAN.}\par
00310   {\cf17 explicit} FloatingPoint({\cf17 const} RawType& x) \{ u_.value_ = x; \}\par
00311 \par
00312   {\cf20 // Static methods}\par
00313 \par
00314   {\cf20 // Reinterprets a bit pattern as a floating-point number.}\par
00315   {\cf20 //}\par
00316   {\cf20 // This function is needed to test the AlmostEquals() method.}\par
00317   {\cf17 static} RawType ReinterpretBits({\cf17 const} Bits bits) \{\par
00318     FloatingPoint fp(0);\par
00319     fp.u_.bits_ = bits;\par
00320     {\cf19 return} fp.u_.value_;\par
00321   \}\par
00322 \par
00323   {\cf20 // Returns the floating-point number that represent positive infinity.}\par
00324   {\cf17 static} RawType Infinity() \{\par
00325     {\cf19 return} ReinterpretBits(kExponentBitMask);\par
00326   \}\par
00327 \par
00328   {\cf20 // Returns the maximum representable finite floating-point number.}\par
00329   {\cf17 static} RawType Max();\par
00330 \par
00331   {\cf20 // Non-static methods}\par
00332 \par
00333   {\cf20 // Returns the bits that represents this number.}\par
00334   {\cf17 const} Bits &bits(){\cf17  const }\{ {\cf19 return} u_.bits_; \}\par
00335 \par
00336   {\cf20 // Returns the exponent bits of this number.}\par
00337   Bits exponent_bits(){\cf17  const }\{ {\cf19 return} kExponentBitMask & u_.bits_; \}\par
00338 \par
00339   {\cf20 // Returns the fraction bits of this number.}\par
00340   Bits fraction_bits(){\cf17  const }\{ {\cf19 return} kFractionBitMask & u_.bits_; \}\par
00341 \par
00342   {\cf20 // Returns the sign bit of this number.}\par
00343   Bits sign_bit(){\cf17  const }\{ {\cf19 return} kSignBitMask & u_.bits_; \}\par
00344 \par
00345   {\cf20 // Returns true iff this is NAN (not a number).}\par
00346   {\cf18 bool} is_nan(){\cf17  const }\{\par
00347     {\cf20 // It's a NAN if the exponent bits are all ones and the fraction}\par
00348     {\cf20 // bits are not entirely zeros.}\par
00349     {\cf19 return} (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);\par
00350   \}\par
00351 \par
00352   {\cf20 // Returns true iff this number is at most kMaxUlps ULP's away from}\par
00353   {\cf20 // rhs.  In particular, this function:}\par
00354   {\cf20 //}\par
00355   {\cf20 //   - returns false if either number is (or both are) NAN.}\par
00356   {\cf20 //   - treats really large numbers as almost equal to infinity.}\par
00357   {\cf20 //   - thinks +0.0 and -0.0 are 0 DLP's apart.}\par
00358   {\cf18 bool} AlmostEquals({\cf17 const} FloatingPoint& rhs){\cf17  const }\{\par
00359     {\cf20 // The IEEE standard says that any comparison operation involving}\par
00360     {\cf20 // a NAN must return false.}\par
00361     {\cf19 if} (is_nan() || rhs.is_nan()) {\cf19 return} {\cf17 false};\par
00362 \par
00363     {\cf19 return} DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)\par
00364         <= kMaxUlps;\par
00365   \}\par
00366 \par
00367  {\cf17 private}:\par
00368   {\cf20 // The data type used to store the actual floating-point number.}\par
00369   {\cf17 union }FloatingPointUnion \{\par
00370     RawType value_;  {\cf20 // The raw floating-point number.}\par
00371     Bits bits_;      {\cf20 // The bits that represent the number.}\par
00372   \};\par
00373 \par
00374   {\cf20 // Converts an integer from the sign-and-magnitude representation to}\par
00375   {\cf20 // the biased representation.  More precisely, let N be 2 to the}\par
00376   {\cf20 // power of (kBitCount - 1), an integer x is represented by the}\par
00377   {\cf20 // unsigned number x + N.}\par
00378   {\cf20 //}\par
00379   {\cf20 // For instance,}\par
00380   {\cf20 //}\par
00381   {\cf20 //   -N + 1 (the most negative number representable using}\par
00382   {\cf20 //          sign-and-magnitude) is represented by 1;}\par
00383   {\cf20 //   0      is represented by N; and}\par
00384   {\cf20 //   N - 1  (the biggest number representable using}\par
00385   {\cf20 //          sign-and-magnitude) is represented by 2N - 1.}\par
00386   {\cf20 //}\par
00387   {\cf20 // Read http://en.wikipedia.org/wiki/Signed_number_representations}\par
00388   {\cf20 // for more details on signed number representations.}\par
00389   {\cf17 static} Bits SignAndMagnitudeToBiased({\cf17 const} Bits &sam) \{\par
00390     {\cf19 if} (kSignBitMask & sam) \{\par
00391       {\cf20 // sam represents a negative number.}\par
00392       {\cf19 return} ~sam + 1;\par
00393     \} {\cf19 else} \{\par
00394       {\cf20 // sam represents a positive number.}\par
00395       {\cf19 return} kSignBitMask | sam;\par
00396     \}\par
00397   \}\par
00398 \par
00399   {\cf20 // Given two numbers in the sign-and-magnitude representation,}\par
00400   {\cf20 // returns the distance between them as an unsigned number.}\par
00401   {\cf17 static} Bits DistanceBetweenSignAndMagnitudeNumbers({\cf17 const} Bits &sam1,\par
00402                                                      {\cf17 const} Bits &sam2) \{\par
00403     {\cf17 const} Bits biased1 = SignAndMagnitudeToBiased(sam1);\par
00404     {\cf17 const} Bits biased2 = SignAndMagnitudeToBiased(sam2);\par
00405     {\cf19 return} (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);\par
00406   \}\par
00407 \par
00408   FloatingPointUnion u_;\par
00409 \};\par
00410 \par
00411 {\cf20 // We cannot use std::numeric_limits<T>::max() as it clashes with the max()}\par
00412 {\cf20 // macro defined by <windows.h>.}\par
00413 {\cf17 template} <>\par
00414 {\cf17 inline} {\cf18 float} FloatingPoint<float>::Max() \{ {\cf19 return} FLT_MAX; \}\par
00415 {\cf17 template} <>\par
00416 {\cf17 inline} {\cf18 double} FloatingPoint<double>::Max() \{ {\cf19 return} DBL_MAX; \}\par
00417 \par
00418 {\cf20 // Typedefs the instances of the FloatingPoint template class that we}\par
00419 {\cf20 // care to use.}\par
00420 {\cf17 typedef} FloatingPoint<float> Float;\par
00421 {\cf17 typedef} FloatingPoint<double> Double;\par
00422 \par
00423 {\cf20 // In order to catch the mistake of putting tests that use different}\par
00424 {\cf20 // test fixture classes in the same test case, we need to assign}\par
00425 {\cf20 // unique IDs to fixture classes and compare them.  The TypeId type is}\par
00426 {\cf20 // used to hold such IDs.  The user should treat TypeId as an opaque}\par
00427 {\cf20 // type: the only operation allowed on TypeId values is to compare}\par
00428 {\cf20 // them for equality using the == operator.}\par
00429 {\cf17 typedef} {\cf17 const} {\cf18 void}* TypeId;\par
00430 \par
00431 {\cf17 template} <{\cf17 typename} T>\par
00432 {\cf17 class }TypeIdHelper \{\par
00433  {\cf17 public}:\par
00434   {\cf20 // dummy_ must not have a const type.  Otherwise an overly eager}\par
00435   {\cf20 // compiler (e.g. MSVC 7.1 & 8.0) may try to merge}\par
00436   {\cf20 // TypeIdHelper<T>::dummy_ for different Ts as an "optimization".}\par
00437   {\cf17 static} {\cf18 bool} dummy_;\par
00438 \};\par
00439 \par
00440 {\cf17 template} <{\cf17 typename} T>\par
00441 {\cf18 bool} TypeIdHelper<T>::dummy_ = {\cf17 false};\par
00442 \par
00443 {\cf20 // GetTypeId<T>() returns the ID of type T.  Different values will be}\par
00444 {\cf20 // returned for different types.  Calling the function twice with the}\par
00445 {\cf20 // same type argument is guaranteed to return the same ID.}\par
00446 {\cf17 template} <{\cf17 typename} T>\par
00447 TypeId GetTypeId() \{\par
00448   {\cf20 // The compiler is required to allocate a different}\par
00449   {\cf20 // TypeIdHelper<T>::dummy_ variable for each T used to instantiate}\par
00450   {\cf20 // the template.  Therefore, the address of dummy_ is guaranteed to}\par
00451   {\cf20 // be unique.}\par
00452   {\cf19 return} &(TypeIdHelper<T>::dummy_);\par
00453 \}\par
00454 \par
00455 {\cf20 // Returns the type ID of ::testing::Test.  Always call this instead}\par
00456 {\cf20 // of GetTypeId< ::testing::Test>() to get the type ID of}\par
00457 {\cf20 // ::testing::Test, as the latter may give the wrong result due to a}\par
00458 {\cf20 // suspected linker bug when compiling Google Test as a Mac OS X}\par
00459 {\cf20 // framework.}\par
00460 GTEST_API_ TypeId GetTestTypeId();\par
00461 \par
00462 {\cf20 // Defines the abstract factory interface that creates instances}\par
00463 {\cf20 // of a Test object.}\par
00464 {\cf17 class }TestFactoryBase \{\par
00465  {\cf17 public}:\par
00466   {\cf17 virtual} ~TestFactoryBase() \{\}\par
00467 \par
00468   {\cf20 // Creates a test instance to run. The instance is both created and destroyed}\par
00469   {\cf20 // within TestInfoImpl::Run()}\par
00470   {\cf17 virtual} Test* CreateTest() = 0;\par
00471 \par
00472  {\cf17 protected}:\par
00473   TestFactoryBase() \{\}\par
00474 \par
00475  {\cf17 private}:\par
00476   GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\par
00477 \};\par
00478 \par
00479 {\cf20 // This class provides implementation of TeastFactoryBase interface.}\par
00480 {\cf20 // It is used in TEST and TEST_F macros.}\par
00481 {\cf17 template} <{\cf17 class} TestClass>\par
00482 {\cf17 class }TestFactoryImpl : {\cf17 public} TestFactoryBase \{\par
00483  {\cf17 public}:\par
00484   {\cf17 virtual} Test* CreateTest() \{ {\cf19 return} {\cf17 new} TestClass; \}\par
00485 \};\par
00486 \par
00487 {\cf21 #if GTEST_OS_WINDOWS}\par
00488 \par
00489 {\cf20 // Predicate-formatters for implementing the HRESULT checking macros}\par
00490 {\cf20 // \{ASSERT|EXPECT\}_HRESULT_\{SUCCEEDED|FAILED\}}\par
00491 {\cf20 // We pass a long instead of HRESULT to avoid causing an}\par
00492 {\cf20 // include dependency for the HRESULT type.}\par
00493 GTEST_API_ AssertionResult IsHRESULTSuccess({\cf17 const} {\cf18 char}* expr,\par
00494                                             {\cf18 long} hr);  {\cf20 // NOLINT}\par
00495 GTEST_API_ AssertionResult IsHRESULTFailure({\cf17 const} {\cf18 char}* expr,\par
00496                                             {\cf18 long} hr);  {\cf20 // NOLINT}\par
00497 \par
00498 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
00499 \par
00500 {\cf20 // Types of SetUpTestCase() and TearDownTestCase() functions.}\par
00501 {\cf17 typedef} void (*SetUpTestCaseFunc)();\par
00502 {\cf17 typedef} void (*TearDownTestCaseFunc)();\par
00503 \par
00504 {\cf17 struct }CodeLocation \{\par
00505   CodeLocation({\cf17 const} std::string& a_file, {\cf18 int} a_line)\par
00506       : file(a_file), line(a_line) \{\}\par
00507 \par
00508   std::string file;\par
00509   {\cf18 int} line;\par
00510 \};\par
00511 \par
00512 {\cf20 // Creates a new TestInfo object and registers it with Google Test;}\par
00513 {\cf20 // returns the created object.}\par
00514 {\cf20 //}\par
00515 {\cf20 // Arguments:}\par
00516 {\cf20 //}\par
00517 {\cf20 //   test_case_name:   name of the test case}\par
00518 {\cf20 //   name:             name of the test}\par
00519 {\cf20 //   type_param        the name of the test's type parameter, or NULL if}\par
00520 {\cf20 //                     this is not a typed or a type-parameterized test.}\par
00521 {\cf20 //   value_param       text representation of the test's value parameter,}\par
00522 {\cf20 //                     or NULL if this is not a type-parameterized test.}\par
00523 {\cf20 //   code_location:    code location where the test is defined}\par
00524 {\cf20 //   fixture_class_id: ID of the test fixture class}\par
00525 {\cf20 //   set_up_tc:        pointer to the function that sets up the test case}\par
00526 {\cf20 //   tear_down_tc:     pointer to the function that tears down the test case}\par
00527 {\cf20 //   factory:          pointer to the factory that creates a test object.}\par
00528 {\cf20 //                     The newly created TestInfo instance will assume}\par
00529 {\cf20 //                     ownership of the factory object.}\par
00530 GTEST_API_ TestInfo* MakeAndRegisterTestInfo(\par
00531     {\cf17 const} {\cf18 char}* test_case_name,\par
00532     {\cf17 const} {\cf18 char}* name,\par
00533     {\cf17 const} {\cf18 char}* type_param,\par
00534     {\cf17 const} {\cf18 char}* value_param,\par
00535     CodeLocation code_location,\par
00536     TypeId fixture_class_id,\par
00537     SetUpTestCaseFunc set_up_tc,\par
00538     TearDownTestCaseFunc tear_down_tc,\par
00539     TestFactoryBase* factory);\par
00540 \par
00541 {\cf20 // If *pstr starts with the given prefix, modifies *pstr to be right}\par
00542 {\cf20 // past the prefix and returns true; otherwise leaves *pstr unchanged}\par
00543 {\cf20 // and returns false.  None of pstr, *pstr, and prefix can be NULL.}\par
00544 GTEST_API_ {\cf18 bool} SkipPrefix({\cf17 const} {\cf18 char}* prefix, {\cf17 const} {\cf18 char}** pstr);\par
00545 \par
00546 {\cf21 #if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P}\par
00547 \par
00548 {\cf20 // State of the definition of a type-parameterized test case.}\par
00549 {\cf17 class }GTEST_API_ TypedTestCasePState \{\par
00550  {\cf17 public}:\par
00551   TypedTestCasePState() : registered_(false) \{\}\par
00552 \par
00553   {\cf20 // Adds the given test name to defined_test_names_ and return true}\par
00554   {\cf20 // if the test case hasn't been registered; otherwise aborts the}\par
00555   {\cf20 // program.}\par
00556   {\cf18 bool} AddTestName({\cf17 const} {\cf18 char}* file, {\cf18 int} line, {\cf17 const} {\cf18 char}* case_name,\par
00557                    {\cf17 const} {\cf18 char}* test_name) \{\par
00558     {\cf19 if} (registered_) \{\par
00559       fprintf(stderr, {\cf22 "%s Test %s must be defined before "}\par
00560               {\cf22 "REGISTER_TYPED_TEST_CASE_P(%s, ...).\\n"},\par
00561               FormatFileLocation(file, line).c_str(), test_name, case_name);\par
00562       fflush(stderr);\par
00563       posix::Abort();\par
00564     \}\par
00565     registered_tests_.insert(\par
00566         ::std::make_pair(test_name, CodeLocation(file, line)));\par
00567     {\cf19 return} {\cf17 true};\par
00568   \}\par
00569 \par
00570   {\cf18 bool} TestExists({\cf17 const} std::string& test_name){\cf17  const }\{\par
00571     {\cf19 return} registered_tests_.count(test_name) > 0;\par
00572   \}\par
00573 \par
00574   {\cf17 const} CodeLocation& GetCodeLocation({\cf17 const} std::string& test_name){\cf17  const }\{\par
00575     RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);\par
00576     GTEST_CHECK_(it != registered_tests_.end());\par
00577     {\cf19 return} it->second;\par
00578   \}\par
00579 \par
00580   {\cf20 // Verifies that registered_tests match the test names in}\par
00581   {\cf20 // defined_test_names_; returns registered_tests if successful, or}\par
00582   {\cf20 // aborts the program otherwise.}\par
00583   {\cf17 const} {\cf18 char}* VerifyRegisteredTestNames(\par
00584       {\cf17 const} {\cf18 char}* file, {\cf18 int} line, {\cf17 const} {\cf18 char}* registered_tests);\par
00585 \par
00586  {\cf17 private}:\par
00587   typedef ::std::map<std::string, CodeLocation> RegisteredTestsMap;\par
00588 \par
00589   {\cf18 bool} registered_;\par
00590   RegisteredTestsMap registered_tests_;\par
00591 \};\par
00592 \par
00593 {\cf20 // Skips to the first non-space char after the first comma in 'str';}\par
00594 {\cf20 // returns NULL if no comma is found in 'str'.}\par
00595 {\cf17 inline} {\cf17 const} {\cf18 char}* SkipComma({\cf17 const} {\cf18 char}* str) \{\par
00596   {\cf17 const} {\cf18 char}* comma = strchr(str, {\cf23 ','});\par
00597   {\cf19 if} (comma == NULL) \{\par
00598     {\cf19 return} NULL;\par
00599   \}\par
00600   {\cf19 while} (IsSpace(*(++comma))) \{\}\par
00601   {\cf19 return} comma;\par
00602 \}\par
00603 \par
00604 {\cf20 // Returns the prefix of 'str' before the first comma in it; returns}\par
00605 {\cf20 // the entire string if it contains no comma.}\par
00606 {\cf17 inline} std::string GetPrefixUntilComma({\cf17 const} {\cf18 char}* str) \{\par
00607   {\cf17 const} {\cf18 char}* comma = strchr(str, {\cf23 ','});\par
00608   {\cf19 return} comma == NULL ? str : std::string(str, comma);\par
00609 \}\par
00610 \par
00611 {\cf20 // Splits a given string on a given delimiter, populating a given}\par
00612 {\cf20 // vector with the fields.}\par
00613 {\cf18 void} SplitString(const ::std::string& str, {\cf18 char} delimiter,\par
00614                  ::std::vector< ::std::string>* dest);\par
00615 \par
00616 {\cf20 // TypeParameterizedTest<Fixture, TestSel, Types>::Register()}\par
00617 {\cf20 // registers a list of type-parameterized tests with Google Test.  The}\par
00618 {\cf20 // return value is insignificant - we just need to return something}\par
00619 {\cf20 // such that we can call this function in a namespace scope.}\par
00620 {\cf20 //}\par
00621 {\cf20 // Implementation note: The GTEST_TEMPLATE_ macro declares a template}\par
00622 {\cf20 // template parameter.  It's defined in gtest-type-util.h.}\par
00623 {\cf17 template} <GTEST_TEMPLATE_ Fixture, {\cf17 class} TestSel, {\cf17 typename} Types>\par
00624 {\cf17 class }TypeParameterizedTest \{\par
00625  {\cf17 public}:\par
00626   {\cf20 // 'index' is the index of the test in the type list 'Types'}\par
00627   {\cf20 // specified in INSTANTIATE_TYPED_TEST_CASE_P(Prefix, TestCase,}\par
00628   {\cf20 // Types).  Valid values for 'index' are [0, N - 1] where N is the}\par
00629   {\cf20 // length of Types.}\par
00630   {\cf17 static} {\cf18 bool} Register({\cf17 const} {\cf18 char}* prefix,\par
00631                        CodeLocation code_location,\par
00632                        {\cf17 const} {\cf18 char}* case_name, {\cf17 const} {\cf18 char}* test_names,\par
00633                        {\cf18 int} index) \{\par
00634     {\cf17 typedef} {\cf17 typename} Types::Head Type;\par
00635     {\cf17 typedef} Fixture<Type> FixtureClass;\par
00636     {\cf17 typedef} {\cf17 typename} GTEST_BIND_(TestSel, Type) TestClass;\par
00637 \par
00638     {\cf20 // First, registers the first type-parameterized test in the type}\par
00639     {\cf20 // list.}\par
00640     MakeAndRegisterTestInfo(\par
00641         (std::string(prefix) + (prefix[0] == {\cf23 '\\0'} ? {\cf22 ""} : {\cf22 "/"}) + case_name + {\cf22 "/"}\par
00642          + StreamableToString(index)).c_str(),\par
00643         StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),\par
00644         GetTypeName<Type>().c_str(),\par
00645         NULL,  {\cf20 // No value parameter.}\par
00646         code_location,\par
00647         GetTypeId<FixtureClass>(),\par
00648         TestClass::SetUpTestCase,\par
00649         TestClass::TearDownTestCase,\par
00650         {\cf17 new} TestFactoryImpl<TestClass>);\par
00651 \par
00652     {\cf20 // Next, recurses (at compile time) with the tail of the type list.}\par
00653     {\cf19 return} TypeParameterizedTest<Fixture, TestSel, typename Types::Tail>\par
00654         ::Register(prefix, code_location, case_name, test_names, index + 1);\par
00655   \}\par
00656 \};\par
00657 \par
00658 {\cf20 // The base case for the compile time recursion.}\par
00659 {\cf17 template} <GTEST_TEMPLATE_ Fixture, {\cf17 class} TestSel>\par
00660 {\cf17 class }TypeParameterizedTest<Fixture, TestSel, Types0> \{\par
00661  {\cf17 public}:\par
00662   {\cf17 static} {\cf18 bool} Register({\cf17 const} {\cf18 char}* {\cf20 /*prefix*/}, CodeLocation,\par
00663                        {\cf17 const} {\cf18 char}* {\cf20 /*case_name*/}, {\cf17 const} {\cf18 char}* {\cf20 /*test_names*/},\par
00664                        {\cf18 int} {\cf20 /*index*/}) \{\par
00665     {\cf19 return} {\cf17 true};\par
00666   \}\par
00667 \};\par
00668 \par
00669 {\cf20 // TypeParameterizedTestCase<Fixture, Tests, Types>::Register()}\par
00670 {\cf20 // registers *all combinations* of 'Tests' and 'Types' with Google}\par
00671 {\cf20 // Test.  The return value is insignificant - we just need to return}\par
00672 {\cf20 // something such that we can call this function in a namespace scope.}\par
00673 {\cf17 template} <GTEST_TEMPLATE_ Fixture, {\cf17 typename} Tests, {\cf17 typename} Types>\par
00674 {\cf17 class }TypeParameterizedTestCase \{\par
00675  {\cf17 public}:\par
00676   {\cf17 static} {\cf18 bool} Register({\cf17 const} {\cf18 char}* prefix, CodeLocation code_location,\par
00677                        {\cf17 const} TypedTestCasePState* state,\par
00678                        {\cf17 const} {\cf18 char}* case_name, {\cf17 const} {\cf18 char}* test_names) \{\par
00679     std::string test_name = StripTrailingSpaces(\par
00680         GetPrefixUntilComma(test_names));\par
00681     {\cf19 if} (!state->TestExists(test_name)) \{\par
00682       fprintf(stderr, {\cf22 "Failed to get code location for test %s.%s at %s."},\par
00683               case_name, test_name.c_str(),\par
00684               FormatFileLocation(code_location.file.c_str(),\par
00685                                  code_location.line).c_str());\par
00686       fflush(stderr);\par
00687       posix::Abort();\par
00688     \}\par
00689     {\cf17 const} CodeLocation& test_location = state->GetCodeLocation(test_name);\par
00690 \par
00691     {\cf17 typedef} {\cf17 typename} Tests::Head Head;\par
00692 \par
00693     {\cf20 // First, register the first test in 'Test' for each type in 'Types'.}\par
00694     TypeParameterizedTest<Fixture, Head, Types>::Register(\par
00695         prefix, test_location, case_name, test_names, 0);\par
00696 \par
00697     {\cf20 // Next, recurses (at compile time) with the tail of the test list.}\par
00698     {\cf19 return} TypeParameterizedTestCase<Fixture, typename Tests::Tail, Types>\par
00699         ::Register(prefix, code_location, state,\par
00700                    case_name, SkipComma(test_names));\par
00701   \}\par
00702 \};\par
00703 \par
00704 {\cf20 // The base case for the compile time recursion.}\par
00705 {\cf17 template} <GTEST_TEMPLATE_ Fixture, {\cf17 typename} Types>\par
00706 {\cf17 class }TypeParameterizedTestCase<Fixture, Templates0, Types> \{\par
00707  {\cf17 public}:\par
00708   {\cf17 static} {\cf18 bool} Register({\cf17 const} {\cf18 char}* {\cf20 /*prefix*/}, CodeLocation,\par
00709                        {\cf17 const} TypedTestCasePState* {\cf20 /*state*/},\par
00710                        {\cf17 const} {\cf18 char}* {\cf20 /*case_name*/}, {\cf17 const} {\cf18 char}* {\cf20 /*test_names*/}) \{\par
00711     {\cf19 return} {\cf17 true};\par
00712   \}\par
00713 \};\par
00714 \par
00715 {\cf21 #endif  }{\cf20 // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P}\par
00716 \par
00717 {\cf20 // Returns the current OS stack trace as an std::string.}\par
00718 {\cf20 //}\par
00719 {\cf20 // The maximum number of stack frames to be included is specified by}\par
00720 {\cf20 // the gtest_stack_trace_depth flag.  The skip_count parameter}\par
00721 {\cf20 // specifies the number of top frames to be skipped, which doesn't}\par
00722 {\cf20 // count against the number of frames to be included.}\par
00723 {\cf20 //}\par
00724 {\cf20 // For example, if Foo() calls Bar(), which in turn calls}\par
00725 {\cf20 // GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in}\par
00726 {\cf20 // the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.}\par
00727 GTEST_API_ std::string GetCurrentOsStackTraceExceptTop(\par
00728     UnitTest* unit_test, {\cf18 int} skip_count);\par
00729 \par
00730 {\cf20 // Helpers for suppressing warnings on unreachable code or constant}\par
00731 {\cf20 // condition.}\par
00732 \par
00733 {\cf20 // Always returns true.}\par
00734 GTEST_API_ {\cf18 bool} AlwaysTrue();\par
00735 \par
00736 {\cf20 // Always returns false.}\par
00737 {\cf17 inline} {\cf18 bool} AlwaysFalse() \{ {\cf19 return} !AlwaysTrue(); \}\par
00738 \par
00739 {\cf20 // Helper for suppressing false warning from Clang on a const char*}\par
00740 {\cf20 // variable declared in a conditional expression always being NULL in}\par
00741 {\cf20 // the else branch.}\par
00742 {\cf17 struct }GTEST_API_ ConstCharPtr \{\par
00743   ConstCharPtr({\cf17 const} {\cf18 char}* str) : value(str) \{\}\par
00744   {\cf17 operator} bool(){\cf17  const }\{ {\cf19 return} {\cf17 true}; \}\par
00745   {\cf17 const} {\cf18 char}* value;\par
00746 \};\par
00747 \par
00748 {\cf20 // A simple Linear Congruential Generator for generating random}\par
00749 {\cf20 // numbers with a uniform distribution.  Unlike rand() and srand(), it}\par
00750 {\cf20 // doesn't use global state (and therefore can't interfere with user}\par
00751 {\cf20 // code).  Unlike rand_r(), it's portable.  An LCG isn't very random,}\par
00752 {\cf20 // but it's good enough for our purposes.}\par
00753 {\cf17 class }GTEST_API_ Random \{\par
00754  {\cf17 public}:\par
00755   {\cf17 static} {\cf17 const} UInt32 kMaxRange = 1u << 31;\par
00756 \par
00757   {\cf17 explicit} Random(UInt32 seed) : state_(seed) \{\}\par
00758 \par
00759   {\cf18 void} Reseed(UInt32 seed) \{ state_ = seed; \}\par
00760 \par
00761   {\cf20 // Generates a random number from [0, range).  Crashes if 'range' is}\par
00762   {\cf20 // 0 or greater than kMaxRange.}\par
00763   UInt32 Generate(UInt32 range);\par
00764 \par
00765  {\cf17 private}:\par
00766   UInt32 state_;\par
00767   GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);\par
00768 \};\par
00769 \par
00770 {\cf20 // Defining a variable of type CompileAssertTypesEqual<T1, T2> will cause a}\par
00771 {\cf20 // compiler error iff T1 and T2 are different types.}\par
00772 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
00773 {\cf17 struct }CompileAssertTypesEqual;\par
00774 \par
00775 {\cf17 template} <{\cf17 typename} T>\par
00776 {\cf17 struct }CompileAssertTypesEqual<T, T> \{\par
00777 \};\par
00778 \par
00779 {\cf20 // Removes the reference from a type if it is a reference type,}\par
00780 {\cf20 // otherwise leaves it unchanged.  This is the same as}\par
00781 {\cf20 // tr1::remove_reference, which is not widely available yet.}\par
00782 {\cf17 template} <{\cf17 typename} T>\par
00783 {\cf17 struct }RemoveReference \{ {\cf17 typedef} T type; \};  {\cf20 // NOLINT}\par
00784 {\cf17 template} <{\cf17 typename} T>\par
00785 {\cf17 struct }RemoveReference<T&> \{ {\cf17 typedef} T type; \};  {\cf20 // NOLINT}\par
00786 \par
00787 {\cf20 // A handy wrapper around RemoveReference that works when the argument}\par
00788 {\cf20 // T depends on template parameters.}\par
00789 {\cf21 #define GTEST_REMOVE_REFERENCE_(T) \\}\par
00790 {\cf21     typename ::testing::internal::RemoveReference<T>::type}\par
00791 \par
00792 {\cf20 // Removes const from a type if it is a const type, otherwise leaves}\par
00793 {\cf20 // it unchanged.  This is the same as tr1::remove_const, which is not}\par
00794 {\cf20 // widely available yet.}\par
00795 {\cf17 template} <{\cf17 typename} T>\par
00796 {\cf17 struct }RemoveConst \{ {\cf17 typedef} T type; \};  {\cf20 // NOLINT}\par
00797 {\cf17 template} <{\cf17 typename} T>\par
00798 {\cf17 struct }RemoveConst<const T> \{ {\cf17 typedef} T type; \};  {\cf20 // NOLINT}\par
00799 \par
00800 {\cf20 // MSVC 8.0, Sun C++, and IBM XL C++ have a bug which causes the above}\par
00801 {\cf20 // definition to fail to remove the const in 'const int[3]' and 'const}\par
00802 {\cf20 // char[3][4]'.  The following specialization works around the bug.}\par
00803 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} N>\par
00804 {\cf17 struct }RemoveConst<const T[N]> \{\par
00805   {\cf17 typedef} {\cf17 typename} RemoveConst<T>::type type[N];\par
00806 \};\par
00807 \par
00808 {\cf21 #if defined(_MSC_VER) && _MSC_VER < 1400}\par
00809 {\cf20 // This is the only specialization that allows VC++ 7.1 to remove const in}\par
00810 {\cf20 // 'const int[3] and 'const int[3][4]'.  However, it causes trouble with GCC}\par
00811 {\cf20 // and thus needs to be conditionally compiled.}\par
00812 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} N>\par
00813 {\cf17 struct }RemoveConst<T[N]> \{\par
00814   {\cf17 typedef} {\cf17 typename} RemoveConst<T>::type type[N];\par
00815 \};\par
00816 {\cf21 #endif}\par
00817 \par
00818 {\cf20 // A handy wrapper around RemoveConst that works when the argument}\par
00819 {\cf20 // T depends on template parameters.}\par
00820 {\cf21 #define GTEST_REMOVE_CONST_(T) \\}\par
00821 {\cf21     typename ::testing::internal::RemoveConst<T>::type}\par
00822 \par
00823 {\cf20 // Turns const U&, U&, const U, and U all into U.}\par
00824 {\cf21 #define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \\}\par
00825 {\cf21     GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))}\par
00826 \par
00827 {\cf20 // Adds reference to a type if it is not a reference type,}\par
00828 {\cf20 // otherwise leaves it unchanged.  This is the same as}\par
00829 {\cf20 // tr1::add_reference, which is not widely available yet.}\par
00830 {\cf17 template} <{\cf17 typename} T>\par
00831 {\cf17 struct }AddReference \{ {\cf17 typedef} T& type; \};  {\cf20 // NOLINT}\par
00832 {\cf17 template} <{\cf17 typename} T>\par
00833 {\cf17 struct }AddReference<T&> \{ {\cf17 typedef} T& type; \};  {\cf20 // NOLINT}\par
00834 \par
00835 {\cf20 // A handy wrapper around AddReference that works when the argument T}\par
00836 {\cf20 // depends on template parameters.}\par
00837 {\cf21 #define GTEST_ADD_REFERENCE_(T) \\}\par
00838 {\cf21     typename ::testing::internal::AddReference<T>::type}\par
00839 \par
00840 {\cf20 // Adds a reference to const on top of T as necessary.  For example,}\par
00841 {\cf20 // it transforms}\par
00842 {\cf20 //}\par
00843 {\cf20 //   char         ==> const char&}\par
00844 {\cf20 //   const char   ==> const char&}\par
00845 {\cf20 //   char&        ==> const char&}\par
00846 {\cf20 //   const char&  ==> const char&}\par
00847 {\cf20 //}\par
00848 {\cf20 // The argument T must depend on some template parameters.}\par
00849 {\cf21 #define GTEST_REFERENCE_TO_CONST_(T) \\}\par
00850 {\cf21     GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))}\par
00851 \par
00852 {\cf20 // ImplicitlyConvertible<From, To>::value is a compile-time bool}\par
00853 {\cf20 // constant that's true iff type From can be implicitly converted to}\par
00854 {\cf20 // type To.}\par
00855 {\cf17 template} <{\cf17 typename} From, {\cf17 typename} To>\par
00856 {\cf17 class }ImplicitlyConvertible \{\par
00857  {\cf17 private}:\par
00858   {\cf20 // We need the following helper functions only for their types.}\par
00859   {\cf20 // They have no implementations.}\par
00860 \par
00861   {\cf20 // MakeFrom() is an expression whose type is From.  We cannot simply}\par
00862   {\cf20 // use From(), as the type From may not have a public default}\par
00863   {\cf20 // constructor.}\par
00864   {\cf17 static} {\cf17 typename} AddReference<From>::type MakeFrom();\par
00865 \par
00866   {\cf20 // These two functions are overloaded.  Given an expression}\par
00867   {\cf20 // Helper(x), the compiler will pick the first version if x can be}\par
00868   {\cf20 // implicitly converted to type To; otherwise it will pick the}\par
00869   {\cf20 // second version.}\par
00870   {\cf20 //}\par
00871   {\cf20 // The first version returns a value of size 1, and the second}\par
00872   {\cf20 // version returns a value of size 2.  Therefore, by checking the}\par
00873   {\cf20 // size of Helper(x), which can be done at compile time, we can tell}\par
00874   {\cf20 // which version of Helper() is used, and hence whether x can be}\par
00875   {\cf20 // implicitly converted to type To.}\par
00876   {\cf17 static} {\cf18 char} Helper(To);\par
00877   {\cf17 static} char (&Helper(...))[2];  {\cf20 // NOLINT}\par
00878 \par
00879   {\cf20 // We have to put the 'public' section after the 'private' section,}\par
00880   {\cf20 // or MSVC refuses to compile the code.}\par
00881  {\cf17 public}:\par
00882 {\cf21 #if defined(__BORLANDC__)}\par
00883   {\cf20 // C++Builder cannot use member overload resolution during template}\par
00884   {\cf20 // instantiation.  The simplest workaround is to use its C++0x type traits}\par
00885   {\cf20 // functions (C++Builder 2009 and above only).}\par
00886   {\cf17 static} {\cf17 const} {\cf18 bool} value = __is_convertible(From, To);\par
00887 {\cf21 #else}\par
00888   {\cf20 // MSVC warns about implicitly converting from double to int for}\par
00889   {\cf20 // possible loss of data, so we need to temporarily disable the}\par
00890   {\cf20 // warning.}\par
00891   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4244)\par
00892   static const {\cf18 bool} value =\par
00893       sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;\par
00894   GTEST_DISABLE_MSC_WARNINGS_POP_()\par
00895 {\cf21 #endif  }{\cf20 // __BORLANDC__}\par
00896 \};\par
00897 {\cf17 template} <{\cf17 typename} From, {\cf17 typename} To>\par
00898 {\cf17 const} {\cf18 bool} ImplicitlyConvertible<From, To>::value;\par
00899 \par
00900 {\cf20 // IsAProtocolMessage<T>::value is a compile-time bool constant that's}\par
00901 {\cf20 // true iff T is type ProtocolMessage, proto2::Message, or a subclass}\par
00902 {\cf20 // of those.}\par
00903 {\cf17 template} <{\cf17 typename} T>\par
00904 {\cf17 struct }IsAProtocolMessage\par
00905     : {\cf17 public} bool_constant<\par
00906   ImplicitlyConvertible<const T*, const ::ProtocolMessage*>::value ||\par
00907   ImplicitlyConvertible<const T*, const ::proto2::Message*>::value> \{\par
00908 \};\par
00909 \par
00910 {\cf20 // When the compiler sees expression IsContainerTest<C>(0), if C is an}\par
00911 {\cf20 // STL-style container class, the first overload of IsContainerTest}\par
00912 {\cf20 // will be viable (since both C::iterator* and C::const_iterator* are}\par
00913 {\cf20 // valid types and NULL can be implicitly converted to them).  It will}\par
00914 {\cf20 // be picked over the second overload as 'int' is a perfect match for}\par
00915 {\cf20 // the type of argument 0.  If C::iterator or C::const_iterator is not}\par
00916 {\cf20 // a valid type, the first overload is not viable, and the second}\par
00917 {\cf20 // overload will be picked.  Therefore, we can determine whether C is}\par
00918 {\cf20 // a container class by checking the type of IsContainerTest<C>(0).}\par
00919 {\cf20 // The value of the expression is insignificant.}\par
00920 {\cf20 //}\par
00921 {\cf20 // Note that we look for both C::iterator and C::const_iterator.  The}\par
00922 {\cf20 // reason is that C++ injects the name of a class as a member of the}\par
00923 {\cf20 // class itself (e.g. you can refer to class iterator as either}\par
00924 {\cf20 // 'iterator' or 'iterator::iterator').  If we look for C::iterator}\par
00925 {\cf20 // only, for example, we would mistakenly think that a class named}\par
00926 {\cf20 // iterator is an STL container.}\par
00927 {\cf20 //}\par
00928 {\cf20 // Also note that the simpler approach of overloading}\par
00929 {\cf20 // IsContainerTest(typename C::const_iterator*) and}\par
00930 {\cf20 // IsContainerTest(...) doesn't work with Visual Age C++ and Sun C++.}\par
00931 {\cf17 typedef} {\cf18 int} IsContainer;\par
00932 {\cf17 template} <{\cf17 class} C>\par
00933 IsContainer IsContainerTest({\cf18 int} {\cf20 /* dummy */},\par
00934                             {\cf17 typename} C::iterator* {\cf20 /* it */} = NULL,\par
00935                             {\cf17 typename} C::const_iterator* {\cf20 /* const_it */} = NULL) \{\par
00936   {\cf19 return} 0;\par
00937 \}\par
00938 \par
00939 {\cf17 typedef} {\cf18 char} IsNotContainer;\par
00940 {\cf17 template} <{\cf17 class} C>\par
00941 IsNotContainer IsContainerTest({\cf18 long} {\cf20 /* dummy */}) \{ {\cf19 return} {\cf23 '\\0'}; \}\par
00942 \par
00943 {\cf20 // EnableIf<condition>::type is void when 'Cond' is true, and}\par
00944 {\cf20 // undefined when 'Cond' is false.  To use SFINAE to make a function}\par
00945 {\cf20 // overload only apply when a particular expression is true, add}\par
00946 {\cf20 // "typename EnableIf<expression>::type* = 0" as the last parameter.}\par
00947 {\cf17 template}<{\cf18 bool}> {\cf17 struct }EnableIf;\par
00948 {\cf17 template}<> {\cf17 struct }EnableIf<true> \{ {\cf17 typedef} {\cf18 void} type; \};  {\cf20 // NOLINT}\par
00949 \par
00950 {\cf20 // Utilities for native arrays.}\par
00951 \par
00952 {\cf20 // ArrayEq() compares two k-dimensional native arrays using the}\par
00953 {\cf20 // elements' operator==, where k can be any integer >= 0.  When k is}\par
00954 {\cf20 // 0, ArrayEq() degenerates into comparing a single pair of values.}\par
00955 \par
00956 {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U>\par
00957 {\cf18 bool} ArrayEq({\cf17 const} T* lhs, {\cf18 size_t} size, {\cf17 const} U* rhs);\par
00958 \par
00959 {\cf20 // This generic version is used when k is 0.}\par
00960 {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U>\par
00961 {\cf17 inline} {\cf18 bool} ArrayEq({\cf17 const} T& lhs, {\cf17 const} U& rhs) \{ {\cf19 return} lhs == rhs; \}\par
00962 \par
00963 {\cf20 // This overload is used when k >= 1.}\par
00964 {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U, {\cf18 size_t} N>\par
00965 {\cf17 inline} {\cf18 bool} ArrayEq({\cf17 const} T(&lhs)[N], {\cf17 const} U(&rhs)[N]) \{\par
00966   {\cf19 return} internal::ArrayEq(lhs, N, rhs);\par
00967 \}\par
00968 \par
00969 {\cf20 // This helper reduces code bloat.  If we instead put its logic inside}\par
00970 {\cf20 // the previous ArrayEq() function, arrays with different sizes would}\par
00971 {\cf20 // lead to different copies of the template code.}\par
00972 {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U>\par
00973 {\cf18 bool} ArrayEq({\cf17 const} T* lhs, {\cf18 size_t} size, {\cf17 const} U* rhs) \{\par
00974   {\cf19 for} ({\cf18 size_t} i = 0; i != size; i++) \{\par
00975     {\cf19 if} (!internal::ArrayEq(lhs[i], rhs[i]))\par
00976       {\cf19 return} {\cf17 false};\par
00977   \}\par
00978   {\cf19 return} {\cf17 true};\par
00979 \}\par
00980 \par
00981 {\cf20 // Finds the first element in the iterator range [begin, end) that}\par
00982 {\cf20 // equals elem.  Element may be a native array type itself.}\par
00983 {\cf17 template} <{\cf17 typename} Iter, {\cf17 typename} Element>\par
00984 Iter ArrayAwareFind(Iter begin, Iter end, {\cf17 const} Element& elem) \{\par
00985   {\cf19 for} (Iter it = begin; it != end; ++it) \{\par
00986     {\cf19 if} (internal::ArrayEq(*it, elem))\par
00987       {\cf19 return} it;\par
00988   \}\par
00989   {\cf19 return} end;\par
00990 \}\par
00991 \par
00992 {\cf20 // CopyArray() copies a k-dimensional native array using the elements'}\par
00993 {\cf20 // operator=, where k can be any integer >= 0.  When k is 0,}\par
00994 {\cf20 // CopyArray() degenerates into copying a single value.}\par
00995 \par
00996 {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U>\par
00997 {\cf18 void} CopyArray({\cf17 const} T* from, {\cf18 size_t} size, U* to);\par
00998 \par
00999 {\cf20 // This generic version is used when k is 0.}\par
01000 {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U>\par
01001 {\cf17 inline} {\cf18 void} CopyArray({\cf17 const} T& from, U* to) \{ *to = from; \}\par
01002 \par
01003 {\cf20 // This overload is used when k >= 1.}\par
01004 {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U, {\cf18 size_t} N>\par
01005 {\cf17 inline} {\cf18 void} CopyArray({\cf17 const} T(&from)[N], U(*to)[N]) \{\par
01006   internal::CopyArray(from, N, *to);\par
01007 \}\par
01008 \par
01009 {\cf20 // This helper reduces code bloat.  If we instead put its logic inside}\par
01010 {\cf20 // the previous CopyArray() function, arrays with different sizes}\par
01011 {\cf20 // would lead to different copies of the template code.}\par
01012 {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U>\par
01013 {\cf18 void} CopyArray({\cf17 const} T* from, {\cf18 size_t} size, U* to) \{\par
01014   {\cf19 for} ({\cf18 size_t} i = 0; i != size; i++) \{\par
01015     internal::CopyArray(from[i], to + i);\par
01016   \}\par
01017 \}\par
01018 \par
01019 {\cf20 // The relation between an NativeArray object (see below) and the}\par
01020 {\cf20 // native array it represents.}\par
01021 {\cf20 // We use 2 different structs to allow non-copyable types to be used, as long}\par
01022 {\cf20 // as RelationToSourceReference() is passed.}\par
01023 {\cf17 struct }RelationToSourceReference \{\};\par
01024 {\cf17 struct }RelationToSourceCopy \{\};\par
01025 \par
01026 {\cf20 // Adapts a native array to a read-only STL-style container.  Instead}\par
01027 {\cf20 // of the complete STL container concept, this adaptor only implements}\par
01028 {\cf20 // members useful for Google Mock's container matchers.  New members}\par
01029 {\cf20 // should be added as needed.  To simplify the implementation, we only}\par
01030 {\cf20 // support Element being a raw type (i.e. having no top-level const or}\par
01031 {\cf20 // reference modifier).  It's the client's responsibility to satisfy}\par
01032 {\cf20 // this requirement.  Element can be an array type itself (hence}\par
01033 {\cf20 // multi-dimensional arrays are supported).}\par
01034 {\cf17 template} <{\cf17 typename} Element>\par
01035 {\cf17 class }NativeArray \{\par
01036  {\cf17 public}:\par
01037   {\cf20 // STL-style container typedefs.}\par
01038   {\cf17 typedef} Element value_type;\par
01039   {\cf17 typedef} Element* iterator;\par
01040   {\cf17 typedef} {\cf17 const} Element* const_iterator;\par
01041 \par
01042   {\cf20 // Constructs from a native array. References the source.}\par
01043   NativeArray({\cf17 const} Element* array, {\cf18 size_t} count, RelationToSourceReference) \{\par
01044     InitRef(array, count);\par
01045   \}\par
01046 \par
01047   {\cf20 // Constructs from a native array. Copies the source.}\par
01048   NativeArray({\cf17 const} Element* array, {\cf18 size_t} count, RelationToSourceCopy) \{\par
01049     InitCopy(array, count);\par
01050   \}\par
01051 \par
01052   {\cf20 // Copy constructor.}\par
01053   NativeArray({\cf17 const} NativeArray& rhs) \{\par
01054     (this->*rhs.clone_)(rhs.array_, rhs.size_);\par
01055   \}\par
01056 \par
01057   ~NativeArray() \{\par
01058     {\cf19 if} (clone_ != &NativeArray::InitRef)\par
01059       {\cf17 delete}[] array_;\par
01060   \}\par
01061 \par
01062   {\cf20 // STL-style container methods.}\par
01063   {\cf18 size_t} size(){\cf17  const }\{ {\cf19 return} size_; \}\par
01064   const_iterator begin(){\cf17  const }\{ {\cf19 return} array_; \}\par
01065   const_iterator end(){\cf17  const }\{ {\cf19 return} array_ + size_; \}\par
01066   {\cf18 bool} operator==({\cf17 const} NativeArray& rhs){\cf17  const }\{\par
01067     {\cf19 return} size() == rhs.size() &&\par
01068         ArrayEq(begin(), size(), rhs.begin());\par
01069   \}\par
01070 \par
01071  {\cf17 private}:\par
01072   {\cf17 enum} \{\par
01073     kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper<\par
01074         Element, GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>::value,\par
01075   \};\par
01076 \par
01077   {\cf20 // Initializes this object with a copy of the input.}\par
01078   {\cf18 void} InitCopy({\cf17 const} Element* array, {\cf18 size_t} a_size) \{\par
01079     Element* {\cf17 const} copy = {\cf17 new} Element[a_size];\par
01080     CopyArray(array, a_size, copy);\par
01081     array_ = copy;\par
01082     size_ = a_size;\par
01083     clone_ = &NativeArray::InitCopy;\par
01084   \}\par
01085 \par
01086   {\cf20 // Initializes this object with a reference of the input.}\par
01087   {\cf18 void} InitRef({\cf17 const} Element* array, {\cf18 size_t} a_size) \{\par
01088     array_ = array;\par
01089     size_ = a_size;\par
01090     clone_ = &NativeArray::InitRef;\par
01091   \}\par
01092 \par
01093   {\cf17 const} Element* array_;\par
01094   {\cf18 size_t} size_;\par
01095   void (NativeArray::*clone_)({\cf17 const} Element*, size_t);\par
01096 \par
01097   GTEST_DISALLOW_ASSIGN_(NativeArray);\par
01098 \};\par
01099 \par
01100 \}  {\cf20 // namespace internal}\par
01101 \}  {\cf20 // namespace testing}\par
01102 \par
01103 {\cf21 #define GTEST_MESSAGE_AT_(file, line, message, result_type) \\}\par
01104 {\cf21   ::testing::internal::AssertHelper(result_type, file, line, message) \\}\par
01105 {\cf21     = ::testing::Message()}\par
01106 \par
01107 {\cf21 #define GTEST_MESSAGE_(message, result_type) \\}\par
01108 {\cf21   GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)}\par
01109 \par
01110 {\cf21 #define GTEST_FATAL_FAILURE_(message) \\}\par
01111 {\cf21   return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)}\par
01112 \par
01113 {\cf21 #define GTEST_NONFATAL_FAILURE_(message) \\}\par
01114 {\cf21   GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)}\par
01115 \par
01116 {\cf21 #define GTEST_SUCCESS_(message) \\}\par
01117 {\cf21   GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)}\par
01118 \par
01119 {\cf20 // Suppresses MSVC warnings 4072 (unreachable code) for the code following}\par
01120 {\cf20 // statement if it returns or throws (or doesn't return or throw in some}\par
01121 {\cf20 // situations).}\par
01122 {\cf21 #define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \\}\par
01123 {\cf21   if (::testing::internal::AlwaysTrue()) \{ statement; \}}\par
01124 \par
01125 {\cf21 #define GTEST_TEST_THROW_(statement, expected_exception, fail) \\}\par
01126 {\cf21   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\}\par
01127 {\cf21   if (::testing::internal::ConstCharPtr gtest_msg = ""}) \{ \\\par
01128     bool gtest_caught_expected = false; \\\par
01129     try \{ \\\par
01130       GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\par
01131     \} \\\par
01132     catch (expected_exception const&) \{ \\\par
01133       gtest_caught_expected = true; \\\par
01134     \} \\\par
01135     catch (...) \{ \\\par
01136       gtest_msg.value = \\\par
01137           "Expected: " #statement " throws an exception of type " \\\par
01138           #expected_exception ".\\n  Actual: it throws a different type."; \\\par
01139       goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\par
01140     \} \\\par
01141     if (!gtest_caught_expected) \{ \\\par
01142       gtest_msg.value = \\\par
01143           "Expected: " #statement " throws an exception of type " \\\par
01144           #expected_exception ".\\n  Actual: it throws nothing."; \\\par
01145       goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\par
01146     \} \\\par
01147   \} else \\\par
01148     GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \\\par
01149       fail(gtest_msg.value)\par
01150 \par
01151 {\cf21 #define GTEST_TEST_NO_THROW_(statement, fail) \\}\par
01152 {\cf21   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\}\par
01153 {\cf21   if (::testing::internal::AlwaysTrue()) \{ \\}\par
01154 {\cf21     try \{ \\}\par
01155 {\cf21       GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\}\par
01156 {\cf21     \} \\}\par
01157 {\cf21     catch (...) \{ \\}\par
01158 {\cf21       goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \\}\par
01159 {\cf21     \} \\}\par
01160 {\cf21   \} else \\}\par
01161 {\cf21     GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \\}\par
01162 {\cf21       fail("Expected: "} #statement " doesn't throw an exception.\\n" \\\par
01163            "  Actual: it throws.")\par
01164 \par
01165 {\cf21 #define GTEST_TEST_ANY_THROW_(statement, fail) \\}\par
01166 {\cf21   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\}\par
01167 {\cf21   if (::testing::internal::AlwaysTrue()) \{ \\}\par
01168 {\cf21     bool gtest_caught_any = false; \\}\par
01169 {\cf21     try \{ \\}\par
01170 {\cf21       GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\}\par
01171 {\cf21     \} \\}\par
01172 {\cf21     catch (...) \{ \\}\par
01173 {\cf21       gtest_caught_any = true; \\}\par
01174 {\cf21     \} \\}\par
01175 {\cf21     if (!gtest_caught_any) \{ \\}\par
01176 {\cf21       goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \\}\par
01177 {\cf21     \} \\}\par
01178 {\cf21   \} else \\}\par
01179 {\cf21     GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \\}\par
01180 {\cf21       fail("Expected: "} #statement " throws an exception.\\n" \\\par
01181            "  Actual: it doesn't.")\par
01182 \par
01183 \par
01184 {\cf20 // Implements Boolean test assertions such as EXPECT_TRUE. expression can be}\par
01185 {\cf20 // either a boolean expression or an AssertionResult. text is a textual}\par
01186 {\cf20 // represenation of expression as it was passed into the EXPECT_TRUE.}\par
01187 {\cf21 #define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \\}\par
01188 {\cf21   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\}\par
01189 {\cf21   if (const ::testing::AssertionResult gtest_ar_ = \\}\par
01190 {\cf21       ::testing::AssertionResult(expression)) \\}\par
01191 {\cf21     ; \\}\par
01192 {\cf21   else \\}\par
01193 {\cf21     fail(::testing::internal::GetBoolAssertionFailureMessage(\\}\par
01194 {\cf21         gtest_ar_, text, #actual, #expected).c_str())}\par
01195 \par
01196 {\cf21 #define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \\}\par
01197 {\cf21   GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\}\par
01198 {\cf21   if (::testing::internal::AlwaysTrue()) \{ \\}\par
01199 {\cf21     ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \\}\par
01200 {\cf21     GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\}\par
01201 {\cf21     if (gtest_fatal_failure_checker.has_new_fatal_failure()) \{ \\}\par
01202 {\cf21       goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \\}\par
01203 {\cf21     \} \\}\par
01204 {\cf21   \} else \\}\par
01205 {\cf21     GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \\}\par
01206 {\cf21       fail("Expected: "} #statement " doesn't generate new fatal " \\\par
01207            "failures in the current thread.\\n" \\\par
01208            "  Actual: it does.")\par
01209 \par
01210 {\cf20 // Expands to the name of the class that implements the given test.}\par
01211 {\cf21 #define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\}\par
01212 {\cf21   test_case_name##_##test_name##_Test}\par
01213 \par
01214 {\cf20 // Helper macro for defining tests.}\par
01215 {\cf21 #define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\}\par
01216 {\cf21 class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class \{\\}\par
01217 {\cf21  public:\\}\par
01218 {\cf21   GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() \{\}\\}\par
01219 {\cf21  private:\\}\par
01220 {\cf21   virtual void TestBody();\\}\par
01221 {\cf21   static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\}\par
01222 {\cf21   GTEST_DISALLOW_COPY_AND_ASSIGN_(\\}\par
01223 {\cf21       GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\}\par
01224 {\cf21 \};\\}\par
01225 {\cf21 \\}\par
01226 {\cf21 ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\}\par
01227 {\cf21   ::test_info_ =\\}\par
01228 {\cf21     ::testing::internal::MakeAndRegisterTestInfo(\\}\par
01229 {\cf21         #test_case_name, #test_name, NULL, NULL, \\}\par
01230 {\cf21         ::testing::internal::CodeLocation(__FILE__, __LINE__), \\}\par
01231 {\cf21         (parent_id), \\}\par
01232 {\cf21         parent_class::SetUpTestCase, \\}\par
01233 {\cf21         parent_class::TearDownTestCase, \\}\par
01234 {\cf21         new ::testing::internal::TestFactoryImpl<\\}\par
01235 {\cf21             GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\}\par
01236 {\cf21 void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()}\par
01237 \par
01238 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_}\par
01239 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/internal/gtest-linked_ptr.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-linked_ptr.h}
{\xe \v gtest/include/gtest/internal/gtest-linked_ptr.h}
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdlib.h>}\par
{\f2 #include <assert.h>}\par
{\f2 #include "gtest/internal/gtest-port.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::linked_ptr_internal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::linked_ptr< T >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b testing::internal::GTEST_DECLARE_STATIC_MUTEX_} (g_linked_ptr_mutex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > bool {\b testing::internal::operator==} (T *ptr, const linked_ptr< T > &x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > bool {\b testing::internal::operator!=} (T *ptr, const linked_ptr< T > &x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > linked_ptr< T > {\b testing::internal::make_linked_ptr} (T *ptr)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-linked_ptr.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-linked_ptr.h}
{\xe \v gtest/include/gtest/internal/gtest-linked_ptr.h}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2003 Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Authors: Dan Egnor (egnor@google.com)}\par
00031 {\cf20 //}\par
00032 {\cf20 // A "smart" pointer type with reference tracking.  Every pointer to a}\par
00033 {\cf20 // particular object is kept on a circular linked list.  When the last pointer}\par
00034 {\cf20 // to an object is destroyed or reassigned, the object is deleted.}\par
00035 {\cf20 //}\par
00036 {\cf20 // Used properly, this deletes the object when the last reference goes away.}\par
00037 {\cf20 // There are several caveats:}\par
00038 {\cf20 // - Like all reference counting schemes, cycles lead to leaks.}\par
00039 {\cf20 // - Each smart pointer is actually two pointers (8 bytes instead of 4).}\par
00040 {\cf20 // - Every time a pointer is assigned, the entire list of pointers to that}\par
00041 {\cf20 //   object is traversed.  This class is therefore NOT SUITABLE when there}\par
00042 {\cf20 //   will often be more than two or three pointers to a particular object.}\par
00043 {\cf20 // - References are only tracked as long as linked_ptr<> objects are copied.}\par
00044 {\cf20 //   If a linked_ptr<> is converted to a raw pointer and back, BAD THINGS}\par
00045 {\cf20 //   will happen (double deletion).}\par
00046 {\cf20 //}\par
00047 {\cf20 // A good use of this class is storing object references in STL containers.}\par
00048 {\cf20 // You can safely put linked_ptr<> in a vector<>.}\par
00049 {\cf20 // Other uses may not be as good.}\par
00050 {\cf20 //}\par
00051 {\cf20 // Note: If you use an incomplete type with linked_ptr<>, the class}\par
00052 {\cf20 // *containing* linked_ptr<> must have a constructor and destructor (even}\par
00053 {\cf20 // if they do nothing!).}\par
00054 {\cf20 //}\par
00055 {\cf20 // Bill Gibbons suggested we use something like this.}\par
00056 {\cf20 //}\par
00057 {\cf20 // Thread Safety:}\par
00058 {\cf20 //   Unlike other linked_ptr implementations, in this implementation}\par
00059 {\cf20 //   a linked_ptr object is thread-safe in the sense that:}\par
00060 {\cf20 //     - it's safe to copy linked_ptr objects concurrently,}\par
00061 {\cf20 //     - it's safe to copy *from* a linked_ptr and read its underlying}\par
00062 {\cf20 //       raw pointer (e.g. via get()) concurrently, and}\par
00063 {\cf20 //     - it's safe to write to two linked_ptrs that point to the same}\par
00064 {\cf20 //       shared object concurrently.}\par
00065 {\cf20 // TODO(wan@google.com): rename this to safe_linked_ptr to avoid}\par
00066 {\cf20 // confusion with normal linked_ptr.}\par
00067 \par
00068 {\cf21 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_}\par
00069 {\cf21 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_}\par
00070 \par
00071 {\cf21 #include <stdlib.h>}\par
00072 {\cf21 #include <assert.h>}\par
00073 \par
00074 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00075 \par
00076 {\cf17 namespace }testing \{\par
00077 {\cf17 namespace }internal \{\par
00078 \par
00079 {\cf20 // Protects copying of all linked_ptr objects.}\par
00080 GTEST_API_ GTEST_DECLARE_STATIC_MUTEX_(g_linked_ptr_mutex);\par
00081 \par
00082 {\cf20 // This is used internally by all instances of linked_ptr<>.  It needs to be}\par
00083 {\cf20 // a non-template class because different types of linked_ptr<> can refer to}\par
00084 {\cf20 // the same object (linked_ptr<Superclass>(obj) vs linked_ptr<Subclass>(obj)).}\par
00085 {\cf20 // So, it needs to be possible for different types of linked_ptr to participate}\par
00086 {\cf20 // in the same circular linked list, so we need a single class type here.}\par
00087 {\cf20 //}\par
00088 {\cf20 // DO NOT USE THIS CLASS DIRECTLY YOURSELF.  Use linked_ptr<T>.}\par
00089 {\cf17 class }linked_ptr_internal \{\par
00090  {\cf17 public}:\par
00091   {\cf20 // Create a new circle that includes only this instance.}\par
00092   {\cf18 void} join_new() \{\par
00093     next_ = {\cf17 this};\par
00094   \}\par
00095 \par
00096   {\cf20 // Many linked_ptr operations may change p.link_ for some linked_ptr}\par
00097   {\cf20 // variable p in the same circle as this object.  Therefore we need}\par
00098   {\cf20 // to prevent two such operations from occurring concurrently.}\par
00099   {\cf20 //}\par
00100   {\cf20 // Note that different types of linked_ptr objects can coexist in a}\par
00101   {\cf20 // circle (e.g. linked_ptr<Base>, linked_ptr<Derived1>, and}\par
00102   {\cf20 // linked_ptr<Derived2>).  Therefore we must use a single mutex to}\par
00103   {\cf20 // protect all linked_ptr objects.  This can create serious}\par
00104   {\cf20 // contention in production code, but is acceptable in a testing}\par
00105   {\cf20 // framework.}\par
00106 \par
00107   {\cf20 // Join an existing circle.}\par
00108   {\cf18 void} join(linked_ptr_internal {\cf17 const}* ptr)\par
00109       GTEST_LOCK_EXCLUDED_(g_linked_ptr_mutex) \{\par
00110     MutexLock lock(&g_linked_ptr_mutex);\par
00111 \par
00112     linked_ptr_internal {\cf17 const}* p = ptr;\par
00113     {\cf19 while} (p->next_ != ptr) \{\par
00114       assert(p->next_ != {\cf17 this} &&\par
00115              {\cf22 "Trying to join() a linked ring we are already in. "}\par
00116              {\cf22 "Is GMock thread safety enabled?"});\par
00117       p = p->next_;\par
00118     \}\par
00119     p->next_ = {\cf17 this};\par
00120     next_ = ptr;\par
00121   \}\par
00122 \par
00123   {\cf20 // Leave whatever circle we're part of.  Returns true if we were the}\par
00124   {\cf20 // last member of the circle.  Once this is done, you can join() another.}\par
00125   {\cf18 bool} depart()\par
00126       GTEST_LOCK_EXCLUDED_(g_linked_ptr_mutex) \{\par
00127     MutexLock lock(&g_linked_ptr_mutex);\par
00128 \par
00129     {\cf19 if} (next_ == {\cf17 this}) {\cf19 return} {\cf17 true};\par
00130     linked_ptr_internal {\cf17 const}* p = next_;\par
00131     {\cf19 while} (p->next_ != {\cf17 this}) \{\par
00132       assert(p->next_ != next_ &&\par
00133              {\cf22 "Trying to depart() a linked ring we are not in. "}\par
00134              {\cf22 "Is GMock thread safety enabled?"});\par
00135       p = p->next_;\par
00136     \}\par
00137     p->next_ = next_;\par
00138     {\cf19 return} {\cf17 false};\par
00139   \}\par
00140 \par
00141  {\cf17 private}:\par
00142   {\cf17 mutable} linked_ptr_internal {\cf17 const}* next_;\par
00143 \};\par
00144 \par
00145 {\cf17 template} <{\cf17 typename} T>\par
00146 {\cf17 class }linked_ptr \{\par
00147  {\cf17 public}:\par
00148   {\cf17 typedef} T element_type;\par
00149 \par
00150   {\cf20 // Take over ownership of a raw pointer.  This should happen as soon as}\par
00151   {\cf20 // possible after the object is created.}\par
00152   {\cf17 explicit} linked_ptr(T* ptr = NULL) \{ capture(ptr); \}\par
00153   ~linked_ptr() \{ depart(); \}\par
00154 \par
00155   {\cf20 // Copy an existing linked_ptr<>, adding ourselves to the list of references.}\par
00156   {\cf17 template} <{\cf17 typename} U> linked_ptr(linked_ptr<U> {\cf17 const}& ptr) \{ copy(&ptr); \}\par
00157   linked_ptr(linked_ptr {\cf17 const}& ptr) \{  {\cf20 // NOLINT}\par
00158     assert(&ptr != {\cf17 this});\par
00159     copy(&ptr);\par
00160   \}\par
00161 \par
00162   {\cf20 // Assignment releases the old value and acquires the new.}\par
00163   {\cf17 template} <{\cf17 typename} U> linked_ptr& operator=(linked_ptr<U> {\cf17 const}& ptr) \{\par
00164     depart();\par
00165     copy(&ptr);\par
00166     {\cf19 return} *{\cf17 this};\par
00167   \}\par
00168 \par
00169   linked_ptr& operator=(linked_ptr {\cf17 const}& ptr) \{\par
00170     {\cf19 if} (&ptr != {\cf17 this}) \{\par
00171       depart();\par
00172       copy(&ptr);\par
00173     \}\par
00174     {\cf19 return} *{\cf17 this};\par
00175   \}\par
00176 \par
00177   {\cf20 // Smart pointer members.}\par
00178   {\cf18 void} reset(T* ptr = NULL) \{\par
00179     depart();\par
00180     capture(ptr);\par
00181   \}\par
00182   T* get(){\cf17  const }\{ {\cf19 return} value_; \}\par
00183   T* operator->(){\cf17  const }\{ {\cf19 return} value_; \}\par
00184   T& operator*(){\cf17  const }\{ {\cf19 return} *value_; \}\par
00185 \par
00186   {\cf18 bool} operator==(T* p){\cf17  const }\{ {\cf19 return} value_ == p; \}\par
00187   {\cf18 bool} operator!=(T* p){\cf17  const }\{ {\cf19 return} value_ != p; \}\par
00188   {\cf17 template} <{\cf17 typename} U>\par
00189   {\cf18 bool} operator==(linked_ptr<U> {\cf17 const}& ptr){\cf17  const }\{\par
00190     {\cf19 return} value_ == ptr.get();\par
00191   \}\par
00192   {\cf17 template} <{\cf17 typename} U>\par
00193   {\cf18 bool} operator!=(linked_ptr<U> {\cf17 const}& ptr){\cf17  const }\{\par
00194     {\cf19 return} value_ != ptr.get();\par
00195   \}\par
00196 \par
00197  {\cf17 private}:\par
00198   {\cf17 template} <{\cf17 typename} U>\par
00199   {\cf17 friend} {\cf17 class }linked_ptr;\par
00200 \par
00201   T* value_;\par
00202   linked_ptr_internal link_;\par
00203 \par
00204   {\cf18 void} depart() \{\par
00205     {\cf19 if} (link_.depart()) {\cf17 delete} value_;\par
00206   \}\par
00207 \par
00208   {\cf18 void} capture(T* ptr) \{\par
00209     value_ = ptr;\par
00210     link_.join_new();\par
00211   \}\par
00212 \par
00213   {\cf17 template} <{\cf17 typename} U> {\cf18 void} copy(linked_ptr<U> {\cf17 const}* ptr) \{\par
00214     value_ = ptr->get();\par
00215     {\cf19 if} (value_)\par
00216       link_.join(&ptr->link_);\par
00217     {\cf19 else}\par
00218       link_.join_new();\par
00219   \}\par
00220 \};\par
00221 \par
00222 {\cf17 template}<{\cf17 typename} T> {\cf17 inline}\par
00223 {\cf18 bool} operator==(T* ptr, {\cf17 const} linked_ptr<T>& x) \{\par
00224   {\cf19 return} ptr == x.get();\par
00225 \}\par
00226 \par
00227 {\cf17 template}<{\cf17 typename} T> {\cf17 inline}\par
00228 {\cf18 bool} operator!=(T* ptr, {\cf17 const} linked_ptr<T>& x) \{\par
00229   {\cf19 return} ptr != x.get();\par
00230 \}\par
00231 \par
00232 {\cf20 // A function to convert T* into linked_ptr<T>}\par
00233 {\cf20 // Doing e.g. make_linked_ptr(new FooBarBaz<type>(arg)) is a shorter notation}\par
00234 {\cf20 // for linked_ptr<FooBarBaz<type> >(new FooBarBaz<type>(arg))}\par
00235 {\cf17 template} <{\cf17 typename} T>\par
00236 linked_ptr<T> make_linked_ptr(T* ptr) \{\par
00237   {\cf19 return} linked_ptr<T>(ptr);\par
00238 \}\par
00239 \par
00240 \}  {\cf20 // namespace internal}\par
00241 \}  {\cf20 // namespace testing}\par
00242 \par
00243 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/internal/gtest-param-util-generated.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-param-util-generated.h}
{\xe \v gtest/include/gtest/internal/gtest-param-util-generated.h}
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/internal/gtest-param-util.h"}\par
{\f2 #include "gtest/internal/gtest-port.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-param-util-generated.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-param-util-generated.h}
{\xe \v gtest/include/gtest/internal/gtest-param-util-generated.h}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // This file was GENERATED by command:}\par
00002 {\cf20 //     pump.py gtest-param-util-generated.h.pump}\par
00003 {\cf20 // DO NOT EDIT BY HAND!!!}\par
00004 \par
00005 {\cf20 // Copyright 2008 Google Inc.}\par
00006 {\cf20 // All Rights Reserved.}\par
00007 {\cf20 //}\par
00008 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00009 {\cf20 // modification, are permitted provided that the following conditions are}\par
00010 {\cf20 // met:}\par
00011 {\cf20 //}\par
00012 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00013 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00014 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00015 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00016 {\cf20 // in the documentation and/or other materials provided with the}\par
00017 {\cf20 // distribution.}\par
00018 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00019 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00020 {\cf20 // this software without specific prior written permission.}\par
00021 {\cf20 //}\par
00022 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00023 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00025 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00026 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00027 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00028 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00029 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00030 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00031 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00032 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00033 {\cf20 //}\par
00034 {\cf20 // Author: vladl@google.com (Vlad Losev)}\par
00035 \par
00036 {\cf20 // Type and function utilities for implementing parameterized tests.}\par
00037 {\cf20 // This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!}\par
00038 {\cf20 //}\par
00039 {\cf20 // Currently Google Test supports at most 50 arguments in Values,}\par
00040 {\cf20 // and at most 10 arguments in Combine. Please contact}\par
00041 {\cf20 // googletestframework@googlegroups.com if you need more.}\par
00042 {\cf20 // Please note that the number of arguments to Combine is limited}\par
00043 {\cf20 // by the maximum arity of the implementation of tuple which is}\par
00044 {\cf20 // currently set at 10.}\par
00045 \par
00046 {\cf21 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_}\par
00047 {\cf21 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_}\par
00048 \par
00049 {\cf20 // scripts/fuse_gtest.py depends on gtest's own header being #included}\par
00050 {\cf20 // *unconditionally*.  Therefore these #includes cannot be moved}\par
00051 {\cf20 // inside #if GTEST_HAS_PARAM_TEST.}\par
00052 {\cf21 #include "gtest/internal/gtest-param-util.h"}\par
00053 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00054 \par
00055 {\cf21 #if GTEST_HAS_PARAM_TEST}\par
00056 \par
00057 {\cf17 namespace }testing \{\par
00058 \par
00059 {\cf20 // Forward declarations of ValuesIn(), which is implemented in}\par
00060 {\cf20 // include/gtest/gtest-param-test.h.}\par
00061 {\cf17 template} <{\cf17 typename} ForwardIterator>\par
00062 internal::ParamGenerator<\par
00063   typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>\par
00064 ValuesIn(ForwardIterator begin, ForwardIterator end);\par
00065 \par
00066 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} N>\par
00067 internal::ParamGenerator<T> ValuesIn({\cf17 const} T (&array)[N]);\par
00068 \par
00069 {\cf17 template} <{\cf17 class} Container>\par
00070 internal::ParamGenerator<typename Container::value_type> ValuesIn(\par
00071     {\cf17 const} Container& container);\par
00072 \par
00073 {\cf17 namespace }internal \{\par
00074 \par
00075 {\cf20 // Used in the Values() function to provide polymorphic capabilities.}\par
00076 {\cf17 template} <{\cf17 typename} T1>\par
00077 {\cf17 class }ValueArray1 \{\par
00078  {\cf17 public}:\par
00079   {\cf17 explicit} ValueArray1(T1 v1) : v1_(v1) \{\}\par
00080 \par
00081   {\cf17 template} <{\cf17 typename} T>\par
00082   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00083     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_)\};\par
00084     {\cf19 return} ValuesIn(array);\par
00085   \}\par
00086 \par
00087  {\cf17 private}:\par
00088   {\cf20 // No implementation - assignment is unsupported.}\par
00089   {\cf18 void} operator=({\cf17 const} ValueArray1& other);\par
00090 \par
00091   {\cf17 const} T1 v1_;\par
00092 \};\par
00093 \par
00094 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
00095 {\cf17 class }ValueArray2 \{\par
00096  {\cf17 public}:\par
00097   ValueArray2(T1 v1, T2 v2) : v1_(v1), v2_(v2) \{\}\par
00098 \par
00099   {\cf17 template} <{\cf17 typename} T>\par
00100   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00101     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_)\};\par
00102     {\cf19 return} ValuesIn(array);\par
00103   \}\par
00104 \par
00105  {\cf17 private}:\par
00106   {\cf20 // No implementation - assignment is unsupported.}\par
00107   {\cf18 void} operator=({\cf17 const} ValueArray2& other);\par
00108 \par
00109   {\cf17 const} T1 v1_;\par
00110   {\cf17 const} T2 v2_;\par
00111 \};\par
00112 \par
00113 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3>\par
00114 {\cf17 class }ValueArray3 \{\par
00115  {\cf17 public}:\par
00116   ValueArray3(T1 v1, T2 v2, T3 v3) : v1_(v1), v2_(v2), v3_(v3) \{\}\par
00117 \par
00118   {\cf17 template} <{\cf17 typename} T>\par
00119   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00120     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00121         {\cf17 static_cast<}T{\cf17 >}(v3_)\};\par
00122     {\cf19 return} ValuesIn(array);\par
00123   \}\par
00124 \par
00125  {\cf17 private}:\par
00126   {\cf20 // No implementation - assignment is unsupported.}\par
00127   {\cf18 void} operator=({\cf17 const} ValueArray3& other);\par
00128 \par
00129   {\cf17 const} T1 v1_;\par
00130   {\cf17 const} T2 v2_;\par
00131   {\cf17 const} T3 v3_;\par
00132 \};\par
00133 \par
00134 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4>\par
00135 {\cf17 class }ValueArray4 \{\par
00136  {\cf17 public}:\par
00137   ValueArray4(T1 v1, T2 v2, T3 v3, T4 v4) : v1_(v1), v2_(v2), v3_(v3),\par
00138       v4_(v4) \{\}\par
00139 \par
00140   {\cf17 template} <{\cf17 typename} T>\par
00141   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00142     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00143         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_)\};\par
00144     {\cf19 return} ValuesIn(array);\par
00145   \}\par
00146 \par
00147  {\cf17 private}:\par
00148   {\cf20 // No implementation - assignment is unsupported.}\par
00149   {\cf18 void} operator=({\cf17 const} ValueArray4& other);\par
00150 \par
00151   {\cf17 const} T1 v1_;\par
00152   {\cf17 const} T2 v2_;\par
00153   {\cf17 const} T3 v3_;\par
00154   {\cf17 const} T4 v4_;\par
00155 \};\par
00156 \par
00157 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5>\par
00158 {\cf17 class }ValueArray5 \{\par
00159  {\cf17 public}:\par
00160   ValueArray5(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5) : v1_(v1), v2_(v2), v3_(v3),\par
00161       v4_(v4), v5_(v5) \{\}\par
00162 \par
00163   {\cf17 template} <{\cf17 typename} T>\par
00164   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00165     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00166         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_)\};\par
00167     {\cf19 return} ValuesIn(array);\par
00168   \}\par
00169 \par
00170  {\cf17 private}:\par
00171   {\cf20 // No implementation - assignment is unsupported.}\par
00172   {\cf18 void} operator=({\cf17 const} ValueArray5& other);\par
00173 \par
00174   {\cf17 const} T1 v1_;\par
00175   {\cf17 const} T2 v2_;\par
00176   {\cf17 const} T3 v3_;\par
00177   {\cf17 const} T4 v4_;\par
00178   {\cf17 const} T5 v5_;\par
00179 \};\par
00180 \par
00181 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00182     {\cf17 typename} T6>\par
00183 {\cf17 class }ValueArray6 \{\par
00184  {\cf17 public}:\par
00185   ValueArray6(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6) : v1_(v1), v2_(v2),\par
00186       v3_(v3), v4_(v4), v5_(v5), v6_(v6) \{\}\par
00187 \par
00188   {\cf17 template} <{\cf17 typename} T>\par
00189   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00190     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00191         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00192         {\cf17 static_cast<}T{\cf17 >}(v6_)\};\par
00193     {\cf19 return} ValuesIn(array);\par
00194   \}\par
00195 \par
00196  {\cf17 private}:\par
00197   {\cf20 // No implementation - assignment is unsupported.}\par
00198   {\cf18 void} operator=({\cf17 const} ValueArray6& other);\par
00199 \par
00200   {\cf17 const} T1 v1_;\par
00201   {\cf17 const} T2 v2_;\par
00202   {\cf17 const} T3 v3_;\par
00203   {\cf17 const} T4 v4_;\par
00204   {\cf17 const} T5 v5_;\par
00205   {\cf17 const} T6 v6_;\par
00206 \};\par
00207 \par
00208 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00209     {\cf17 typename} T6, {\cf17 typename} T7>\par
00210 {\cf17 class }ValueArray7 \{\par
00211  {\cf17 public}:\par
00212   ValueArray7(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7) : v1_(v1),\par
00213       v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7) \{\}\par
00214 \par
00215   {\cf17 template} <{\cf17 typename} T>\par
00216   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00217     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00218         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00219         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_)\};\par
00220     {\cf19 return} ValuesIn(array);\par
00221   \}\par
00222 \par
00223  {\cf17 private}:\par
00224   {\cf20 // No implementation - assignment is unsupported.}\par
00225   {\cf18 void} operator=({\cf17 const} ValueArray7& other);\par
00226 \par
00227   {\cf17 const} T1 v1_;\par
00228   {\cf17 const} T2 v2_;\par
00229   {\cf17 const} T3 v3_;\par
00230   {\cf17 const} T4 v4_;\par
00231   {\cf17 const} T5 v5_;\par
00232   {\cf17 const} T6 v6_;\par
00233   {\cf17 const} T7 v7_;\par
00234 \};\par
00235 \par
00236 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00237     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8>\par
00238 {\cf17 class }ValueArray8 \{\par
00239  {\cf17 public}:\par
00240   ValueArray8(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\par
00241       T8 v8) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\par
00242       v8_(v8) \{\}\par
00243 \par
00244   {\cf17 template} <{\cf17 typename} T>\par
00245   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00246     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00247         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00248         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_)\};\par
00249     {\cf19 return} ValuesIn(array);\par
00250   \}\par
00251 \par
00252  {\cf17 private}:\par
00253   {\cf20 // No implementation - assignment is unsupported.}\par
00254   {\cf18 void} operator=({\cf17 const} ValueArray8& other);\par
00255 \par
00256   {\cf17 const} T1 v1_;\par
00257   {\cf17 const} T2 v2_;\par
00258   {\cf17 const} T3 v3_;\par
00259   {\cf17 const} T4 v4_;\par
00260   {\cf17 const} T5 v5_;\par
00261   {\cf17 const} T6 v6_;\par
00262   {\cf17 const} T7 v7_;\par
00263   {\cf17 const} T8 v8_;\par
00264 \};\par
00265 \par
00266 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00267     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9>\par
00268 {\cf17 class }ValueArray9 \{\par
00269  {\cf17 public}:\par
00270   ValueArray9(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\par
00271       T9 v9) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\par
00272       v8_(v8), v9_(v9) \{\}\par
00273 \par
00274   {\cf17 template} <{\cf17 typename} T>\par
00275   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00276     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00277         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00278         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00279         {\cf17 static_cast<}T{\cf17 >}(v9_)\};\par
00280     {\cf19 return} ValuesIn(array);\par
00281   \}\par
00282 \par
00283  {\cf17 private}:\par
00284   {\cf20 // No implementation - assignment is unsupported.}\par
00285   {\cf18 void} operator=({\cf17 const} ValueArray9& other);\par
00286 \par
00287   {\cf17 const} T1 v1_;\par
00288   {\cf17 const} T2 v2_;\par
00289   {\cf17 const} T3 v3_;\par
00290   {\cf17 const} T4 v4_;\par
00291   {\cf17 const} T5 v5_;\par
00292   {\cf17 const} T6 v6_;\par
00293   {\cf17 const} T7 v7_;\par
00294   {\cf17 const} T8 v8_;\par
00295   {\cf17 const} T9 v9_;\par
00296 \};\par
00297 \par
00298 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00299     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10>\par
00300 {\cf17 class }ValueArray10 \{\par
00301  {\cf17 public}:\par
00302   ValueArray10(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00303       T10 v10) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\par
00304       v8_(v8), v9_(v9), v10_(v10) \{\}\par
00305 \par
00306   {\cf17 template} <{\cf17 typename} T>\par
00307   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00308     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00309         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00310         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00311         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_)\};\par
00312     {\cf19 return} ValuesIn(array);\par
00313   \}\par
00314 \par
00315  {\cf17 private}:\par
00316   {\cf20 // No implementation - assignment is unsupported.}\par
00317   {\cf18 void} operator=({\cf17 const} ValueArray10& other);\par
00318 \par
00319   {\cf17 const} T1 v1_;\par
00320   {\cf17 const} T2 v2_;\par
00321   {\cf17 const} T3 v3_;\par
00322   {\cf17 const} T4 v4_;\par
00323   {\cf17 const} T5 v5_;\par
00324   {\cf17 const} T6 v6_;\par
00325   {\cf17 const} T7 v7_;\par
00326   {\cf17 const} T8 v8_;\par
00327   {\cf17 const} T9 v9_;\par
00328   {\cf17 const} T10 v10_;\par
00329 \};\par
00330 \par
00331 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00332     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00333     {\cf17 typename} T11>\par
00334 {\cf17 class }ValueArray11 \{\par
00335  {\cf17 public}:\par
00336   ValueArray11(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00337       T10 v10, T11 v11) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\par
00338       v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11) \{\}\par
00339 \par
00340   {\cf17 template} <{\cf17 typename} T>\par
00341   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00342     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00343         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00344         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00345         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_)\};\par
00346     {\cf19 return} ValuesIn(array);\par
00347   \}\par
00348 \par
00349  {\cf17 private}:\par
00350   {\cf20 // No implementation - assignment is unsupported.}\par
00351   {\cf18 void} operator=({\cf17 const} ValueArray11& other);\par
00352 \par
00353   {\cf17 const} T1 v1_;\par
00354   {\cf17 const} T2 v2_;\par
00355   {\cf17 const} T3 v3_;\par
00356   {\cf17 const} T4 v4_;\par
00357   {\cf17 const} T5 v5_;\par
00358   {\cf17 const} T6 v6_;\par
00359   {\cf17 const} T7 v7_;\par
00360   {\cf17 const} T8 v8_;\par
00361   {\cf17 const} T9 v9_;\par
00362   {\cf17 const} T10 v10_;\par
00363   {\cf17 const} T11 v11_;\par
00364 \};\par
00365 \par
00366 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00367     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00368     {\cf17 typename} T11, {\cf17 typename} T12>\par
00369 {\cf17 class }ValueArray12 \{\par
00370  {\cf17 public}:\par
00371   ValueArray12(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00372       T10 v10, T11 v11, T12 v12) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\par
00373       v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12) \{\}\par
00374 \par
00375   {\cf17 template} <{\cf17 typename} T>\par
00376   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00377     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00378         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00379         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00380         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
00381         {\cf17 static_cast<}T{\cf17 >}(v12_)\};\par
00382     {\cf19 return} ValuesIn(array);\par
00383   \}\par
00384 \par
00385  {\cf17 private}:\par
00386   {\cf20 // No implementation - assignment is unsupported.}\par
00387   {\cf18 void} operator=({\cf17 const} ValueArray12& other);\par
00388 \par
00389   {\cf17 const} T1 v1_;\par
00390   {\cf17 const} T2 v2_;\par
00391   {\cf17 const} T3 v3_;\par
00392   {\cf17 const} T4 v4_;\par
00393   {\cf17 const} T5 v5_;\par
00394   {\cf17 const} T6 v6_;\par
00395   {\cf17 const} T7 v7_;\par
00396   {\cf17 const} T8 v8_;\par
00397   {\cf17 const} T9 v9_;\par
00398   {\cf17 const} T10 v10_;\par
00399   {\cf17 const} T11 v11_;\par
00400   {\cf17 const} T12 v12_;\par
00401 \};\par
00402 \par
00403 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00404     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00405     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13>\par
00406 {\cf17 class }ValueArray13 \{\par
00407  {\cf17 public}:\par
00408   ValueArray13(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00409       T10 v10, T11 v11, T12 v12, T13 v13) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\par
00410       v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\par
00411       v12_(v12), v13_(v13) \{\}\par
00412 \par
00413   {\cf17 template} <{\cf17 typename} T>\par
00414   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00415     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00416         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00417         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00418         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
00419         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_)\};\par
00420     {\cf19 return} ValuesIn(array);\par
00421   \}\par
00422 \par
00423  {\cf17 private}:\par
00424   {\cf20 // No implementation - assignment is unsupported.}\par
00425   {\cf18 void} operator=({\cf17 const} ValueArray13& other);\par
00426 \par
00427   {\cf17 const} T1 v1_;\par
00428   {\cf17 const} T2 v2_;\par
00429   {\cf17 const} T3 v3_;\par
00430   {\cf17 const} T4 v4_;\par
00431   {\cf17 const} T5 v5_;\par
00432   {\cf17 const} T6 v6_;\par
00433   {\cf17 const} T7 v7_;\par
00434   {\cf17 const} T8 v8_;\par
00435   {\cf17 const} T9 v9_;\par
00436   {\cf17 const} T10 v10_;\par
00437   {\cf17 const} T11 v11_;\par
00438   {\cf17 const} T12 v12_;\par
00439   {\cf17 const} T13 v13_;\par
00440 \};\par
00441 \par
00442 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00443     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00444     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14>\par
00445 {\cf17 class }ValueArray14 \{\par
00446  {\cf17 public}:\par
00447   ValueArray14(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00448       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14) : v1_(v1), v2_(v2), v3_(v3),\par
00449       v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\par
00450       v11_(v11), v12_(v12), v13_(v13), v14_(v14) \{\}\par
00451 \par
00452   {\cf17 template} <{\cf17 typename} T>\par
00453   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00454     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00455         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00456         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00457         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
00458         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_)\};\par
00459     {\cf19 return} ValuesIn(array);\par
00460   \}\par
00461 \par
00462  {\cf17 private}:\par
00463   {\cf20 // No implementation - assignment is unsupported.}\par
00464   {\cf18 void} operator=({\cf17 const} ValueArray14& other);\par
00465 \par
00466   {\cf17 const} T1 v1_;\par
00467   {\cf17 const} T2 v2_;\par
00468   {\cf17 const} T3 v3_;\par
00469   {\cf17 const} T4 v4_;\par
00470   {\cf17 const} T5 v5_;\par
00471   {\cf17 const} T6 v6_;\par
00472   {\cf17 const} T7 v7_;\par
00473   {\cf17 const} T8 v8_;\par
00474   {\cf17 const} T9 v9_;\par
00475   {\cf17 const} T10 v10_;\par
00476   {\cf17 const} T11 v11_;\par
00477   {\cf17 const} T12 v12_;\par
00478   {\cf17 const} T13 v13_;\par
00479   {\cf17 const} T14 v14_;\par
00480 \};\par
00481 \par
00482 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00483     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00484     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15>\par
00485 {\cf17 class }ValueArray15 \{\par
00486  {\cf17 public}:\par
00487   ValueArray15(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00488       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15) : v1_(v1), v2_(v2),\par
00489       v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\par
00490       v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15) \{\}\par
00491 \par
00492   {\cf17 template} <{\cf17 typename} T>\par
00493   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00494     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00495         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00496         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00497         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
00498         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
00499         {\cf17 static_cast<}T{\cf17 >}(v15_)\};\par
00500     {\cf19 return} ValuesIn(array);\par
00501   \}\par
00502 \par
00503  {\cf17 private}:\par
00504   {\cf20 // No implementation - assignment is unsupported.}\par
00505   {\cf18 void} operator=({\cf17 const} ValueArray15& other);\par
00506 \par
00507   {\cf17 const} T1 v1_;\par
00508   {\cf17 const} T2 v2_;\par
00509   {\cf17 const} T3 v3_;\par
00510   {\cf17 const} T4 v4_;\par
00511   {\cf17 const} T5 v5_;\par
00512   {\cf17 const} T6 v6_;\par
00513   {\cf17 const} T7 v7_;\par
00514   {\cf17 const} T8 v8_;\par
00515   {\cf17 const} T9 v9_;\par
00516   {\cf17 const} T10 v10_;\par
00517   {\cf17 const} T11 v11_;\par
00518   {\cf17 const} T12 v12_;\par
00519   {\cf17 const} T13 v13_;\par
00520   {\cf17 const} T14 v14_;\par
00521   {\cf17 const} T15 v15_;\par
00522 \};\par
00523 \par
00524 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00525     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00526     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00527     {\cf17 typename} T16>\par
00528 {\cf17 class }ValueArray16 \{\par
00529  {\cf17 public}:\par
00530   ValueArray16(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00531       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16) : v1_(v1),\par
00532       v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\par
00533       v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\par
00534       v16_(v16) \{\}\par
00535 \par
00536   {\cf17 template} <{\cf17 typename} T>\par
00537   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00538     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00539         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00540         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00541         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
00542         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
00543         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_)\};\par
00544     {\cf19 return} ValuesIn(array);\par
00545   \}\par
00546 \par
00547  {\cf17 private}:\par
00548   {\cf20 // No implementation - assignment is unsupported.}\par
00549   {\cf18 void} operator=({\cf17 const} ValueArray16& other);\par
00550 \par
00551   {\cf17 const} T1 v1_;\par
00552   {\cf17 const} T2 v2_;\par
00553   {\cf17 const} T3 v3_;\par
00554   {\cf17 const} T4 v4_;\par
00555   {\cf17 const} T5 v5_;\par
00556   {\cf17 const} T6 v6_;\par
00557   {\cf17 const} T7 v7_;\par
00558   {\cf17 const} T8 v8_;\par
00559   {\cf17 const} T9 v9_;\par
00560   {\cf17 const} T10 v10_;\par
00561   {\cf17 const} T11 v11_;\par
00562   {\cf17 const} T12 v12_;\par
00563   {\cf17 const} T13 v13_;\par
00564   {\cf17 const} T14 v14_;\par
00565   {\cf17 const} T15 v15_;\par
00566   {\cf17 const} T16 v16_;\par
00567 \};\par
00568 \par
00569 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00570     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00571     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00572     {\cf17 typename} T16, {\cf17 typename} T17>\par
00573 {\cf17 class }ValueArray17 \{\par
00574  {\cf17 public}:\par
00575   ValueArray17(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00576       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,\par
00577       T17 v17) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\par
00578       v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\par
00579       v15_(v15), v16_(v16), v17_(v17) \{\}\par
00580 \par
00581   {\cf17 template} <{\cf17 typename} T>\par
00582   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00583     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00584         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00585         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00586         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
00587         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
00588         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_)\};\par
00589     {\cf19 return} ValuesIn(array);\par
00590   \}\par
00591 \par
00592  {\cf17 private}:\par
00593   {\cf20 // No implementation - assignment is unsupported.}\par
00594   {\cf18 void} operator=({\cf17 const} ValueArray17& other);\par
00595 \par
00596   {\cf17 const} T1 v1_;\par
00597   {\cf17 const} T2 v2_;\par
00598   {\cf17 const} T3 v3_;\par
00599   {\cf17 const} T4 v4_;\par
00600   {\cf17 const} T5 v5_;\par
00601   {\cf17 const} T6 v6_;\par
00602   {\cf17 const} T7 v7_;\par
00603   {\cf17 const} T8 v8_;\par
00604   {\cf17 const} T9 v9_;\par
00605   {\cf17 const} T10 v10_;\par
00606   {\cf17 const} T11 v11_;\par
00607   {\cf17 const} T12 v12_;\par
00608   {\cf17 const} T13 v13_;\par
00609   {\cf17 const} T14 v14_;\par
00610   {\cf17 const} T15 v15_;\par
00611   {\cf17 const} T16 v16_;\par
00612   {\cf17 const} T17 v17_;\par
00613 \};\par
00614 \par
00615 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00616     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00617     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00618     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18>\par
00619 {\cf17 class }ValueArray18 \{\par
00620  {\cf17 public}:\par
00621   ValueArray18(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00622       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00623       T18 v18) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\par
00624       v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\par
00625       v15_(v15), v16_(v16), v17_(v17), v18_(v18) \{\}\par
00626 \par
00627   {\cf17 template} <{\cf17 typename} T>\par
00628   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00629     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00630         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00631         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00632         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
00633         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
00634         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
00635         {\cf17 static_cast<}T{\cf17 >}(v18_)\};\par
00636     {\cf19 return} ValuesIn(array);\par
00637   \}\par
00638 \par
00639  {\cf17 private}:\par
00640   {\cf20 // No implementation - assignment is unsupported.}\par
00641   {\cf18 void} operator=({\cf17 const} ValueArray18& other);\par
00642 \par
00643   {\cf17 const} T1 v1_;\par
00644   {\cf17 const} T2 v2_;\par
00645   {\cf17 const} T3 v3_;\par
00646   {\cf17 const} T4 v4_;\par
00647   {\cf17 const} T5 v5_;\par
00648   {\cf17 const} T6 v6_;\par
00649   {\cf17 const} T7 v7_;\par
00650   {\cf17 const} T8 v8_;\par
00651   {\cf17 const} T9 v9_;\par
00652   {\cf17 const} T10 v10_;\par
00653   {\cf17 const} T11 v11_;\par
00654   {\cf17 const} T12 v12_;\par
00655   {\cf17 const} T13 v13_;\par
00656   {\cf17 const} T14 v14_;\par
00657   {\cf17 const} T15 v15_;\par
00658   {\cf17 const} T16 v16_;\par
00659   {\cf17 const} T17 v17_;\par
00660   {\cf17 const} T18 v18_;\par
00661 \};\par
00662 \par
00663 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00664     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00665     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00666     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19>\par
00667 {\cf17 class }ValueArray19 \{\par
00668  {\cf17 public}:\par
00669   ValueArray19(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00670       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00671       T18 v18, T19 v19) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\par
00672       v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),\par
00673       v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19) \{\}\par
00674 \par
00675   {\cf17 template} <{\cf17 typename} T>\par
00676   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00677     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00678         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00679         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00680         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
00681         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
00682         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
00683         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_)\};\par
00684     {\cf19 return} ValuesIn(array);\par
00685   \}\par
00686 \par
00687  {\cf17 private}:\par
00688   {\cf20 // No implementation - assignment is unsupported.}\par
00689   {\cf18 void} operator=({\cf17 const} ValueArray19& other);\par
00690 \par
00691   {\cf17 const} T1 v1_;\par
00692   {\cf17 const} T2 v2_;\par
00693   {\cf17 const} T3 v3_;\par
00694   {\cf17 const} T4 v4_;\par
00695   {\cf17 const} T5 v5_;\par
00696   {\cf17 const} T6 v6_;\par
00697   {\cf17 const} T7 v7_;\par
00698   {\cf17 const} T8 v8_;\par
00699   {\cf17 const} T9 v9_;\par
00700   {\cf17 const} T10 v10_;\par
00701   {\cf17 const} T11 v11_;\par
00702   {\cf17 const} T12 v12_;\par
00703   {\cf17 const} T13 v13_;\par
00704   {\cf17 const} T14 v14_;\par
00705   {\cf17 const} T15 v15_;\par
00706   {\cf17 const} T16 v16_;\par
00707   {\cf17 const} T17 v17_;\par
00708   {\cf17 const} T18 v18_;\par
00709   {\cf17 const} T19 v19_;\par
00710 \};\par
00711 \par
00712 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00713     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00714     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00715     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20>\par
00716 {\cf17 class }ValueArray20 \{\par
00717  {\cf17 public}:\par
00718   ValueArray20(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00719       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00720       T18 v18, T19 v19, T20 v20) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\par
00721       v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),\par
00722       v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),\par
00723       v19_(v19), v20_(v20) \{\}\par
00724 \par
00725   {\cf17 template} <{\cf17 typename} T>\par
00726   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00727     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00728         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00729         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00730         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
00731         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
00732         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
00733         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_)\};\par
00734     {\cf19 return} ValuesIn(array);\par
00735   \}\par
00736 \par
00737  {\cf17 private}:\par
00738   {\cf20 // No implementation - assignment is unsupported.}\par
00739   {\cf18 void} operator=({\cf17 const} ValueArray20& other);\par
00740 \par
00741   {\cf17 const} T1 v1_;\par
00742   {\cf17 const} T2 v2_;\par
00743   {\cf17 const} T3 v3_;\par
00744   {\cf17 const} T4 v4_;\par
00745   {\cf17 const} T5 v5_;\par
00746   {\cf17 const} T6 v6_;\par
00747   {\cf17 const} T7 v7_;\par
00748   {\cf17 const} T8 v8_;\par
00749   {\cf17 const} T9 v9_;\par
00750   {\cf17 const} T10 v10_;\par
00751   {\cf17 const} T11 v11_;\par
00752   {\cf17 const} T12 v12_;\par
00753   {\cf17 const} T13 v13_;\par
00754   {\cf17 const} T14 v14_;\par
00755   {\cf17 const} T15 v15_;\par
00756   {\cf17 const} T16 v16_;\par
00757   {\cf17 const} T17 v17_;\par
00758   {\cf17 const} T18 v18_;\par
00759   {\cf17 const} T19 v19_;\par
00760   {\cf17 const} T20 v20_;\par
00761 \};\par
00762 \par
00763 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00764     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00765     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00766     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00767     {\cf17 typename} T21>\par
00768 {\cf17 class }ValueArray21 \{\par
00769  {\cf17 public}:\par
00770   ValueArray21(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00771       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00772       T18 v18, T19 v19, T20 v20, T21 v21) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\par
00773       v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\par
00774       v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),\par
00775       v18_(v18), v19_(v19), v20_(v20), v21_(v21) \{\}\par
00776 \par
00777   {\cf17 template} <{\cf17 typename} T>\par
00778   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00779     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00780         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00781         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00782         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
00783         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
00784         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
00785         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
00786         {\cf17 static_cast<}T{\cf17 >}(v21_)\};\par
00787     {\cf19 return} ValuesIn(array);\par
00788   \}\par
00789 \par
00790  {\cf17 private}:\par
00791   {\cf20 // No implementation - assignment is unsupported.}\par
00792   {\cf18 void} operator=({\cf17 const} ValueArray21& other);\par
00793 \par
00794   {\cf17 const} T1 v1_;\par
00795   {\cf17 const} T2 v2_;\par
00796   {\cf17 const} T3 v3_;\par
00797   {\cf17 const} T4 v4_;\par
00798   {\cf17 const} T5 v5_;\par
00799   {\cf17 const} T6 v6_;\par
00800   {\cf17 const} T7 v7_;\par
00801   {\cf17 const} T8 v8_;\par
00802   {\cf17 const} T9 v9_;\par
00803   {\cf17 const} T10 v10_;\par
00804   {\cf17 const} T11 v11_;\par
00805   {\cf17 const} T12 v12_;\par
00806   {\cf17 const} T13 v13_;\par
00807   {\cf17 const} T14 v14_;\par
00808   {\cf17 const} T15 v15_;\par
00809   {\cf17 const} T16 v16_;\par
00810   {\cf17 const} T17 v17_;\par
00811   {\cf17 const} T18 v18_;\par
00812   {\cf17 const} T19 v19_;\par
00813   {\cf17 const} T20 v20_;\par
00814   {\cf17 const} T21 v21_;\par
00815 \};\par
00816 \par
00817 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00818     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00819     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00820     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00821     {\cf17 typename} T21, {\cf17 typename} T22>\par
00822 {\cf17 class }ValueArray22 \{\par
00823  {\cf17 public}:\par
00824   ValueArray22(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00825       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00826       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22) : v1_(v1), v2_(v2), v3_(v3),\par
00827       v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\par
00828       v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\par
00829       v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22) \{\}\par
00830 \par
00831   {\cf17 template} <{\cf17 typename} T>\par
00832   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00833     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00834         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00835         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00836         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
00837         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
00838         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
00839         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
00840         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_)\};\par
00841     {\cf19 return} ValuesIn(array);\par
00842   \}\par
00843 \par
00844  {\cf17 private}:\par
00845   {\cf20 // No implementation - assignment is unsupported.}\par
00846   {\cf18 void} operator=({\cf17 const} ValueArray22& other);\par
00847 \par
00848   {\cf17 const} T1 v1_;\par
00849   {\cf17 const} T2 v2_;\par
00850   {\cf17 const} T3 v3_;\par
00851   {\cf17 const} T4 v4_;\par
00852   {\cf17 const} T5 v5_;\par
00853   {\cf17 const} T6 v6_;\par
00854   {\cf17 const} T7 v7_;\par
00855   {\cf17 const} T8 v8_;\par
00856   {\cf17 const} T9 v9_;\par
00857   {\cf17 const} T10 v10_;\par
00858   {\cf17 const} T11 v11_;\par
00859   {\cf17 const} T12 v12_;\par
00860   {\cf17 const} T13 v13_;\par
00861   {\cf17 const} T14 v14_;\par
00862   {\cf17 const} T15 v15_;\par
00863   {\cf17 const} T16 v16_;\par
00864   {\cf17 const} T17 v17_;\par
00865   {\cf17 const} T18 v18_;\par
00866   {\cf17 const} T19 v19_;\par
00867   {\cf17 const} T20 v20_;\par
00868   {\cf17 const} T21 v21_;\par
00869   {\cf17 const} T22 v22_;\par
00870 \};\par
00871 \par
00872 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00873     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00874     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00875     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00876     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23>\par
00877 {\cf17 class }ValueArray23 \{\par
00878  {\cf17 public}:\par
00879   ValueArray23(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00880       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00881       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23) : v1_(v1), v2_(v2),\par
00882       v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\par
00883       v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\par
00884       v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\par
00885       v23_(v23) \{\}\par
00886 \par
00887   {\cf17 template} <{\cf17 typename} T>\par
00888   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00889     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00890         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00891         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00892         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
00893         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
00894         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
00895         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
00896         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_)\};\par
00897     {\cf19 return} ValuesIn(array);\par
00898   \}\par
00899 \par
00900  {\cf17 private}:\par
00901   {\cf20 // No implementation - assignment is unsupported.}\par
00902   {\cf18 void} operator=({\cf17 const} ValueArray23& other);\par
00903 \par
00904   {\cf17 const} T1 v1_;\par
00905   {\cf17 const} T2 v2_;\par
00906   {\cf17 const} T3 v3_;\par
00907   {\cf17 const} T4 v4_;\par
00908   {\cf17 const} T5 v5_;\par
00909   {\cf17 const} T6 v6_;\par
00910   {\cf17 const} T7 v7_;\par
00911   {\cf17 const} T8 v8_;\par
00912   {\cf17 const} T9 v9_;\par
00913   {\cf17 const} T10 v10_;\par
00914   {\cf17 const} T11 v11_;\par
00915   {\cf17 const} T12 v12_;\par
00916   {\cf17 const} T13 v13_;\par
00917   {\cf17 const} T14 v14_;\par
00918   {\cf17 const} T15 v15_;\par
00919   {\cf17 const} T16 v16_;\par
00920   {\cf17 const} T17 v17_;\par
00921   {\cf17 const} T18 v18_;\par
00922   {\cf17 const} T19 v19_;\par
00923   {\cf17 const} T20 v20_;\par
00924   {\cf17 const} T21 v21_;\par
00925   {\cf17 const} T22 v22_;\par
00926   {\cf17 const} T23 v23_;\par
00927 \};\par
00928 \par
00929 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00930     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00931     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00932     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00933     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24>\par
00934 {\cf17 class }ValueArray24 \{\par
00935  {\cf17 public}:\par
00936   ValueArray24(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00937       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00938       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24) : v1_(v1),\par
00939       v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\par
00940       v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\par
00941       v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),\par
00942       v22_(v22), v23_(v23), v24_(v24) \{\}\par
00943 \par
00944   {\cf17 template} <{\cf17 typename} T>\par
00945   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
00946     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
00947         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
00948         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
00949         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
00950         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
00951         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
00952         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
00953         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
00954         {\cf17 static_cast<}T{\cf17 >}(v24_)\};\par
00955     {\cf19 return} ValuesIn(array);\par
00956   \}\par
00957 \par
00958  {\cf17 private}:\par
00959   {\cf20 // No implementation - assignment is unsupported.}\par
00960   {\cf18 void} operator=({\cf17 const} ValueArray24& other);\par
00961 \par
00962   {\cf17 const} T1 v1_;\par
00963   {\cf17 const} T2 v2_;\par
00964   {\cf17 const} T3 v3_;\par
00965   {\cf17 const} T4 v4_;\par
00966   {\cf17 const} T5 v5_;\par
00967   {\cf17 const} T6 v6_;\par
00968   {\cf17 const} T7 v7_;\par
00969   {\cf17 const} T8 v8_;\par
00970   {\cf17 const} T9 v9_;\par
00971   {\cf17 const} T10 v10_;\par
00972   {\cf17 const} T11 v11_;\par
00973   {\cf17 const} T12 v12_;\par
00974   {\cf17 const} T13 v13_;\par
00975   {\cf17 const} T14 v14_;\par
00976   {\cf17 const} T15 v15_;\par
00977   {\cf17 const} T16 v16_;\par
00978   {\cf17 const} T17 v17_;\par
00979   {\cf17 const} T18 v18_;\par
00980   {\cf17 const} T19 v19_;\par
00981   {\cf17 const} T20 v20_;\par
00982   {\cf17 const} T21 v21_;\par
00983   {\cf17 const} T22 v22_;\par
00984   {\cf17 const} T23 v23_;\par
00985   {\cf17 const} T24 v24_;\par
00986 \};\par
00987 \par
00988 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00989     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00990     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00991     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00992     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25>\par
00993 {\cf17 class }ValueArray25 \{\par
00994  {\cf17 public}:\par
00995   ValueArray25(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
00996       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
00997       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,\par
00998       T25 v25) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\par
00999       v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\par
01000       v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\par
01001       v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25) \{\}\par
01002 \par
01003   {\cf17 template} <{\cf17 typename} T>\par
01004   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
01005     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
01006         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
01007         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
01008         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
01009         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
01010         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
01011         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
01012         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
01013         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_)\};\par
01014     {\cf19 return} ValuesIn(array);\par
01015   \}\par
01016 \par
01017  {\cf17 private}:\par
01018   {\cf20 // No implementation - assignment is unsupported.}\par
01019   {\cf18 void} operator=({\cf17 const} ValueArray25& other);\par
01020 \par
01021   {\cf17 const} T1 v1_;\par
01022   {\cf17 const} T2 v2_;\par
01023   {\cf17 const} T3 v3_;\par
01024   {\cf17 const} T4 v4_;\par
01025   {\cf17 const} T5 v5_;\par
01026   {\cf17 const} T6 v6_;\par
01027   {\cf17 const} T7 v7_;\par
01028   {\cf17 const} T8 v8_;\par
01029   {\cf17 const} T9 v9_;\par
01030   {\cf17 const} T10 v10_;\par
01031   {\cf17 const} T11 v11_;\par
01032   {\cf17 const} T12 v12_;\par
01033   {\cf17 const} T13 v13_;\par
01034   {\cf17 const} T14 v14_;\par
01035   {\cf17 const} T15 v15_;\par
01036   {\cf17 const} T16 v16_;\par
01037   {\cf17 const} T17 v17_;\par
01038   {\cf17 const} T18 v18_;\par
01039   {\cf17 const} T19 v19_;\par
01040   {\cf17 const} T20 v20_;\par
01041   {\cf17 const} T21 v21_;\par
01042   {\cf17 const} T22 v22_;\par
01043   {\cf17 const} T23 v23_;\par
01044   {\cf17 const} T24 v24_;\par
01045   {\cf17 const} T25 v25_;\par
01046 \};\par
01047 \par
01048 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01049     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01050     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01051     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01052     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01053     {\cf17 typename} T26>\par
01054 {\cf17 class }ValueArray26 \{\par
01055  {\cf17 public}:\par
01056   ValueArray26(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
01057       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
01058       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
01059       T26 v26) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\par
01060       v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\par
01061       v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\par
01062       v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26) \{\}\par
01063 \par
01064   {\cf17 template} <{\cf17 typename} T>\par
01065   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
01066     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
01067         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
01068         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
01069         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
01070         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
01071         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
01072         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
01073         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
01074         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_)\};\par
01075     {\cf19 return} ValuesIn(array);\par
01076   \}\par
01077 \par
01078  {\cf17 private}:\par
01079   {\cf20 // No implementation - assignment is unsupported.}\par
01080   {\cf18 void} operator=({\cf17 const} ValueArray26& other);\par
01081 \par
01082   {\cf17 const} T1 v1_;\par
01083   {\cf17 const} T2 v2_;\par
01084   {\cf17 const} T3 v3_;\par
01085   {\cf17 const} T4 v4_;\par
01086   {\cf17 const} T5 v5_;\par
01087   {\cf17 const} T6 v6_;\par
01088   {\cf17 const} T7 v7_;\par
01089   {\cf17 const} T8 v8_;\par
01090   {\cf17 const} T9 v9_;\par
01091   {\cf17 const} T10 v10_;\par
01092   {\cf17 const} T11 v11_;\par
01093   {\cf17 const} T12 v12_;\par
01094   {\cf17 const} T13 v13_;\par
01095   {\cf17 const} T14 v14_;\par
01096   {\cf17 const} T15 v15_;\par
01097   {\cf17 const} T16 v16_;\par
01098   {\cf17 const} T17 v17_;\par
01099   {\cf17 const} T18 v18_;\par
01100   {\cf17 const} T19 v19_;\par
01101   {\cf17 const} T20 v20_;\par
01102   {\cf17 const} T21 v21_;\par
01103   {\cf17 const} T22 v22_;\par
01104   {\cf17 const} T23 v23_;\par
01105   {\cf17 const} T24 v24_;\par
01106   {\cf17 const} T25 v25_;\par
01107   {\cf17 const} T26 v26_;\par
01108 \};\par
01109 \par
01110 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01111     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01112     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01113     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01114     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01115     {\cf17 typename} T26, {\cf17 typename} T27>\par
01116 {\cf17 class }ValueArray27 \{\par
01117  {\cf17 public}:\par
01118   ValueArray27(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
01119       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
01120       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
01121       T26 v26, T27 v27) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\par
01122       v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),\par
01123       v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),\par
01124       v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),\par
01125       v26_(v26), v27_(v27) \{\}\par
01126 \par
01127   {\cf17 template} <{\cf17 typename} T>\par
01128   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
01129     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
01130         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
01131         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
01132         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
01133         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
01134         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
01135         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
01136         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
01137         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
01138         {\cf17 static_cast<}T{\cf17 >}(v27_)\};\par
01139     {\cf19 return} ValuesIn(array);\par
01140   \}\par
01141 \par
01142  {\cf17 private}:\par
01143   {\cf20 // No implementation - assignment is unsupported.}\par
01144   {\cf18 void} operator=({\cf17 const} ValueArray27& other);\par
01145 \par
01146   {\cf17 const} T1 v1_;\par
01147   {\cf17 const} T2 v2_;\par
01148   {\cf17 const} T3 v3_;\par
01149   {\cf17 const} T4 v4_;\par
01150   {\cf17 const} T5 v5_;\par
01151   {\cf17 const} T6 v6_;\par
01152   {\cf17 const} T7 v7_;\par
01153   {\cf17 const} T8 v8_;\par
01154   {\cf17 const} T9 v9_;\par
01155   {\cf17 const} T10 v10_;\par
01156   {\cf17 const} T11 v11_;\par
01157   {\cf17 const} T12 v12_;\par
01158   {\cf17 const} T13 v13_;\par
01159   {\cf17 const} T14 v14_;\par
01160   {\cf17 const} T15 v15_;\par
01161   {\cf17 const} T16 v16_;\par
01162   {\cf17 const} T17 v17_;\par
01163   {\cf17 const} T18 v18_;\par
01164   {\cf17 const} T19 v19_;\par
01165   {\cf17 const} T20 v20_;\par
01166   {\cf17 const} T21 v21_;\par
01167   {\cf17 const} T22 v22_;\par
01168   {\cf17 const} T23 v23_;\par
01169   {\cf17 const} T24 v24_;\par
01170   {\cf17 const} T25 v25_;\par
01171   {\cf17 const} T26 v26_;\par
01172   {\cf17 const} T27 v27_;\par
01173 \};\par
01174 \par
01175 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01176     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01177     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01178     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01179     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01180     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28>\par
01181 {\cf17 class }ValueArray28 \{\par
01182  {\cf17 public}:\par
01183   ValueArray28(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
01184       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
01185       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
01186       T26 v26, T27 v27, T28 v28) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\par
01187       v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),\par
01188       v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),\par
01189       v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),\par
01190       v25_(v25), v26_(v26), v27_(v27), v28_(v28) \{\}\par
01191 \par
01192   {\cf17 template} <{\cf17 typename} T>\par
01193   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
01194     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
01195         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
01196         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
01197         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
01198         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
01199         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
01200         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
01201         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
01202         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
01203         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_)\};\par
01204     {\cf19 return} ValuesIn(array);\par
01205   \}\par
01206 \par
01207  {\cf17 private}:\par
01208   {\cf20 // No implementation - assignment is unsupported.}\par
01209   {\cf18 void} operator=({\cf17 const} ValueArray28& other);\par
01210 \par
01211   {\cf17 const} T1 v1_;\par
01212   {\cf17 const} T2 v2_;\par
01213   {\cf17 const} T3 v3_;\par
01214   {\cf17 const} T4 v4_;\par
01215   {\cf17 const} T5 v5_;\par
01216   {\cf17 const} T6 v6_;\par
01217   {\cf17 const} T7 v7_;\par
01218   {\cf17 const} T8 v8_;\par
01219   {\cf17 const} T9 v9_;\par
01220   {\cf17 const} T10 v10_;\par
01221   {\cf17 const} T11 v11_;\par
01222   {\cf17 const} T12 v12_;\par
01223   {\cf17 const} T13 v13_;\par
01224   {\cf17 const} T14 v14_;\par
01225   {\cf17 const} T15 v15_;\par
01226   {\cf17 const} T16 v16_;\par
01227   {\cf17 const} T17 v17_;\par
01228   {\cf17 const} T18 v18_;\par
01229   {\cf17 const} T19 v19_;\par
01230   {\cf17 const} T20 v20_;\par
01231   {\cf17 const} T21 v21_;\par
01232   {\cf17 const} T22 v22_;\par
01233   {\cf17 const} T23 v23_;\par
01234   {\cf17 const} T24 v24_;\par
01235   {\cf17 const} T25 v25_;\par
01236   {\cf17 const} T26 v26_;\par
01237   {\cf17 const} T27 v27_;\par
01238   {\cf17 const} T28 v28_;\par
01239 \};\par
01240 \par
01241 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01242     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01243     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01244     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01245     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01246     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29>\par
01247 {\cf17 class }ValueArray29 \{\par
01248  {\cf17 public}:\par
01249   ValueArray29(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
01250       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
01251       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
01252       T26 v26, T27 v27, T28 v28, T29 v29) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\par
01253       v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\par
01254       v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),\par
01255       v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),\par
01256       v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29) \{\}\par
01257 \par
01258   {\cf17 template} <{\cf17 typename} T>\par
01259   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
01260     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
01261         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
01262         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
01263         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
01264         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
01265         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
01266         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
01267         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
01268         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
01269         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_)\};\par
01270     {\cf19 return} ValuesIn(array);\par
01271   \}\par
01272 \par
01273  {\cf17 private}:\par
01274   {\cf20 // No implementation - assignment is unsupported.}\par
01275   {\cf18 void} operator=({\cf17 const} ValueArray29& other);\par
01276 \par
01277   {\cf17 const} T1 v1_;\par
01278   {\cf17 const} T2 v2_;\par
01279   {\cf17 const} T3 v3_;\par
01280   {\cf17 const} T4 v4_;\par
01281   {\cf17 const} T5 v5_;\par
01282   {\cf17 const} T6 v6_;\par
01283   {\cf17 const} T7 v7_;\par
01284   {\cf17 const} T8 v8_;\par
01285   {\cf17 const} T9 v9_;\par
01286   {\cf17 const} T10 v10_;\par
01287   {\cf17 const} T11 v11_;\par
01288   {\cf17 const} T12 v12_;\par
01289   {\cf17 const} T13 v13_;\par
01290   {\cf17 const} T14 v14_;\par
01291   {\cf17 const} T15 v15_;\par
01292   {\cf17 const} T16 v16_;\par
01293   {\cf17 const} T17 v17_;\par
01294   {\cf17 const} T18 v18_;\par
01295   {\cf17 const} T19 v19_;\par
01296   {\cf17 const} T20 v20_;\par
01297   {\cf17 const} T21 v21_;\par
01298   {\cf17 const} T22 v22_;\par
01299   {\cf17 const} T23 v23_;\par
01300   {\cf17 const} T24 v24_;\par
01301   {\cf17 const} T25 v25_;\par
01302   {\cf17 const} T26 v26_;\par
01303   {\cf17 const} T27 v27_;\par
01304   {\cf17 const} T28 v28_;\par
01305   {\cf17 const} T29 v29_;\par
01306 \};\par
01307 \par
01308 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01309     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01310     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01311     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01312     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01313     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30>\par
01314 {\cf17 class }ValueArray30 \{\par
01315  {\cf17 public}:\par
01316   ValueArray30(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
01317       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
01318       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
01319       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30) : v1_(v1), v2_(v2), v3_(v3),\par
01320       v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\par
01321       v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\par
01322       v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\par
01323       v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\par
01324       v29_(v29), v30_(v30) \{\}\par
01325 \par
01326   {\cf17 template} <{\cf17 typename} T>\par
01327   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
01328     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
01329         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
01330         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
01331         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
01332         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
01333         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
01334         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
01335         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
01336         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
01337         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
01338         {\cf17 static_cast<}T{\cf17 >}(v30_)\};\par
01339     {\cf19 return} ValuesIn(array);\par
01340   \}\par
01341 \par
01342  {\cf17 private}:\par
01343   {\cf20 // No implementation - assignment is unsupported.}\par
01344   {\cf18 void} operator=({\cf17 const} ValueArray30& other);\par
01345 \par
01346   {\cf17 const} T1 v1_;\par
01347   {\cf17 const} T2 v2_;\par
01348   {\cf17 const} T3 v3_;\par
01349   {\cf17 const} T4 v4_;\par
01350   {\cf17 const} T5 v5_;\par
01351   {\cf17 const} T6 v6_;\par
01352   {\cf17 const} T7 v7_;\par
01353   {\cf17 const} T8 v8_;\par
01354   {\cf17 const} T9 v9_;\par
01355   {\cf17 const} T10 v10_;\par
01356   {\cf17 const} T11 v11_;\par
01357   {\cf17 const} T12 v12_;\par
01358   {\cf17 const} T13 v13_;\par
01359   {\cf17 const} T14 v14_;\par
01360   {\cf17 const} T15 v15_;\par
01361   {\cf17 const} T16 v16_;\par
01362   {\cf17 const} T17 v17_;\par
01363   {\cf17 const} T18 v18_;\par
01364   {\cf17 const} T19 v19_;\par
01365   {\cf17 const} T20 v20_;\par
01366   {\cf17 const} T21 v21_;\par
01367   {\cf17 const} T22 v22_;\par
01368   {\cf17 const} T23 v23_;\par
01369   {\cf17 const} T24 v24_;\par
01370   {\cf17 const} T25 v25_;\par
01371   {\cf17 const} T26 v26_;\par
01372   {\cf17 const} T27 v27_;\par
01373   {\cf17 const} T28 v28_;\par
01374   {\cf17 const} T29 v29_;\par
01375   {\cf17 const} T30 v30_;\par
01376 \};\par
01377 \par
01378 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01379     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01380     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01381     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01382     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01383     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01384     {\cf17 typename} T31>\par
01385 {\cf17 class }ValueArray31 \{\par
01386  {\cf17 public}:\par
01387   ValueArray31(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
01388       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
01389       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
01390       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31) : v1_(v1), v2_(v2),\par
01391       v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\par
01392       v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\par
01393       v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\par
01394       v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\par
01395       v29_(v29), v30_(v30), v31_(v31) \{\}\par
01396 \par
01397   {\cf17 template} <{\cf17 typename} T>\par
01398   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
01399     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
01400         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
01401         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
01402         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
01403         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
01404         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
01405         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
01406         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
01407         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
01408         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
01409         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_)\};\par
01410     {\cf19 return} ValuesIn(array);\par
01411   \}\par
01412 \par
01413  {\cf17 private}:\par
01414   {\cf20 // No implementation - assignment is unsupported.}\par
01415   {\cf18 void} operator=({\cf17 const} ValueArray31& other);\par
01416 \par
01417   {\cf17 const} T1 v1_;\par
01418   {\cf17 const} T2 v2_;\par
01419   {\cf17 const} T3 v3_;\par
01420   {\cf17 const} T4 v4_;\par
01421   {\cf17 const} T5 v5_;\par
01422   {\cf17 const} T6 v6_;\par
01423   {\cf17 const} T7 v7_;\par
01424   {\cf17 const} T8 v8_;\par
01425   {\cf17 const} T9 v9_;\par
01426   {\cf17 const} T10 v10_;\par
01427   {\cf17 const} T11 v11_;\par
01428   {\cf17 const} T12 v12_;\par
01429   {\cf17 const} T13 v13_;\par
01430   {\cf17 const} T14 v14_;\par
01431   {\cf17 const} T15 v15_;\par
01432   {\cf17 const} T16 v16_;\par
01433   {\cf17 const} T17 v17_;\par
01434   {\cf17 const} T18 v18_;\par
01435   {\cf17 const} T19 v19_;\par
01436   {\cf17 const} T20 v20_;\par
01437   {\cf17 const} T21 v21_;\par
01438   {\cf17 const} T22 v22_;\par
01439   {\cf17 const} T23 v23_;\par
01440   {\cf17 const} T24 v24_;\par
01441   {\cf17 const} T25 v25_;\par
01442   {\cf17 const} T26 v26_;\par
01443   {\cf17 const} T27 v27_;\par
01444   {\cf17 const} T28 v28_;\par
01445   {\cf17 const} T29 v29_;\par
01446   {\cf17 const} T30 v30_;\par
01447   {\cf17 const} T31 v31_;\par
01448 \};\par
01449 \par
01450 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01451     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01452     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01453     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01454     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01455     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01456     {\cf17 typename} T31, {\cf17 typename} T32>\par
01457 {\cf17 class }ValueArray32 \{\par
01458  {\cf17 public}:\par
01459   ValueArray32(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
01460       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
01461       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
01462       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32) : v1_(v1),\par
01463       v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\par
01464       v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\par
01465       v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),\par
01466       v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),\par
01467       v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32) \{\}\par
01468 \par
01469   {\cf17 template} <{\cf17 typename} T>\par
01470   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
01471     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
01472         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
01473         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
01474         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
01475         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
01476         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
01477         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
01478         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
01479         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
01480         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
01481         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_)\};\par
01482     {\cf19 return} ValuesIn(array);\par
01483   \}\par
01484 \par
01485  {\cf17 private}:\par
01486   {\cf20 // No implementation - assignment is unsupported.}\par
01487   {\cf18 void} operator=({\cf17 const} ValueArray32& other);\par
01488 \par
01489   {\cf17 const} T1 v1_;\par
01490   {\cf17 const} T2 v2_;\par
01491   {\cf17 const} T3 v3_;\par
01492   {\cf17 const} T4 v4_;\par
01493   {\cf17 const} T5 v5_;\par
01494   {\cf17 const} T6 v6_;\par
01495   {\cf17 const} T7 v7_;\par
01496   {\cf17 const} T8 v8_;\par
01497   {\cf17 const} T9 v9_;\par
01498   {\cf17 const} T10 v10_;\par
01499   {\cf17 const} T11 v11_;\par
01500   {\cf17 const} T12 v12_;\par
01501   {\cf17 const} T13 v13_;\par
01502   {\cf17 const} T14 v14_;\par
01503   {\cf17 const} T15 v15_;\par
01504   {\cf17 const} T16 v16_;\par
01505   {\cf17 const} T17 v17_;\par
01506   {\cf17 const} T18 v18_;\par
01507   {\cf17 const} T19 v19_;\par
01508   {\cf17 const} T20 v20_;\par
01509   {\cf17 const} T21 v21_;\par
01510   {\cf17 const} T22 v22_;\par
01511   {\cf17 const} T23 v23_;\par
01512   {\cf17 const} T24 v24_;\par
01513   {\cf17 const} T25 v25_;\par
01514   {\cf17 const} T26 v26_;\par
01515   {\cf17 const} T27 v27_;\par
01516   {\cf17 const} T28 v28_;\par
01517   {\cf17 const} T29 v29_;\par
01518   {\cf17 const} T30 v30_;\par
01519   {\cf17 const} T31 v31_;\par
01520   {\cf17 const} T32 v32_;\par
01521 \};\par
01522 \par
01523 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01524     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01525     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01526     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01527     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01528     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01529     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33>\par
01530 {\cf17 class }ValueArray33 \{\par
01531  {\cf17 public}:\par
01532   ValueArray33(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
01533       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
01534       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
01535       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32,\par
01536       T33 v33) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\par
01537       v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\par
01538       v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\par
01539       v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\par
01540       v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\par
01541       v33_(v33) \{\}\par
01542 \par
01543   {\cf17 template} <{\cf17 typename} T>\par
01544   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
01545     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
01546         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
01547         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
01548         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
01549         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
01550         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
01551         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
01552         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
01553         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
01554         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
01555         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
01556         {\cf17 static_cast<}T{\cf17 >}(v33_)\};\par
01557     {\cf19 return} ValuesIn(array);\par
01558   \}\par
01559 \par
01560  {\cf17 private}:\par
01561   {\cf20 // No implementation - assignment is unsupported.}\par
01562   {\cf18 void} operator=({\cf17 const} ValueArray33& other);\par
01563 \par
01564   {\cf17 const} T1 v1_;\par
01565   {\cf17 const} T2 v2_;\par
01566   {\cf17 const} T3 v3_;\par
01567   {\cf17 const} T4 v4_;\par
01568   {\cf17 const} T5 v5_;\par
01569   {\cf17 const} T6 v6_;\par
01570   {\cf17 const} T7 v7_;\par
01571   {\cf17 const} T8 v8_;\par
01572   {\cf17 const} T9 v9_;\par
01573   {\cf17 const} T10 v10_;\par
01574   {\cf17 const} T11 v11_;\par
01575   {\cf17 const} T12 v12_;\par
01576   {\cf17 const} T13 v13_;\par
01577   {\cf17 const} T14 v14_;\par
01578   {\cf17 const} T15 v15_;\par
01579   {\cf17 const} T16 v16_;\par
01580   {\cf17 const} T17 v17_;\par
01581   {\cf17 const} T18 v18_;\par
01582   {\cf17 const} T19 v19_;\par
01583   {\cf17 const} T20 v20_;\par
01584   {\cf17 const} T21 v21_;\par
01585   {\cf17 const} T22 v22_;\par
01586   {\cf17 const} T23 v23_;\par
01587   {\cf17 const} T24 v24_;\par
01588   {\cf17 const} T25 v25_;\par
01589   {\cf17 const} T26 v26_;\par
01590   {\cf17 const} T27 v27_;\par
01591   {\cf17 const} T28 v28_;\par
01592   {\cf17 const} T29 v29_;\par
01593   {\cf17 const} T30 v30_;\par
01594   {\cf17 const} T31 v31_;\par
01595   {\cf17 const} T32 v32_;\par
01596   {\cf17 const} T33 v33_;\par
01597 \};\par
01598 \par
01599 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01600     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01601     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01602     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01603     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01604     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01605     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34>\par
01606 {\cf17 class }ValueArray34 \{\par
01607  {\cf17 public}:\par
01608   ValueArray34(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
01609       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
01610       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
01611       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
01612       T34 v34) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\par
01613       v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\par
01614       v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\par
01615       v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\par
01616       v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\par
01617       v33_(v33), v34_(v34) \{\}\par
01618 \par
01619   {\cf17 template} <{\cf17 typename} T>\par
01620   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
01621     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
01622         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
01623         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
01624         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
01625         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
01626         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
01627         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
01628         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
01629         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
01630         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
01631         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
01632         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_)\};\par
01633     {\cf19 return} ValuesIn(array);\par
01634   \}\par
01635 \par
01636  {\cf17 private}:\par
01637   {\cf20 // No implementation - assignment is unsupported.}\par
01638   {\cf18 void} operator=({\cf17 const} ValueArray34& other);\par
01639 \par
01640   {\cf17 const} T1 v1_;\par
01641   {\cf17 const} T2 v2_;\par
01642   {\cf17 const} T3 v3_;\par
01643   {\cf17 const} T4 v4_;\par
01644   {\cf17 const} T5 v5_;\par
01645   {\cf17 const} T6 v6_;\par
01646   {\cf17 const} T7 v7_;\par
01647   {\cf17 const} T8 v8_;\par
01648   {\cf17 const} T9 v9_;\par
01649   {\cf17 const} T10 v10_;\par
01650   {\cf17 const} T11 v11_;\par
01651   {\cf17 const} T12 v12_;\par
01652   {\cf17 const} T13 v13_;\par
01653   {\cf17 const} T14 v14_;\par
01654   {\cf17 const} T15 v15_;\par
01655   {\cf17 const} T16 v16_;\par
01656   {\cf17 const} T17 v17_;\par
01657   {\cf17 const} T18 v18_;\par
01658   {\cf17 const} T19 v19_;\par
01659   {\cf17 const} T20 v20_;\par
01660   {\cf17 const} T21 v21_;\par
01661   {\cf17 const} T22 v22_;\par
01662   {\cf17 const} T23 v23_;\par
01663   {\cf17 const} T24 v24_;\par
01664   {\cf17 const} T25 v25_;\par
01665   {\cf17 const} T26 v26_;\par
01666   {\cf17 const} T27 v27_;\par
01667   {\cf17 const} T28 v28_;\par
01668   {\cf17 const} T29 v29_;\par
01669   {\cf17 const} T30 v30_;\par
01670   {\cf17 const} T31 v31_;\par
01671   {\cf17 const} T32 v32_;\par
01672   {\cf17 const} T33 v33_;\par
01673   {\cf17 const} T34 v34_;\par
01674 \};\par
01675 \par
01676 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01677     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01678     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01679     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01680     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01681     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01682     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35>\par
01683 {\cf17 class }ValueArray35 \{\par
01684  {\cf17 public}:\par
01685   ValueArray35(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
01686       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
01687       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
01688       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
01689       T34 v34, T35 v35) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\par
01690       v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),\par
01691       v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),\par
01692       v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),\par
01693       v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31),\par
01694       v32_(v32), v33_(v33), v34_(v34), v35_(v35) \{\}\par
01695 \par
01696   {\cf17 template} <{\cf17 typename} T>\par
01697   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
01698     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
01699         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
01700         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
01701         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
01702         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
01703         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
01704         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
01705         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
01706         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
01707         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
01708         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
01709         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_)\};\par
01710     {\cf19 return} ValuesIn(array);\par
01711   \}\par
01712 \par
01713  {\cf17 private}:\par
01714   {\cf20 // No implementation - assignment is unsupported.}\par
01715   {\cf18 void} operator=({\cf17 const} ValueArray35& other);\par
01716 \par
01717   {\cf17 const} T1 v1_;\par
01718   {\cf17 const} T2 v2_;\par
01719   {\cf17 const} T3 v3_;\par
01720   {\cf17 const} T4 v4_;\par
01721   {\cf17 const} T5 v5_;\par
01722   {\cf17 const} T6 v6_;\par
01723   {\cf17 const} T7 v7_;\par
01724   {\cf17 const} T8 v8_;\par
01725   {\cf17 const} T9 v9_;\par
01726   {\cf17 const} T10 v10_;\par
01727   {\cf17 const} T11 v11_;\par
01728   {\cf17 const} T12 v12_;\par
01729   {\cf17 const} T13 v13_;\par
01730   {\cf17 const} T14 v14_;\par
01731   {\cf17 const} T15 v15_;\par
01732   {\cf17 const} T16 v16_;\par
01733   {\cf17 const} T17 v17_;\par
01734   {\cf17 const} T18 v18_;\par
01735   {\cf17 const} T19 v19_;\par
01736   {\cf17 const} T20 v20_;\par
01737   {\cf17 const} T21 v21_;\par
01738   {\cf17 const} T22 v22_;\par
01739   {\cf17 const} T23 v23_;\par
01740   {\cf17 const} T24 v24_;\par
01741   {\cf17 const} T25 v25_;\par
01742   {\cf17 const} T26 v26_;\par
01743   {\cf17 const} T27 v27_;\par
01744   {\cf17 const} T28 v28_;\par
01745   {\cf17 const} T29 v29_;\par
01746   {\cf17 const} T30 v30_;\par
01747   {\cf17 const} T31 v31_;\par
01748   {\cf17 const} T32 v32_;\par
01749   {\cf17 const} T33 v33_;\par
01750   {\cf17 const} T34 v34_;\par
01751   {\cf17 const} T35 v35_;\par
01752 \};\par
01753 \par
01754 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01755     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01756     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01757     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01758     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01759     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01760     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01761     {\cf17 typename} T36>\par
01762 {\cf17 class }ValueArray36 \{\par
01763  {\cf17 public}:\par
01764   ValueArray36(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
01765       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
01766       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
01767       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
01768       T34 v34, T35 v35, T36 v36) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\par
01769       v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),\par
01770       v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),\par
01771       v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),\par
01772       v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30),\par
01773       v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36) \{\}\par
01774 \par
01775   {\cf17 template} <{\cf17 typename} T>\par
01776   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
01777     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
01778         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
01779         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
01780         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
01781         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
01782         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
01783         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
01784         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
01785         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
01786         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
01787         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
01788         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
01789         {\cf17 static_cast<}T{\cf17 >}(v36_)\};\par
01790     {\cf19 return} ValuesIn(array);\par
01791   \}\par
01792 \par
01793  {\cf17 private}:\par
01794   {\cf20 // No implementation - assignment is unsupported.}\par
01795   {\cf18 void} operator=({\cf17 const} ValueArray36& other);\par
01796 \par
01797   {\cf17 const} T1 v1_;\par
01798   {\cf17 const} T2 v2_;\par
01799   {\cf17 const} T3 v3_;\par
01800   {\cf17 const} T4 v4_;\par
01801   {\cf17 const} T5 v5_;\par
01802   {\cf17 const} T6 v6_;\par
01803   {\cf17 const} T7 v7_;\par
01804   {\cf17 const} T8 v8_;\par
01805   {\cf17 const} T9 v9_;\par
01806   {\cf17 const} T10 v10_;\par
01807   {\cf17 const} T11 v11_;\par
01808   {\cf17 const} T12 v12_;\par
01809   {\cf17 const} T13 v13_;\par
01810   {\cf17 const} T14 v14_;\par
01811   {\cf17 const} T15 v15_;\par
01812   {\cf17 const} T16 v16_;\par
01813   {\cf17 const} T17 v17_;\par
01814   {\cf17 const} T18 v18_;\par
01815   {\cf17 const} T19 v19_;\par
01816   {\cf17 const} T20 v20_;\par
01817   {\cf17 const} T21 v21_;\par
01818   {\cf17 const} T22 v22_;\par
01819   {\cf17 const} T23 v23_;\par
01820   {\cf17 const} T24 v24_;\par
01821   {\cf17 const} T25 v25_;\par
01822   {\cf17 const} T26 v26_;\par
01823   {\cf17 const} T27 v27_;\par
01824   {\cf17 const} T28 v28_;\par
01825   {\cf17 const} T29 v29_;\par
01826   {\cf17 const} T30 v30_;\par
01827   {\cf17 const} T31 v31_;\par
01828   {\cf17 const} T32 v32_;\par
01829   {\cf17 const} T33 v33_;\par
01830   {\cf17 const} T34 v34_;\par
01831   {\cf17 const} T35 v35_;\par
01832   {\cf17 const} T36 v36_;\par
01833 \};\par
01834 \par
01835 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01836     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01837     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01838     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01839     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01840     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01841     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01842     {\cf17 typename} T36, {\cf17 typename} T37>\par
01843 {\cf17 class }ValueArray37 \{\par
01844  {\cf17 public}:\par
01845   ValueArray37(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
01846       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
01847       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
01848       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
01849       T34 v34, T35 v35, T36 v36, T37 v37) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\par
01850       v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\par
01851       v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),\par
01852       v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),\par
01853       v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29),\par
01854       v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35),\par
01855       v36_(v36), v37_(v37) \{\}\par
01856 \par
01857   {\cf17 template} <{\cf17 typename} T>\par
01858   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
01859     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
01860         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
01861         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
01862         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
01863         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
01864         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
01865         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
01866         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
01867         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
01868         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
01869         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
01870         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
01871         {\cf17 static_cast<}T{\cf17 >}(v36_), {\cf17 static_cast<}T{\cf17 >}(v37_)\};\par
01872     {\cf19 return} ValuesIn(array);\par
01873   \}\par
01874 \par
01875  {\cf17 private}:\par
01876   {\cf20 // No implementation - assignment is unsupported.}\par
01877   {\cf18 void} operator=({\cf17 const} ValueArray37& other);\par
01878 \par
01879   {\cf17 const} T1 v1_;\par
01880   {\cf17 const} T2 v2_;\par
01881   {\cf17 const} T3 v3_;\par
01882   {\cf17 const} T4 v4_;\par
01883   {\cf17 const} T5 v5_;\par
01884   {\cf17 const} T6 v6_;\par
01885   {\cf17 const} T7 v7_;\par
01886   {\cf17 const} T8 v8_;\par
01887   {\cf17 const} T9 v9_;\par
01888   {\cf17 const} T10 v10_;\par
01889   {\cf17 const} T11 v11_;\par
01890   {\cf17 const} T12 v12_;\par
01891   {\cf17 const} T13 v13_;\par
01892   {\cf17 const} T14 v14_;\par
01893   {\cf17 const} T15 v15_;\par
01894   {\cf17 const} T16 v16_;\par
01895   {\cf17 const} T17 v17_;\par
01896   {\cf17 const} T18 v18_;\par
01897   {\cf17 const} T19 v19_;\par
01898   {\cf17 const} T20 v20_;\par
01899   {\cf17 const} T21 v21_;\par
01900   {\cf17 const} T22 v22_;\par
01901   {\cf17 const} T23 v23_;\par
01902   {\cf17 const} T24 v24_;\par
01903   {\cf17 const} T25 v25_;\par
01904   {\cf17 const} T26 v26_;\par
01905   {\cf17 const} T27 v27_;\par
01906   {\cf17 const} T28 v28_;\par
01907   {\cf17 const} T29 v29_;\par
01908   {\cf17 const} T30 v30_;\par
01909   {\cf17 const} T31 v31_;\par
01910   {\cf17 const} T32 v32_;\par
01911   {\cf17 const} T33 v33_;\par
01912   {\cf17 const} T34 v34_;\par
01913   {\cf17 const} T35 v35_;\par
01914   {\cf17 const} T36 v36_;\par
01915   {\cf17 const} T37 v37_;\par
01916 \};\par
01917 \par
01918 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01919     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01920     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01921     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01922     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01923     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01924     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01925     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38>\par
01926 {\cf17 class }ValueArray38 \{\par
01927  {\cf17 public}:\par
01928   ValueArray38(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
01929       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
01930       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
01931       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
01932       T34 v34, T35 v35, T36 v36, T37 v37, T38 v38) : v1_(v1), v2_(v2), v3_(v3),\par
01933       v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\par
01934       v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\par
01935       v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\par
01936       v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\par
01937       v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),\par
01938       v35_(v35), v36_(v36), v37_(v37), v38_(v38) \{\}\par
01939 \par
01940   {\cf17 template} <{\cf17 typename} T>\par
01941   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
01942     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
01943         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
01944         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
01945         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
01946         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
01947         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
01948         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
01949         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
01950         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
01951         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
01952         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
01953         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
01954         {\cf17 static_cast<}T{\cf17 >}(v36_), {\cf17 static_cast<}T{\cf17 >}(v37_), {\cf17 static_cast<}T{\cf17 >}(v38_)\};\par
01955     {\cf19 return} ValuesIn(array);\par
01956   \}\par
01957 \par
01958  {\cf17 private}:\par
01959   {\cf20 // No implementation - assignment is unsupported.}\par
01960   {\cf18 void} operator=({\cf17 const} ValueArray38& other);\par
01961 \par
01962   {\cf17 const} T1 v1_;\par
01963   {\cf17 const} T2 v2_;\par
01964   {\cf17 const} T3 v3_;\par
01965   {\cf17 const} T4 v4_;\par
01966   {\cf17 const} T5 v5_;\par
01967   {\cf17 const} T6 v6_;\par
01968   {\cf17 const} T7 v7_;\par
01969   {\cf17 const} T8 v8_;\par
01970   {\cf17 const} T9 v9_;\par
01971   {\cf17 const} T10 v10_;\par
01972   {\cf17 const} T11 v11_;\par
01973   {\cf17 const} T12 v12_;\par
01974   {\cf17 const} T13 v13_;\par
01975   {\cf17 const} T14 v14_;\par
01976   {\cf17 const} T15 v15_;\par
01977   {\cf17 const} T16 v16_;\par
01978   {\cf17 const} T17 v17_;\par
01979   {\cf17 const} T18 v18_;\par
01980   {\cf17 const} T19 v19_;\par
01981   {\cf17 const} T20 v20_;\par
01982   {\cf17 const} T21 v21_;\par
01983   {\cf17 const} T22 v22_;\par
01984   {\cf17 const} T23 v23_;\par
01985   {\cf17 const} T24 v24_;\par
01986   {\cf17 const} T25 v25_;\par
01987   {\cf17 const} T26 v26_;\par
01988   {\cf17 const} T27 v27_;\par
01989   {\cf17 const} T28 v28_;\par
01990   {\cf17 const} T29 v29_;\par
01991   {\cf17 const} T30 v30_;\par
01992   {\cf17 const} T31 v31_;\par
01993   {\cf17 const} T32 v32_;\par
01994   {\cf17 const} T33 v33_;\par
01995   {\cf17 const} T34 v34_;\par
01996   {\cf17 const} T35 v35_;\par
01997   {\cf17 const} T36 v36_;\par
01998   {\cf17 const} T37 v37_;\par
01999   {\cf17 const} T38 v38_;\par
02000 \};\par
02001 \par
02002 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
02003     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
02004     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
02005     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
02006     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
02007     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
02008     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
02009     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39>\par
02010 {\cf17 class }ValueArray39 \{\par
02011  {\cf17 public}:\par
02012   ValueArray39(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
02013       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
02014       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
02015       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
02016       T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39) : v1_(v1), v2_(v2),\par
02017       v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\par
02018       v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\par
02019       v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\par
02020       v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\par
02021       v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),\par
02022       v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39) \{\}\par
02023 \par
02024   {\cf17 template} <{\cf17 typename} T>\par
02025   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
02026     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
02027         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
02028         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
02029         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
02030         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
02031         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
02032         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
02033         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
02034         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
02035         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
02036         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
02037         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
02038         {\cf17 static_cast<}T{\cf17 >}(v36_), {\cf17 static_cast<}T{\cf17 >}(v37_), {\cf17 static_cast<}T{\cf17 >}(v38_),\par
02039         {\cf17 static_cast<}T{\cf17 >}(v39_)\};\par
02040     {\cf19 return} ValuesIn(array);\par
02041   \}\par
02042 \par
02043  {\cf17 private}:\par
02044   {\cf20 // No implementation - assignment is unsupported.}\par
02045   {\cf18 void} operator=({\cf17 const} ValueArray39& other);\par
02046 \par
02047   {\cf17 const} T1 v1_;\par
02048   {\cf17 const} T2 v2_;\par
02049   {\cf17 const} T3 v3_;\par
02050   {\cf17 const} T4 v4_;\par
02051   {\cf17 const} T5 v5_;\par
02052   {\cf17 const} T6 v6_;\par
02053   {\cf17 const} T7 v7_;\par
02054   {\cf17 const} T8 v8_;\par
02055   {\cf17 const} T9 v9_;\par
02056   {\cf17 const} T10 v10_;\par
02057   {\cf17 const} T11 v11_;\par
02058   {\cf17 const} T12 v12_;\par
02059   {\cf17 const} T13 v13_;\par
02060   {\cf17 const} T14 v14_;\par
02061   {\cf17 const} T15 v15_;\par
02062   {\cf17 const} T16 v16_;\par
02063   {\cf17 const} T17 v17_;\par
02064   {\cf17 const} T18 v18_;\par
02065   {\cf17 const} T19 v19_;\par
02066   {\cf17 const} T20 v20_;\par
02067   {\cf17 const} T21 v21_;\par
02068   {\cf17 const} T22 v22_;\par
02069   {\cf17 const} T23 v23_;\par
02070   {\cf17 const} T24 v24_;\par
02071   {\cf17 const} T25 v25_;\par
02072   {\cf17 const} T26 v26_;\par
02073   {\cf17 const} T27 v27_;\par
02074   {\cf17 const} T28 v28_;\par
02075   {\cf17 const} T29 v29_;\par
02076   {\cf17 const} T30 v30_;\par
02077   {\cf17 const} T31 v31_;\par
02078   {\cf17 const} T32 v32_;\par
02079   {\cf17 const} T33 v33_;\par
02080   {\cf17 const} T34 v34_;\par
02081   {\cf17 const} T35 v35_;\par
02082   {\cf17 const} T36 v36_;\par
02083   {\cf17 const} T37 v37_;\par
02084   {\cf17 const} T38 v38_;\par
02085   {\cf17 const} T39 v39_;\par
02086 \};\par
02087 \par
02088 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
02089     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
02090     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
02091     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
02092     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
02093     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
02094     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
02095     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40>\par
02096 {\cf17 class }ValueArray40 \{\par
02097  {\cf17 public}:\par
02098   ValueArray40(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
02099       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
02100       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
02101       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
02102       T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40) : v1_(v1),\par
02103       v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\par
02104       v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\par
02105       v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),\par
02106       v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),\par
02107       v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33),\par
02108       v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39),\par
02109       v40_(v40) \{\}\par
02110 \par
02111   {\cf17 template} <{\cf17 typename} T>\par
02112   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
02113     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
02114         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
02115         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
02116         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
02117         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
02118         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
02119         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
02120         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
02121         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
02122         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
02123         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
02124         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
02125         {\cf17 static_cast<}T{\cf17 >}(v36_), {\cf17 static_cast<}T{\cf17 >}(v37_), {\cf17 static_cast<}T{\cf17 >}(v38_),\par
02126         {\cf17 static_cast<}T{\cf17 >}(v39_), {\cf17 static_cast<}T{\cf17 >}(v40_)\};\par
02127     {\cf19 return} ValuesIn(array);\par
02128   \}\par
02129 \par
02130  {\cf17 private}:\par
02131   {\cf20 // No implementation - assignment is unsupported.}\par
02132   {\cf18 void} operator=({\cf17 const} ValueArray40& other);\par
02133 \par
02134   {\cf17 const} T1 v1_;\par
02135   {\cf17 const} T2 v2_;\par
02136   {\cf17 const} T3 v3_;\par
02137   {\cf17 const} T4 v4_;\par
02138   {\cf17 const} T5 v5_;\par
02139   {\cf17 const} T6 v6_;\par
02140   {\cf17 const} T7 v7_;\par
02141   {\cf17 const} T8 v8_;\par
02142   {\cf17 const} T9 v9_;\par
02143   {\cf17 const} T10 v10_;\par
02144   {\cf17 const} T11 v11_;\par
02145   {\cf17 const} T12 v12_;\par
02146   {\cf17 const} T13 v13_;\par
02147   {\cf17 const} T14 v14_;\par
02148   {\cf17 const} T15 v15_;\par
02149   {\cf17 const} T16 v16_;\par
02150   {\cf17 const} T17 v17_;\par
02151   {\cf17 const} T18 v18_;\par
02152   {\cf17 const} T19 v19_;\par
02153   {\cf17 const} T20 v20_;\par
02154   {\cf17 const} T21 v21_;\par
02155   {\cf17 const} T22 v22_;\par
02156   {\cf17 const} T23 v23_;\par
02157   {\cf17 const} T24 v24_;\par
02158   {\cf17 const} T25 v25_;\par
02159   {\cf17 const} T26 v26_;\par
02160   {\cf17 const} T27 v27_;\par
02161   {\cf17 const} T28 v28_;\par
02162   {\cf17 const} T29 v29_;\par
02163   {\cf17 const} T30 v30_;\par
02164   {\cf17 const} T31 v31_;\par
02165   {\cf17 const} T32 v32_;\par
02166   {\cf17 const} T33 v33_;\par
02167   {\cf17 const} T34 v34_;\par
02168   {\cf17 const} T35 v35_;\par
02169   {\cf17 const} T36 v36_;\par
02170   {\cf17 const} T37 v37_;\par
02171   {\cf17 const} T38 v38_;\par
02172   {\cf17 const} T39 v39_;\par
02173   {\cf17 const} T40 v40_;\par
02174 \};\par
02175 \par
02176 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
02177     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
02178     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
02179     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
02180     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
02181     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
02182     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
02183     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
02184     {\cf17 typename} T41>\par
02185 {\cf17 class }ValueArray41 \{\par
02186  {\cf17 public}:\par
02187   ValueArray41(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
02188       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
02189       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
02190       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
02191       T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40,\par
02192       T41 v41) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\par
02193       v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\par
02194       v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\par
02195       v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\par
02196       v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\par
02197       v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),\par
02198       v39_(v39), v40_(v40), v41_(v41) \{\}\par
02199 \par
02200   {\cf17 template} <{\cf17 typename} T>\par
02201   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
02202     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
02203         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
02204         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
02205         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
02206         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
02207         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
02208         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
02209         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
02210         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
02211         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
02212         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
02213         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
02214         {\cf17 static_cast<}T{\cf17 >}(v36_), {\cf17 static_cast<}T{\cf17 >}(v37_), {\cf17 static_cast<}T{\cf17 >}(v38_),\par
02215         {\cf17 static_cast<}T{\cf17 >}(v39_), {\cf17 static_cast<}T{\cf17 >}(v40_), {\cf17 static_cast<}T{\cf17 >}(v41_)\};\par
02216     {\cf19 return} ValuesIn(array);\par
02217   \}\par
02218 \par
02219  {\cf17 private}:\par
02220   {\cf20 // No implementation - assignment is unsupported.}\par
02221   {\cf18 void} operator=({\cf17 const} ValueArray41& other);\par
02222 \par
02223   {\cf17 const} T1 v1_;\par
02224   {\cf17 const} T2 v2_;\par
02225   {\cf17 const} T3 v3_;\par
02226   {\cf17 const} T4 v4_;\par
02227   {\cf17 const} T5 v5_;\par
02228   {\cf17 const} T6 v6_;\par
02229   {\cf17 const} T7 v7_;\par
02230   {\cf17 const} T8 v8_;\par
02231   {\cf17 const} T9 v9_;\par
02232   {\cf17 const} T10 v10_;\par
02233   {\cf17 const} T11 v11_;\par
02234   {\cf17 const} T12 v12_;\par
02235   {\cf17 const} T13 v13_;\par
02236   {\cf17 const} T14 v14_;\par
02237   {\cf17 const} T15 v15_;\par
02238   {\cf17 const} T16 v16_;\par
02239   {\cf17 const} T17 v17_;\par
02240   {\cf17 const} T18 v18_;\par
02241   {\cf17 const} T19 v19_;\par
02242   {\cf17 const} T20 v20_;\par
02243   {\cf17 const} T21 v21_;\par
02244   {\cf17 const} T22 v22_;\par
02245   {\cf17 const} T23 v23_;\par
02246   {\cf17 const} T24 v24_;\par
02247   {\cf17 const} T25 v25_;\par
02248   {\cf17 const} T26 v26_;\par
02249   {\cf17 const} T27 v27_;\par
02250   {\cf17 const} T28 v28_;\par
02251   {\cf17 const} T29 v29_;\par
02252   {\cf17 const} T30 v30_;\par
02253   {\cf17 const} T31 v31_;\par
02254   {\cf17 const} T32 v32_;\par
02255   {\cf17 const} T33 v33_;\par
02256   {\cf17 const} T34 v34_;\par
02257   {\cf17 const} T35 v35_;\par
02258   {\cf17 const} T36 v36_;\par
02259   {\cf17 const} T37 v37_;\par
02260   {\cf17 const} T38 v38_;\par
02261   {\cf17 const} T39 v39_;\par
02262   {\cf17 const} T40 v40_;\par
02263   {\cf17 const} T41 v41_;\par
02264 \};\par
02265 \par
02266 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
02267     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
02268     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
02269     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
02270     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
02271     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
02272     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
02273     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
02274     {\cf17 typename} T41, {\cf17 typename} T42>\par
02275 {\cf17 class }ValueArray42 \{\par
02276  {\cf17 public}:\par
02277   ValueArray42(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
02278       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
02279       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
02280       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
02281       T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\par
02282       T42 v42) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\par
02283       v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\par
02284       v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\par
02285       v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\par
02286       v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\par
02287       v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),\par
02288       v39_(v39), v40_(v40), v41_(v41), v42_(v42) \{\}\par
02289 \par
02290   {\cf17 template} <{\cf17 typename} T>\par
02291   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
02292     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
02293         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
02294         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
02295         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
02296         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
02297         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
02298         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
02299         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
02300         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
02301         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
02302         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
02303         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
02304         {\cf17 static_cast<}T{\cf17 >}(v36_), {\cf17 static_cast<}T{\cf17 >}(v37_), {\cf17 static_cast<}T{\cf17 >}(v38_),\par
02305         {\cf17 static_cast<}T{\cf17 >}(v39_), {\cf17 static_cast<}T{\cf17 >}(v40_), {\cf17 static_cast<}T{\cf17 >}(v41_),\par
02306         {\cf17 static_cast<}T{\cf17 >}(v42_)\};\par
02307     {\cf19 return} ValuesIn(array);\par
02308   \}\par
02309 \par
02310  {\cf17 private}:\par
02311   {\cf20 // No implementation - assignment is unsupported.}\par
02312   {\cf18 void} operator=({\cf17 const} ValueArray42& other);\par
02313 \par
02314   {\cf17 const} T1 v1_;\par
02315   {\cf17 const} T2 v2_;\par
02316   {\cf17 const} T3 v3_;\par
02317   {\cf17 const} T4 v4_;\par
02318   {\cf17 const} T5 v5_;\par
02319   {\cf17 const} T6 v6_;\par
02320   {\cf17 const} T7 v7_;\par
02321   {\cf17 const} T8 v8_;\par
02322   {\cf17 const} T9 v9_;\par
02323   {\cf17 const} T10 v10_;\par
02324   {\cf17 const} T11 v11_;\par
02325   {\cf17 const} T12 v12_;\par
02326   {\cf17 const} T13 v13_;\par
02327   {\cf17 const} T14 v14_;\par
02328   {\cf17 const} T15 v15_;\par
02329   {\cf17 const} T16 v16_;\par
02330   {\cf17 const} T17 v17_;\par
02331   {\cf17 const} T18 v18_;\par
02332   {\cf17 const} T19 v19_;\par
02333   {\cf17 const} T20 v20_;\par
02334   {\cf17 const} T21 v21_;\par
02335   {\cf17 const} T22 v22_;\par
02336   {\cf17 const} T23 v23_;\par
02337   {\cf17 const} T24 v24_;\par
02338   {\cf17 const} T25 v25_;\par
02339   {\cf17 const} T26 v26_;\par
02340   {\cf17 const} T27 v27_;\par
02341   {\cf17 const} T28 v28_;\par
02342   {\cf17 const} T29 v29_;\par
02343   {\cf17 const} T30 v30_;\par
02344   {\cf17 const} T31 v31_;\par
02345   {\cf17 const} T32 v32_;\par
02346   {\cf17 const} T33 v33_;\par
02347   {\cf17 const} T34 v34_;\par
02348   {\cf17 const} T35 v35_;\par
02349   {\cf17 const} T36 v36_;\par
02350   {\cf17 const} T37 v37_;\par
02351   {\cf17 const} T38 v38_;\par
02352   {\cf17 const} T39 v39_;\par
02353   {\cf17 const} T40 v40_;\par
02354   {\cf17 const} T41 v41_;\par
02355   {\cf17 const} T42 v42_;\par
02356 \};\par
02357 \par
02358 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
02359     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
02360     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
02361     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
02362     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
02363     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
02364     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
02365     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
02366     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43>\par
02367 {\cf17 class }ValueArray43 \{\par
02368  {\cf17 public}:\par
02369   ValueArray43(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
02370       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
02371       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
02372       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
02373       T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\par
02374       T42 v42, T43 v43) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\par
02375       v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),\par
02376       v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),\par
02377       v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),\par
02378       v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31),\par
02379       v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37),\par
02380       v38_(v38), v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43) \{\}\par
02381 \par
02382   {\cf17 template} <{\cf17 typename} T>\par
02383   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
02384     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
02385         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
02386         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
02387         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
02388         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
02389         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
02390         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
02391         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
02392         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
02393         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
02394         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
02395         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
02396         {\cf17 static_cast<}T{\cf17 >}(v36_), {\cf17 static_cast<}T{\cf17 >}(v37_), {\cf17 static_cast<}T{\cf17 >}(v38_),\par
02397         {\cf17 static_cast<}T{\cf17 >}(v39_), {\cf17 static_cast<}T{\cf17 >}(v40_), {\cf17 static_cast<}T{\cf17 >}(v41_),\par
02398         {\cf17 static_cast<}T{\cf17 >}(v42_), {\cf17 static_cast<}T{\cf17 >}(v43_)\};\par
02399     {\cf19 return} ValuesIn(array);\par
02400   \}\par
02401 \par
02402  {\cf17 private}:\par
02403   {\cf20 // No implementation - assignment is unsupported.}\par
02404   {\cf18 void} operator=({\cf17 const} ValueArray43& other);\par
02405 \par
02406   {\cf17 const} T1 v1_;\par
02407   {\cf17 const} T2 v2_;\par
02408   {\cf17 const} T3 v3_;\par
02409   {\cf17 const} T4 v4_;\par
02410   {\cf17 const} T5 v5_;\par
02411   {\cf17 const} T6 v6_;\par
02412   {\cf17 const} T7 v7_;\par
02413   {\cf17 const} T8 v8_;\par
02414   {\cf17 const} T9 v9_;\par
02415   {\cf17 const} T10 v10_;\par
02416   {\cf17 const} T11 v11_;\par
02417   {\cf17 const} T12 v12_;\par
02418   {\cf17 const} T13 v13_;\par
02419   {\cf17 const} T14 v14_;\par
02420   {\cf17 const} T15 v15_;\par
02421   {\cf17 const} T16 v16_;\par
02422   {\cf17 const} T17 v17_;\par
02423   {\cf17 const} T18 v18_;\par
02424   {\cf17 const} T19 v19_;\par
02425   {\cf17 const} T20 v20_;\par
02426   {\cf17 const} T21 v21_;\par
02427   {\cf17 const} T22 v22_;\par
02428   {\cf17 const} T23 v23_;\par
02429   {\cf17 const} T24 v24_;\par
02430   {\cf17 const} T25 v25_;\par
02431   {\cf17 const} T26 v26_;\par
02432   {\cf17 const} T27 v27_;\par
02433   {\cf17 const} T28 v28_;\par
02434   {\cf17 const} T29 v29_;\par
02435   {\cf17 const} T30 v30_;\par
02436   {\cf17 const} T31 v31_;\par
02437   {\cf17 const} T32 v32_;\par
02438   {\cf17 const} T33 v33_;\par
02439   {\cf17 const} T34 v34_;\par
02440   {\cf17 const} T35 v35_;\par
02441   {\cf17 const} T36 v36_;\par
02442   {\cf17 const} T37 v37_;\par
02443   {\cf17 const} T38 v38_;\par
02444   {\cf17 const} T39 v39_;\par
02445   {\cf17 const} T40 v40_;\par
02446   {\cf17 const} T41 v41_;\par
02447   {\cf17 const} T42 v42_;\par
02448   {\cf17 const} T43 v43_;\par
02449 \};\par
02450 \par
02451 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
02452     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
02453     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
02454     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
02455     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
02456     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
02457     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
02458     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
02459     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44>\par
02460 {\cf17 class }ValueArray44 \{\par
02461  {\cf17 public}:\par
02462   ValueArray44(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
02463       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
02464       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
02465       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
02466       T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\par
02467       T42 v42, T43 v43, T44 v44) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\par
02468       v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),\par
02469       v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),\par
02470       v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),\par
02471       v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30),\par
02472       v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36),\par
02473       v37_(v37), v38_(v38), v39_(v39), v40_(v40), v41_(v41), v42_(v42),\par
02474       v43_(v43), v44_(v44) \{\}\par
02475 \par
02476   {\cf17 template} <{\cf17 typename} T>\par
02477   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
02478     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
02479         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
02480         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
02481         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
02482         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
02483         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
02484         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
02485         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
02486         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
02487         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
02488         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
02489         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
02490         {\cf17 static_cast<}T{\cf17 >}(v36_), {\cf17 static_cast<}T{\cf17 >}(v37_), {\cf17 static_cast<}T{\cf17 >}(v38_),\par
02491         {\cf17 static_cast<}T{\cf17 >}(v39_), {\cf17 static_cast<}T{\cf17 >}(v40_), {\cf17 static_cast<}T{\cf17 >}(v41_),\par
02492         {\cf17 static_cast<}T{\cf17 >}(v42_), {\cf17 static_cast<}T{\cf17 >}(v43_), {\cf17 static_cast<}T{\cf17 >}(v44_)\};\par
02493     {\cf19 return} ValuesIn(array);\par
02494   \}\par
02495 \par
02496  {\cf17 private}:\par
02497   {\cf20 // No implementation - assignment is unsupported.}\par
02498   {\cf18 void} operator=({\cf17 const} ValueArray44& other);\par
02499 \par
02500   {\cf17 const} T1 v1_;\par
02501   {\cf17 const} T2 v2_;\par
02502   {\cf17 const} T3 v3_;\par
02503   {\cf17 const} T4 v4_;\par
02504   {\cf17 const} T5 v5_;\par
02505   {\cf17 const} T6 v6_;\par
02506   {\cf17 const} T7 v7_;\par
02507   {\cf17 const} T8 v8_;\par
02508   {\cf17 const} T9 v9_;\par
02509   {\cf17 const} T10 v10_;\par
02510   {\cf17 const} T11 v11_;\par
02511   {\cf17 const} T12 v12_;\par
02512   {\cf17 const} T13 v13_;\par
02513   {\cf17 const} T14 v14_;\par
02514   {\cf17 const} T15 v15_;\par
02515   {\cf17 const} T16 v16_;\par
02516   {\cf17 const} T17 v17_;\par
02517   {\cf17 const} T18 v18_;\par
02518   {\cf17 const} T19 v19_;\par
02519   {\cf17 const} T20 v20_;\par
02520   {\cf17 const} T21 v21_;\par
02521   {\cf17 const} T22 v22_;\par
02522   {\cf17 const} T23 v23_;\par
02523   {\cf17 const} T24 v24_;\par
02524   {\cf17 const} T25 v25_;\par
02525   {\cf17 const} T26 v26_;\par
02526   {\cf17 const} T27 v27_;\par
02527   {\cf17 const} T28 v28_;\par
02528   {\cf17 const} T29 v29_;\par
02529   {\cf17 const} T30 v30_;\par
02530   {\cf17 const} T31 v31_;\par
02531   {\cf17 const} T32 v32_;\par
02532   {\cf17 const} T33 v33_;\par
02533   {\cf17 const} T34 v34_;\par
02534   {\cf17 const} T35 v35_;\par
02535   {\cf17 const} T36 v36_;\par
02536   {\cf17 const} T37 v37_;\par
02537   {\cf17 const} T38 v38_;\par
02538   {\cf17 const} T39 v39_;\par
02539   {\cf17 const} T40 v40_;\par
02540   {\cf17 const} T41 v41_;\par
02541   {\cf17 const} T42 v42_;\par
02542   {\cf17 const} T43 v43_;\par
02543   {\cf17 const} T44 v44_;\par
02544 \};\par
02545 \par
02546 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
02547     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
02548     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
02549     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
02550     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
02551     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
02552     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
02553     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
02554     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45>\par
02555 {\cf17 class }ValueArray45 \{\par
02556  {\cf17 public}:\par
02557   ValueArray45(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
02558       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
02559       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
02560       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
02561       T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\par
02562       T42 v42, T43 v43, T44 v44, T45 v45) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\par
02563       v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\par
02564       v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),\par
02565       v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),\par
02566       v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29),\par
02567       v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35),\par
02568       v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40), v41_(v41),\par
02569       v42_(v42), v43_(v43), v44_(v44), v45_(v45) \{\}\par
02570 \par
02571   {\cf17 template} <{\cf17 typename} T>\par
02572   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
02573     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
02574         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
02575         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
02576         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
02577         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
02578         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
02579         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
02580         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
02581         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
02582         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
02583         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
02584         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
02585         {\cf17 static_cast<}T{\cf17 >}(v36_), {\cf17 static_cast<}T{\cf17 >}(v37_), {\cf17 static_cast<}T{\cf17 >}(v38_),\par
02586         {\cf17 static_cast<}T{\cf17 >}(v39_), {\cf17 static_cast<}T{\cf17 >}(v40_), {\cf17 static_cast<}T{\cf17 >}(v41_),\par
02587         {\cf17 static_cast<}T{\cf17 >}(v42_), {\cf17 static_cast<}T{\cf17 >}(v43_), {\cf17 static_cast<}T{\cf17 >}(v44_),\par
02588         {\cf17 static_cast<}T{\cf17 >}(v45_)\};\par
02589     {\cf19 return} ValuesIn(array);\par
02590   \}\par
02591 \par
02592  {\cf17 private}:\par
02593   {\cf20 // No implementation - assignment is unsupported.}\par
02594   {\cf18 void} operator=({\cf17 const} ValueArray45& other);\par
02595 \par
02596   {\cf17 const} T1 v1_;\par
02597   {\cf17 const} T2 v2_;\par
02598   {\cf17 const} T3 v3_;\par
02599   {\cf17 const} T4 v4_;\par
02600   {\cf17 const} T5 v5_;\par
02601   {\cf17 const} T6 v6_;\par
02602   {\cf17 const} T7 v7_;\par
02603   {\cf17 const} T8 v8_;\par
02604   {\cf17 const} T9 v9_;\par
02605   {\cf17 const} T10 v10_;\par
02606   {\cf17 const} T11 v11_;\par
02607   {\cf17 const} T12 v12_;\par
02608   {\cf17 const} T13 v13_;\par
02609   {\cf17 const} T14 v14_;\par
02610   {\cf17 const} T15 v15_;\par
02611   {\cf17 const} T16 v16_;\par
02612   {\cf17 const} T17 v17_;\par
02613   {\cf17 const} T18 v18_;\par
02614   {\cf17 const} T19 v19_;\par
02615   {\cf17 const} T20 v20_;\par
02616   {\cf17 const} T21 v21_;\par
02617   {\cf17 const} T22 v22_;\par
02618   {\cf17 const} T23 v23_;\par
02619   {\cf17 const} T24 v24_;\par
02620   {\cf17 const} T25 v25_;\par
02621   {\cf17 const} T26 v26_;\par
02622   {\cf17 const} T27 v27_;\par
02623   {\cf17 const} T28 v28_;\par
02624   {\cf17 const} T29 v29_;\par
02625   {\cf17 const} T30 v30_;\par
02626   {\cf17 const} T31 v31_;\par
02627   {\cf17 const} T32 v32_;\par
02628   {\cf17 const} T33 v33_;\par
02629   {\cf17 const} T34 v34_;\par
02630   {\cf17 const} T35 v35_;\par
02631   {\cf17 const} T36 v36_;\par
02632   {\cf17 const} T37 v37_;\par
02633   {\cf17 const} T38 v38_;\par
02634   {\cf17 const} T39 v39_;\par
02635   {\cf17 const} T40 v40_;\par
02636   {\cf17 const} T41 v41_;\par
02637   {\cf17 const} T42 v42_;\par
02638   {\cf17 const} T43 v43_;\par
02639   {\cf17 const} T44 v44_;\par
02640   {\cf17 const} T45 v45_;\par
02641 \};\par
02642 \par
02643 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
02644     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
02645     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
02646     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
02647     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
02648     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
02649     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
02650     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
02651     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
02652     {\cf17 typename} T46>\par
02653 {\cf17 class }ValueArray46 \{\par
02654  {\cf17 public}:\par
02655   ValueArray46(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
02656       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
02657       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
02658       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
02659       T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\par
02660       T42 v42, T43 v43, T44 v44, T45 v45, T46 v46) : v1_(v1), v2_(v2), v3_(v3),\par
02661       v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\par
02662       v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\par
02663       v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\par
02664       v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\par
02665       v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),\par
02666       v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40),\par
02667       v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45), v46_(v46) \{\}\par
02668 \par
02669   {\cf17 template} <{\cf17 typename} T>\par
02670   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
02671     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
02672         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
02673         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
02674         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
02675         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
02676         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
02677         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
02678         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
02679         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
02680         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
02681         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
02682         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
02683         {\cf17 static_cast<}T{\cf17 >}(v36_), {\cf17 static_cast<}T{\cf17 >}(v37_), {\cf17 static_cast<}T{\cf17 >}(v38_),\par
02684         {\cf17 static_cast<}T{\cf17 >}(v39_), {\cf17 static_cast<}T{\cf17 >}(v40_), {\cf17 static_cast<}T{\cf17 >}(v41_),\par
02685         {\cf17 static_cast<}T{\cf17 >}(v42_), {\cf17 static_cast<}T{\cf17 >}(v43_), {\cf17 static_cast<}T{\cf17 >}(v44_),\par
02686         {\cf17 static_cast<}T{\cf17 >}(v45_), {\cf17 static_cast<}T{\cf17 >}(v46_)\};\par
02687     {\cf19 return} ValuesIn(array);\par
02688   \}\par
02689 \par
02690  {\cf17 private}:\par
02691   {\cf20 // No implementation - assignment is unsupported.}\par
02692   {\cf18 void} operator=({\cf17 const} ValueArray46& other);\par
02693 \par
02694   {\cf17 const} T1 v1_;\par
02695   {\cf17 const} T2 v2_;\par
02696   {\cf17 const} T3 v3_;\par
02697   {\cf17 const} T4 v4_;\par
02698   {\cf17 const} T5 v5_;\par
02699   {\cf17 const} T6 v6_;\par
02700   {\cf17 const} T7 v7_;\par
02701   {\cf17 const} T8 v8_;\par
02702   {\cf17 const} T9 v9_;\par
02703   {\cf17 const} T10 v10_;\par
02704   {\cf17 const} T11 v11_;\par
02705   {\cf17 const} T12 v12_;\par
02706   {\cf17 const} T13 v13_;\par
02707   {\cf17 const} T14 v14_;\par
02708   {\cf17 const} T15 v15_;\par
02709   {\cf17 const} T16 v16_;\par
02710   {\cf17 const} T17 v17_;\par
02711   {\cf17 const} T18 v18_;\par
02712   {\cf17 const} T19 v19_;\par
02713   {\cf17 const} T20 v20_;\par
02714   {\cf17 const} T21 v21_;\par
02715   {\cf17 const} T22 v22_;\par
02716   {\cf17 const} T23 v23_;\par
02717   {\cf17 const} T24 v24_;\par
02718   {\cf17 const} T25 v25_;\par
02719   {\cf17 const} T26 v26_;\par
02720   {\cf17 const} T27 v27_;\par
02721   {\cf17 const} T28 v28_;\par
02722   {\cf17 const} T29 v29_;\par
02723   {\cf17 const} T30 v30_;\par
02724   {\cf17 const} T31 v31_;\par
02725   {\cf17 const} T32 v32_;\par
02726   {\cf17 const} T33 v33_;\par
02727   {\cf17 const} T34 v34_;\par
02728   {\cf17 const} T35 v35_;\par
02729   {\cf17 const} T36 v36_;\par
02730   {\cf17 const} T37 v37_;\par
02731   {\cf17 const} T38 v38_;\par
02732   {\cf17 const} T39 v39_;\par
02733   {\cf17 const} T40 v40_;\par
02734   {\cf17 const} T41 v41_;\par
02735   {\cf17 const} T42 v42_;\par
02736   {\cf17 const} T43 v43_;\par
02737   {\cf17 const} T44 v44_;\par
02738   {\cf17 const} T45 v45_;\par
02739   {\cf17 const} T46 v46_;\par
02740 \};\par
02741 \par
02742 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
02743     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
02744     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
02745     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
02746     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
02747     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
02748     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
02749     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
02750     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
02751     {\cf17 typename} T46, {\cf17 typename} T47>\par
02752 {\cf17 class }ValueArray47 \{\par
02753  {\cf17 public}:\par
02754   ValueArray47(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
02755       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
02756       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
02757       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
02758       T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\par
02759       T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47) : v1_(v1), v2_(v2),\par
02760       v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\par
02761       v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\par
02762       v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\par
02763       v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\par
02764       v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),\par
02765       v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40),\par
02766       v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45), v46_(v46),\par
02767       v47_(v47) \{\}\par
02768 \par
02769   {\cf17 template} <{\cf17 typename} T>\par
02770   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
02771     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
02772         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
02773         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
02774         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
02775         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
02776         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
02777         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
02778         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
02779         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
02780         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
02781         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
02782         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
02783         {\cf17 static_cast<}T{\cf17 >}(v36_), {\cf17 static_cast<}T{\cf17 >}(v37_), {\cf17 static_cast<}T{\cf17 >}(v38_),\par
02784         {\cf17 static_cast<}T{\cf17 >}(v39_), {\cf17 static_cast<}T{\cf17 >}(v40_), {\cf17 static_cast<}T{\cf17 >}(v41_),\par
02785         {\cf17 static_cast<}T{\cf17 >}(v42_), {\cf17 static_cast<}T{\cf17 >}(v43_), {\cf17 static_cast<}T{\cf17 >}(v44_),\par
02786         {\cf17 static_cast<}T{\cf17 >}(v45_), {\cf17 static_cast<}T{\cf17 >}(v46_), {\cf17 static_cast<}T{\cf17 >}(v47_)\};\par
02787     {\cf19 return} ValuesIn(array);\par
02788   \}\par
02789 \par
02790  {\cf17 private}:\par
02791   {\cf20 // No implementation - assignment is unsupported.}\par
02792   {\cf18 void} operator=({\cf17 const} ValueArray47& other);\par
02793 \par
02794   {\cf17 const} T1 v1_;\par
02795   {\cf17 const} T2 v2_;\par
02796   {\cf17 const} T3 v3_;\par
02797   {\cf17 const} T4 v4_;\par
02798   {\cf17 const} T5 v5_;\par
02799   {\cf17 const} T6 v6_;\par
02800   {\cf17 const} T7 v7_;\par
02801   {\cf17 const} T8 v8_;\par
02802   {\cf17 const} T9 v9_;\par
02803   {\cf17 const} T10 v10_;\par
02804   {\cf17 const} T11 v11_;\par
02805   {\cf17 const} T12 v12_;\par
02806   {\cf17 const} T13 v13_;\par
02807   {\cf17 const} T14 v14_;\par
02808   {\cf17 const} T15 v15_;\par
02809   {\cf17 const} T16 v16_;\par
02810   {\cf17 const} T17 v17_;\par
02811   {\cf17 const} T18 v18_;\par
02812   {\cf17 const} T19 v19_;\par
02813   {\cf17 const} T20 v20_;\par
02814   {\cf17 const} T21 v21_;\par
02815   {\cf17 const} T22 v22_;\par
02816   {\cf17 const} T23 v23_;\par
02817   {\cf17 const} T24 v24_;\par
02818   {\cf17 const} T25 v25_;\par
02819   {\cf17 const} T26 v26_;\par
02820   {\cf17 const} T27 v27_;\par
02821   {\cf17 const} T28 v28_;\par
02822   {\cf17 const} T29 v29_;\par
02823   {\cf17 const} T30 v30_;\par
02824   {\cf17 const} T31 v31_;\par
02825   {\cf17 const} T32 v32_;\par
02826   {\cf17 const} T33 v33_;\par
02827   {\cf17 const} T34 v34_;\par
02828   {\cf17 const} T35 v35_;\par
02829   {\cf17 const} T36 v36_;\par
02830   {\cf17 const} T37 v37_;\par
02831   {\cf17 const} T38 v38_;\par
02832   {\cf17 const} T39 v39_;\par
02833   {\cf17 const} T40 v40_;\par
02834   {\cf17 const} T41 v41_;\par
02835   {\cf17 const} T42 v42_;\par
02836   {\cf17 const} T43 v43_;\par
02837   {\cf17 const} T44 v44_;\par
02838   {\cf17 const} T45 v45_;\par
02839   {\cf17 const} T46 v46_;\par
02840   {\cf17 const} T47 v47_;\par
02841 \};\par
02842 \par
02843 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
02844     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
02845     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
02846     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
02847     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
02848     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
02849     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
02850     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
02851     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
02852     {\cf17 typename} T46, {\cf17 typename} T47, {\cf17 typename} T48>\par
02853 {\cf17 class }ValueArray48 \{\par
02854  {\cf17 public}:\par
02855   ValueArray48(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
02856       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
02857       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
02858       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
02859       T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\par
02860       T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48) : v1_(v1),\par
02861       v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\par
02862       v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\par
02863       v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),\par
02864       v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),\par
02865       v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33),\par
02866       v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39),\par
02867       v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45),\par
02868       v46_(v46), v47_(v47), v48_(v48) \{\}\par
02869 \par
02870   {\cf17 template} <{\cf17 typename} T>\par
02871   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
02872     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
02873         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
02874         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
02875         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
02876         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
02877         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
02878         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
02879         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
02880         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
02881         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
02882         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
02883         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
02884         {\cf17 static_cast<}T{\cf17 >}(v36_), {\cf17 static_cast<}T{\cf17 >}(v37_), {\cf17 static_cast<}T{\cf17 >}(v38_),\par
02885         {\cf17 static_cast<}T{\cf17 >}(v39_), {\cf17 static_cast<}T{\cf17 >}(v40_), {\cf17 static_cast<}T{\cf17 >}(v41_),\par
02886         {\cf17 static_cast<}T{\cf17 >}(v42_), {\cf17 static_cast<}T{\cf17 >}(v43_), {\cf17 static_cast<}T{\cf17 >}(v44_),\par
02887         {\cf17 static_cast<}T{\cf17 >}(v45_), {\cf17 static_cast<}T{\cf17 >}(v46_), {\cf17 static_cast<}T{\cf17 >}(v47_),\par
02888         {\cf17 static_cast<}T{\cf17 >}(v48_)\};\par
02889     {\cf19 return} ValuesIn(array);\par
02890   \}\par
02891 \par
02892  {\cf17 private}:\par
02893   {\cf20 // No implementation - assignment is unsupported.}\par
02894   {\cf18 void} operator=({\cf17 const} ValueArray48& other);\par
02895 \par
02896   {\cf17 const} T1 v1_;\par
02897   {\cf17 const} T2 v2_;\par
02898   {\cf17 const} T3 v3_;\par
02899   {\cf17 const} T4 v4_;\par
02900   {\cf17 const} T5 v5_;\par
02901   {\cf17 const} T6 v6_;\par
02902   {\cf17 const} T7 v7_;\par
02903   {\cf17 const} T8 v8_;\par
02904   {\cf17 const} T9 v9_;\par
02905   {\cf17 const} T10 v10_;\par
02906   {\cf17 const} T11 v11_;\par
02907   {\cf17 const} T12 v12_;\par
02908   {\cf17 const} T13 v13_;\par
02909   {\cf17 const} T14 v14_;\par
02910   {\cf17 const} T15 v15_;\par
02911   {\cf17 const} T16 v16_;\par
02912   {\cf17 const} T17 v17_;\par
02913   {\cf17 const} T18 v18_;\par
02914   {\cf17 const} T19 v19_;\par
02915   {\cf17 const} T20 v20_;\par
02916   {\cf17 const} T21 v21_;\par
02917   {\cf17 const} T22 v22_;\par
02918   {\cf17 const} T23 v23_;\par
02919   {\cf17 const} T24 v24_;\par
02920   {\cf17 const} T25 v25_;\par
02921   {\cf17 const} T26 v26_;\par
02922   {\cf17 const} T27 v27_;\par
02923   {\cf17 const} T28 v28_;\par
02924   {\cf17 const} T29 v29_;\par
02925   {\cf17 const} T30 v30_;\par
02926   {\cf17 const} T31 v31_;\par
02927   {\cf17 const} T32 v32_;\par
02928   {\cf17 const} T33 v33_;\par
02929   {\cf17 const} T34 v34_;\par
02930   {\cf17 const} T35 v35_;\par
02931   {\cf17 const} T36 v36_;\par
02932   {\cf17 const} T37 v37_;\par
02933   {\cf17 const} T38 v38_;\par
02934   {\cf17 const} T39 v39_;\par
02935   {\cf17 const} T40 v40_;\par
02936   {\cf17 const} T41 v41_;\par
02937   {\cf17 const} T42 v42_;\par
02938   {\cf17 const} T43 v43_;\par
02939   {\cf17 const} T44 v44_;\par
02940   {\cf17 const} T45 v45_;\par
02941   {\cf17 const} T46 v46_;\par
02942   {\cf17 const} T47 v47_;\par
02943   {\cf17 const} T48 v48_;\par
02944 \};\par
02945 \par
02946 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
02947     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
02948     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
02949     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
02950     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
02951     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
02952     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
02953     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
02954     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
02955     {\cf17 typename} T46, {\cf17 typename} T47, {\cf17 typename} T48, {\cf17 typename} T49>\par
02956 {\cf17 class }ValueArray49 \{\par
02957  {\cf17 public}:\par
02958   ValueArray49(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
02959       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
02960       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
02961       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
02962       T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\par
02963       T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48,\par
02964       T49 v49) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\par
02965       v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\par
02966       v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\par
02967       v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\par
02968       v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\par
02969       v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),\par
02970       v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44),\par
02971       v45_(v45), v46_(v46), v47_(v47), v48_(v48), v49_(v49) \{\}\par
02972 \par
02973   {\cf17 template} <{\cf17 typename} T>\par
02974   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
02975     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
02976         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
02977         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
02978         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
02979         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
02980         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
02981         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
02982         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
02983         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
02984         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
02985         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
02986         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
02987         {\cf17 static_cast<}T{\cf17 >}(v36_), {\cf17 static_cast<}T{\cf17 >}(v37_), {\cf17 static_cast<}T{\cf17 >}(v38_),\par
02988         {\cf17 static_cast<}T{\cf17 >}(v39_), {\cf17 static_cast<}T{\cf17 >}(v40_), {\cf17 static_cast<}T{\cf17 >}(v41_),\par
02989         {\cf17 static_cast<}T{\cf17 >}(v42_), {\cf17 static_cast<}T{\cf17 >}(v43_), {\cf17 static_cast<}T{\cf17 >}(v44_),\par
02990         {\cf17 static_cast<}T{\cf17 >}(v45_), {\cf17 static_cast<}T{\cf17 >}(v46_), {\cf17 static_cast<}T{\cf17 >}(v47_),\par
02991         {\cf17 static_cast<}T{\cf17 >}(v48_), {\cf17 static_cast<}T{\cf17 >}(v49_)\};\par
02992     {\cf19 return} ValuesIn(array);\par
02993   \}\par
02994 \par
02995  {\cf17 private}:\par
02996   {\cf20 // No implementation - assignment is unsupported.}\par
02997   {\cf18 void} operator=({\cf17 const} ValueArray49& other);\par
02998 \par
02999   {\cf17 const} T1 v1_;\par
03000   {\cf17 const} T2 v2_;\par
03001   {\cf17 const} T3 v3_;\par
03002   {\cf17 const} T4 v4_;\par
03003   {\cf17 const} T5 v5_;\par
03004   {\cf17 const} T6 v6_;\par
03005   {\cf17 const} T7 v7_;\par
03006   {\cf17 const} T8 v8_;\par
03007   {\cf17 const} T9 v9_;\par
03008   {\cf17 const} T10 v10_;\par
03009   {\cf17 const} T11 v11_;\par
03010   {\cf17 const} T12 v12_;\par
03011   {\cf17 const} T13 v13_;\par
03012   {\cf17 const} T14 v14_;\par
03013   {\cf17 const} T15 v15_;\par
03014   {\cf17 const} T16 v16_;\par
03015   {\cf17 const} T17 v17_;\par
03016   {\cf17 const} T18 v18_;\par
03017   {\cf17 const} T19 v19_;\par
03018   {\cf17 const} T20 v20_;\par
03019   {\cf17 const} T21 v21_;\par
03020   {\cf17 const} T22 v22_;\par
03021   {\cf17 const} T23 v23_;\par
03022   {\cf17 const} T24 v24_;\par
03023   {\cf17 const} T25 v25_;\par
03024   {\cf17 const} T26 v26_;\par
03025   {\cf17 const} T27 v27_;\par
03026   {\cf17 const} T28 v28_;\par
03027   {\cf17 const} T29 v29_;\par
03028   {\cf17 const} T30 v30_;\par
03029   {\cf17 const} T31 v31_;\par
03030   {\cf17 const} T32 v32_;\par
03031   {\cf17 const} T33 v33_;\par
03032   {\cf17 const} T34 v34_;\par
03033   {\cf17 const} T35 v35_;\par
03034   {\cf17 const} T36 v36_;\par
03035   {\cf17 const} T37 v37_;\par
03036   {\cf17 const} T38 v38_;\par
03037   {\cf17 const} T39 v39_;\par
03038   {\cf17 const} T40 v40_;\par
03039   {\cf17 const} T41 v41_;\par
03040   {\cf17 const} T42 v42_;\par
03041   {\cf17 const} T43 v43_;\par
03042   {\cf17 const} T44 v44_;\par
03043   {\cf17 const} T45 v45_;\par
03044   {\cf17 const} T46 v46_;\par
03045   {\cf17 const} T47 v47_;\par
03046   {\cf17 const} T48 v48_;\par
03047   {\cf17 const} T49 v49_;\par
03048 \};\par
03049 \par
03050 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
03051     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
03052     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
03053     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
03054     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
03055     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
03056     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
03057     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
03058     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
03059     {\cf17 typename} T46, {\cf17 typename} T47, {\cf17 typename} T48, {\cf17 typename} T49, {\cf17 typename} T50>\par
03060 {\cf17 class }ValueArray50 \{\par
03061  {\cf17 public}:\par
03062   ValueArray50(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\par
03063       T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\par
03064       T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\par
03065       T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\par
03066       T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\par
03067       T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48, T49 v49,\par
03068       T50 v50) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\par
03069       v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\par
03070       v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\par
03071       v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\par
03072       v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\par
03073       v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),\par
03074       v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44),\par
03075       v45_(v45), v46_(v46), v47_(v47), v48_(v48), v49_(v49), v50_(v50) \{\}\par
03076 \par
03077   {\cf17 template} <{\cf17 typename} T>\par
03078   {\cf17 operator} ParamGenerator<T>(){\cf17  const }\{\par
03079     {\cf17 const} T array[] = \{{\cf17 static_cast<}T{\cf17 >}(v1_), {\cf17 static_cast<}T{\cf17 >}(v2_),\par
03080         {\cf17 static_cast<}T{\cf17 >}(v3_), {\cf17 static_cast<}T{\cf17 >}(v4_), {\cf17 static_cast<}T{\cf17 >}(v5_),\par
03081         {\cf17 static_cast<}T{\cf17 >}(v6_), {\cf17 static_cast<}T{\cf17 >}(v7_), {\cf17 static_cast<}T{\cf17 >}(v8_),\par
03082         {\cf17 static_cast<}T{\cf17 >}(v9_), {\cf17 static_cast<}T{\cf17 >}(v10_), {\cf17 static_cast<}T{\cf17 >}(v11_),\par
03083         {\cf17 static_cast<}T{\cf17 >}(v12_), {\cf17 static_cast<}T{\cf17 >}(v13_), {\cf17 static_cast<}T{\cf17 >}(v14_),\par
03084         {\cf17 static_cast<}T{\cf17 >}(v15_), {\cf17 static_cast<}T{\cf17 >}(v16_), {\cf17 static_cast<}T{\cf17 >}(v17_),\par
03085         {\cf17 static_cast<}T{\cf17 >}(v18_), {\cf17 static_cast<}T{\cf17 >}(v19_), {\cf17 static_cast<}T{\cf17 >}(v20_),\par
03086         {\cf17 static_cast<}T{\cf17 >}(v21_), {\cf17 static_cast<}T{\cf17 >}(v22_), {\cf17 static_cast<}T{\cf17 >}(v23_),\par
03087         {\cf17 static_cast<}T{\cf17 >}(v24_), {\cf17 static_cast<}T{\cf17 >}(v25_), {\cf17 static_cast<}T{\cf17 >}(v26_),\par
03088         {\cf17 static_cast<}T{\cf17 >}(v27_), {\cf17 static_cast<}T{\cf17 >}(v28_), {\cf17 static_cast<}T{\cf17 >}(v29_),\par
03089         {\cf17 static_cast<}T{\cf17 >}(v30_), {\cf17 static_cast<}T{\cf17 >}(v31_), {\cf17 static_cast<}T{\cf17 >}(v32_),\par
03090         {\cf17 static_cast<}T{\cf17 >}(v33_), {\cf17 static_cast<}T{\cf17 >}(v34_), {\cf17 static_cast<}T{\cf17 >}(v35_),\par
03091         {\cf17 static_cast<}T{\cf17 >}(v36_), {\cf17 static_cast<}T{\cf17 >}(v37_), {\cf17 static_cast<}T{\cf17 >}(v38_),\par
03092         {\cf17 static_cast<}T{\cf17 >}(v39_), {\cf17 static_cast<}T{\cf17 >}(v40_), {\cf17 static_cast<}T{\cf17 >}(v41_),\par
03093         {\cf17 static_cast<}T{\cf17 >}(v42_), {\cf17 static_cast<}T{\cf17 >}(v43_), {\cf17 static_cast<}T{\cf17 >}(v44_),\par
03094         {\cf17 static_cast<}T{\cf17 >}(v45_), {\cf17 static_cast<}T{\cf17 >}(v46_), {\cf17 static_cast<}T{\cf17 >}(v47_),\par
03095         {\cf17 static_cast<}T{\cf17 >}(v48_), {\cf17 static_cast<}T{\cf17 >}(v49_), {\cf17 static_cast<}T{\cf17 >}(v50_)\};\par
03096     {\cf19 return} ValuesIn(array);\par
03097   \}\par
03098 \par
03099  {\cf17 private}:\par
03100   {\cf20 // No implementation - assignment is unsupported.}\par
03101   {\cf18 void} operator=({\cf17 const} ValueArray50& other);\par
03102 \par
03103   {\cf17 const} T1 v1_;\par
03104   {\cf17 const} T2 v2_;\par
03105   {\cf17 const} T3 v3_;\par
03106   {\cf17 const} T4 v4_;\par
03107   {\cf17 const} T5 v5_;\par
03108   {\cf17 const} T6 v6_;\par
03109   {\cf17 const} T7 v7_;\par
03110   {\cf17 const} T8 v8_;\par
03111   {\cf17 const} T9 v9_;\par
03112   {\cf17 const} T10 v10_;\par
03113   {\cf17 const} T11 v11_;\par
03114   {\cf17 const} T12 v12_;\par
03115   {\cf17 const} T13 v13_;\par
03116   {\cf17 const} T14 v14_;\par
03117   {\cf17 const} T15 v15_;\par
03118   {\cf17 const} T16 v16_;\par
03119   {\cf17 const} T17 v17_;\par
03120   {\cf17 const} T18 v18_;\par
03121   {\cf17 const} T19 v19_;\par
03122   {\cf17 const} T20 v20_;\par
03123   {\cf17 const} T21 v21_;\par
03124   {\cf17 const} T22 v22_;\par
03125   {\cf17 const} T23 v23_;\par
03126   {\cf17 const} T24 v24_;\par
03127   {\cf17 const} T25 v25_;\par
03128   {\cf17 const} T26 v26_;\par
03129   {\cf17 const} T27 v27_;\par
03130   {\cf17 const} T28 v28_;\par
03131   {\cf17 const} T29 v29_;\par
03132   {\cf17 const} T30 v30_;\par
03133   {\cf17 const} T31 v31_;\par
03134   {\cf17 const} T32 v32_;\par
03135   {\cf17 const} T33 v33_;\par
03136   {\cf17 const} T34 v34_;\par
03137   {\cf17 const} T35 v35_;\par
03138   {\cf17 const} T36 v36_;\par
03139   {\cf17 const} T37 v37_;\par
03140   {\cf17 const} T38 v38_;\par
03141   {\cf17 const} T39 v39_;\par
03142   {\cf17 const} T40 v40_;\par
03143   {\cf17 const} T41 v41_;\par
03144   {\cf17 const} T42 v42_;\par
03145   {\cf17 const} T43 v43_;\par
03146   {\cf17 const} T44 v44_;\par
03147   {\cf17 const} T45 v45_;\par
03148   {\cf17 const} T46 v46_;\par
03149   {\cf17 const} T47 v47_;\par
03150   {\cf17 const} T48 v48_;\par
03151   {\cf17 const} T49 v49_;\par
03152   {\cf17 const} T50 v50_;\par
03153 \};\par
03154 \par
03155 {\cf21 # if GTEST_HAS_COMBINE}\par
03156 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
03157 {\cf20 //}\par
03158 {\cf20 // Generates values from the Cartesian product of values produced}\par
03159 {\cf20 // by the argument generators.}\par
03160 {\cf20 //}\par
03161 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
03162 {\cf17 class }CartesianProductGenerator2\par
03163     : {\cf17 public} ParamGeneratorInterface< ::testing::tuple<T1, T2> > \{\par
03164  {\cf17 public}:\par
03165   typedef ::testing::tuple<T1, T2> ParamType;\par
03166 \par
03167   CartesianProductGenerator2({\cf17 const} ParamGenerator<T1>& g1,\par
03168       {\cf17 const} ParamGenerator<T2>& g2)\par
03169       : g1_(g1), g2_(g2) \{\}\par
03170   {\cf17 virtual} ~CartesianProductGenerator2() \{\}\par
03171 \par
03172   {\cf17 virtual} ParamIteratorInterface<ParamType>* Begin(){\cf17  const }\{\par
03173     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.begin(), g2_, g2_.begin());\par
03174   \}\par
03175   {\cf17 virtual} ParamIteratorInterface<ParamType>* End(){\cf17  const }\{\par
03176     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.end(), g2_, g2_.end());\par
03177   \}\par
03178 \par
03179  {\cf17 private}:\par
03180   {\cf17 class }Iterator : {\cf17 public} ParamIteratorInterface<ParamType> \{\par
03181    {\cf17 public}:\par
03182     Iterator({\cf17 const} ParamGeneratorInterface<ParamType>* base,\par
03183       {\cf17 const} ParamGenerator<T1>& g1,\par
03184       {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator& current1,\par
03185       {\cf17 const} ParamGenerator<T2>& g2,\par
03186       {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator& current2)\par
03187         : base_(base),\par
03188           begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\par
03189           begin2_(g2.begin()), end2_(g2.end()), current2_(current2)    \{\par
03190       ComputeCurrentValue();\par
03191     \}\par
03192     {\cf17 virtual} ~Iterator() \{\}\par
03193 \par
03194     {\cf17 virtual} {\cf17 const} ParamGeneratorInterface<ParamType>* BaseGenerator(){\cf17  const }\{\par
03195       {\cf19 return} base_;\par
03196     \}\par
03197     {\cf20 // Advance should not be called on beyond-of-range iterators}\par
03198     {\cf20 // so no component iterators must be beyond end of range, either.}\par
03199     {\cf17 virtual} {\cf18 void} Advance() \{\par
03200       assert(!AtEnd());\par
03201       ++current2_;\par
03202       {\cf19 if} (current2_ == end2_) \{\par
03203         current2_ = begin2_;\par
03204         ++current1_;\par
03205       \}\par
03206       ComputeCurrentValue();\par
03207     \}\par
03208     {\cf17 virtual} ParamIteratorInterface<ParamType>* Clone(){\cf17  const }\{\par
03209       {\cf19 return} {\cf17 new} Iterator(*{\cf17 this});\par
03210     \}\par
03211     {\cf17 virtual} {\cf17 const} ParamType* Current(){\cf17  const }\{ {\cf19 return} &current_value_; \}\par
03212     {\cf17 virtual} {\cf18 bool} Equals({\cf17 const} ParamIteratorInterface<ParamType>& other){\cf17  const }\{\par
03213       {\cf20 // Having the same base generator guarantees that the other}\par
03214       {\cf20 // iterator is of the same type and we can downcast.}\par
03215       GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\par
03216           << {\cf22 "The program attempted to compare iterators "}\par
03217           << {\cf22 "from different generators."} << std::endl;\par
03218       {\cf17 const} Iterator* typed_other =\par
03219           CheckedDowncastToActualType<const Iterator>(&other);\par
03220       {\cf20 // We must report iterators equal if they both point beyond their}\par
03221       {\cf20 // respective ranges. That can happen in a variety of fashions,}\par
03222       {\cf20 // so we have to consult AtEnd().}\par
03223       {\cf19 return} (AtEnd() && typed_other->AtEnd()) ||\par
03224          (\par
03225           current1_ == typed_other->current1_ &&\par
03226           current2_ == typed_other->current2_);\par
03227     \}\par
03228 \par
03229    {\cf17 private}:\par
03230     Iterator({\cf17 const} Iterator& other)\par
03231         : base_(other.base_),\par
03232         begin1_(other.begin1_),\par
03233         end1_(other.end1_),\par
03234         current1_(other.current1_),\par
03235         begin2_(other.begin2_),\par
03236         end2_(other.end2_),\par
03237         current2_(other.current2_) \{\par
03238       ComputeCurrentValue();\par
03239     \}\par
03240 \par
03241     {\cf18 void} ComputeCurrentValue() \{\par
03242       {\cf19 if} (!AtEnd())\par
03243         current_value_ = ParamType(*current1_, *current2_);\par
03244     \}\par
03245     {\cf18 bool} AtEnd(){\cf17  const }\{\par
03246       {\cf20 // We must report iterator past the end of the range when either of the}\par
03247       {\cf20 // component iterators has reached the end of its range.}\par
03248       {\cf19 return}\par
03249           current1_ == end1_ ||\par
03250           current2_ == end2_;\par
03251     \}\par
03252 \par
03253     {\cf20 // No implementation - assignment is unsupported.}\par
03254     {\cf18 void} operator=({\cf17 const} Iterator& other);\par
03255 \par
03256     {\cf17 const} ParamGeneratorInterface<ParamType>* {\cf17 const} base_;\par
03257     {\cf20 // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.}\par
03258     {\cf20 // current[i]_ is the actual traversing iterator.}\par
03259     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator begin1_;\par
03260     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator end1_;\par
03261     {\cf17 typename} ParamGenerator<T1>::iterator current1_;\par
03262     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator begin2_;\par
03263     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator end2_;\par
03264     {\cf17 typename} ParamGenerator<T2>::iterator current2_;\par
03265     ParamType current_value_;\par
03266   \};  {\cf20 // class CartesianProductGenerator2::Iterator}\par
03267 \par
03268   {\cf20 // No implementation - assignment is unsupported.}\par
03269   {\cf18 void} operator=({\cf17 const} CartesianProductGenerator2& other);\par
03270 \par
03271   {\cf17 const} ParamGenerator<T1> g1_;\par
03272   {\cf17 const} ParamGenerator<T2> g2_;\par
03273 \};  {\cf20 // class CartesianProductGenerator2}\par
03274 \par
03275 \par
03276 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3>\par
03277 {\cf17 class }CartesianProductGenerator3\par
03278     : {\cf17 public} ParamGeneratorInterface< ::testing::tuple<T1, T2, T3> > \{\par
03279  {\cf17 public}:\par
03280   typedef ::testing::tuple<T1, T2, T3> ParamType;\par
03281 \par
03282   CartesianProductGenerator3({\cf17 const} ParamGenerator<T1>& g1,\par
03283       {\cf17 const} ParamGenerator<T2>& g2, {\cf17 const} ParamGenerator<T3>& g3)\par
03284       : g1_(g1), g2_(g2), g3_(g3) \{\}\par
03285   {\cf17 virtual} ~CartesianProductGenerator3() \{\}\par
03286 \par
03287   {\cf17 virtual} ParamIteratorInterface<ParamType>* Begin(){\cf17  const }\{\par
03288     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\par
03289         g3_.begin());\par
03290   \}\par
03291   {\cf17 virtual} ParamIteratorInterface<ParamType>* End(){\cf17  const }\{\par
03292     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end());\par
03293   \}\par
03294 \par
03295  {\cf17 private}:\par
03296   {\cf17 class }Iterator : {\cf17 public} ParamIteratorInterface<ParamType> \{\par
03297    {\cf17 public}:\par
03298     Iterator({\cf17 const} ParamGeneratorInterface<ParamType>* base,\par
03299       {\cf17 const} ParamGenerator<T1>& g1,\par
03300       {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator& current1,\par
03301       {\cf17 const} ParamGenerator<T2>& g2,\par
03302       {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator& current2,\par
03303       {\cf17 const} ParamGenerator<T3>& g3,\par
03304       {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator& current3)\par
03305         : base_(base),\par
03306           begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\par
03307           begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\par
03308           begin3_(g3.begin()), end3_(g3.end()), current3_(current3)    \{\par
03309       ComputeCurrentValue();\par
03310     \}\par
03311     {\cf17 virtual} ~Iterator() \{\}\par
03312 \par
03313     {\cf17 virtual} {\cf17 const} ParamGeneratorInterface<ParamType>* BaseGenerator(){\cf17  const }\{\par
03314       {\cf19 return} base_;\par
03315     \}\par
03316     {\cf20 // Advance should not be called on beyond-of-range iterators}\par
03317     {\cf20 // so no component iterators must be beyond end of range, either.}\par
03318     {\cf17 virtual} {\cf18 void} Advance() \{\par
03319       assert(!AtEnd());\par
03320       ++current3_;\par
03321       {\cf19 if} (current3_ == end3_) \{\par
03322         current3_ = begin3_;\par
03323         ++current2_;\par
03324       \}\par
03325       {\cf19 if} (current2_ == end2_) \{\par
03326         current2_ = begin2_;\par
03327         ++current1_;\par
03328       \}\par
03329       ComputeCurrentValue();\par
03330     \}\par
03331     {\cf17 virtual} ParamIteratorInterface<ParamType>* Clone(){\cf17  const }\{\par
03332       {\cf19 return} {\cf17 new} Iterator(*{\cf17 this});\par
03333     \}\par
03334     {\cf17 virtual} {\cf17 const} ParamType* Current(){\cf17  const }\{ {\cf19 return} &current_value_; \}\par
03335     {\cf17 virtual} {\cf18 bool} Equals({\cf17 const} ParamIteratorInterface<ParamType>& other){\cf17  const }\{\par
03336       {\cf20 // Having the same base generator guarantees that the other}\par
03337       {\cf20 // iterator is of the same type and we can downcast.}\par
03338       GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\par
03339           << {\cf22 "The program attempted to compare iterators "}\par
03340           << {\cf22 "from different generators."} << std::endl;\par
03341       {\cf17 const} Iterator* typed_other =\par
03342           CheckedDowncastToActualType<const Iterator>(&other);\par
03343       {\cf20 // We must report iterators equal if they both point beyond their}\par
03344       {\cf20 // respective ranges. That can happen in a variety of fashions,}\par
03345       {\cf20 // so we have to consult AtEnd().}\par
03346       {\cf19 return} (AtEnd() && typed_other->AtEnd()) ||\par
03347          (\par
03348           current1_ == typed_other->current1_ &&\par
03349           current2_ == typed_other->current2_ &&\par
03350           current3_ == typed_other->current3_);\par
03351     \}\par
03352 \par
03353    {\cf17 private}:\par
03354     Iterator({\cf17 const} Iterator& other)\par
03355         : base_(other.base_),\par
03356         begin1_(other.begin1_),\par
03357         end1_(other.end1_),\par
03358         current1_(other.current1_),\par
03359         begin2_(other.begin2_),\par
03360         end2_(other.end2_),\par
03361         current2_(other.current2_),\par
03362         begin3_(other.begin3_),\par
03363         end3_(other.end3_),\par
03364         current3_(other.current3_) \{\par
03365       ComputeCurrentValue();\par
03366     \}\par
03367 \par
03368     {\cf18 void} ComputeCurrentValue() \{\par
03369       {\cf19 if} (!AtEnd())\par
03370         current_value_ = ParamType(*current1_, *current2_, *current3_);\par
03371     \}\par
03372     {\cf18 bool} AtEnd(){\cf17  const }\{\par
03373       {\cf20 // We must report iterator past the end of the range when either of the}\par
03374       {\cf20 // component iterators has reached the end of its range.}\par
03375       {\cf19 return}\par
03376           current1_ == end1_ ||\par
03377           current2_ == end2_ ||\par
03378           current3_ == end3_;\par
03379     \}\par
03380 \par
03381     {\cf20 // No implementation - assignment is unsupported.}\par
03382     {\cf18 void} operator=({\cf17 const} Iterator& other);\par
03383 \par
03384     {\cf17 const} ParamGeneratorInterface<ParamType>* {\cf17 const} base_;\par
03385     {\cf20 // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.}\par
03386     {\cf20 // current[i]_ is the actual traversing iterator.}\par
03387     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator begin1_;\par
03388     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator end1_;\par
03389     {\cf17 typename} ParamGenerator<T1>::iterator current1_;\par
03390     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator begin2_;\par
03391     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator end2_;\par
03392     {\cf17 typename} ParamGenerator<T2>::iterator current2_;\par
03393     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator begin3_;\par
03394     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator end3_;\par
03395     {\cf17 typename} ParamGenerator<T3>::iterator current3_;\par
03396     ParamType current_value_;\par
03397   \};  {\cf20 // class CartesianProductGenerator3::Iterator}\par
03398 \par
03399   {\cf20 // No implementation - assignment is unsupported.}\par
03400   {\cf18 void} operator=({\cf17 const} CartesianProductGenerator3& other);\par
03401 \par
03402   {\cf17 const} ParamGenerator<T1> g1_;\par
03403   {\cf17 const} ParamGenerator<T2> g2_;\par
03404   {\cf17 const} ParamGenerator<T3> g3_;\par
03405 \};  {\cf20 // class CartesianProductGenerator3}\par
03406 \par
03407 \par
03408 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4>\par
03409 {\cf17 class }CartesianProductGenerator4\par
03410     : {\cf17 public} ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4> > \{\par
03411  {\cf17 public}:\par
03412   typedef ::testing::tuple<T1, T2, T3, T4> ParamType;\par
03413 \par
03414   CartesianProductGenerator4({\cf17 const} ParamGenerator<T1>& g1,\par
03415       {\cf17 const} ParamGenerator<T2>& g2, {\cf17 const} ParamGenerator<T3>& g3,\par
03416       {\cf17 const} ParamGenerator<T4>& g4)\par
03417       : g1_(g1), g2_(g2), g3_(g3), g4_(g4) \{\}\par
03418   {\cf17 virtual} ~CartesianProductGenerator4() \{\}\par
03419 \par
03420   {\cf17 virtual} ParamIteratorInterface<ParamType>* Begin(){\cf17  const }\{\par
03421     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\par
03422         g3_.begin(), g4_, g4_.begin());\par
03423   \}\par
03424   {\cf17 virtual} ParamIteratorInterface<ParamType>* End(){\cf17  const }\{\par
03425     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\par
03426         g4_, g4_.end());\par
03427   \}\par
03428 \par
03429  {\cf17 private}:\par
03430   {\cf17 class }Iterator : {\cf17 public} ParamIteratorInterface<ParamType> \{\par
03431    {\cf17 public}:\par
03432     Iterator({\cf17 const} ParamGeneratorInterface<ParamType>* base,\par
03433       {\cf17 const} ParamGenerator<T1>& g1,\par
03434       {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator& current1,\par
03435       {\cf17 const} ParamGenerator<T2>& g2,\par
03436       {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator& current2,\par
03437       {\cf17 const} ParamGenerator<T3>& g3,\par
03438       {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator& current3,\par
03439       {\cf17 const} ParamGenerator<T4>& g4,\par
03440       {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator& current4)\par
03441         : base_(base),\par
03442           begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\par
03443           begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\par
03444           begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\par
03445           begin4_(g4.begin()), end4_(g4.end()), current4_(current4)    \{\par
03446       ComputeCurrentValue();\par
03447     \}\par
03448     {\cf17 virtual} ~Iterator() \{\}\par
03449 \par
03450     {\cf17 virtual} {\cf17 const} ParamGeneratorInterface<ParamType>* BaseGenerator(){\cf17  const }\{\par
03451       {\cf19 return} base_;\par
03452     \}\par
03453     {\cf20 // Advance should not be called on beyond-of-range iterators}\par
03454     {\cf20 // so no component iterators must be beyond end of range, either.}\par
03455     {\cf17 virtual} {\cf18 void} Advance() \{\par
03456       assert(!AtEnd());\par
03457       ++current4_;\par
03458       {\cf19 if} (current4_ == end4_) \{\par
03459         current4_ = begin4_;\par
03460         ++current3_;\par
03461       \}\par
03462       {\cf19 if} (current3_ == end3_) \{\par
03463         current3_ = begin3_;\par
03464         ++current2_;\par
03465       \}\par
03466       {\cf19 if} (current2_ == end2_) \{\par
03467         current2_ = begin2_;\par
03468         ++current1_;\par
03469       \}\par
03470       ComputeCurrentValue();\par
03471     \}\par
03472     {\cf17 virtual} ParamIteratorInterface<ParamType>* Clone(){\cf17  const }\{\par
03473       {\cf19 return} {\cf17 new} Iterator(*{\cf17 this});\par
03474     \}\par
03475     {\cf17 virtual} {\cf17 const} ParamType* Current(){\cf17  const }\{ {\cf19 return} &current_value_; \}\par
03476     {\cf17 virtual} {\cf18 bool} Equals({\cf17 const} ParamIteratorInterface<ParamType>& other){\cf17  const }\{\par
03477       {\cf20 // Having the same base generator guarantees that the other}\par
03478       {\cf20 // iterator is of the same type and we can downcast.}\par
03479       GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\par
03480           << {\cf22 "The program attempted to compare iterators "}\par
03481           << {\cf22 "from different generators."} << std::endl;\par
03482       {\cf17 const} Iterator* typed_other =\par
03483           CheckedDowncastToActualType<const Iterator>(&other);\par
03484       {\cf20 // We must report iterators equal if they both point beyond their}\par
03485       {\cf20 // respective ranges. That can happen in a variety of fashions,}\par
03486       {\cf20 // so we have to consult AtEnd().}\par
03487       {\cf19 return} (AtEnd() && typed_other->AtEnd()) ||\par
03488          (\par
03489           current1_ == typed_other->current1_ &&\par
03490           current2_ == typed_other->current2_ &&\par
03491           current3_ == typed_other->current3_ &&\par
03492           current4_ == typed_other->current4_);\par
03493     \}\par
03494 \par
03495    {\cf17 private}:\par
03496     Iterator({\cf17 const} Iterator& other)\par
03497         : base_(other.base_),\par
03498         begin1_(other.begin1_),\par
03499         end1_(other.end1_),\par
03500         current1_(other.current1_),\par
03501         begin2_(other.begin2_),\par
03502         end2_(other.end2_),\par
03503         current2_(other.current2_),\par
03504         begin3_(other.begin3_),\par
03505         end3_(other.end3_),\par
03506         current3_(other.current3_),\par
03507         begin4_(other.begin4_),\par
03508         end4_(other.end4_),\par
03509         current4_(other.current4_) \{\par
03510       ComputeCurrentValue();\par
03511     \}\par
03512 \par
03513     {\cf18 void} ComputeCurrentValue() \{\par
03514       {\cf19 if} (!AtEnd())\par
03515         current_value_ = ParamType(*current1_, *current2_, *current3_,\par
03516             *current4_);\par
03517     \}\par
03518     {\cf18 bool} AtEnd(){\cf17  const }\{\par
03519       {\cf20 // We must report iterator past the end of the range when either of the}\par
03520       {\cf20 // component iterators has reached the end of its range.}\par
03521       {\cf19 return}\par
03522           current1_ == end1_ ||\par
03523           current2_ == end2_ ||\par
03524           current3_ == end3_ ||\par
03525           current4_ == end4_;\par
03526     \}\par
03527 \par
03528     {\cf20 // No implementation - assignment is unsupported.}\par
03529     {\cf18 void} operator=({\cf17 const} Iterator& other);\par
03530 \par
03531     {\cf17 const} ParamGeneratorInterface<ParamType>* {\cf17 const} base_;\par
03532     {\cf20 // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.}\par
03533     {\cf20 // current[i]_ is the actual traversing iterator.}\par
03534     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator begin1_;\par
03535     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator end1_;\par
03536     {\cf17 typename} ParamGenerator<T1>::iterator current1_;\par
03537     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator begin2_;\par
03538     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator end2_;\par
03539     {\cf17 typename} ParamGenerator<T2>::iterator current2_;\par
03540     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator begin3_;\par
03541     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator end3_;\par
03542     {\cf17 typename} ParamGenerator<T3>::iterator current3_;\par
03543     {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator begin4_;\par
03544     {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator end4_;\par
03545     {\cf17 typename} ParamGenerator<T4>::iterator current4_;\par
03546     ParamType current_value_;\par
03547   \};  {\cf20 // class CartesianProductGenerator4::Iterator}\par
03548 \par
03549   {\cf20 // No implementation - assignment is unsupported.}\par
03550   {\cf18 void} operator=({\cf17 const} CartesianProductGenerator4& other);\par
03551 \par
03552   {\cf17 const} ParamGenerator<T1> g1_;\par
03553   {\cf17 const} ParamGenerator<T2> g2_;\par
03554   {\cf17 const} ParamGenerator<T3> g3_;\par
03555   {\cf17 const} ParamGenerator<T4> g4_;\par
03556 \};  {\cf20 // class CartesianProductGenerator4}\par
03557 \par
03558 \par
03559 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5>\par
03560 {\cf17 class }CartesianProductGenerator5\par
03561     : {\cf17 public} ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5> > \{\par
03562  {\cf17 public}:\par
03563   typedef ::testing::tuple<T1, T2, T3, T4, T5> ParamType;\par
03564 \par
03565   CartesianProductGenerator5({\cf17 const} ParamGenerator<T1>& g1,\par
03566       {\cf17 const} ParamGenerator<T2>& g2, {\cf17 const} ParamGenerator<T3>& g3,\par
03567       {\cf17 const} ParamGenerator<T4>& g4, {\cf17 const} ParamGenerator<T5>& g5)\par
03568       : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5) \{\}\par
03569   {\cf17 virtual} ~CartesianProductGenerator5() \{\}\par
03570 \par
03571   {\cf17 virtual} ParamIteratorInterface<ParamType>* Begin(){\cf17  const }\{\par
03572     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\par
03573         g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin());\par
03574   \}\par
03575   {\cf17 virtual} ParamIteratorInterface<ParamType>* End(){\cf17  const }\{\par
03576     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\par
03577         g4_, g4_.end(), g5_, g5_.end());\par
03578   \}\par
03579 \par
03580  {\cf17 private}:\par
03581   {\cf17 class }Iterator : {\cf17 public} ParamIteratorInterface<ParamType> \{\par
03582    {\cf17 public}:\par
03583     Iterator({\cf17 const} ParamGeneratorInterface<ParamType>* base,\par
03584       {\cf17 const} ParamGenerator<T1>& g1,\par
03585       {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator& current1,\par
03586       {\cf17 const} ParamGenerator<T2>& g2,\par
03587       {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator& current2,\par
03588       {\cf17 const} ParamGenerator<T3>& g3,\par
03589       {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator& current3,\par
03590       {\cf17 const} ParamGenerator<T4>& g4,\par
03591       {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator& current4,\par
03592       {\cf17 const} ParamGenerator<T5>& g5,\par
03593       {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator& current5)\par
03594         : base_(base),\par
03595           begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\par
03596           begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\par
03597           begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\par
03598           begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\par
03599           begin5_(g5.begin()), end5_(g5.end()), current5_(current5)    \{\par
03600       ComputeCurrentValue();\par
03601     \}\par
03602     {\cf17 virtual} ~Iterator() \{\}\par
03603 \par
03604     {\cf17 virtual} {\cf17 const} ParamGeneratorInterface<ParamType>* BaseGenerator(){\cf17  const }\{\par
03605       {\cf19 return} base_;\par
03606     \}\par
03607     {\cf20 // Advance should not be called on beyond-of-range iterators}\par
03608     {\cf20 // so no component iterators must be beyond end of range, either.}\par
03609     {\cf17 virtual} {\cf18 void} Advance() \{\par
03610       assert(!AtEnd());\par
03611       ++current5_;\par
03612       {\cf19 if} (current5_ == end5_) \{\par
03613         current5_ = begin5_;\par
03614         ++current4_;\par
03615       \}\par
03616       {\cf19 if} (current4_ == end4_) \{\par
03617         current4_ = begin4_;\par
03618         ++current3_;\par
03619       \}\par
03620       {\cf19 if} (current3_ == end3_) \{\par
03621         current3_ = begin3_;\par
03622         ++current2_;\par
03623       \}\par
03624       {\cf19 if} (current2_ == end2_) \{\par
03625         current2_ = begin2_;\par
03626         ++current1_;\par
03627       \}\par
03628       ComputeCurrentValue();\par
03629     \}\par
03630     {\cf17 virtual} ParamIteratorInterface<ParamType>* Clone(){\cf17  const }\{\par
03631       {\cf19 return} {\cf17 new} Iterator(*{\cf17 this});\par
03632     \}\par
03633     {\cf17 virtual} {\cf17 const} ParamType* Current(){\cf17  const }\{ {\cf19 return} &current_value_; \}\par
03634     {\cf17 virtual} {\cf18 bool} Equals({\cf17 const} ParamIteratorInterface<ParamType>& other){\cf17  const }\{\par
03635       {\cf20 // Having the same base generator guarantees that the other}\par
03636       {\cf20 // iterator is of the same type and we can downcast.}\par
03637       GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\par
03638           << {\cf22 "The program attempted to compare iterators "}\par
03639           << {\cf22 "from different generators."} << std::endl;\par
03640       {\cf17 const} Iterator* typed_other =\par
03641           CheckedDowncastToActualType<const Iterator>(&other);\par
03642       {\cf20 // We must report iterators equal if they both point beyond their}\par
03643       {\cf20 // respective ranges. That can happen in a variety of fashions,}\par
03644       {\cf20 // so we have to consult AtEnd().}\par
03645       {\cf19 return} (AtEnd() && typed_other->AtEnd()) ||\par
03646          (\par
03647           current1_ == typed_other->current1_ &&\par
03648           current2_ == typed_other->current2_ &&\par
03649           current3_ == typed_other->current3_ &&\par
03650           current4_ == typed_other->current4_ &&\par
03651           current5_ == typed_other->current5_);\par
03652     \}\par
03653 \par
03654    {\cf17 private}:\par
03655     Iterator({\cf17 const} Iterator& other)\par
03656         : base_(other.base_),\par
03657         begin1_(other.begin1_),\par
03658         end1_(other.end1_),\par
03659         current1_(other.current1_),\par
03660         begin2_(other.begin2_),\par
03661         end2_(other.end2_),\par
03662         current2_(other.current2_),\par
03663         begin3_(other.begin3_),\par
03664         end3_(other.end3_),\par
03665         current3_(other.current3_),\par
03666         begin4_(other.begin4_),\par
03667         end4_(other.end4_),\par
03668         current4_(other.current4_),\par
03669         begin5_(other.begin5_),\par
03670         end5_(other.end5_),\par
03671         current5_(other.current5_) \{\par
03672       ComputeCurrentValue();\par
03673     \}\par
03674 \par
03675     {\cf18 void} ComputeCurrentValue() \{\par
03676       {\cf19 if} (!AtEnd())\par
03677         current_value_ = ParamType(*current1_, *current2_, *current3_,\par
03678             *current4_, *current5_);\par
03679     \}\par
03680     {\cf18 bool} AtEnd(){\cf17  const }\{\par
03681       {\cf20 // We must report iterator past the end of the range when either of the}\par
03682       {\cf20 // component iterators has reached the end of its range.}\par
03683       {\cf19 return}\par
03684           current1_ == end1_ ||\par
03685           current2_ == end2_ ||\par
03686           current3_ == end3_ ||\par
03687           current4_ == end4_ ||\par
03688           current5_ == end5_;\par
03689     \}\par
03690 \par
03691     {\cf20 // No implementation - assignment is unsupported.}\par
03692     {\cf18 void} operator=({\cf17 const} Iterator& other);\par
03693 \par
03694     {\cf17 const} ParamGeneratorInterface<ParamType>* {\cf17 const} base_;\par
03695     {\cf20 // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.}\par
03696     {\cf20 // current[i]_ is the actual traversing iterator.}\par
03697     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator begin1_;\par
03698     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator end1_;\par
03699     {\cf17 typename} ParamGenerator<T1>::iterator current1_;\par
03700     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator begin2_;\par
03701     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator end2_;\par
03702     {\cf17 typename} ParamGenerator<T2>::iterator current2_;\par
03703     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator begin3_;\par
03704     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator end3_;\par
03705     {\cf17 typename} ParamGenerator<T3>::iterator current3_;\par
03706     {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator begin4_;\par
03707     {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator end4_;\par
03708     {\cf17 typename} ParamGenerator<T4>::iterator current4_;\par
03709     {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator begin5_;\par
03710     {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator end5_;\par
03711     {\cf17 typename} ParamGenerator<T5>::iterator current5_;\par
03712     ParamType current_value_;\par
03713   \};  {\cf20 // class CartesianProductGenerator5::Iterator}\par
03714 \par
03715   {\cf20 // No implementation - assignment is unsupported.}\par
03716   {\cf18 void} operator=({\cf17 const} CartesianProductGenerator5& other);\par
03717 \par
03718   {\cf17 const} ParamGenerator<T1> g1_;\par
03719   {\cf17 const} ParamGenerator<T2> g2_;\par
03720   {\cf17 const} ParamGenerator<T3> g3_;\par
03721   {\cf17 const} ParamGenerator<T4> g4_;\par
03722   {\cf17 const} ParamGenerator<T5> g5_;\par
03723 \};  {\cf20 // class CartesianProductGenerator5}\par
03724 \par
03725 \par
03726 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
03727     {\cf17 typename} T6>\par
03728 {\cf17 class }CartesianProductGenerator6\par
03729     : {\cf17 public} ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5,\par
03730         T6> > \{\par
03731  {\cf17 public}:\par
03732   typedef ::testing::tuple<T1, T2, T3, T4, T5, T6> ParamType;\par
03733 \par
03734   CartesianProductGenerator6({\cf17 const} ParamGenerator<T1>& g1,\par
03735       {\cf17 const} ParamGenerator<T2>& g2, {\cf17 const} ParamGenerator<T3>& g3,\par
03736       {\cf17 const} ParamGenerator<T4>& g4, {\cf17 const} ParamGenerator<T5>& g5,\par
03737       {\cf17 const} ParamGenerator<T6>& g6)\par
03738       : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6) \{\}\par
03739   {\cf17 virtual} ~CartesianProductGenerator6() \{\}\par
03740 \par
03741   {\cf17 virtual} ParamIteratorInterface<ParamType>* Begin(){\cf17  const }\{\par
03742     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\par
03743         g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin());\par
03744   \}\par
03745   {\cf17 virtual} ParamIteratorInterface<ParamType>* End(){\cf17  const }\{\par
03746     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\par
03747         g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end());\par
03748   \}\par
03749 \par
03750  {\cf17 private}:\par
03751   {\cf17 class }Iterator : {\cf17 public} ParamIteratorInterface<ParamType> \{\par
03752    {\cf17 public}:\par
03753     Iterator({\cf17 const} ParamGeneratorInterface<ParamType>* base,\par
03754       {\cf17 const} ParamGenerator<T1>& g1,\par
03755       {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator& current1,\par
03756       {\cf17 const} ParamGenerator<T2>& g2,\par
03757       {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator& current2,\par
03758       {\cf17 const} ParamGenerator<T3>& g3,\par
03759       {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator& current3,\par
03760       {\cf17 const} ParamGenerator<T4>& g4,\par
03761       {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator& current4,\par
03762       {\cf17 const} ParamGenerator<T5>& g5,\par
03763       {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator& current5,\par
03764       {\cf17 const} ParamGenerator<T6>& g6,\par
03765       {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator& current6)\par
03766         : base_(base),\par
03767           begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\par
03768           begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\par
03769           begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\par
03770           begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\par
03771           begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\par
03772           begin6_(g6.begin()), end6_(g6.end()), current6_(current6)    \{\par
03773       ComputeCurrentValue();\par
03774     \}\par
03775     {\cf17 virtual} ~Iterator() \{\}\par
03776 \par
03777     {\cf17 virtual} {\cf17 const} ParamGeneratorInterface<ParamType>* BaseGenerator(){\cf17  const }\{\par
03778       {\cf19 return} base_;\par
03779     \}\par
03780     {\cf20 // Advance should not be called on beyond-of-range iterators}\par
03781     {\cf20 // so no component iterators must be beyond end of range, either.}\par
03782     {\cf17 virtual} {\cf18 void} Advance() \{\par
03783       assert(!AtEnd());\par
03784       ++current6_;\par
03785       {\cf19 if} (current6_ == end6_) \{\par
03786         current6_ = begin6_;\par
03787         ++current5_;\par
03788       \}\par
03789       {\cf19 if} (current5_ == end5_) \{\par
03790         current5_ = begin5_;\par
03791         ++current4_;\par
03792       \}\par
03793       {\cf19 if} (current4_ == end4_) \{\par
03794         current4_ = begin4_;\par
03795         ++current3_;\par
03796       \}\par
03797       {\cf19 if} (current3_ == end3_) \{\par
03798         current3_ = begin3_;\par
03799         ++current2_;\par
03800       \}\par
03801       {\cf19 if} (current2_ == end2_) \{\par
03802         current2_ = begin2_;\par
03803         ++current1_;\par
03804       \}\par
03805       ComputeCurrentValue();\par
03806     \}\par
03807     {\cf17 virtual} ParamIteratorInterface<ParamType>* Clone(){\cf17  const }\{\par
03808       {\cf19 return} {\cf17 new} Iterator(*{\cf17 this});\par
03809     \}\par
03810     {\cf17 virtual} {\cf17 const} ParamType* Current(){\cf17  const }\{ {\cf19 return} &current_value_; \}\par
03811     {\cf17 virtual} {\cf18 bool} Equals({\cf17 const} ParamIteratorInterface<ParamType>& other){\cf17  const }\{\par
03812       {\cf20 // Having the same base generator guarantees that the other}\par
03813       {\cf20 // iterator is of the same type and we can downcast.}\par
03814       GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\par
03815           << {\cf22 "The program attempted to compare iterators "}\par
03816           << {\cf22 "from different generators."} << std::endl;\par
03817       {\cf17 const} Iterator* typed_other =\par
03818           CheckedDowncastToActualType<const Iterator>(&other);\par
03819       {\cf20 // We must report iterators equal if they both point beyond their}\par
03820       {\cf20 // respective ranges. That can happen in a variety of fashions,}\par
03821       {\cf20 // so we have to consult AtEnd().}\par
03822       {\cf19 return} (AtEnd() && typed_other->AtEnd()) ||\par
03823          (\par
03824           current1_ == typed_other->current1_ &&\par
03825           current2_ == typed_other->current2_ &&\par
03826           current3_ == typed_other->current3_ &&\par
03827           current4_ == typed_other->current4_ &&\par
03828           current5_ == typed_other->current5_ &&\par
03829           current6_ == typed_other->current6_);\par
03830     \}\par
03831 \par
03832    {\cf17 private}:\par
03833     Iterator({\cf17 const} Iterator& other)\par
03834         : base_(other.base_),\par
03835         begin1_(other.begin1_),\par
03836         end1_(other.end1_),\par
03837         current1_(other.current1_),\par
03838         begin2_(other.begin2_),\par
03839         end2_(other.end2_),\par
03840         current2_(other.current2_),\par
03841         begin3_(other.begin3_),\par
03842         end3_(other.end3_),\par
03843         current3_(other.current3_),\par
03844         begin4_(other.begin4_),\par
03845         end4_(other.end4_),\par
03846         current4_(other.current4_),\par
03847         begin5_(other.begin5_),\par
03848         end5_(other.end5_),\par
03849         current5_(other.current5_),\par
03850         begin6_(other.begin6_),\par
03851         end6_(other.end6_),\par
03852         current6_(other.current6_) \{\par
03853       ComputeCurrentValue();\par
03854     \}\par
03855 \par
03856     {\cf18 void} ComputeCurrentValue() \{\par
03857       {\cf19 if} (!AtEnd())\par
03858         current_value_ = ParamType(*current1_, *current2_, *current3_,\par
03859             *current4_, *current5_, *current6_);\par
03860     \}\par
03861     {\cf18 bool} AtEnd(){\cf17  const }\{\par
03862       {\cf20 // We must report iterator past the end of the range when either of the}\par
03863       {\cf20 // component iterators has reached the end of its range.}\par
03864       {\cf19 return}\par
03865           current1_ == end1_ ||\par
03866           current2_ == end2_ ||\par
03867           current3_ == end3_ ||\par
03868           current4_ == end4_ ||\par
03869           current5_ == end5_ ||\par
03870           current6_ == end6_;\par
03871     \}\par
03872 \par
03873     {\cf20 // No implementation - assignment is unsupported.}\par
03874     {\cf18 void} operator=({\cf17 const} Iterator& other);\par
03875 \par
03876     {\cf17 const} ParamGeneratorInterface<ParamType>* {\cf17 const} base_;\par
03877     {\cf20 // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.}\par
03878     {\cf20 // current[i]_ is the actual traversing iterator.}\par
03879     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator begin1_;\par
03880     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator end1_;\par
03881     {\cf17 typename} ParamGenerator<T1>::iterator current1_;\par
03882     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator begin2_;\par
03883     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator end2_;\par
03884     {\cf17 typename} ParamGenerator<T2>::iterator current2_;\par
03885     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator begin3_;\par
03886     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator end3_;\par
03887     {\cf17 typename} ParamGenerator<T3>::iterator current3_;\par
03888     {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator begin4_;\par
03889     {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator end4_;\par
03890     {\cf17 typename} ParamGenerator<T4>::iterator current4_;\par
03891     {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator begin5_;\par
03892     {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator end5_;\par
03893     {\cf17 typename} ParamGenerator<T5>::iterator current5_;\par
03894     {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator begin6_;\par
03895     {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator end6_;\par
03896     {\cf17 typename} ParamGenerator<T6>::iterator current6_;\par
03897     ParamType current_value_;\par
03898   \};  {\cf20 // class CartesianProductGenerator6::Iterator}\par
03899 \par
03900   {\cf20 // No implementation - assignment is unsupported.}\par
03901   {\cf18 void} operator=({\cf17 const} CartesianProductGenerator6& other);\par
03902 \par
03903   {\cf17 const} ParamGenerator<T1> g1_;\par
03904   {\cf17 const} ParamGenerator<T2> g2_;\par
03905   {\cf17 const} ParamGenerator<T3> g3_;\par
03906   {\cf17 const} ParamGenerator<T4> g4_;\par
03907   {\cf17 const} ParamGenerator<T5> g5_;\par
03908   {\cf17 const} ParamGenerator<T6> g6_;\par
03909 \};  {\cf20 // class CartesianProductGenerator6}\par
03910 \par
03911 \par
03912 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
03913     {\cf17 typename} T6, {\cf17 typename} T7>\par
03914 {\cf17 class }CartesianProductGenerator7\par
03915     : {\cf17 public} ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,\par
03916         T7> > \{\par
03917  {\cf17 public}:\par
03918   typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7> ParamType;\par
03919 \par
03920   CartesianProductGenerator7({\cf17 const} ParamGenerator<T1>& g1,\par
03921       {\cf17 const} ParamGenerator<T2>& g2, {\cf17 const} ParamGenerator<T3>& g3,\par
03922       {\cf17 const} ParamGenerator<T4>& g4, {\cf17 const} ParamGenerator<T5>& g5,\par
03923       {\cf17 const} ParamGenerator<T6>& g6, {\cf17 const} ParamGenerator<T7>& g7)\par
03924       : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7) \{\}\par
03925   {\cf17 virtual} ~CartesianProductGenerator7() \{\}\par
03926 \par
03927   {\cf17 virtual} ParamIteratorInterface<ParamType>* Begin(){\cf17  const }\{\par
03928     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\par
03929         g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,\par
03930         g7_.begin());\par
03931   \}\par
03932   {\cf17 virtual} ParamIteratorInterface<ParamType>* End(){\cf17  const }\{\par
03933     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\par
03934         g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end());\par
03935   \}\par
03936 \par
03937  {\cf17 private}:\par
03938   {\cf17 class }Iterator : {\cf17 public} ParamIteratorInterface<ParamType> \{\par
03939    {\cf17 public}:\par
03940     Iterator({\cf17 const} ParamGeneratorInterface<ParamType>* base,\par
03941       {\cf17 const} ParamGenerator<T1>& g1,\par
03942       {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator& current1,\par
03943       {\cf17 const} ParamGenerator<T2>& g2,\par
03944       {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator& current2,\par
03945       {\cf17 const} ParamGenerator<T3>& g3,\par
03946       {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator& current3,\par
03947       {\cf17 const} ParamGenerator<T4>& g4,\par
03948       {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator& current4,\par
03949       {\cf17 const} ParamGenerator<T5>& g5,\par
03950       {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator& current5,\par
03951       {\cf17 const} ParamGenerator<T6>& g6,\par
03952       {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator& current6,\par
03953       {\cf17 const} ParamGenerator<T7>& g7,\par
03954       {\cf17 const} {\cf17 typename} ParamGenerator<T7>::iterator& current7)\par
03955         : base_(base),\par
03956           begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\par
03957           begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\par
03958           begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\par
03959           begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\par
03960           begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\par
03961           begin6_(g6.begin()), end6_(g6.end()), current6_(current6),\par
03962           begin7_(g7.begin()), end7_(g7.end()), current7_(current7)    \{\par
03963       ComputeCurrentValue();\par
03964     \}\par
03965     {\cf17 virtual} ~Iterator() \{\}\par
03966 \par
03967     {\cf17 virtual} {\cf17 const} ParamGeneratorInterface<ParamType>* BaseGenerator(){\cf17  const }\{\par
03968       {\cf19 return} base_;\par
03969     \}\par
03970     {\cf20 // Advance should not be called on beyond-of-range iterators}\par
03971     {\cf20 // so no component iterators must be beyond end of range, either.}\par
03972     {\cf17 virtual} {\cf18 void} Advance() \{\par
03973       assert(!AtEnd());\par
03974       ++current7_;\par
03975       {\cf19 if} (current7_ == end7_) \{\par
03976         current7_ = begin7_;\par
03977         ++current6_;\par
03978       \}\par
03979       {\cf19 if} (current6_ == end6_) \{\par
03980         current6_ = begin6_;\par
03981         ++current5_;\par
03982       \}\par
03983       {\cf19 if} (current5_ == end5_) \{\par
03984         current5_ = begin5_;\par
03985         ++current4_;\par
03986       \}\par
03987       {\cf19 if} (current4_ == end4_) \{\par
03988         current4_ = begin4_;\par
03989         ++current3_;\par
03990       \}\par
03991       {\cf19 if} (current3_ == end3_) \{\par
03992         current3_ = begin3_;\par
03993         ++current2_;\par
03994       \}\par
03995       {\cf19 if} (current2_ == end2_) \{\par
03996         current2_ = begin2_;\par
03997         ++current1_;\par
03998       \}\par
03999       ComputeCurrentValue();\par
04000     \}\par
04001     {\cf17 virtual} ParamIteratorInterface<ParamType>* Clone(){\cf17  const }\{\par
04002       {\cf19 return} {\cf17 new} Iterator(*{\cf17 this});\par
04003     \}\par
04004     {\cf17 virtual} {\cf17 const} ParamType* Current(){\cf17  const }\{ {\cf19 return} &current_value_; \}\par
04005     {\cf17 virtual} {\cf18 bool} Equals({\cf17 const} ParamIteratorInterface<ParamType>& other){\cf17  const }\{\par
04006       {\cf20 // Having the same base generator guarantees that the other}\par
04007       {\cf20 // iterator is of the same type and we can downcast.}\par
04008       GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\par
04009           << {\cf22 "The program attempted to compare iterators "}\par
04010           << {\cf22 "from different generators."} << std::endl;\par
04011       {\cf17 const} Iterator* typed_other =\par
04012           CheckedDowncastToActualType<const Iterator>(&other);\par
04013       {\cf20 // We must report iterators equal if they both point beyond their}\par
04014       {\cf20 // respective ranges. That can happen in a variety of fashions,}\par
04015       {\cf20 // so we have to consult AtEnd().}\par
04016       {\cf19 return} (AtEnd() && typed_other->AtEnd()) ||\par
04017          (\par
04018           current1_ == typed_other->current1_ &&\par
04019           current2_ == typed_other->current2_ &&\par
04020           current3_ == typed_other->current3_ &&\par
04021           current4_ == typed_other->current4_ &&\par
04022           current5_ == typed_other->current5_ &&\par
04023           current6_ == typed_other->current6_ &&\par
04024           current7_ == typed_other->current7_);\par
04025     \}\par
04026 \par
04027    {\cf17 private}:\par
04028     Iterator({\cf17 const} Iterator& other)\par
04029         : base_(other.base_),\par
04030         begin1_(other.begin1_),\par
04031         end1_(other.end1_),\par
04032         current1_(other.current1_),\par
04033         begin2_(other.begin2_),\par
04034         end2_(other.end2_),\par
04035         current2_(other.current2_),\par
04036         begin3_(other.begin3_),\par
04037         end3_(other.end3_),\par
04038         current3_(other.current3_),\par
04039         begin4_(other.begin4_),\par
04040         end4_(other.end4_),\par
04041         current4_(other.current4_),\par
04042         begin5_(other.begin5_),\par
04043         end5_(other.end5_),\par
04044         current5_(other.current5_),\par
04045         begin6_(other.begin6_),\par
04046         end6_(other.end6_),\par
04047         current6_(other.current6_),\par
04048         begin7_(other.begin7_),\par
04049         end7_(other.end7_),\par
04050         current7_(other.current7_) \{\par
04051       ComputeCurrentValue();\par
04052     \}\par
04053 \par
04054     {\cf18 void} ComputeCurrentValue() \{\par
04055       {\cf19 if} (!AtEnd())\par
04056         current_value_ = ParamType(*current1_, *current2_, *current3_,\par
04057             *current4_, *current5_, *current6_, *current7_);\par
04058     \}\par
04059     {\cf18 bool} AtEnd(){\cf17  const }\{\par
04060       {\cf20 // We must report iterator past the end of the range when either of the}\par
04061       {\cf20 // component iterators has reached the end of its range.}\par
04062       {\cf19 return}\par
04063           current1_ == end1_ ||\par
04064           current2_ == end2_ ||\par
04065           current3_ == end3_ ||\par
04066           current4_ == end4_ ||\par
04067           current5_ == end5_ ||\par
04068           current6_ == end6_ ||\par
04069           current7_ == end7_;\par
04070     \}\par
04071 \par
04072     {\cf20 // No implementation - assignment is unsupported.}\par
04073     {\cf18 void} operator=({\cf17 const} Iterator& other);\par
04074 \par
04075     {\cf17 const} ParamGeneratorInterface<ParamType>* {\cf17 const} base_;\par
04076     {\cf20 // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.}\par
04077     {\cf20 // current[i]_ is the actual traversing iterator.}\par
04078     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator begin1_;\par
04079     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator end1_;\par
04080     {\cf17 typename} ParamGenerator<T1>::iterator current1_;\par
04081     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator begin2_;\par
04082     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator end2_;\par
04083     {\cf17 typename} ParamGenerator<T2>::iterator current2_;\par
04084     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator begin3_;\par
04085     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator end3_;\par
04086     {\cf17 typename} ParamGenerator<T3>::iterator current3_;\par
04087     {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator begin4_;\par
04088     {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator end4_;\par
04089     {\cf17 typename} ParamGenerator<T4>::iterator current4_;\par
04090     {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator begin5_;\par
04091     {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator end5_;\par
04092     {\cf17 typename} ParamGenerator<T5>::iterator current5_;\par
04093     {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator begin6_;\par
04094     {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator end6_;\par
04095     {\cf17 typename} ParamGenerator<T6>::iterator current6_;\par
04096     {\cf17 const} {\cf17 typename} ParamGenerator<T7>::iterator begin7_;\par
04097     {\cf17 const} {\cf17 typename} ParamGenerator<T7>::iterator end7_;\par
04098     {\cf17 typename} ParamGenerator<T7>::iterator current7_;\par
04099     ParamType current_value_;\par
04100   \};  {\cf20 // class CartesianProductGenerator7::Iterator}\par
04101 \par
04102   {\cf20 // No implementation - assignment is unsupported.}\par
04103   {\cf18 void} operator=({\cf17 const} CartesianProductGenerator7& other);\par
04104 \par
04105   {\cf17 const} ParamGenerator<T1> g1_;\par
04106   {\cf17 const} ParamGenerator<T2> g2_;\par
04107   {\cf17 const} ParamGenerator<T3> g3_;\par
04108   {\cf17 const} ParamGenerator<T4> g4_;\par
04109   {\cf17 const} ParamGenerator<T5> g5_;\par
04110   {\cf17 const} ParamGenerator<T6> g6_;\par
04111   {\cf17 const} ParamGenerator<T7> g7_;\par
04112 \};  {\cf20 // class CartesianProductGenerator7}\par
04113 \par
04114 \par
04115 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
04116     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8>\par
04117 {\cf17 class }CartesianProductGenerator8\par
04118     : {\cf17 public} ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,\par
04119         T7, T8> > \{\par
04120  {\cf17 public}:\par
04121   typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8> ParamType;\par
04122 \par
04123   CartesianProductGenerator8({\cf17 const} ParamGenerator<T1>& g1,\par
04124       {\cf17 const} ParamGenerator<T2>& g2, {\cf17 const} ParamGenerator<T3>& g3,\par
04125       {\cf17 const} ParamGenerator<T4>& g4, {\cf17 const} ParamGenerator<T5>& g5,\par
04126       {\cf17 const} ParamGenerator<T6>& g6, {\cf17 const} ParamGenerator<T7>& g7,\par
04127       {\cf17 const} ParamGenerator<T8>& g8)\par
04128       : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7),\par
04129           g8_(g8) \{\}\par
04130   {\cf17 virtual} ~CartesianProductGenerator8() \{\}\par
04131 \par
04132   {\cf17 virtual} ParamIteratorInterface<ParamType>* Begin(){\cf17  const }\{\par
04133     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\par
04134         g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,\par
04135         g7_.begin(), g8_, g8_.begin());\par
04136   \}\par
04137   {\cf17 virtual} ParamIteratorInterface<ParamType>* End(){\cf17  const }\{\par
04138     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\par
04139         g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,\par
04140         g8_.end());\par
04141   \}\par
04142 \par
04143  {\cf17 private}:\par
04144   {\cf17 class }Iterator : {\cf17 public} ParamIteratorInterface<ParamType> \{\par
04145    {\cf17 public}:\par
04146     Iterator({\cf17 const} ParamGeneratorInterface<ParamType>* base,\par
04147       {\cf17 const} ParamGenerator<T1>& g1,\par
04148       {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator& current1,\par
04149       {\cf17 const} ParamGenerator<T2>& g2,\par
04150       {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator& current2,\par
04151       {\cf17 const} ParamGenerator<T3>& g3,\par
04152       {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator& current3,\par
04153       {\cf17 const} ParamGenerator<T4>& g4,\par
04154       {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator& current4,\par
04155       {\cf17 const} ParamGenerator<T5>& g5,\par
04156       {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator& current5,\par
04157       {\cf17 const} ParamGenerator<T6>& g6,\par
04158       {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator& current6,\par
04159       {\cf17 const} ParamGenerator<T7>& g7,\par
04160       {\cf17 const} {\cf17 typename} ParamGenerator<T7>::iterator& current7,\par
04161       {\cf17 const} ParamGenerator<T8>& g8,\par
04162       {\cf17 const} {\cf17 typename} ParamGenerator<T8>::iterator& current8)\par
04163         : base_(base),\par
04164           begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\par
04165           begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\par
04166           begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\par
04167           begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\par
04168           begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\par
04169           begin6_(g6.begin()), end6_(g6.end()), current6_(current6),\par
04170           begin7_(g7.begin()), end7_(g7.end()), current7_(current7),\par
04171           begin8_(g8.begin()), end8_(g8.end()), current8_(current8)    \{\par
04172       ComputeCurrentValue();\par
04173     \}\par
04174     {\cf17 virtual} ~Iterator() \{\}\par
04175 \par
04176     {\cf17 virtual} {\cf17 const} ParamGeneratorInterface<ParamType>* BaseGenerator(){\cf17  const }\{\par
04177       {\cf19 return} base_;\par
04178     \}\par
04179     {\cf20 // Advance should not be called on beyond-of-range iterators}\par
04180     {\cf20 // so no component iterators must be beyond end of range, either.}\par
04181     {\cf17 virtual} {\cf18 void} Advance() \{\par
04182       assert(!AtEnd());\par
04183       ++current8_;\par
04184       {\cf19 if} (current8_ == end8_) \{\par
04185         current8_ = begin8_;\par
04186         ++current7_;\par
04187       \}\par
04188       {\cf19 if} (current7_ == end7_) \{\par
04189         current7_ = begin7_;\par
04190         ++current6_;\par
04191       \}\par
04192       {\cf19 if} (current6_ == end6_) \{\par
04193         current6_ = begin6_;\par
04194         ++current5_;\par
04195       \}\par
04196       {\cf19 if} (current5_ == end5_) \{\par
04197         current5_ = begin5_;\par
04198         ++current4_;\par
04199       \}\par
04200       {\cf19 if} (current4_ == end4_) \{\par
04201         current4_ = begin4_;\par
04202         ++current3_;\par
04203       \}\par
04204       {\cf19 if} (current3_ == end3_) \{\par
04205         current3_ = begin3_;\par
04206         ++current2_;\par
04207       \}\par
04208       {\cf19 if} (current2_ == end2_) \{\par
04209         current2_ = begin2_;\par
04210         ++current1_;\par
04211       \}\par
04212       ComputeCurrentValue();\par
04213     \}\par
04214     {\cf17 virtual} ParamIteratorInterface<ParamType>* Clone(){\cf17  const }\{\par
04215       {\cf19 return} {\cf17 new} Iterator(*{\cf17 this});\par
04216     \}\par
04217     {\cf17 virtual} {\cf17 const} ParamType* Current(){\cf17  const }\{ {\cf19 return} &current_value_; \}\par
04218     {\cf17 virtual} {\cf18 bool} Equals({\cf17 const} ParamIteratorInterface<ParamType>& other){\cf17  const }\{\par
04219       {\cf20 // Having the same base generator guarantees that the other}\par
04220       {\cf20 // iterator is of the same type and we can downcast.}\par
04221       GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\par
04222           << {\cf22 "The program attempted to compare iterators "}\par
04223           << {\cf22 "from different generators."} << std::endl;\par
04224       {\cf17 const} Iterator* typed_other =\par
04225           CheckedDowncastToActualType<const Iterator>(&other);\par
04226       {\cf20 // We must report iterators equal if they both point beyond their}\par
04227       {\cf20 // respective ranges. That can happen in a variety of fashions,}\par
04228       {\cf20 // so we have to consult AtEnd().}\par
04229       {\cf19 return} (AtEnd() && typed_other->AtEnd()) ||\par
04230          (\par
04231           current1_ == typed_other->current1_ &&\par
04232           current2_ == typed_other->current2_ &&\par
04233           current3_ == typed_other->current3_ &&\par
04234           current4_ == typed_other->current4_ &&\par
04235           current5_ == typed_other->current5_ &&\par
04236           current6_ == typed_other->current6_ &&\par
04237           current7_ == typed_other->current7_ &&\par
04238           current8_ == typed_other->current8_);\par
04239     \}\par
04240 \par
04241    {\cf17 private}:\par
04242     Iterator({\cf17 const} Iterator& other)\par
04243         : base_(other.base_),\par
04244         begin1_(other.begin1_),\par
04245         end1_(other.end1_),\par
04246         current1_(other.current1_),\par
04247         begin2_(other.begin2_),\par
04248         end2_(other.end2_),\par
04249         current2_(other.current2_),\par
04250         begin3_(other.begin3_),\par
04251         end3_(other.end3_),\par
04252         current3_(other.current3_),\par
04253         begin4_(other.begin4_),\par
04254         end4_(other.end4_),\par
04255         current4_(other.current4_),\par
04256         begin5_(other.begin5_),\par
04257         end5_(other.end5_),\par
04258         current5_(other.current5_),\par
04259         begin6_(other.begin6_),\par
04260         end6_(other.end6_),\par
04261         current6_(other.current6_),\par
04262         begin7_(other.begin7_),\par
04263         end7_(other.end7_),\par
04264         current7_(other.current7_),\par
04265         begin8_(other.begin8_),\par
04266         end8_(other.end8_),\par
04267         current8_(other.current8_) \{\par
04268       ComputeCurrentValue();\par
04269     \}\par
04270 \par
04271     {\cf18 void} ComputeCurrentValue() \{\par
04272       {\cf19 if} (!AtEnd())\par
04273         current_value_ = ParamType(*current1_, *current2_, *current3_,\par
04274             *current4_, *current5_, *current6_, *current7_, *current8_);\par
04275     \}\par
04276     {\cf18 bool} AtEnd(){\cf17  const }\{\par
04277       {\cf20 // We must report iterator past the end of the range when either of the}\par
04278       {\cf20 // component iterators has reached the end of its range.}\par
04279       {\cf19 return}\par
04280           current1_ == end1_ ||\par
04281           current2_ == end2_ ||\par
04282           current3_ == end3_ ||\par
04283           current4_ == end4_ ||\par
04284           current5_ == end5_ ||\par
04285           current6_ == end6_ ||\par
04286           current7_ == end7_ ||\par
04287           current8_ == end8_;\par
04288     \}\par
04289 \par
04290     {\cf20 // No implementation - assignment is unsupported.}\par
04291     {\cf18 void} operator=({\cf17 const} Iterator& other);\par
04292 \par
04293     {\cf17 const} ParamGeneratorInterface<ParamType>* {\cf17 const} base_;\par
04294     {\cf20 // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.}\par
04295     {\cf20 // current[i]_ is the actual traversing iterator.}\par
04296     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator begin1_;\par
04297     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator end1_;\par
04298     {\cf17 typename} ParamGenerator<T1>::iterator current1_;\par
04299     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator begin2_;\par
04300     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator end2_;\par
04301     {\cf17 typename} ParamGenerator<T2>::iterator current2_;\par
04302     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator begin3_;\par
04303     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator end3_;\par
04304     {\cf17 typename} ParamGenerator<T3>::iterator current3_;\par
04305     {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator begin4_;\par
04306     {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator end4_;\par
04307     {\cf17 typename} ParamGenerator<T4>::iterator current4_;\par
04308     {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator begin5_;\par
04309     {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator end5_;\par
04310     {\cf17 typename} ParamGenerator<T5>::iterator current5_;\par
04311     {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator begin6_;\par
04312     {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator end6_;\par
04313     {\cf17 typename} ParamGenerator<T6>::iterator current6_;\par
04314     {\cf17 const} {\cf17 typename} ParamGenerator<T7>::iterator begin7_;\par
04315     {\cf17 const} {\cf17 typename} ParamGenerator<T7>::iterator end7_;\par
04316     {\cf17 typename} ParamGenerator<T7>::iterator current7_;\par
04317     {\cf17 const} {\cf17 typename} ParamGenerator<T8>::iterator begin8_;\par
04318     {\cf17 const} {\cf17 typename} ParamGenerator<T8>::iterator end8_;\par
04319     {\cf17 typename} ParamGenerator<T8>::iterator current8_;\par
04320     ParamType current_value_;\par
04321   \};  {\cf20 // class CartesianProductGenerator8::Iterator}\par
04322 \par
04323   {\cf20 // No implementation - assignment is unsupported.}\par
04324   {\cf18 void} operator=({\cf17 const} CartesianProductGenerator8& other);\par
04325 \par
04326   {\cf17 const} ParamGenerator<T1> g1_;\par
04327   {\cf17 const} ParamGenerator<T2> g2_;\par
04328   {\cf17 const} ParamGenerator<T3> g3_;\par
04329   {\cf17 const} ParamGenerator<T4> g4_;\par
04330   {\cf17 const} ParamGenerator<T5> g5_;\par
04331   {\cf17 const} ParamGenerator<T6> g6_;\par
04332   {\cf17 const} ParamGenerator<T7> g7_;\par
04333   {\cf17 const} ParamGenerator<T8> g8_;\par
04334 \};  {\cf20 // class CartesianProductGenerator8}\par
04335 \par
04336 \par
04337 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
04338     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9>\par
04339 {\cf17 class }CartesianProductGenerator9\par
04340     : {\cf17 public} ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,\par
04341         T7, T8, T9> > \{\par
04342  {\cf17 public}:\par
04343   typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9> ParamType;\par
04344 \par
04345   CartesianProductGenerator9({\cf17 const} ParamGenerator<T1>& g1,\par
04346       {\cf17 const} ParamGenerator<T2>& g2, {\cf17 const} ParamGenerator<T3>& g3,\par
04347       {\cf17 const} ParamGenerator<T4>& g4, {\cf17 const} ParamGenerator<T5>& g5,\par
04348       {\cf17 const} ParamGenerator<T6>& g6, {\cf17 const} ParamGenerator<T7>& g7,\par
04349       {\cf17 const} ParamGenerator<T8>& g8, {\cf17 const} ParamGenerator<T9>& g9)\par
04350       : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),\par
04351           g9_(g9) \{\}\par
04352   {\cf17 virtual} ~CartesianProductGenerator9() \{\}\par
04353 \par
04354   {\cf17 virtual} ParamIteratorInterface<ParamType>* Begin(){\cf17  const }\{\par
04355     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\par
04356         g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,\par
04357         g7_.begin(), g8_, g8_.begin(), g9_, g9_.begin());\par
04358   \}\par
04359   {\cf17 virtual} ParamIteratorInterface<ParamType>* End(){\cf17  const }\{\par
04360     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\par
04361         g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,\par
04362         g8_.end(), g9_, g9_.end());\par
04363   \}\par
04364 \par
04365  {\cf17 private}:\par
04366   {\cf17 class }Iterator : {\cf17 public} ParamIteratorInterface<ParamType> \{\par
04367    {\cf17 public}:\par
04368     Iterator({\cf17 const} ParamGeneratorInterface<ParamType>* base,\par
04369       {\cf17 const} ParamGenerator<T1>& g1,\par
04370       {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator& current1,\par
04371       {\cf17 const} ParamGenerator<T2>& g2,\par
04372       {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator& current2,\par
04373       {\cf17 const} ParamGenerator<T3>& g3,\par
04374       {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator& current3,\par
04375       {\cf17 const} ParamGenerator<T4>& g4,\par
04376       {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator& current4,\par
04377       {\cf17 const} ParamGenerator<T5>& g5,\par
04378       {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator& current5,\par
04379       {\cf17 const} ParamGenerator<T6>& g6,\par
04380       {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator& current6,\par
04381       {\cf17 const} ParamGenerator<T7>& g7,\par
04382       {\cf17 const} {\cf17 typename} ParamGenerator<T7>::iterator& current7,\par
04383       {\cf17 const} ParamGenerator<T8>& g8,\par
04384       {\cf17 const} {\cf17 typename} ParamGenerator<T8>::iterator& current8,\par
04385       {\cf17 const} ParamGenerator<T9>& g9,\par
04386       {\cf17 const} {\cf17 typename} ParamGenerator<T9>::iterator& current9)\par
04387         : base_(base),\par
04388           begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\par
04389           begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\par
04390           begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\par
04391           begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\par
04392           begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\par
04393           begin6_(g6.begin()), end6_(g6.end()), current6_(current6),\par
04394           begin7_(g7.begin()), end7_(g7.end()), current7_(current7),\par
04395           begin8_(g8.begin()), end8_(g8.end()), current8_(current8),\par
04396           begin9_(g9.begin()), end9_(g9.end()), current9_(current9)    \{\par
04397       ComputeCurrentValue();\par
04398     \}\par
04399     {\cf17 virtual} ~Iterator() \{\}\par
04400 \par
04401     {\cf17 virtual} {\cf17 const} ParamGeneratorInterface<ParamType>* BaseGenerator(){\cf17  const }\{\par
04402       {\cf19 return} base_;\par
04403     \}\par
04404     {\cf20 // Advance should not be called on beyond-of-range iterators}\par
04405     {\cf20 // so no component iterators must be beyond end of range, either.}\par
04406     {\cf17 virtual} {\cf18 void} Advance() \{\par
04407       assert(!AtEnd());\par
04408       ++current9_;\par
04409       {\cf19 if} (current9_ == end9_) \{\par
04410         current9_ = begin9_;\par
04411         ++current8_;\par
04412       \}\par
04413       {\cf19 if} (current8_ == end8_) \{\par
04414         current8_ = begin8_;\par
04415         ++current7_;\par
04416       \}\par
04417       {\cf19 if} (current7_ == end7_) \{\par
04418         current7_ = begin7_;\par
04419         ++current6_;\par
04420       \}\par
04421       {\cf19 if} (current6_ == end6_) \{\par
04422         current6_ = begin6_;\par
04423         ++current5_;\par
04424       \}\par
04425       {\cf19 if} (current5_ == end5_) \{\par
04426         current5_ = begin5_;\par
04427         ++current4_;\par
04428       \}\par
04429       {\cf19 if} (current4_ == end4_) \{\par
04430         current4_ = begin4_;\par
04431         ++current3_;\par
04432       \}\par
04433       {\cf19 if} (current3_ == end3_) \{\par
04434         current3_ = begin3_;\par
04435         ++current2_;\par
04436       \}\par
04437       {\cf19 if} (current2_ == end2_) \{\par
04438         current2_ = begin2_;\par
04439         ++current1_;\par
04440       \}\par
04441       ComputeCurrentValue();\par
04442     \}\par
04443     {\cf17 virtual} ParamIteratorInterface<ParamType>* Clone(){\cf17  const }\{\par
04444       {\cf19 return} {\cf17 new} Iterator(*{\cf17 this});\par
04445     \}\par
04446     {\cf17 virtual} {\cf17 const} ParamType* Current(){\cf17  const }\{ {\cf19 return} &current_value_; \}\par
04447     {\cf17 virtual} {\cf18 bool} Equals({\cf17 const} ParamIteratorInterface<ParamType>& other){\cf17  const }\{\par
04448       {\cf20 // Having the same base generator guarantees that the other}\par
04449       {\cf20 // iterator is of the same type and we can downcast.}\par
04450       GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\par
04451           << {\cf22 "The program attempted to compare iterators "}\par
04452           << {\cf22 "from different generators."} << std::endl;\par
04453       {\cf17 const} Iterator* typed_other =\par
04454           CheckedDowncastToActualType<const Iterator>(&other);\par
04455       {\cf20 // We must report iterators equal if they both point beyond their}\par
04456       {\cf20 // respective ranges. That can happen in a variety of fashions,}\par
04457       {\cf20 // so we have to consult AtEnd().}\par
04458       {\cf19 return} (AtEnd() && typed_other->AtEnd()) ||\par
04459          (\par
04460           current1_ == typed_other->current1_ &&\par
04461           current2_ == typed_other->current2_ &&\par
04462           current3_ == typed_other->current3_ &&\par
04463           current4_ == typed_other->current4_ &&\par
04464           current5_ == typed_other->current5_ &&\par
04465           current6_ == typed_other->current6_ &&\par
04466           current7_ == typed_other->current7_ &&\par
04467           current8_ == typed_other->current8_ &&\par
04468           current9_ == typed_other->current9_);\par
04469     \}\par
04470 \par
04471    {\cf17 private}:\par
04472     Iterator({\cf17 const} Iterator& other)\par
04473         : base_(other.base_),\par
04474         begin1_(other.begin1_),\par
04475         end1_(other.end1_),\par
04476         current1_(other.current1_),\par
04477         begin2_(other.begin2_),\par
04478         end2_(other.end2_),\par
04479         current2_(other.current2_),\par
04480         begin3_(other.begin3_),\par
04481         end3_(other.end3_),\par
04482         current3_(other.current3_),\par
04483         begin4_(other.begin4_),\par
04484         end4_(other.end4_),\par
04485         current4_(other.current4_),\par
04486         begin5_(other.begin5_),\par
04487         end5_(other.end5_),\par
04488         current5_(other.current5_),\par
04489         begin6_(other.begin6_),\par
04490         end6_(other.end6_),\par
04491         current6_(other.current6_),\par
04492         begin7_(other.begin7_),\par
04493         end7_(other.end7_),\par
04494         current7_(other.current7_),\par
04495         begin8_(other.begin8_),\par
04496         end8_(other.end8_),\par
04497         current8_(other.current8_),\par
04498         begin9_(other.begin9_),\par
04499         end9_(other.end9_),\par
04500         current9_(other.current9_) \{\par
04501       ComputeCurrentValue();\par
04502     \}\par
04503 \par
04504     {\cf18 void} ComputeCurrentValue() \{\par
04505       {\cf19 if} (!AtEnd())\par
04506         current_value_ = ParamType(*current1_, *current2_, *current3_,\par
04507             *current4_, *current5_, *current6_, *current7_, *current8_,\par
04508             *current9_);\par
04509     \}\par
04510     {\cf18 bool} AtEnd(){\cf17  const }\{\par
04511       {\cf20 // We must report iterator past the end of the range when either of the}\par
04512       {\cf20 // component iterators has reached the end of its range.}\par
04513       {\cf19 return}\par
04514           current1_ == end1_ ||\par
04515           current2_ == end2_ ||\par
04516           current3_ == end3_ ||\par
04517           current4_ == end4_ ||\par
04518           current5_ == end5_ ||\par
04519           current6_ == end6_ ||\par
04520           current7_ == end7_ ||\par
04521           current8_ == end8_ ||\par
04522           current9_ == end9_;\par
04523     \}\par
04524 \par
04525     {\cf20 // No implementation - assignment is unsupported.}\par
04526     {\cf18 void} operator=({\cf17 const} Iterator& other);\par
04527 \par
04528     {\cf17 const} ParamGeneratorInterface<ParamType>* {\cf17 const} base_;\par
04529     {\cf20 // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.}\par
04530     {\cf20 // current[i]_ is the actual traversing iterator.}\par
04531     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator begin1_;\par
04532     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator end1_;\par
04533     {\cf17 typename} ParamGenerator<T1>::iterator current1_;\par
04534     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator begin2_;\par
04535     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator end2_;\par
04536     {\cf17 typename} ParamGenerator<T2>::iterator current2_;\par
04537     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator begin3_;\par
04538     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator end3_;\par
04539     {\cf17 typename} ParamGenerator<T3>::iterator current3_;\par
04540     {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator begin4_;\par
04541     {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator end4_;\par
04542     {\cf17 typename} ParamGenerator<T4>::iterator current4_;\par
04543     {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator begin5_;\par
04544     {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator end5_;\par
04545     {\cf17 typename} ParamGenerator<T5>::iterator current5_;\par
04546     {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator begin6_;\par
04547     {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator end6_;\par
04548     {\cf17 typename} ParamGenerator<T6>::iterator current6_;\par
04549     {\cf17 const} {\cf17 typename} ParamGenerator<T7>::iterator begin7_;\par
04550     {\cf17 const} {\cf17 typename} ParamGenerator<T7>::iterator end7_;\par
04551     {\cf17 typename} ParamGenerator<T7>::iterator current7_;\par
04552     {\cf17 const} {\cf17 typename} ParamGenerator<T8>::iterator begin8_;\par
04553     {\cf17 const} {\cf17 typename} ParamGenerator<T8>::iterator end8_;\par
04554     {\cf17 typename} ParamGenerator<T8>::iterator current8_;\par
04555     {\cf17 const} {\cf17 typename} ParamGenerator<T9>::iterator begin9_;\par
04556     {\cf17 const} {\cf17 typename} ParamGenerator<T9>::iterator end9_;\par
04557     {\cf17 typename} ParamGenerator<T9>::iterator current9_;\par
04558     ParamType current_value_;\par
04559   \};  {\cf20 // class CartesianProductGenerator9::Iterator}\par
04560 \par
04561   {\cf20 // No implementation - assignment is unsupported.}\par
04562   {\cf18 void} operator=({\cf17 const} CartesianProductGenerator9& other);\par
04563 \par
04564   {\cf17 const} ParamGenerator<T1> g1_;\par
04565   {\cf17 const} ParamGenerator<T2> g2_;\par
04566   {\cf17 const} ParamGenerator<T3> g3_;\par
04567   {\cf17 const} ParamGenerator<T4> g4_;\par
04568   {\cf17 const} ParamGenerator<T5> g5_;\par
04569   {\cf17 const} ParamGenerator<T6> g6_;\par
04570   {\cf17 const} ParamGenerator<T7> g7_;\par
04571   {\cf17 const} ParamGenerator<T8> g8_;\par
04572   {\cf17 const} ParamGenerator<T9> g9_;\par
04573 \};  {\cf20 // class CartesianProductGenerator9}\par
04574 \par
04575 \par
04576 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
04577     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10>\par
04578 {\cf17 class }CartesianProductGenerator10\par
04579     : {\cf17 public} ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,\par
04580         T7, T8, T9, T10> > \{\par
04581  {\cf17 public}:\par
04582   typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ParamType;\par
04583 \par
04584   CartesianProductGenerator10({\cf17 const} ParamGenerator<T1>& g1,\par
04585       {\cf17 const} ParamGenerator<T2>& g2, {\cf17 const} ParamGenerator<T3>& g3,\par
04586       {\cf17 const} ParamGenerator<T4>& g4, {\cf17 const} ParamGenerator<T5>& g5,\par
04587       {\cf17 const} ParamGenerator<T6>& g6, {\cf17 const} ParamGenerator<T7>& g7,\par
04588       {\cf17 const} ParamGenerator<T8>& g8, {\cf17 const} ParamGenerator<T9>& g9,\par
04589       {\cf17 const} ParamGenerator<T10>& g10)\par
04590       : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),\par
04591           g9_(g9), g10_(g10) \{\}\par
04592   {\cf17 virtual} ~CartesianProductGenerator10() \{\}\par
04593 \par
04594   {\cf17 virtual} ParamIteratorInterface<ParamType>* Begin(){\cf17  const }\{\par
04595     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\par
04596         g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,\par
04597         g7_.begin(), g8_, g8_.begin(), g9_, g9_.begin(), g10_, g10_.begin());\par
04598   \}\par
04599   {\cf17 virtual} ParamIteratorInterface<ParamType>* End(){\cf17  const }\{\par
04600     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\par
04601         g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,\par
04602         g8_.end(), g9_, g9_.end(), g10_, g10_.end());\par
04603   \}\par
04604 \par
04605  {\cf17 private}:\par
04606   {\cf17 class }Iterator : {\cf17 public} ParamIteratorInterface<ParamType> \{\par
04607    {\cf17 public}:\par
04608     Iterator({\cf17 const} ParamGeneratorInterface<ParamType>* base,\par
04609       {\cf17 const} ParamGenerator<T1>& g1,\par
04610       {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator& current1,\par
04611       {\cf17 const} ParamGenerator<T2>& g2,\par
04612       {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator& current2,\par
04613       {\cf17 const} ParamGenerator<T3>& g3,\par
04614       {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator& current3,\par
04615       {\cf17 const} ParamGenerator<T4>& g4,\par
04616       {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator& current4,\par
04617       {\cf17 const} ParamGenerator<T5>& g5,\par
04618       {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator& current5,\par
04619       {\cf17 const} ParamGenerator<T6>& g6,\par
04620       {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator& current6,\par
04621       {\cf17 const} ParamGenerator<T7>& g7,\par
04622       {\cf17 const} {\cf17 typename} ParamGenerator<T7>::iterator& current7,\par
04623       {\cf17 const} ParamGenerator<T8>& g8,\par
04624       {\cf17 const} {\cf17 typename} ParamGenerator<T8>::iterator& current8,\par
04625       {\cf17 const} ParamGenerator<T9>& g9,\par
04626       {\cf17 const} {\cf17 typename} ParamGenerator<T9>::iterator& current9,\par
04627       {\cf17 const} ParamGenerator<T10>& g10,\par
04628       {\cf17 const} {\cf17 typename} ParamGenerator<T10>::iterator& current10)\par
04629         : base_(base),\par
04630           begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\par
04631           begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\par
04632           begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\par
04633           begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\par
04634           begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\par
04635           begin6_(g6.begin()), end6_(g6.end()), current6_(current6),\par
04636           begin7_(g7.begin()), end7_(g7.end()), current7_(current7),\par
04637           begin8_(g8.begin()), end8_(g8.end()), current8_(current8),\par
04638           begin9_(g9.begin()), end9_(g9.end()), current9_(current9),\par
04639           begin10_(g10.begin()), end10_(g10.end()), current10_(current10)    \{\par
04640       ComputeCurrentValue();\par
04641     \}\par
04642     {\cf17 virtual} ~Iterator() \{\}\par
04643 \par
04644     {\cf17 virtual} {\cf17 const} ParamGeneratorInterface<ParamType>* BaseGenerator(){\cf17  const }\{\par
04645       {\cf19 return} base_;\par
04646     \}\par
04647     {\cf20 // Advance should not be called on beyond-of-range iterators}\par
04648     {\cf20 // so no component iterators must be beyond end of range, either.}\par
04649     {\cf17 virtual} {\cf18 void} Advance() \{\par
04650       assert(!AtEnd());\par
04651       ++current10_;\par
04652       {\cf19 if} (current10_ == end10_) \{\par
04653         current10_ = begin10_;\par
04654         ++current9_;\par
04655       \}\par
04656       {\cf19 if} (current9_ == end9_) \{\par
04657         current9_ = begin9_;\par
04658         ++current8_;\par
04659       \}\par
04660       {\cf19 if} (current8_ == end8_) \{\par
04661         current8_ = begin8_;\par
04662         ++current7_;\par
04663       \}\par
04664       {\cf19 if} (current7_ == end7_) \{\par
04665         current7_ = begin7_;\par
04666         ++current6_;\par
04667       \}\par
04668       {\cf19 if} (current6_ == end6_) \{\par
04669         current6_ = begin6_;\par
04670         ++current5_;\par
04671       \}\par
04672       {\cf19 if} (current5_ == end5_) \{\par
04673         current5_ = begin5_;\par
04674         ++current4_;\par
04675       \}\par
04676       {\cf19 if} (current4_ == end4_) \{\par
04677         current4_ = begin4_;\par
04678         ++current3_;\par
04679       \}\par
04680       {\cf19 if} (current3_ == end3_) \{\par
04681         current3_ = begin3_;\par
04682         ++current2_;\par
04683       \}\par
04684       {\cf19 if} (current2_ == end2_) \{\par
04685         current2_ = begin2_;\par
04686         ++current1_;\par
04687       \}\par
04688       ComputeCurrentValue();\par
04689     \}\par
04690     {\cf17 virtual} ParamIteratorInterface<ParamType>* Clone(){\cf17  const }\{\par
04691       {\cf19 return} {\cf17 new} Iterator(*{\cf17 this});\par
04692     \}\par
04693     {\cf17 virtual} {\cf17 const} ParamType* Current(){\cf17  const }\{ {\cf19 return} &current_value_; \}\par
04694     {\cf17 virtual} {\cf18 bool} Equals({\cf17 const} ParamIteratorInterface<ParamType>& other){\cf17  const }\{\par
04695       {\cf20 // Having the same base generator guarantees that the other}\par
04696       {\cf20 // iterator is of the same type and we can downcast.}\par
04697       GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\par
04698           << {\cf22 "The program attempted to compare iterators "}\par
04699           << {\cf22 "from different generators."} << std::endl;\par
04700       {\cf17 const} Iterator* typed_other =\par
04701           CheckedDowncastToActualType<const Iterator>(&other);\par
04702       {\cf20 // We must report iterators equal if they both point beyond their}\par
04703       {\cf20 // respective ranges. That can happen in a variety of fashions,}\par
04704       {\cf20 // so we have to consult AtEnd().}\par
04705       {\cf19 return} (AtEnd() && typed_other->AtEnd()) ||\par
04706          (\par
04707           current1_ == typed_other->current1_ &&\par
04708           current2_ == typed_other->current2_ &&\par
04709           current3_ == typed_other->current3_ &&\par
04710           current4_ == typed_other->current4_ &&\par
04711           current5_ == typed_other->current5_ &&\par
04712           current6_ == typed_other->current6_ &&\par
04713           current7_ == typed_other->current7_ &&\par
04714           current8_ == typed_other->current8_ &&\par
04715           current9_ == typed_other->current9_ &&\par
04716           current10_ == typed_other->current10_);\par
04717     \}\par
04718 \par
04719    {\cf17 private}:\par
04720     Iterator({\cf17 const} Iterator& other)\par
04721         : base_(other.base_),\par
04722         begin1_(other.begin1_),\par
04723         end1_(other.end1_),\par
04724         current1_(other.current1_),\par
04725         begin2_(other.begin2_),\par
04726         end2_(other.end2_),\par
04727         current2_(other.current2_),\par
04728         begin3_(other.begin3_),\par
04729         end3_(other.end3_),\par
04730         current3_(other.current3_),\par
04731         begin4_(other.begin4_),\par
04732         end4_(other.end4_),\par
04733         current4_(other.current4_),\par
04734         begin5_(other.begin5_),\par
04735         end5_(other.end5_),\par
04736         current5_(other.current5_),\par
04737         begin6_(other.begin6_),\par
04738         end6_(other.end6_),\par
04739         current6_(other.current6_),\par
04740         begin7_(other.begin7_),\par
04741         end7_(other.end7_),\par
04742         current7_(other.current7_),\par
04743         begin8_(other.begin8_),\par
04744         end8_(other.end8_),\par
04745         current8_(other.current8_),\par
04746         begin9_(other.begin9_),\par
04747         end9_(other.end9_),\par
04748         current9_(other.current9_),\par
04749         begin10_(other.begin10_),\par
04750         end10_(other.end10_),\par
04751         current10_(other.current10_) \{\par
04752       ComputeCurrentValue();\par
04753     \}\par
04754 \par
04755     {\cf18 void} ComputeCurrentValue() \{\par
04756       {\cf19 if} (!AtEnd())\par
04757         current_value_ = ParamType(*current1_, *current2_, *current3_,\par
04758             *current4_, *current5_, *current6_, *current7_, *current8_,\par
04759             *current9_, *current10_);\par
04760     \}\par
04761     {\cf18 bool} AtEnd(){\cf17  const }\{\par
04762       {\cf20 // We must report iterator past the end of the range when either of the}\par
04763       {\cf20 // component iterators has reached the end of its range.}\par
04764       {\cf19 return}\par
04765           current1_ == end1_ ||\par
04766           current2_ == end2_ ||\par
04767           current3_ == end3_ ||\par
04768           current4_ == end4_ ||\par
04769           current5_ == end5_ ||\par
04770           current6_ == end6_ ||\par
04771           current7_ == end7_ ||\par
04772           current8_ == end8_ ||\par
04773           current9_ == end9_ ||\par
04774           current10_ == end10_;\par
04775     \}\par
04776 \par
04777     {\cf20 // No implementation - assignment is unsupported.}\par
04778     {\cf18 void} operator=({\cf17 const} Iterator& other);\par
04779 \par
04780     {\cf17 const} ParamGeneratorInterface<ParamType>* {\cf17 const} base_;\par
04781     {\cf20 // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.}\par
04782     {\cf20 // current[i]_ is the actual traversing iterator.}\par
04783     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator begin1_;\par
04784     {\cf17 const} {\cf17 typename} ParamGenerator<T1>::iterator end1_;\par
04785     {\cf17 typename} ParamGenerator<T1>::iterator current1_;\par
04786     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator begin2_;\par
04787     {\cf17 const} {\cf17 typename} ParamGenerator<T2>::iterator end2_;\par
04788     {\cf17 typename} ParamGenerator<T2>::iterator current2_;\par
04789     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator begin3_;\par
04790     {\cf17 const} {\cf17 typename} ParamGenerator<T3>::iterator end3_;\par
04791     {\cf17 typename} ParamGenerator<T3>::iterator current3_;\par
04792     {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator begin4_;\par
04793     {\cf17 const} {\cf17 typename} ParamGenerator<T4>::iterator end4_;\par
04794     {\cf17 typename} ParamGenerator<T4>::iterator current4_;\par
04795     {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator begin5_;\par
04796     {\cf17 const} {\cf17 typename} ParamGenerator<T5>::iterator end5_;\par
04797     {\cf17 typename} ParamGenerator<T5>::iterator current5_;\par
04798     {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator begin6_;\par
04799     {\cf17 const} {\cf17 typename} ParamGenerator<T6>::iterator end6_;\par
04800     {\cf17 typename} ParamGenerator<T6>::iterator current6_;\par
04801     {\cf17 const} {\cf17 typename} ParamGenerator<T7>::iterator begin7_;\par
04802     {\cf17 const} {\cf17 typename} ParamGenerator<T7>::iterator end7_;\par
04803     {\cf17 typename} ParamGenerator<T7>::iterator current7_;\par
04804     {\cf17 const} {\cf17 typename} ParamGenerator<T8>::iterator begin8_;\par
04805     {\cf17 const} {\cf17 typename} ParamGenerator<T8>::iterator end8_;\par
04806     {\cf17 typename} ParamGenerator<T8>::iterator current8_;\par
04807     {\cf17 const} {\cf17 typename} ParamGenerator<T9>::iterator begin9_;\par
04808     {\cf17 const} {\cf17 typename} ParamGenerator<T9>::iterator end9_;\par
04809     {\cf17 typename} ParamGenerator<T9>::iterator current9_;\par
04810     {\cf17 const} {\cf17 typename} ParamGenerator<T10>::iterator begin10_;\par
04811     {\cf17 const} {\cf17 typename} ParamGenerator<T10>::iterator end10_;\par
04812     {\cf17 typename} ParamGenerator<T10>::iterator current10_;\par
04813     ParamType current_value_;\par
04814   \};  {\cf20 // class CartesianProductGenerator10::Iterator}\par
04815 \par
04816   {\cf20 // No implementation - assignment is unsupported.}\par
04817   {\cf18 void} operator=({\cf17 const} CartesianProductGenerator10& other);\par
04818 \par
04819   {\cf17 const} ParamGenerator<T1> g1_;\par
04820   {\cf17 const} ParamGenerator<T2> g2_;\par
04821   {\cf17 const} ParamGenerator<T3> g3_;\par
04822   {\cf17 const} ParamGenerator<T4> g4_;\par
04823   {\cf17 const} ParamGenerator<T5> g5_;\par
04824   {\cf17 const} ParamGenerator<T6> g6_;\par
04825   {\cf17 const} ParamGenerator<T7> g7_;\par
04826   {\cf17 const} ParamGenerator<T8> g8_;\par
04827   {\cf17 const} ParamGenerator<T9> g9_;\par
04828   {\cf17 const} ParamGenerator<T10> g10_;\par
04829 \};  {\cf20 // class CartesianProductGenerator10}\par
04830 \par
04831 \par
04832 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
04833 {\cf20 //}\par
04834 {\cf20 // Helper classes providing Combine() with polymorphic features. They allow}\par
04835 {\cf20 // casting CartesianProductGeneratorN<T> to ParamGenerator<U> if T is}\par
04836 {\cf20 // convertible to U.}\par
04837 {\cf20 //}\par
04838 {\cf17 template} <{\cf17 class} Generator1, {\cf17 class} Generator2>\par
04839 {\cf17 class }CartesianProductHolder2 \{\par
04840  {\cf17 public}:\par
04841 CartesianProductHolder2({\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2)\par
04842       : g1_(g1), g2_(g2) \{\}\par
04843   {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
04844   {\cf17 operator} ParamGenerator< ::testing::tuple<T1, T2> >() {\cf17 const} \{\par
04845     {\cf19 return} ParamGenerator< ::testing::tuple<T1, T2> >(\par
04846         {\cf17 new} CartesianProductGenerator2<T1, T2>(\par
04847         {\cf17 static_cast<}ParamGenerator<T1> {\cf17 >}(g1_),\par
04848         {\cf17 static_cast<}ParamGenerator<T2> {\cf17 >}(g2_)));\par
04849   \}\par
04850 \par
04851  {\cf17 private}:\par
04852   {\cf20 // No implementation - assignment is unsupported.}\par
04853   {\cf18 void} operator=({\cf17 const} CartesianProductHolder2& other);\par
04854 \par
04855   {\cf17 const} Generator1 g1_;\par
04856   {\cf17 const} Generator2 g2_;\par
04857 \};  {\cf20 // class CartesianProductHolder2}\par
04858 \par
04859 {\cf17 template} <{\cf17 class} Generator1, {\cf17 class} Generator2, {\cf17 class} Generator3>\par
04860 {\cf17 class }CartesianProductHolder3 \{\par
04861  {\cf17 public}:\par
04862 CartesianProductHolder3({\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2,\par
04863     {\cf17 const} Generator3& g3)\par
04864       : g1_(g1), g2_(g2), g3_(g3) \{\}\par
04865   {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3>\par
04866   {\cf17 operator} ParamGenerator< ::testing::tuple<T1, T2, T3> >() {\cf17 const} \{\par
04867     {\cf19 return} ParamGenerator< ::testing::tuple<T1, T2, T3> >(\par
04868         {\cf17 new} CartesianProductGenerator3<T1, T2, T3>(\par
04869         {\cf17 static_cast<}ParamGenerator<T1> {\cf17 >}(g1_),\par
04870         {\cf17 static_cast<}ParamGenerator<T2> {\cf17 >}(g2_),\par
04871         {\cf17 static_cast<}ParamGenerator<T3> {\cf17 >}(g3_)));\par
04872   \}\par
04873 \par
04874  {\cf17 private}:\par
04875   {\cf20 // No implementation - assignment is unsupported.}\par
04876   {\cf18 void} operator=({\cf17 const} CartesianProductHolder3& other);\par
04877 \par
04878   {\cf17 const} Generator1 g1_;\par
04879   {\cf17 const} Generator2 g2_;\par
04880   {\cf17 const} Generator3 g3_;\par
04881 \};  {\cf20 // class CartesianProductHolder3}\par
04882 \par
04883 {\cf17 template} <{\cf17 class }Generator1, {\cf17 class }Generator2, {\cf17 class }Generator3,\par
04884     {\cf17 class }Generator4>\par
04885 {\cf17 class }CartesianProductHolder4 \{\par
04886  {\cf17 public}:\par
04887 CartesianProductHolder4({\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2,\par
04888     {\cf17 const} Generator3& g3, {\cf17 const} Generator4& g4)\par
04889       : g1_(g1), g2_(g2), g3_(g3), g4_(g4) \{\}\par
04890   {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4>\par
04891   {\cf17 operator} ParamGenerator< ::testing::tuple<T1, T2, T3, T4> >() {\cf17 const} \{\par
04892     {\cf19 return} ParamGenerator< ::testing::tuple<T1, T2, T3, T4> >(\par
04893         {\cf17 new} CartesianProductGenerator4<T1, T2, T3, T4>(\par
04894         {\cf17 static_cast<}ParamGenerator<T1> {\cf17 >}(g1_),\par
04895         {\cf17 static_cast<}ParamGenerator<T2> {\cf17 >}(g2_),\par
04896         {\cf17 static_cast<}ParamGenerator<T3> {\cf17 >}(g3_),\par
04897         {\cf17 static_cast<}ParamGenerator<T4> {\cf17 >}(g4_)));\par
04898   \}\par
04899 \par
04900  {\cf17 private}:\par
04901   {\cf20 // No implementation - assignment is unsupported.}\par
04902   {\cf18 void} operator=({\cf17 const} CartesianProductHolder4& other);\par
04903 \par
04904   {\cf17 const} Generator1 g1_;\par
04905   {\cf17 const} Generator2 g2_;\par
04906   {\cf17 const} Generator3 g3_;\par
04907   {\cf17 const} Generator4 g4_;\par
04908 \};  {\cf20 // class CartesianProductHolder4}\par
04909 \par
04910 {\cf17 template} <{\cf17 class }Generator1, {\cf17 class }Generator2, {\cf17 class }Generator3,\par
04911     {\cf17 class }Generator4, {\cf17 class }Generator5>\par
04912 {\cf17 class }CartesianProductHolder5 \{\par
04913  {\cf17 public}:\par
04914 CartesianProductHolder5({\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2,\par
04915     {\cf17 const} Generator3& g3, {\cf17 const} Generator4& g4, {\cf17 const} Generator5& g5)\par
04916       : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5) \{\}\par
04917   {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5>\par
04918   {\cf17 operator} ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5> >() {\cf17 const} \{\par
04919     {\cf19 return} ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5> >(\par
04920         {\cf17 new} CartesianProductGenerator5<T1, T2, T3, T4, T5>(\par
04921         {\cf17 static_cast<}ParamGenerator<T1> {\cf17 >}(g1_),\par
04922         {\cf17 static_cast<}ParamGenerator<T2> {\cf17 >}(g2_),\par
04923         {\cf17 static_cast<}ParamGenerator<T3> {\cf17 >}(g3_),\par
04924         {\cf17 static_cast<}ParamGenerator<T4> {\cf17 >}(g4_),\par
04925         {\cf17 static_cast<}ParamGenerator<T5> {\cf17 >}(g5_)));\par
04926   \}\par
04927 \par
04928  {\cf17 private}:\par
04929   {\cf20 // No implementation - assignment is unsupported.}\par
04930   {\cf18 void} operator=({\cf17 const} CartesianProductHolder5& other);\par
04931 \par
04932   {\cf17 const} Generator1 g1_;\par
04933   {\cf17 const} Generator2 g2_;\par
04934   {\cf17 const} Generator3 g3_;\par
04935   {\cf17 const} Generator4 g4_;\par
04936   {\cf17 const} Generator5 g5_;\par
04937 \};  {\cf20 // class CartesianProductHolder5}\par
04938 \par
04939 {\cf17 template} <{\cf17 class }Generator1, {\cf17 class }Generator2, {\cf17 class }Generator3,\par
04940     {\cf17 class }Generator4, {\cf17 class }Generator5, {\cf17 class }Generator6>\par
04941 {\cf17 class }CartesianProductHolder6 \{\par
04942  {\cf17 public}:\par
04943 CartesianProductHolder6({\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2,\par
04944     {\cf17 const} Generator3& g3, {\cf17 const} Generator4& g4, {\cf17 const} Generator5& g5,\par
04945     {\cf17 const} Generator6& g6)\par
04946       : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6) \{\}\par
04947   {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
04948       {\cf17 typename} T6>\par
04949   {\cf17 operator} ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6> >() {\cf17 const} \{\par
04950     {\cf19 return} ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6> >(\par
04951         {\cf17 new} CartesianProductGenerator6<T1, T2, T3, T4, T5, T6>(\par
04952         {\cf17 static_cast<}ParamGenerator<T1> {\cf17 >}(g1_),\par
04953         {\cf17 static_cast<}ParamGenerator<T2> {\cf17 >}(g2_),\par
04954         {\cf17 static_cast<}ParamGenerator<T3> {\cf17 >}(g3_),\par
04955         {\cf17 static_cast<}ParamGenerator<T4> {\cf17 >}(g4_),\par
04956         {\cf17 static_cast<}ParamGenerator<T5> {\cf17 >}(g5_),\par
04957         {\cf17 static_cast<}ParamGenerator<T6> {\cf17 >}(g6_)));\par
04958   \}\par
04959 \par
04960  {\cf17 private}:\par
04961   {\cf20 // No implementation - assignment is unsupported.}\par
04962   {\cf18 void} operator=({\cf17 const} CartesianProductHolder6& other);\par
04963 \par
04964   {\cf17 const} Generator1 g1_;\par
04965   {\cf17 const} Generator2 g2_;\par
04966   {\cf17 const} Generator3 g3_;\par
04967   {\cf17 const} Generator4 g4_;\par
04968   {\cf17 const} Generator5 g5_;\par
04969   {\cf17 const} Generator6 g6_;\par
04970 \};  {\cf20 // class CartesianProductHolder6}\par
04971 \par
04972 {\cf17 template} <{\cf17 class }Generator1, {\cf17 class }Generator2, {\cf17 class }Generator3,\par
04973     {\cf17 class }Generator4, {\cf17 class }Generator5, {\cf17 class }Generator6, {\cf17 class }Generator7>\par
04974 {\cf17 class }CartesianProductHolder7 \{\par
04975  {\cf17 public}:\par
04976 CartesianProductHolder7({\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2,\par
04977     {\cf17 const} Generator3& g3, {\cf17 const} Generator4& g4, {\cf17 const} Generator5& g5,\par
04978     {\cf17 const} Generator6& g6, {\cf17 const} Generator7& g7)\par
04979       : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7) \{\}\par
04980   {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
04981       {\cf17 typename} T6, {\cf17 typename} T7>\par
04982   {\cf17 operator} ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6,\par
04983       T7> >() {\cf17 const} \{\par
04984     {\cf19 return} ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7> >(\par
04985         {\cf17 new} CartesianProductGenerator7<T1, T2, T3, T4, T5, T6, T7>(\par
04986         {\cf17 static_cast<}ParamGenerator<T1> {\cf17 >}(g1_),\par
04987         {\cf17 static_cast<}ParamGenerator<T2> {\cf17 >}(g2_),\par
04988         {\cf17 static_cast<}ParamGenerator<T3> {\cf17 >}(g3_),\par
04989         {\cf17 static_cast<}ParamGenerator<T4> {\cf17 >}(g4_),\par
04990         {\cf17 static_cast<}ParamGenerator<T5> {\cf17 >}(g5_),\par
04991         {\cf17 static_cast<}ParamGenerator<T6> {\cf17 >}(g6_),\par
04992         {\cf17 static_cast<}ParamGenerator<T7> {\cf17 >}(g7_)));\par
04993   \}\par
04994 \par
04995  {\cf17 private}:\par
04996   {\cf20 // No implementation - assignment is unsupported.}\par
04997   {\cf18 void} operator=({\cf17 const} CartesianProductHolder7& other);\par
04998 \par
04999   {\cf17 const} Generator1 g1_;\par
05000   {\cf17 const} Generator2 g2_;\par
05001   {\cf17 const} Generator3 g3_;\par
05002   {\cf17 const} Generator4 g4_;\par
05003   {\cf17 const} Generator5 g5_;\par
05004   {\cf17 const} Generator6 g6_;\par
05005   {\cf17 const} Generator7 g7_;\par
05006 \};  {\cf20 // class CartesianProductHolder7}\par
05007 \par
05008 {\cf17 template} <{\cf17 class }Generator1, {\cf17 class }Generator2, {\cf17 class }Generator3,\par
05009     {\cf17 class }Generator4, {\cf17 class }Generator5, {\cf17 class }Generator6, {\cf17 class }Generator7,\par
05010     {\cf17 class }Generator8>\par
05011 {\cf17 class }CartesianProductHolder8 \{\par
05012  {\cf17 public}:\par
05013 CartesianProductHolder8({\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2,\par
05014     {\cf17 const} Generator3& g3, {\cf17 const} Generator4& g4, {\cf17 const} Generator5& g5,\par
05015     {\cf17 const} Generator6& g6, {\cf17 const} Generator7& g7, {\cf17 const} Generator8& g8)\par
05016       : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7),\par
05017           g8_(g8) \{\}\par
05018   {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
05019       {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8>\par
05020   {\cf17 operator} ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7,\par
05021       T8> >() {\cf17 const} \{\par
05022     {\cf19 return} ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8> >(\par
05023         {\cf17 new} CartesianProductGenerator8<T1, T2, T3, T4, T5, T6, T7, T8>(\par
05024         {\cf17 static_cast<}ParamGenerator<T1> {\cf17 >}(g1_),\par
05025         {\cf17 static_cast<}ParamGenerator<T2> {\cf17 >}(g2_),\par
05026         {\cf17 static_cast<}ParamGenerator<T3> {\cf17 >}(g3_),\par
05027         {\cf17 static_cast<}ParamGenerator<T4> {\cf17 >}(g4_),\par
05028         {\cf17 static_cast<}ParamGenerator<T5> {\cf17 >}(g5_),\par
05029         {\cf17 static_cast<}ParamGenerator<T6> {\cf17 >}(g6_),\par
05030         {\cf17 static_cast<}ParamGenerator<T7> {\cf17 >}(g7_),\par
05031         {\cf17 static_cast<}ParamGenerator<T8> {\cf17 >}(g8_)));\par
05032   \}\par
05033 \par
05034  {\cf17 private}:\par
05035   {\cf20 // No implementation - assignment is unsupported.}\par
05036   {\cf18 void} operator=({\cf17 const} CartesianProductHolder8& other);\par
05037 \par
05038   {\cf17 const} Generator1 g1_;\par
05039   {\cf17 const} Generator2 g2_;\par
05040   {\cf17 const} Generator3 g3_;\par
05041   {\cf17 const} Generator4 g4_;\par
05042   {\cf17 const} Generator5 g5_;\par
05043   {\cf17 const} Generator6 g6_;\par
05044   {\cf17 const} Generator7 g7_;\par
05045   {\cf17 const} Generator8 g8_;\par
05046 \};  {\cf20 // class CartesianProductHolder8}\par
05047 \par
05048 {\cf17 template} <{\cf17 class }Generator1, {\cf17 class }Generator2, {\cf17 class }Generator3,\par
05049     {\cf17 class }Generator4, {\cf17 class }Generator5, {\cf17 class }Generator6, {\cf17 class }Generator7,\par
05050     {\cf17 class }Generator8, {\cf17 class }Generator9>\par
05051 {\cf17 class }CartesianProductHolder9 \{\par
05052  {\cf17 public}:\par
05053 CartesianProductHolder9({\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2,\par
05054     {\cf17 const} Generator3& g3, {\cf17 const} Generator4& g4, {\cf17 const} Generator5& g5,\par
05055     {\cf17 const} Generator6& g6, {\cf17 const} Generator7& g7, {\cf17 const} Generator8& g8,\par
05056     {\cf17 const} Generator9& g9)\par
05057       : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),\par
05058           g9_(g9) \{\}\par
05059   {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
05060       {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9>\par
05061   {\cf17 operator} ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8,\par
05062       T9> >() {\cf17 const} \{\par
05063     {\cf19 return} ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8,\par
05064         T9> >(\par
05065         {\cf17 new} CartesianProductGenerator9<T1, T2, T3, T4, T5, T6, T7, T8, T9>(\par
05066         {\cf17 static_cast<}ParamGenerator<T1> {\cf17 >}(g1_),\par
05067         {\cf17 static_cast<}ParamGenerator<T2> {\cf17 >}(g2_),\par
05068         {\cf17 static_cast<}ParamGenerator<T3> {\cf17 >}(g3_),\par
05069         {\cf17 static_cast<}ParamGenerator<T4> {\cf17 >}(g4_),\par
05070         {\cf17 static_cast<}ParamGenerator<T5> {\cf17 >}(g5_),\par
05071         {\cf17 static_cast<}ParamGenerator<T6> {\cf17 >}(g6_),\par
05072         {\cf17 static_cast<}ParamGenerator<T7> {\cf17 >}(g7_),\par
05073         {\cf17 static_cast<}ParamGenerator<T8> {\cf17 >}(g8_),\par
05074         {\cf17 static_cast<}ParamGenerator<T9> {\cf17 >}(g9_)));\par
05075   \}\par
05076 \par
05077  {\cf17 private}:\par
05078   {\cf20 // No implementation - assignment is unsupported.}\par
05079   {\cf18 void} operator=({\cf17 const} CartesianProductHolder9& other);\par
05080 \par
05081   {\cf17 const} Generator1 g1_;\par
05082   {\cf17 const} Generator2 g2_;\par
05083   {\cf17 const} Generator3 g3_;\par
05084   {\cf17 const} Generator4 g4_;\par
05085   {\cf17 const} Generator5 g5_;\par
05086   {\cf17 const} Generator6 g6_;\par
05087   {\cf17 const} Generator7 g7_;\par
05088   {\cf17 const} Generator8 g8_;\par
05089   {\cf17 const} Generator9 g9_;\par
05090 \};  {\cf20 // class CartesianProductHolder9}\par
05091 \par
05092 {\cf17 template} <{\cf17 class }Generator1, {\cf17 class }Generator2, {\cf17 class }Generator3,\par
05093     {\cf17 class }Generator4, {\cf17 class }Generator5, {\cf17 class }Generator6, {\cf17 class }Generator7,\par
05094     {\cf17 class }Generator8, {\cf17 class }Generator9, {\cf17 class }Generator10>\par
05095 {\cf17 class }CartesianProductHolder10 \{\par
05096  {\cf17 public}:\par
05097 CartesianProductHolder10({\cf17 const} Generator1& g1, {\cf17 const} Generator2& g2,\par
05098     {\cf17 const} Generator3& g3, {\cf17 const} Generator4& g4, {\cf17 const} Generator5& g5,\par
05099     {\cf17 const} Generator6& g6, {\cf17 const} Generator7& g7, {\cf17 const} Generator8& g8,\par
05100     {\cf17 const} Generator9& g9, {\cf17 const} Generator10& g10)\par
05101       : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),\par
05102           g9_(g9), g10_(g10) \{\}\par
05103   {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
05104       {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10>\par
05105   {\cf17 operator} ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9,\par
05106       T10> >() {\cf17 const} \{\par
05107     {\cf19 return} ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9,\par
05108         T10> >(\par
05109         {\cf17 new} CartesianProductGenerator10<T1, T2, T3, T4, T5, T6, T7, T8, T9,\par
05110             T10>(\par
05111         {\cf17 static_cast<}ParamGenerator<T1> {\cf17 >}(g1_),\par
05112         {\cf17 static_cast<}ParamGenerator<T2> {\cf17 >}(g2_),\par
05113         {\cf17 static_cast<}ParamGenerator<T3> {\cf17 >}(g3_),\par
05114         {\cf17 static_cast<}ParamGenerator<T4> {\cf17 >}(g4_),\par
05115         {\cf17 static_cast<}ParamGenerator<T5> {\cf17 >}(g5_),\par
05116         {\cf17 static_cast<}ParamGenerator<T6> {\cf17 >}(g6_),\par
05117         {\cf17 static_cast<}ParamGenerator<T7> {\cf17 >}(g7_),\par
05118         {\cf17 static_cast<}ParamGenerator<T8> {\cf17 >}(g8_),\par
05119         {\cf17 static_cast<}ParamGenerator<T9> {\cf17 >}(g9_),\par
05120         {\cf17 static_cast<}ParamGenerator<T10> {\cf17 >}(g10_)));\par
05121   \}\par
05122 \par
05123  {\cf17 private}:\par
05124   {\cf20 // No implementation - assignment is unsupported.}\par
05125   {\cf18 void} operator=({\cf17 const} CartesianProductHolder10& other);\par
05126 \par
05127   {\cf17 const} Generator1 g1_;\par
05128   {\cf17 const} Generator2 g2_;\par
05129   {\cf17 const} Generator3 g3_;\par
05130   {\cf17 const} Generator4 g4_;\par
05131   {\cf17 const} Generator5 g5_;\par
05132   {\cf17 const} Generator6 g6_;\par
05133   {\cf17 const} Generator7 g7_;\par
05134   {\cf17 const} Generator8 g8_;\par
05135   {\cf17 const} Generator9 g9_;\par
05136   {\cf17 const} Generator10 g10_;\par
05137 \};  {\cf20 // class CartesianProductHolder10}\par
05138 \par
05139 {\cf21 # endif  }{\cf20 // GTEST_HAS_COMBINE}\par
05140 \par
05141 \}  {\cf20 // namespace internal}\par
05142 \}  {\cf20 // namespace testing}\par
05143 \par
05144 {\cf21 #endif  }{\cf20 //  GTEST_HAS_PARAM_TEST}\par
05145 \par
05146 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/internal/gtest-param-util.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-param-util.h}
{\xe \v gtest/include/gtest/internal/gtest-param-util.h}
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <ctype.h>}\par
{\f2 #include <iterator>}\par
{\f2 #include <set>}\par
{\f2 #include <utility>}\par
{\f2 #include <vector>}\par
{\f2 #include "gtest/internal/gtest-internal.h"}\par
{\f2 #include "gtest/internal/gtest-linked_ptr.h"}\par
{\f2 #include "gtest/internal/gtest-port.h"}\par
{\f2 #include "gtest/gtest-printers.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-param-util.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-param-util.h}
{\xe \v gtest/include/gtest/internal/gtest-param-util.h}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2008 Google Inc.}\par
00002 {\cf20 // All Rights Reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: vladl@google.com (Vlad Losev)}\par
00031 \par
00032 {\cf20 // Type and function utilities for implementing parameterized tests.}\par
00033 \par
00034 {\cf21 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_}\par
00035 {\cf21 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_}\par
00036 \par
00037 {\cf21 #include <ctype.h>}\par
00038 \par
00039 {\cf21 #include <iterator>}\par
00040 {\cf21 #include <set>}\par
00041 {\cf21 #include <utility>}\par
00042 {\cf21 #include <vector>}\par
00043 \par
00044 {\cf20 // scripts/fuse_gtest.py depends on gtest's own header being #included}\par
00045 {\cf20 // *unconditionally*.  Therefore these #includes cannot be moved}\par
00046 {\cf20 // inside #if GTEST_HAS_PARAM_TEST.}\par
00047 {\cf21 #include "gtest/internal/gtest-internal.h"}\par
00048 {\cf21 #include "gtest/internal/gtest-linked_ptr.h"}\par
00049 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00050 {\cf21 #include "gtest/gtest-printers.h"}\par
00051 \par
00052 {\cf21 #if GTEST_HAS_PARAM_TEST}\par
00053 \par
00054 {\cf17 namespace }testing \{\par
00055 \par
00056 {\cf20 // Input to a parameterized test name generator, describing a test parameter.}\par
00057 {\cf20 // Consists of the parameter value and the integer parameter index.}\par
00058 {\cf17 template} <{\cf17 class} ParamType>\par
00059 {\cf17 struct }TestParamInfo \{\par
00060   TestParamInfo({\cf17 const} ParamType& a_param, {\cf18 size_t} an_index) :\par
00061     param(a_param),\par
00062     index(an_index) \{\}\par
00063   ParamType param;\par
00064   {\cf18 size_t} index;\par
00065 \};\par
00066 \par
00067 {\cf20 // A builtin parameterized test name generator which returns the result of}\par
00068 {\cf20 // testing::PrintToString.}\par
00069 {\cf17 struct }PrintToStringParamName \{\par
00070   {\cf17 template} <{\cf17 class} ParamType>\par
00071   std::string operator()({\cf17 const} TestParamInfo<ParamType>& info){\cf17  const }\{\par
00072     {\cf19 return} PrintToString(info.param);\par
00073   \}\par
00074 \};\par
00075 \par
00076 {\cf17 namespace }internal \{\par
00077 \par
00078 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
00079 {\cf20 //}\par
00080 {\cf20 // Outputs a message explaining invalid registration of different}\par
00081 {\cf20 // fixture class for the same test case. This may happen when}\par
00082 {\cf20 // TEST_P macro is used to define two tests with the same name}\par
00083 {\cf20 // but in different namespaces.}\par
00084 GTEST_API_ {\cf18 void} ReportInvalidTestCaseType({\cf17 const} {\cf18 char}* test_case_name,\par
00085                                           CodeLocation code_location);\par
00086 \par
00087 {\cf17 template} <{\cf17 typename}> {\cf17 class }ParamGeneratorInterface;\par
00088 {\cf17 template} <{\cf17 typename}> {\cf17 class }ParamGenerator;\par
00089 \par
00090 {\cf20 // Interface for iterating over elements provided by an implementation}\par
00091 {\cf20 // of ParamGeneratorInterface<T>.}\par
00092 {\cf17 template} <{\cf17 typename} T>\par
00093 {\cf17 class }ParamIteratorInterface \{\par
00094  {\cf17 public}:\par
00095   {\cf17 virtual} ~ParamIteratorInterface() \{\}\par
00096   {\cf20 // A pointer to the base generator instance.}\par
00097   {\cf20 // Used only for the purposes of iterator comparison}\par
00098   {\cf20 // to make sure that two iterators belong to the same generator.}\par
00099   {\cf17 virtual} {\cf17 const} ParamGeneratorInterface<T>* BaseGenerator() {\cf17 const} = 0;\par
00100   {\cf20 // Advances iterator to point to the next element}\par
00101   {\cf20 // provided by the generator. The caller is responsible}\par
00102   {\cf20 // for not calling Advance() on an iterator equal to}\par
00103   {\cf20 // BaseGenerator()->End().}\par
00104   {\cf17 virtual} {\cf18 void} Advance() = 0;\par
00105   {\cf20 // Clones the iterator object. Used for implementing copy semantics}\par
00106   {\cf20 // of ParamIterator<T>.}\par
00107   {\cf17 virtual} ParamIteratorInterface* Clone() {\cf17 const} = 0;\par
00108   {\cf20 // Dereferences the current iterator and provides (read-only) access}\par
00109   {\cf20 // to the pointed value. It is the caller's responsibility not to call}\par
00110   {\cf20 // Current() on an iterator equal to BaseGenerator()->End().}\par
00111   {\cf20 // Used for implementing ParamGenerator<T>::operator*().}\par
00112   {\cf17 virtual} {\cf17 const} T* Current() {\cf17 const} = 0;\par
00113   {\cf20 // Determines whether the given iterator and other point to the same}\par
00114   {\cf20 // element in the sequence generated by the generator.}\par
00115   {\cf20 // Used for implementing ParamGenerator<T>::operator==().}\par
00116   {\cf17 virtual} {\cf18 bool} Equals({\cf17 const} ParamIteratorInterface& other) {\cf17 const} = 0;\par
00117 \};\par
00118 \par
00119 {\cf20 // Class iterating over elements provided by an implementation of}\par
00120 {\cf20 // ParamGeneratorInterface<T>. It wraps ParamIteratorInterface<T>}\par
00121 {\cf20 // and implements the const forward iterator concept.}\par
00122 {\cf17 template} <{\cf17 typename} T>\par
00123 {\cf17 class }ParamIterator \{\par
00124  {\cf17 public}:\par
00125   {\cf17 typedef} T value_type;\par
00126   {\cf17 typedef} {\cf17 const} T& reference;\par
00127   {\cf17 typedef} ptrdiff_t difference_type;\par
00128 \par
00129   {\cf20 // ParamIterator assumes ownership of the impl_ pointer.}\par
00130   ParamIterator({\cf17 const} ParamIterator& other) : impl_(other.impl_->Clone()) \{\}\par
00131   ParamIterator& operator=({\cf17 const} ParamIterator& other) \{\par
00132     {\cf19 if} ({\cf17 this} != &other)\par
00133       impl_.reset(other.impl_->Clone());\par
00134     {\cf19 return} *{\cf17 this};\par
00135   \}\par
00136 \par
00137   {\cf17 const} T& operator*(){\cf17  const }\{ {\cf19 return} *impl_->Current(); \}\par
00138   {\cf17 const} T* operator->(){\cf17  const }\{ {\cf19 return} impl_->Current(); \}\par
00139   {\cf20 // Prefix version of operator++.}\par
00140   ParamIterator& operator++() \{\par
00141     impl_->Advance();\par
00142     {\cf19 return} *{\cf17 this};\par
00143   \}\par
00144   {\cf20 // Postfix version of operator++.}\par
00145   ParamIterator operator++({\cf18 int} {\cf20 /*unused*/}) \{\par
00146     ParamIteratorInterface<T>* clone = impl_->Clone();\par
00147     impl_->Advance();\par
00148     {\cf19 return} ParamIterator(clone);\par
00149   \}\par
00150   {\cf18 bool} operator==({\cf17 const} ParamIterator& other){\cf17  const }\{\par
00151     {\cf19 return} impl_.get() == other.impl_.get() || impl_->Equals(*other.impl_);\par
00152   \}\par
00153   {\cf18 bool} operator!=({\cf17 const} ParamIterator& other){\cf17  const }\{\par
00154     {\cf19 return} !(*{\cf17 this} == other);\par
00155   \}\par
00156 \par
00157  {\cf17 private}:\par
00158   {\cf17 friend} {\cf17 class }ParamGenerator<T>;\par
00159   {\cf17 explicit} ParamIterator(ParamIteratorInterface<T>* impl) : impl_(impl) \{\}\par
00160   scoped_ptr<ParamIteratorInterface<T> > impl_;\par
00161 \};\par
00162 \par
00163 {\cf20 // ParamGeneratorInterface<T> is the binary interface to access generators}\par
00164 {\cf20 // defined in other translation units.}\par
00165 {\cf17 template} <{\cf17 typename} T>\par
00166 {\cf17 class }ParamGeneratorInterface \{\par
00167  {\cf17 public}:\par
00168   {\cf17 typedef} T ParamType;\par
00169 \par
00170   {\cf17 virtual} ~ParamGeneratorInterface() \{\}\par
00171 \par
00172   {\cf20 // Generator interface definition}\par
00173   {\cf17 virtual} ParamIteratorInterface<T>* Begin() {\cf17 const} = 0;\par
00174   {\cf17 virtual} ParamIteratorInterface<T>* End() {\cf17 const} = 0;\par
00175 \};\par
00176 \par
00177 {\cf20 // Wraps ParamGeneratorInterface<T> and provides general generator syntax}\par
00178 {\cf20 // compatible with the STL Container concept.}\par
00179 {\cf20 // This class implements copy initialization semantics and the contained}\par
00180 {\cf20 // ParamGeneratorInterface<T> instance is shared among all copies}\par
00181 {\cf20 // of the original object. This is possible because that instance is immutable.}\par
00182 {\cf17 template}<{\cf17 typename} T>\par
00183 {\cf17 class }ParamGenerator \{\par
00184  {\cf17 public}:\par
00185   {\cf17 typedef} ParamIterator<T> iterator;\par
00186 \par
00187   {\cf17 explicit} ParamGenerator(ParamGeneratorInterface<T>* impl) : impl_(impl) \{\}\par
00188   ParamGenerator({\cf17 const} ParamGenerator& other) : impl_(other.impl_) \{\}\par
00189 \par
00190   ParamGenerator& operator=({\cf17 const} ParamGenerator& other) \{\par
00191     impl_ = other.impl_;\par
00192     {\cf19 return} *{\cf17 this};\par
00193   \}\par
00194 \par
00195   iterator begin(){\cf17  const }\{ {\cf19 return} iterator(impl_->Begin()); \}\par
00196   iterator end(){\cf17  const }\{ {\cf19 return} iterator(impl_->End()); \}\par
00197 \par
00198  {\cf17 private}:\par
00199   linked_ptr<const ParamGeneratorInterface<T> > impl_;\par
00200 \};\par
00201 \par
00202 {\cf20 // Generates values from a range of two comparable values. Can be used to}\par
00203 {\cf20 // generate sequences of user-defined types that implement operator+() and}\par
00204 {\cf20 // operator<().}\par
00205 {\cf20 // This class is used in the Range() function.}\par
00206 {\cf17 template} <{\cf17 typename} T, {\cf17 typename} IncrementT>\par
00207 {\cf17 class }RangeGenerator : {\cf17 public} ParamGeneratorInterface<T> \{\par
00208  {\cf17 public}:\par
00209   RangeGenerator(T begin, T end, IncrementT step)\par
00210       : begin_(begin), end_(end),\par
00211         step_(step), end_index_(CalculateEndIndex(begin, end, step)) \{\}\par
00212   {\cf17 virtual} ~RangeGenerator() \{\}\par
00213 \par
00214   {\cf17 virtual} ParamIteratorInterface<T>* Begin(){\cf17  const }\{\par
00215     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, begin_, 0, step_);\par
00216   \}\par
00217   {\cf17 virtual} ParamIteratorInterface<T>* End(){\cf17  const }\{\par
00218     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, end_, end_index_, step_);\par
00219   \}\par
00220 \par
00221  {\cf17 private}:\par
00222   {\cf17 class }Iterator : {\cf17 public} ParamIteratorInterface<T> \{\par
00223    {\cf17 public}:\par
00224     Iterator({\cf17 const} ParamGeneratorInterface<T>* base, T value, {\cf18 int} index,\par
00225              IncrementT step)\par
00226         : base_(base), value_(value), index_(index), step_(step) \{\}\par
00227     {\cf17 virtual} ~Iterator() \{\}\par
00228 \par
00229     {\cf17 virtual} {\cf17 const} ParamGeneratorInterface<T>* BaseGenerator(){\cf17  const }\{\par
00230       {\cf19 return} base_;\par
00231     \}\par
00232     {\cf17 virtual} {\cf18 void} Advance() \{\par
00233       value_ = {\cf17 static_cast<}T{\cf17 >}(value_ + step_);\par
00234       index_++;\par
00235     \}\par
00236     {\cf17 virtual} ParamIteratorInterface<T>* Clone(){\cf17  const }\{\par
00237       {\cf19 return} {\cf17 new} Iterator(*{\cf17 this});\par
00238     \}\par
00239     {\cf17 virtual} {\cf17 const} T* Current(){\cf17  const }\{ {\cf19 return} &value_; \}\par
00240     {\cf17 virtual} {\cf18 bool} Equals({\cf17 const} ParamIteratorInterface<T>& other){\cf17  const }\{\par
00241       {\cf20 // Having the same base generator guarantees that the other}\par
00242       {\cf20 // iterator is of the same type and we can downcast.}\par
00243       GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\par
00244           << {\cf22 "The program attempted to compare iterators "}\par
00245           << {\cf22 "from different generators."} << std::endl;\par
00246       {\cf17 const} {\cf18 int} other_index =\par
00247           CheckedDowncastToActualType<const Iterator>(&other)->index_;\par
00248       {\cf19 return} index_ == other_index;\par
00249     \}\par
00250 \par
00251    {\cf17 private}:\par
00252     Iterator({\cf17 const} Iterator& other)\par
00253         : ParamIteratorInterface<T>(),\par
00254           base_(other.base_), value_(other.value_), index_(other.index_),\par
00255           step_(other.step_) \{\}\par
00256 \par
00257     {\cf20 // No implementation - assignment is unsupported.}\par
00258     {\cf18 void} operator=({\cf17 const} Iterator& other);\par
00259 \par
00260     {\cf17 const} ParamGeneratorInterface<T>* {\cf17 const} base_;\par
00261     T value_;\par
00262     {\cf18 int} index_;\par
00263     {\cf17 const} IncrementT step_;\par
00264   \};  {\cf20 // class RangeGenerator::Iterator}\par
00265 \par
00266   {\cf17 static} {\cf18 int} CalculateEndIndex({\cf17 const} T& begin,\par
00267                                {\cf17 const} T& end,\par
00268                                {\cf17 const} IncrementT& step) \{\par
00269     {\cf18 int} end_index = 0;\par
00270     {\cf19 for} (T i = begin; i < end; i = static_cast<T>(i + step))\par
00271       end_index++;\par
00272     {\cf19 return} end_index;\par
00273   \}\par
00274 \par
00275   {\cf20 // No implementation - assignment is unsupported.}\par
00276   {\cf18 void} operator=({\cf17 const} RangeGenerator& other);\par
00277 \par
00278   {\cf17 const} T begin_;\par
00279   {\cf17 const} T end_;\par
00280   {\cf17 const} IncrementT step_;\par
00281   {\cf20 // The index for the end() iterator. All the elements in the generated}\par
00282   {\cf20 // sequence are indexed (0-based) to aid iterator comparison.}\par
00283   {\cf17 const} {\cf18 int} end_index_;\par
00284 \};  {\cf20 // class RangeGenerator}\par
00285 \par
00286 \par
00287 {\cf20 // Generates values from a pair of STL-style iterators. Used in the}\par
00288 {\cf20 // ValuesIn() function. The elements are copied from the source range}\par
00289 {\cf20 // since the source can be located on the stack, and the generator}\par
00290 {\cf20 // is likely to persist beyond that stack frame.}\par
00291 {\cf17 template} <{\cf17 typename} T>\par
00292 {\cf17 class }ValuesInIteratorRangeGenerator : {\cf17 public} ParamGeneratorInterface<T> \{\par
00293  {\cf17 public}:\par
00294   {\cf17 template} <{\cf17 typename} ForwardIterator>\par
00295   ValuesInIteratorRangeGenerator(ForwardIterator begin, ForwardIterator end)\par
00296       : container_(begin, end) \{\}\par
00297   {\cf17 virtual} ~ValuesInIteratorRangeGenerator() \{\}\par
00298 \par
00299   {\cf17 virtual} ParamIteratorInterface<T>* Begin(){\cf17  const }\{\par
00300     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, container_.begin());\par
00301   \}\par
00302   {\cf17 virtual} ParamIteratorInterface<T>* End(){\cf17  const }\{\par
00303     {\cf19 return} {\cf17 new} Iterator({\cf17 this}, container_.end());\par
00304   \}\par
00305 \par
00306  {\cf17 private}:\par
00307   {\cf17 typedef} typename ::std::vector<T> ContainerType;\par
00308 \par
00309   {\cf17 class }Iterator : {\cf17 public} ParamIteratorInterface<T> \{\par
00310    {\cf17 public}:\par
00311     Iterator({\cf17 const} ParamGeneratorInterface<T>* base,\par
00312              {\cf17 typename} ContainerType::const_iterator iterator)\par
00313         : base_(base), iterator_(iterator) \{\}\par
00314     {\cf17 virtual} ~Iterator() \{\}\par
00315 \par
00316     {\cf17 virtual} {\cf17 const} ParamGeneratorInterface<T>* BaseGenerator(){\cf17  const }\{\par
00317       {\cf19 return} base_;\par
00318     \}\par
00319     {\cf17 virtual} {\cf18 void} Advance() \{\par
00320       ++iterator_;\par
00321       value_.reset();\par
00322     \}\par
00323     {\cf17 virtual} ParamIteratorInterface<T>* Clone(){\cf17  const }\{\par
00324       {\cf19 return} {\cf17 new} Iterator(*{\cf17 this});\par
00325     \}\par
00326     {\cf20 // We need to use cached value referenced by iterator_ because *iterator_}\par
00327     {\cf20 // can return a temporary object (and of type other then T), so just}\par
00328     {\cf20 // having "return &*iterator_;" doesn't work.}\par
00329     {\cf20 // value_ is updated here and not in Advance() because Advance()}\par
00330     {\cf20 // can advance iterator_ beyond the end of the range, and we cannot}\par
00331     {\cf20 // detect that fact. The client code, on the other hand, is}\par
00332     {\cf20 // responsible for not calling Current() on an out-of-range iterator.}\par
00333     {\cf17 virtual} {\cf17 const} T* Current(){\cf17  const }\{\par
00334       {\cf19 if} (value_.get() == NULL)\par
00335         value_.reset({\cf17 new} T(*iterator_));\par
00336       {\cf19 return} value_.get();\par
00337     \}\par
00338     {\cf17 virtual} {\cf18 bool} Equals({\cf17 const} ParamIteratorInterface<T>& other){\cf17  const }\{\par
00339       {\cf20 // Having the same base generator guarantees that the other}\par
00340       {\cf20 // iterator is of the same type and we can downcast.}\par
00341       GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\par
00342           << {\cf22 "The program attempted to compare iterators "}\par
00343           << {\cf22 "from different generators."} << std::endl;\par
00344       {\cf19 return} iterator_ ==\par
00345           CheckedDowncastToActualType<const Iterator>(&other)->iterator_;\par
00346     \}\par
00347 \par
00348    {\cf17 private}:\par
00349     Iterator({\cf17 const} Iterator& other)\par
00350           {\cf20 // The explicit constructor call suppresses a false warning}\par
00351           {\cf20 // emitted by gcc when supplied with the -Wextra option.}\par
00352         : ParamIteratorInterface<T>(),\par
00353           base_(other.base_),\par
00354           iterator_(other.iterator_) \{\}\par
00355 \par
00356     {\cf17 const} ParamGeneratorInterface<T>* {\cf17 const} base_;\par
00357     {\cf17 typename} ContainerType::const_iterator iterator_;\par
00358     {\cf20 // A cached value of *iterator_. We keep it here to allow access by}\par
00359     {\cf20 // pointer in the wrapping iterator's operator->().}\par
00360     {\cf20 // value_ needs to be mutable to be accessed in Current().}\par
00361     {\cf20 // Use of scoped_ptr helps manage cached value's lifetime,}\par
00362     {\cf20 // which is bound by the lifespan of the iterator itself.}\par
00363     {\cf17 mutable} scoped_ptr<const T> value_;\par
00364   \};  {\cf20 // class ValuesInIteratorRangeGenerator::Iterator}\par
00365 \par
00366   {\cf20 // No implementation - assignment is unsupported.}\par
00367   {\cf18 void} operator=({\cf17 const} ValuesInIteratorRangeGenerator& other);\par
00368 \par
00369   {\cf17 const} ContainerType container_;\par
00370 \};  {\cf20 // class ValuesInIteratorRangeGenerator}\par
00371 \par
00372 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
00373 {\cf20 //}\par
00374 {\cf20 // Default parameterized test name generator, returns a string containing the}\par
00375 {\cf20 // integer test parameter index.}\par
00376 {\cf17 template} <{\cf17 class} ParamType>\par
00377 std::string DefaultParamName({\cf17 const} TestParamInfo<ParamType>& info) \{\par
00378   Message name_stream;\par
00379   name_stream << info.index;\par
00380   {\cf19 return} name_stream.GetString();\par
00381 \}\par
00382 \par
00383 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
00384 {\cf20 //}\par
00385 {\cf20 // Parameterized test name overload helpers, which help the}\par
00386 {\cf20 // INSTANTIATE_TEST_CASE_P macro choose between the default parameterized}\par
00387 {\cf20 // test name generator and user param name generator.}\par
00388 {\cf17 template} <{\cf17 class} ParamType, {\cf17 class} ParamNameGenFunctor>\par
00389 ParamNameGenFunctor GetParamNameGen(ParamNameGenFunctor func) \{\par
00390   {\cf19 return} func;\par
00391 \}\par
00392 \par
00393 {\cf17 template} <{\cf17 class} ParamType>\par
00394 {\cf17 struct }ParamNameGenFunc \{\par
00395   {\cf17 typedef} std::string Type({\cf17 const} TestParamInfo<ParamType>&);\par
00396 \};\par
00397 \par
00398 {\cf17 template} <{\cf17 class} ParamType>\par
00399 {\cf17 typename} ParamNameGenFunc<ParamType>::Type *GetParamNameGen() \{\par
00400   {\cf19 return} DefaultParamName;\par
00401 \}\par
00402 \par
00403 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
00404 {\cf20 //}\par
00405 {\cf20 // Stores a parameter value and later creates tests parameterized with that}\par
00406 {\cf20 // value.}\par
00407 {\cf17 template} <{\cf17 class} TestClass>\par
00408 {\cf17 class }ParameterizedTestFactory : {\cf17 public} TestFactoryBase \{\par
00409  {\cf17 public}:\par
00410   {\cf17 typedef} {\cf17 typename} TestClass::ParamType ParamType;\par
00411   {\cf17 explicit} ParameterizedTestFactory(ParamType parameter) :\par
00412       parameter_(parameter) \{\}\par
00413   {\cf17 virtual} Test* CreateTest() \{\par
00414     TestClass::SetParam(&parameter_);\par
00415     {\cf19 return} {\cf17 new} TestClass();\par
00416   \}\par
00417 \par
00418  {\cf17 private}:\par
00419   {\cf17 const} ParamType parameter_;\par
00420 \par
00421   GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestFactory);\par
00422 \};\par
00423 \par
00424 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
00425 {\cf20 //}\par
00426 {\cf20 // TestMetaFactoryBase is a base class for meta-factories that create}\par
00427 {\cf20 // test factories for passing into MakeAndRegisterTestInfo function.}\par
00428 {\cf17 template} <{\cf17 class} ParamType>\par
00429 {\cf17 class }TestMetaFactoryBase \{\par
00430  {\cf17 public}:\par
00431   {\cf17 virtual} ~TestMetaFactoryBase() \{\}\par
00432 \par
00433   {\cf17 virtual} TestFactoryBase* CreateTestFactory(ParamType parameter) = 0;\par
00434 \};\par
00435 \par
00436 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
00437 {\cf20 //}\par
00438 {\cf20 // TestMetaFactory creates test factories for passing into}\par
00439 {\cf20 // MakeAndRegisterTestInfo function. Since MakeAndRegisterTestInfo receives}\par
00440 {\cf20 // ownership of test factory pointer, same factory object cannot be passed}\par
00441 {\cf20 // into that method twice. But ParameterizedTestCaseInfo is going to call}\par
00442 {\cf20 // it for each Test/Parameter value combination. Thus it needs meta factory}\par
00443 {\cf20 // creator class.}\par
00444 {\cf17 template} <{\cf17 class} TestCase>\par
00445 {\cf17 class }TestMetaFactory\par
00446     : {\cf17 public} TestMetaFactoryBase<typename TestCase::ParamType> \{\par
00447  {\cf17 public}:\par
00448   {\cf17 typedef} {\cf17 typename} TestCase::ParamType ParamType;\par
00449 \par
00450   TestMetaFactory() \{\}\par
00451 \par
00452   {\cf17 virtual} TestFactoryBase* CreateTestFactory(ParamType parameter) \{\par
00453     {\cf19 return} {\cf17 new} ParameterizedTestFactory<TestCase>(parameter);\par
00454   \}\par
00455 \par
00456  {\cf17 private}:\par
00457   GTEST_DISALLOW_COPY_AND_ASSIGN_(TestMetaFactory);\par
00458 \};\par
00459 \par
00460 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
00461 {\cf20 //}\par
00462 {\cf20 // ParameterizedTestCaseInfoBase is a generic interface}\par
00463 {\cf20 // to ParameterizedTestCaseInfo classes. ParameterizedTestCaseInfoBase}\par
00464 {\cf20 // accumulates test information provided by TEST_P macro invocations}\par
00465 {\cf20 // and generators provided by INSTANTIATE_TEST_CASE_P macro invocations}\par
00466 {\cf20 // and uses that information to register all resulting test instances}\par
00467 {\cf20 // in RegisterTests method. The ParameterizeTestCaseRegistry class holds}\par
00468 {\cf20 // a collection of pointers to the ParameterizedTestCaseInfo objects}\par
00469 {\cf20 // and calls RegisterTests() on each of them when asked.}\par
00470 {\cf17 class }ParameterizedTestCaseInfoBase \{\par
00471  {\cf17 public}:\par
00472   {\cf17 virtual} ~ParameterizedTestCaseInfoBase() \{\}\par
00473 \par
00474   {\cf20 // Base part of test case name for display purposes.}\par
00475   {\cf17 virtual} {\cf17 const} std::string& GetTestCaseName() {\cf17 const} = 0;\par
00476   {\cf20 // Test case id to verify identity.}\par
00477   {\cf17 virtual} TypeId GetTestCaseTypeId() {\cf17 const} = 0;\par
00478   {\cf20 // UnitTest class invokes this method to register tests in this}\par
00479   {\cf20 // test case right before running them in RUN_ALL_TESTS macro.}\par
00480   {\cf20 // This method should not be called more then once on any single}\par
00481   {\cf20 // instance of a ParameterizedTestCaseInfoBase derived class.}\par
00482   {\cf17 virtual} {\cf18 void} RegisterTests() = 0;\par
00483 \par
00484  {\cf17 protected}:\par
00485   ParameterizedTestCaseInfoBase() \{\}\par
00486 \par
00487  {\cf17 private}:\par
00488   GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseInfoBase);\par
00489 \};\par
00490 \par
00491 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
00492 {\cf20 //}\par
00493 {\cf20 // ParameterizedTestCaseInfo accumulates tests obtained from TEST_P}\par
00494 {\cf20 // macro invocations for a particular test case and generators}\par
00495 {\cf20 // obtained from INSTANTIATE_TEST_CASE_P macro invocations for that}\par
00496 {\cf20 // test case. It registers tests with all values generated by all}\par
00497 {\cf20 // generators when asked.}\par
00498 {\cf17 template} <{\cf17 class} TestCase>\par
00499 {\cf17 class }ParameterizedTestCaseInfo : {\cf17 public} ParameterizedTestCaseInfoBase \{\par
00500  {\cf17 public}:\par
00501   {\cf20 // ParamType and GeneratorCreationFunc are private types but are required}\par
00502   {\cf20 // for declarations of public methods AddTestPattern() and}\par
00503   {\cf20 // AddTestCaseInstantiation().}\par
00504   {\cf17 typedef} {\cf17 typename} TestCase::ParamType ParamType;\par
00505   {\cf20 // A function that returns an instance of appropriate generator type.}\par
00506   {\cf17 typedef} ParamGenerator<ParamType>(GeneratorCreationFunc)();\par
00507   {\cf17 typedef} {\cf17 typename} ParamNameGenFunc<ParamType>::Type ParamNameGeneratorFunc;\par
00508 \par
00509   {\cf17 explicit} ParameterizedTestCaseInfo(\par
00510       {\cf17 const} {\cf18 char}* name, CodeLocation code_location)\par
00511       : test_case_name_(name), code_location_(code_location) \{\}\par
00512 \par
00513   {\cf20 // Test case base name for display purposes.}\par
00514   {\cf17 virtual} {\cf17 const} std::string& GetTestCaseName(){\cf17  const }\{ {\cf19 return} test_case_name_; \}\par
00515   {\cf20 // Test case id to verify identity.}\par
00516   {\cf17 virtual} TypeId GetTestCaseTypeId(){\cf17  const }\{ {\cf19 return} GetTypeId<TestCase>(); \}\par
00517   {\cf20 // TEST_P macro uses AddTestPattern() to record information}\par
00518   {\cf20 // about a single test in a LocalTestInfo structure.}\par
00519   {\cf20 // test_case_name is the base name of the test case (without invocation}\par
00520   {\cf20 // prefix). test_base_name is the name of an individual test without}\par
00521   {\cf20 // parameter index. For the test SequenceA/FooTest.DoBar/1 FooTest is}\par
00522   {\cf20 // test case base name and DoBar is test base name.}\par
00523   {\cf18 void} AddTestPattern({\cf17 const} {\cf18 char}* test_case_name,\par
00524                       {\cf17 const} {\cf18 char}* test_base_name,\par
00525                       TestMetaFactoryBase<ParamType>* meta_factory) \{\par
00526     tests_.push_back(linked_ptr<TestInfo>({\cf17 new} TestInfo(test_case_name,\par
00527                                                        test_base_name,\par
00528                                                        meta_factory)));\par
00529   \}\par
00530   {\cf20 // INSTANTIATE_TEST_CASE_P macro uses AddGenerator() to record information}\par
00531   {\cf20 // about a generator.}\par
00532   {\cf18 int} AddTestCaseInstantiation({\cf17 const} std::string& instantiation_name,\par
00533                                GeneratorCreationFunc* func,\par
00534                                ParamNameGeneratorFunc* name_func,\par
00535                                {\cf17 const} {\cf18 char}* file, {\cf18 int} line) \{\par
00536     instantiations_.push_back(\par
00537         InstantiationInfo(instantiation_name, func, name_func, file, line));\par
00538     {\cf19 return} 0;  {\cf20 // Return value used only to run this method in namespace scope.}\par
00539   \}\par
00540   {\cf20 // UnitTest class invokes this method to register tests in this test case}\par
00541   {\cf20 // test cases right before running tests in RUN_ALL_TESTS macro.}\par
00542   {\cf20 // This method should not be called more then once on any single}\par
00543   {\cf20 // instance of a ParameterizedTestCaseInfoBase derived class.}\par
00544   {\cf20 // UnitTest has a guard to prevent from calling this method more then once.}\par
00545   {\cf17 virtual} {\cf18 void} RegisterTests() \{\par
00546     {\cf19 for} ({\cf17 typename} TestInfoContainer::iterator test_it = tests_.begin();\par
00547          test_it != tests_.end(); ++test_it) \{\par
00548       linked_ptr<TestInfo> test_info = *test_it;\par
00549       {\cf19 for} ({\cf17 typename} InstantiationContainer::iterator gen_it =\par
00550                instantiations_.begin(); gen_it != instantiations_.end();\par
00551                ++gen_it) \{\par
00552         {\cf17 const} std::string& instantiation_name = gen_it->name;\par
00553         ParamGenerator<ParamType> generator((*gen_it->generator)());\par
00554         ParamNameGeneratorFunc* name_func = gen_it->name_func;\par
00555         {\cf17 const} {\cf18 char}* file = gen_it->file;\par
00556         {\cf18 int} line = gen_it->line;\par
00557 \par
00558         std::string test_case_name;\par
00559         {\cf19 if} ( !instantiation_name.empty() )\par
00560           test_case_name = instantiation_name + {\cf22 "/"};\par
00561         test_case_name += test_info->test_case_base_name;\par
00562 \par
00563         {\cf18 size_t} i = 0;\par
00564         std::set<std::string> test_param_names;\par
00565         {\cf19 for} ({\cf17 typename} ParamGenerator<ParamType>::iterator param_it =\par
00566                  generator.begin();\par
00567              param_it != generator.end(); ++param_it, ++i) \{\par
00568           Message test_name_stream;\par
00569 \par
00570           std::string param_name = name_func(\par
00571               TestParamInfo<ParamType>(*param_it, i));\par
00572 \par
00573           GTEST_CHECK_(IsValidParamName(param_name))\par
00574               << {\cf22 "Parameterized test name '"} << param_name\par
00575               << {\cf22 "' is invalid, in "} << file\par
00576               << {\cf22 " line "} << line << std::endl;\par
00577 \par
00578           GTEST_CHECK_(test_param_names.count(param_name) == 0)\par
00579               << {\cf22 "Duplicate parameterized test name '"} << param_name\par
00580               << {\cf22 "', in "} << file << {\cf22 " line "} << line << std::endl;\par
00581 \par
00582           test_param_names.insert(param_name);\par
00583 \par
00584           test_name_stream << test_info->test_base_name << {\cf22 "/"} << param_name;\par
00585           MakeAndRegisterTestInfo(\par
00586               test_case_name.c_str(),\par
00587               test_name_stream.GetString().c_str(),\par
00588               NULL,  {\cf20 // No type parameter.}\par
00589               PrintToString(*param_it).c_str(),\par
00590               code_location_,\par
00591               GetTestCaseTypeId(),\par
00592               TestCase::SetUpTestCase,\par
00593               TestCase::TearDownTestCase,\par
00594               test_info->test_meta_factory->CreateTestFactory(*param_it));\par
00595         \}  {\cf20 // for param_it}\par
00596       \}  {\cf20 // for gen_it}\par
00597     \}  {\cf20 // for test_it}\par
00598   \}  {\cf20 // RegisterTests}\par
00599 \par
00600  {\cf17 private}:\par
00601   {\cf20 // LocalTestInfo structure keeps information about a single test registered}\par
00602   {\cf20 // with TEST_P macro.}\par
00603   {\cf17 struct }TestInfo \{\par
00604     TestInfo({\cf17 const} {\cf18 char}* a_test_case_base_name,\par
00605              {\cf17 const} {\cf18 char}* a_test_base_name,\par
00606              TestMetaFactoryBase<ParamType>* a_test_meta_factory) :\par
00607         test_case_base_name(a_test_case_base_name),\par
00608         test_base_name(a_test_base_name),\par
00609         test_meta_factory(a_test_meta_factory) \{\}\par
00610 \par
00611     {\cf17 const} std::string test_case_base_name;\par
00612     {\cf17 const} std::string test_base_name;\par
00613     {\cf17 const} scoped_ptr<TestMetaFactoryBase<ParamType> > test_meta_factory;\par
00614   \};\par
00615   typedef ::std::vector<linked_ptr<TestInfo> > TestInfoContainer;\par
00616   {\cf20 // Records data received from INSTANTIATE_TEST_CASE_P macros:}\par
00617   {\cf20 //  <Instantiation name, Sequence generator creation function,}\par
00618   {\cf20 //     Name generator function, Source file, Source line>}\par
00619   {\cf17 struct }InstantiationInfo \{\par
00620       InstantiationInfo({\cf17 const} std::string &name_in,\par
00621                         GeneratorCreationFunc* generator_in,\par
00622                         ParamNameGeneratorFunc* name_func_in,\par
00623                         {\cf17 const} {\cf18 char}* file_in,\par
00624                         {\cf18 int} line_in)\par
00625           : name(name_in),\par
00626             generator(generator_in),\par
00627             name_func(name_func_in),\par
00628             file(file_in),\par
00629             line(line_in) \{\}\par
00630 \par
00631       std::string name;\par
00632       GeneratorCreationFunc* generator;\par
00633       ParamNameGeneratorFunc* name_func;\par
00634       {\cf17 const} {\cf18 char}* file;\par
00635       {\cf18 int} line;\par
00636   \};\par
00637   typedef ::std::vector<InstantiationInfo> InstantiationContainer;\par
00638 \par
00639   {\cf17 static} {\cf18 bool} IsValidParamName({\cf17 const} std::string& name) \{\par
00640     {\cf20 // Check for empty string}\par
00641     {\cf19 if} (name.empty())\par
00642       {\cf19 return} {\cf17 false};\par
00643 \par
00644     {\cf20 // Check for invalid characters}\par
00645     {\cf19 for} (std::string::size_type index = 0; index < name.size(); ++index) \{\par
00646       {\cf19 if} (!isalnum(name[index]) && name[index] != {\cf23 '_'})\par
00647         {\cf19 return} {\cf17 false};\par
00648     \}\par
00649 \par
00650     {\cf19 return} {\cf17 true};\par
00651   \}\par
00652 \par
00653   {\cf17 const} std::string test_case_name_;\par
00654   CodeLocation code_location_;\par
00655   TestInfoContainer tests_;\par
00656   InstantiationContainer instantiations_;\par
00657 \par
00658   GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseInfo);\par
00659 \};  {\cf20 // class ParameterizedTestCaseInfo}\par
00660 \par
00661 {\cf20 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.}\par
00662 {\cf20 //}\par
00663 {\cf20 // ParameterizedTestCaseRegistry contains a map of ParameterizedTestCaseInfoBase}\par
00664 {\cf20 // classes accessed by test case names. TEST_P and INSTANTIATE_TEST_CASE_P}\par
00665 {\cf20 // macros use it to locate their corresponding ParameterizedTestCaseInfo}\par
00666 {\cf20 // descriptors.}\par
00667 {\cf17 class }ParameterizedTestCaseRegistry \{\par
00668  {\cf17 public}:\par
00669   ParameterizedTestCaseRegistry() \{\}\par
00670   ~ParameterizedTestCaseRegistry() \{\par
00671     {\cf19 for} (TestCaseInfoContainer::iterator it = test_case_infos_.begin();\par
00672          it != test_case_infos_.end(); ++it) \{\par
00673       {\cf17 delete} *it;\par
00674     \}\par
00675   \}\par
00676 \par
00677   {\cf20 // Looks up or creates and returns a structure containing information about}\par
00678   {\cf20 // tests and instantiations of a particular test case.}\par
00679   {\cf17 template} <{\cf17 class} TestCase>\par
00680   ParameterizedTestCaseInfo<TestCase>* GetTestCasePatternHolder(\par
00681       {\cf17 const} {\cf18 char}* test_case_name,\par
00682       CodeLocation code_location) \{\par
00683     ParameterizedTestCaseInfo<TestCase>* typed_test_info = NULL;\par
00684     {\cf19 for} (TestCaseInfoContainer::iterator it = test_case_infos_.begin();\par
00685          it != test_case_infos_.end(); ++it) \{\par
00686       {\cf19 if} ((*it)->GetTestCaseName() == test_case_name) \{\par
00687         {\cf19 if} ((*it)->GetTestCaseTypeId() != GetTypeId<TestCase>()) \{\par
00688           {\cf20 // Complain about incorrect usage of Google Test facilities}\par
00689           {\cf20 // and terminate the program since we cannot guaranty correct}\par
00690           {\cf20 // test case setup and tear-down in this case.}\par
00691           ReportInvalidTestCaseType(test_case_name, code_location);\par
00692           posix::Abort();\par
00693         \} {\cf19 else} \{\par
00694           {\cf20 // At this point we are sure that the object we found is of the same}\par
00695           {\cf20 // type we are looking for, so we downcast it to that type}\par
00696           {\cf20 // without further checks.}\par
00697           typed_test_info = CheckedDowncastToActualType<\par
00698               ParameterizedTestCaseInfo<TestCase> >(*it);\par
00699         \}\par
00700         {\cf19 break};\par
00701       \}\par
00702     \}\par
00703     {\cf19 if} (typed_test_info == NULL) \{\par
00704       typed_test_info = {\cf17 new} ParameterizedTestCaseInfo<TestCase>(\par
00705           test_case_name, code_location);\par
00706       test_case_infos_.push_back(typed_test_info);\par
00707     \}\par
00708     {\cf19 return} typed_test_info;\par
00709   \}\par
00710   {\cf18 void} RegisterTests() \{\par
00711     {\cf19 for} (TestCaseInfoContainer::iterator it = test_case_infos_.begin();\par
00712          it != test_case_infos_.end(); ++it) \{\par
00713       (*it)->RegisterTests();\par
00714     \}\par
00715   \}\par
00716 \par
00717  {\cf17 private}:\par
00718   typedef ::std::vector<ParameterizedTestCaseInfoBase*> TestCaseInfoContainer;\par
00719 \par
00720   TestCaseInfoContainer test_case_infos_;\par
00721 \par
00722   GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseRegistry);\par
00723 \};\par
00724 \par
00725 \}  {\cf20 // namespace internal}\par
00726 \}  {\cf20 // namespace testing}\par
00727 \par
00728 {\cf21 #endif  }{\cf20 //  GTEST_HAS_PARAM_TEST}\par
00729 \par
00730 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/internal/gtest-port-arch.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-port-arch.h}
{\xe \v gtest/include/gtest/internal/gtest-port-arch.h}
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-port-arch.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-port-arch.h}
{\xe \v gtest/include/gtest/internal/gtest-port-arch.h}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2015, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // The Google C++ Testing Framework (Google Test)}\par
00031 {\cf20 //}\par
00032 {\cf20 // This header file defines the GTEST_OS_* macro.}\par
00033 {\cf20 // It is separate from gtest-port.h so that custom/gtest-port.h can include it.}\par
00034 \par
00035 {\cf21 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_ARCH_H_}\par
00036 {\cf21 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_ARCH_H_}\par
00037 \par
00038 {\cf20 // Determines the platform on which Google Test is compiled.}\par
00039 {\cf21 #ifdef __CYGWIN__}\par
00040 {\cf21 # define GTEST_OS_CYGWIN 1}\par
00041 {\cf21 #elif defined __SYMBIAN32__}\par
00042 {\cf21 # define GTEST_OS_SYMBIAN 1}\par
00043 {\cf21 #elif defined _WIN32}\par
00044 {\cf21 # define GTEST_OS_WINDOWS 1}\par
00045 {\cf21 # ifdef _WIN32_WCE}\par
00046 {\cf21 #  define GTEST_OS_WINDOWS_MOBILE 1}\par
00047 {\cf21 # elif defined(__MINGW__) || defined(__MINGW32__)}\par
00048 {\cf21 #  define GTEST_OS_WINDOWS_MINGW 1}\par
00049 {\cf21 # elif defined(WINAPI_FAMILY)}\par
00050 {\cf21 #  include <winapifamily.h>}\par
00051 {\cf21 #  if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)}\par
00052 {\cf21 #   define GTEST_OS_WINDOWS_DESKTOP 1}\par
00053 {\cf21 #  elif WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_PHONE_APP)}\par
00054 {\cf21 #   define GTEST_OS_WINDOWS_PHONE 1}\par
00055 {\cf21 #  elif WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)}\par
00056 {\cf21 #   define GTEST_OS_WINDOWS_RT 1}\par
00057 {\cf21 #  else}\par
00058     {\cf20 // WINAPI_FAMILY defined but no known partition matched.}\par
00059     {\cf20 // Default to desktop.}\par
00060 {\cf21 #   define GTEST_OS_WINDOWS_DESKTOP 1}\par
00061 {\cf21 #  endif}\par
00062 {\cf21 # else}\par
00063 {\cf21 #  define GTEST_OS_WINDOWS_DESKTOP 1}\par
00064 {\cf21 # endif  }{\cf20 // _WIN32_WCE}\par
00065 {\cf21 #elif defined __APPLE__}\par
00066 {\cf21 # define GTEST_OS_MAC 1}\par
00067 {\cf21 # if TARGET_OS_IPHONE}\par
00068 {\cf21 #  define GTEST_OS_IOS 1}\par
00069 {\cf21 # endif}\par
00070 {\cf21 #elif defined __FreeBSD__}\par
00071 {\cf21 # define GTEST_OS_FREEBSD 1}\par
00072 {\cf21 #elif defined __linux__}\par
00073 {\cf21 # define GTEST_OS_LINUX 1}\par
00074 {\cf21 # if defined __ANDROID__}\par
00075 {\cf21 #  define GTEST_OS_LINUX_ANDROID 1}\par
00076 {\cf21 # endif}\par
00077 {\cf21 #elif defined __MVS__}\par
00078 {\cf21 # define GTEST_OS_ZOS 1}\par
00079 {\cf21 #elif defined(__sun) && defined(__SVR4)}\par
00080 {\cf21 # define GTEST_OS_SOLARIS 1}\par
00081 {\cf21 #elif defined(_AIX)}\par
00082 {\cf21 # define GTEST_OS_AIX 1}\par
00083 {\cf21 #elif defined(__hpux)}\par
00084 {\cf21 # define GTEST_OS_HPUX 1}\par
00085 {\cf21 #elif defined __native_client__}\par
00086 {\cf21 # define GTEST_OS_NACL 1}\par
00087 {\cf21 #elif defined __NetBSD__}\par
00088 {\cf21 # define GTEST_OS_NETBSD 1}\par
00089 {\cf21 #elif defined __OpenBSD__}\par
00090 {\cf21 # define GTEST_OS_OPENBSD 1}\par
00091 {\cf21 #elif defined __QNX__}\par
00092 {\cf21 # define GTEST_OS_QNX 1}\par
00093 {\cf21 #endif  }{\cf20 // __CYGWIN__}\par
00094 \par
00095 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_ARCH_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/internal/gtest-string.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-string.h}
{\xe \v gtest/include/gtest/internal/gtest-string.h}
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string.h>}\par
{\f2 #include <string>}\par
{\f2 #include "gtest/internal/gtest-port.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::String}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::StringStreamToString} (::std::stringstream *stream)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-string.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-string.h}
{\xe \v gtest/include/gtest/internal/gtest-string.h}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2005, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)}\par
00031 {\cf20 //}\par
00032 {\cf20 // The Google C++ Testing Framework (Google Test)}\par
00033 {\cf20 //}\par
00034 {\cf20 // This header file declares the String class and functions used internally by}\par
00035 {\cf20 // Google Test.  They are subject to change without notice. They should not used}\par
00036 {\cf20 // by code external to Google Test.}\par
00037 {\cf20 //}\par
00038 {\cf20 // This header file is #included by <gtest/internal/gtest-internal.h>.}\par
00039 {\cf20 // It should not be #included by other files.}\par
00040 \par
00041 {\cf21 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_STRING_H_}\par
00042 {\cf21 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_STRING_H_}\par
00043 \par
00044 {\cf21 #ifdef __BORLANDC__}\par
00045 {\cf20 // string.h is not guaranteed to provide strcpy on C++ Builder.}\par
00046 {\cf21 # include <mem.h>}\par
00047 {\cf21 #endif}\par
00048 \par
00049 {\cf21 #include <string.h>}\par
00050 {\cf21 #include <string>}\par
00051 \par
00052 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00053 \par
00054 {\cf17 namespace }testing \{\par
00055 {\cf17 namespace }internal \{\par
00056 \par
00057 {\cf20 // String - an abstract class holding static string utilities.}\par
00058 {\cf17 class }GTEST_API_ String \{\par
00059  {\cf17 public}:\par
00060   {\cf20 // Static utility methods}\par
00061 \par
00062   {\cf20 // Clones a 0-terminated C string, allocating memory using new.  The}\par
00063   {\cf20 // caller is responsible for deleting the return value using}\par
00064   {\cf20 // delete[].  Returns the cloned string, or NULL if the input is}\par
00065   {\cf20 // NULL.}\par
00066   {\cf20 //}\par
00067   {\cf20 // This is different from strdup() in string.h, which allocates}\par
00068   {\cf20 // memory using malloc().}\par
00069   {\cf17 static} {\cf17 const} {\cf18 char}* CloneCString({\cf17 const} {\cf18 char}* c_str);\par
00070 \par
00071 {\cf21 #if GTEST_OS_WINDOWS_MOBILE}\par
00072   {\cf20 // Windows CE does not have the 'ANSI' versions of Win32 APIs. To be}\par
00073   {\cf20 // able to pass strings to Win32 APIs on CE we need to convert them}\par
00074   {\cf20 // to 'Unicode', UTF-16.}\par
00075 \par
00076   {\cf20 // Creates a UTF-16 wide string from the given ANSI string, allocating}\par
00077   {\cf20 // memory using new. The caller is responsible for deleting the return}\par
00078   {\cf20 // value using delete[]. Returns the wide string, or NULL if the}\par
00079   {\cf20 // input is NULL.}\par
00080   {\cf20 //}\par
00081   {\cf20 // The wide string is created using the ANSI codepage (CP_ACP) to}\par
00082   {\cf20 // match the behaviour of the ANSI versions of Win32 calls and the}\par
00083   {\cf20 // C runtime.}\par
00084   {\cf17 static} LPCWSTR AnsiToUtf16({\cf17 const} {\cf18 char}* c_str);\par
00085 \par
00086   {\cf20 // Creates an ANSI string from the given wide string, allocating}\par
00087   {\cf20 // memory using new. The caller is responsible for deleting the return}\par
00088   {\cf20 // value using delete[]. Returns the ANSI string, or NULL if the}\par
00089   {\cf20 // input is NULL.}\par
00090   {\cf20 //}\par
00091   {\cf20 // The returned string is created using the ANSI codepage (CP_ACP) to}\par
00092   {\cf20 // match the behaviour of the ANSI versions of Win32 calls and the}\par
00093   {\cf20 // C runtime.}\par
00094   {\cf17 static} {\cf17 const} {\cf18 char}* Utf16ToAnsi(LPCWSTR utf16_str);\par
00095 {\cf21 #endif}\par
00096 \par
00097   {\cf20 // Compares two C strings.  Returns true iff they have the same content.}\par
00098   {\cf20 //}\par
00099   {\cf20 // Unlike strcmp(), this function can handle NULL argument(s).  A}\par
00100   {\cf20 // NULL C string is considered different to any non-NULL C string,}\par
00101   {\cf20 // including the empty string.}\par
00102   {\cf17 static} {\cf18 bool} CStringEquals({\cf17 const} {\cf18 char}* lhs, {\cf17 const} {\cf18 char}* rhs);\par
00103 \par
00104   {\cf20 // Converts a wide C string to a String using the UTF-8 encoding.}\par
00105   {\cf20 // NULL will be converted to "(null)".  If an error occurred during}\par
00106   {\cf20 // the conversion, "(failed to convert from wide string)" is}\par
00107   {\cf20 // returned.}\par
00108   {\cf17 static} std::string ShowWideCString({\cf17 const} {\cf18 wchar_t}* wide_c_str);\par
00109 \par
00110   {\cf20 // Compares two wide C strings.  Returns true iff they have the same}\par
00111   {\cf20 // content.}\par
00112   {\cf20 //}\par
00113   {\cf20 // Unlike wcscmp(), this function can handle NULL argument(s).  A}\par
00114   {\cf20 // NULL C string is considered different to any non-NULL C string,}\par
00115   {\cf20 // including the empty string.}\par
00116   {\cf17 static} {\cf18 bool} WideCStringEquals({\cf17 const} {\cf18 wchar_t}* lhs, {\cf17 const} {\cf18 wchar_t}* rhs);\par
00117 \par
00118   {\cf20 // Compares two C strings, ignoring case.  Returns true iff they}\par
00119   {\cf20 // have the same content.}\par
00120   {\cf20 //}\par
00121   {\cf20 // Unlike strcasecmp(), this function can handle NULL argument(s).}\par
00122   {\cf20 // A NULL C string is considered different to any non-NULL C string,}\par
00123   {\cf20 // including the empty string.}\par
00124   {\cf17 static} {\cf18 bool} CaseInsensitiveCStringEquals({\cf17 const} {\cf18 char}* lhs,\par
00125                                            {\cf17 const} {\cf18 char}* rhs);\par
00126 \par
00127   {\cf20 // Compares two wide C strings, ignoring case.  Returns true iff they}\par
00128   {\cf20 // have the same content.}\par
00129   {\cf20 //}\par
00130   {\cf20 // Unlike wcscasecmp(), this function can handle NULL argument(s).}\par
00131   {\cf20 // A NULL C string is considered different to any non-NULL wide C string,}\par
00132   {\cf20 // including the empty string.}\par
00133   {\cf20 // NB: The implementations on different platforms slightly differ.}\par
00134   {\cf20 // On windows, this method uses _wcsicmp which compares according to LC_CTYPE}\par
00135   {\cf20 // environment variable. On GNU platform this method uses wcscasecmp}\par
00136   {\cf20 // which compares according to LC_CTYPE category of the current locale.}\par
00137   {\cf20 // On MacOS X, it uses towlower, which also uses LC_CTYPE category of the}\par
00138   {\cf20 // current locale.}\par
00139   {\cf17 static} {\cf18 bool} CaseInsensitiveWideCStringEquals({\cf17 const} {\cf18 wchar_t}* lhs,\par
00140                                                {\cf17 const} {\cf18 wchar_t}* rhs);\par
00141 \par
00142   {\cf20 // Returns true iff the given string ends with the given suffix, ignoring}\par
00143   {\cf20 // case. Any string is considered to end with an empty suffix.}\par
00144   {\cf17 static} {\cf18 bool} EndsWithCaseInsensitive(\par
00145       {\cf17 const} std::string& str, {\cf17 const} std::string& suffix);\par
00146 \par
00147   {\cf20 // Formats an int value as "%02d".}\par
00148   {\cf17 static} std::string FormatIntWidth2({\cf18 int} value);  {\cf20 // "%02d" for width == 2}\par
00149 \par
00150   {\cf20 // Formats an int value as "%X".}\par
00151   {\cf17 static} std::string FormatHexInt({\cf18 int} value);\par
00152 \par
00153   {\cf20 // Formats a byte as "%02X".}\par
00154   {\cf17 static} std::string FormatByte({\cf18 unsigned} {\cf18 char} value);\par
00155 \par
00156  {\cf17 private}:\par
00157   String();  {\cf20 // Not meant to be instantiated.}\par
00158 \};  {\cf20 // class String}\par
00159 \par
00160 {\cf20 // Gets the content of the stringstream's buffer as an std::string.  Each '\\0'}\par
00161 {\cf20 // character in the buffer is replaced with "\\\\0".}\par
00162 GTEST_API_ std::string StringStreamToString(::std::stringstream* stream);\par
00163 \par
00164 \}  {\cf20 // namespace internal}\par
00165 \}  {\cf20 // namespace testing}\par
00166 \par
00167 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_STRING_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/internal/gtest-tuple.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-tuple.h}
{\xe \v gtest/include/gtest/internal/gtest-tuple.h}
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <utility>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::ByRef< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::ByRef< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::AddRef< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::AddRef< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::TupleElement< true, 0, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::TupleElement< true, 1, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::TupleElement< true, 2, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::TupleElement< true, 3, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::TupleElement< true, 4, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::TupleElement< true, 5, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::TupleElement< true, 6, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::TupleElement< true, 7, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::TupleElement< true, 8, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::TupleElement< true, 9, GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b std::tr1::tuple<>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b std::tr1::tuple<>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::tuple_size< GTEST_0_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::tuple_size< GTEST_1_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::tuple_size< GTEST_2_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::tuple_size< GTEST_3_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::tuple_size< GTEST_4_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::tuple_size< GTEST_5_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::tuple_size< GTEST_6_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::tuple_size< GTEST_7_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::tuple_size< GTEST_8_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::tuple_size< GTEST_9_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::tuple_size< GTEST_10_TUPLE_(T) >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::tuple_element< k, Tuple >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b std::tr1::gtest_internal::Get< 0 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b std::tr1::gtest_internal::Get< 1 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b std::tr1::gtest_internal::Get< 2 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b std::tr1::gtest_internal::Get< 3 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b std::tr1::gtest_internal::Get< 4 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b std::tr1::gtest_internal::Get< 5 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b std::tr1::gtest_internal::Get< 6 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b std::tr1::gtest_internal::Get< 7 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b std::tr1::gtest_internal::Get< 8 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b std::tr1::gtest_internal::Get< 9 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::SameSizeTuplePrefixComparator< 0, 0 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::tr1::gtest_internal::SameSizeTuplePrefixComparator< k, k >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b std}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b std::tr1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b std::tr1::gtest_internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_DECLARE_TUPLE_AS_FRIEND_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_0_TUPLE_}(T)\~ tuple<>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_1_TUPLE_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_2_TUPLE_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_3_TUPLE_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_4_TUPLE_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_5_TUPLE_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_6_TUPLE_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_7_TUPLE_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_8_TUPLE_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_9_TUPLE_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_10_TUPLE_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_0_TYPENAMES_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_1_TYPENAMES_}(T)\~ typename T##0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_2_TYPENAMES_}(T)\~ typename T##0, typename T##1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_3_TYPENAMES_}(T)\~ typename T##0, typename T##1, typename T##2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_4_TYPENAMES_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_5_TYPENAMES_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_6_TYPENAMES_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_7_TYPENAMES_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_8_TYPENAMES_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_9_TYPENAMES_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_10_TYPENAMES_}(T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_BY_REF_}(T)\~ typename {\b ::std::tr1::gtest_internal::ByRef}<T>::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_ADD_REF_}(T)\~ typename {\b ::std::tr1::gtest_internal::AddRef}<T>::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_TUPLE_ELEMENT_}(k,  Tuple)\~ typename tuple_element<k, Tuple >::type\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_1_TYPENAMES_}(T) > class {\b std::tr1::GTEST_1_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_2_TYPENAMES_}(T) > class {\b std::tr1::GTEST_2_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_3_TYPENAMES_}(T) > class {\b std::tr1::GTEST_3_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_4_TYPENAMES_}(T) > class {\b std::tr1::GTEST_4_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_5_TYPENAMES_}(T) > class {\b std::tr1::GTEST_5_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_6_TYPENAMES_}(T) > class {\b std::tr1::GTEST_6_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_7_TYPENAMES_}(T) > class {\b std::tr1::GTEST_7_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_8_TYPENAMES_}(T) > class {\b std::tr1::GTEST_8_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_9_TYPENAMES_}(T) > class {\b std::tr1::GTEST_9_TUPLE_} (T)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
tuple {\b std::tr1::make_tuple} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_1_TYPENAMES_}(T) > {\b std::tr1::GTEST_1_TUPLE_} (T) make_tuple(const T0 &f0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_2_TYPENAMES_}(T) > {\b std::tr1::GTEST_2_TUPLE_} (T) make_tuple(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_3_TYPENAMES_}(T) > {\b std::tr1::GTEST_3_TUPLE_} (T) make_tuple(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_4_TYPENAMES_}(T) > {\b std::tr1::GTEST_4_TUPLE_} (T) make_tuple(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_5_TYPENAMES_}(T) > {\b std::tr1::GTEST_5_TUPLE_} (T) make_tuple(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_6_TYPENAMES_}(T) > {\b std::tr1::GTEST_6_TUPLE_} (T) make_tuple(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_7_TYPENAMES_}(T) > {\b std::tr1::GTEST_7_TUPLE_} (T) make_tuple(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_8_TYPENAMES_}(T) > {\b std::tr1::GTEST_8_TUPLE_} (T) make_tuple(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_9_TYPENAMES_}(T) > {\b std::tr1::GTEST_9_TUPLE_} (T) make_tuple(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T) > {\b std::tr1::GTEST_10_TUPLE_} (T) make_tuple(const T0 &f0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<int k, {\b GTEST_10_TYPENAMES_}(T) > {\b std::tr1::GTEST_ADD_REF_} ({\b GTEST_TUPLE_ELEMENT_}(k, {\b GTEST_10_TUPLE_}(T))) get({\b GTEST_10_TUPLE_}(T) &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<int k, {\b GTEST_10_TYPENAMES_}(T) > {\b std::tr1::GTEST_BY_REF_} ({\b GTEST_TUPLE_ELEMENT_}(k, {\b GTEST_10_TUPLE_}(T))) get(const {\b GTEST_10_TUPLE_}(T) &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T) , {\b GTEST_10_TYPENAMES_}(U) > bool {\b std::tr1::operator==} (const {\b GTEST_10_TUPLE_}(T)&t, const {\b GTEST_10_TUPLE_}(U)&u)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b GTEST_10_TYPENAMES_}(T) , {\b GTEST_10_TYPENAMES_}(U) > bool {\b std::tr1::operator!=} (const {\b GTEST_10_TUPLE_}(T)&t, const {\b GTEST_10_TUPLE_}(U)&u)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 & {\b std::tr1::f1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 & {\b std::tr1::f2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 const T3 & {\b std::tr1::f3}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 const T3 const T4 & {\b std::tr1::f4}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 const T3 const T4 const T5 & {\b std::tr1::f5}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 const T3 const T4 const T5 const T6 & {\b std::tr1::f6}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 const T3 const T4 const T5 const T6 const T7 & {\b std::tr1::f7}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 const T3 const T4 const T5 const T6 const T7 const T8 & {\b std::tr1::f8}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T1 const T2 const T3 const T4 const T5 const T6 const T7 const T8 const T9 & {\b std::tr1::f9}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v GTEST_0_TUPLE_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_0_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_0_TUPLE_( T)\~ tuple<>}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 65}}\par
}
{\xe \v GTEST_0_TYPENAMES_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_0_TYPENAMES_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_0_TYPENAMES_( T)}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 88}}\par
}
{\xe \v GTEST_10_TUPLE_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_10_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_10_TUPLE_( T)}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     tuple<T##0, T##1, T##2, T##3, T##4, T##5, T##6, \\\par
    T##7, T##8, T##9>\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 84}}\par
}
{\xe \v GTEST_10_TYPENAMES_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_10_TYPENAMES_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_10_TYPENAMES_( T)}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 typename} T##0, {\cf17 typename} T##1, {\cf17 typename} T##2, \\\par
    typename T##3, {\cf17 typename} T##4, {\cf17 typename} T##5, {\cf17 typename} T##6, \\\par
    typename T##7, {\cf17 typename} T##8, {\cf17 typename} T##9\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 105}}\par
}
{\xe \v GTEST_1_TUPLE_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_1_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_1_TUPLE_( T)}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     tuple<T##0, void, void, void, void, void, void, \\\par
    void, void, {\cf18 void}>\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 66}}\par
}
{\xe \v GTEST_1_TYPENAMES_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_1_TYPENAMES_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_1_TYPENAMES_( T)\~ typename T##0}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 89}}\par
}
{\xe \v GTEST_2_TUPLE_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_2_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_2_TUPLE_( T)}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     tuple<T##0, T##1, void, void, void, void, void, \\\par
    void, void, {\cf18 void}>\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 68}}\par
}
{\xe \v GTEST_2_TYPENAMES_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_2_TYPENAMES_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_2_TYPENAMES_( T)\~ typename T##0, typename T##1}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 90}}\par
}
{\xe \v GTEST_3_TUPLE_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_3_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_3_TUPLE_( T)}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     tuple<T##0, T##1, T##2, void, void, void, void, \\\par
    void, void, {\cf18 void}>\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 70}}\par
}
{\xe \v GTEST_3_TYPENAMES_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_3_TYPENAMES_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_3_TYPENAMES_( T)\~ typename T##0, typename T##1, typename T##2}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 91}}\par
}
{\xe \v GTEST_4_TUPLE_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_4_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_4_TUPLE_( T)}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     tuple<T##0, T##1, T##2, T##3, void, void, void, \\\par
    void, void, {\cf18 void}>\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 72}}\par
}
{\xe \v GTEST_4_TYPENAMES_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_4_TYPENAMES_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_4_TYPENAMES_( T)}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 typename} T##0, {\cf17 typename} T##1, {\cf17 typename} T##2, \\\par
    typename T##3\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 92}}\par
}
{\xe \v GTEST_5_TUPLE_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_5_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_5_TUPLE_( T)}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     tuple<T##0, T##1, T##2, T##3, T##4, void, void, \\\par
    void, void, {\cf18 void}>\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 74}}\par
}
{\xe \v GTEST_5_TYPENAMES_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_5_TYPENAMES_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_5_TYPENAMES_( T)}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 typename} T##0, {\cf17 typename} T##1, {\cf17 typename} T##2, \\\par
    typename T##3, {\cf17 typename} T##4\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 94}}\par
}
{\xe \v GTEST_6_TUPLE_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_6_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_6_TUPLE_( T)}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     tuple<T##0, T##1, T##2, T##3, T##4, T##5, void, \\\par
    void, void, {\cf18 void}>\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 76}}\par
}
{\xe \v GTEST_6_TYPENAMES_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_6_TYPENAMES_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_6_TYPENAMES_( T)}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 typename} T##0, {\cf17 typename} T##1, {\cf17 typename} T##2, \\\par
    typename T##3, {\cf17 typename} T##4, {\cf17 typename} T##5\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 96}}\par
}
{\xe \v GTEST_7_TUPLE_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_7_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_7_TUPLE_( T)}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     tuple<T##0, T##1, T##2, T##3, T##4, T##5, T##6, \\\par
    void, void, {\cf18 void}>\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 78}}\par
}
{\xe \v GTEST_7_TYPENAMES_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_7_TYPENAMES_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_7_TYPENAMES_( T)}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 typename} T##0, {\cf17 typename} T##1, {\cf17 typename} T##2, \\\par
    typename T##3, {\cf17 typename} T##4, {\cf17 typename} T##5, {\cf17 typename} T##6\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 98}}\par
}
{\xe \v GTEST_8_TUPLE_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_8_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_8_TUPLE_( T)}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     tuple<T##0, T##1, T##2, T##3, T##4, T##5, T##6, \\\par
    T##7, void, {\cf18 void}>\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 80}}\par
}
{\xe \v GTEST_8_TYPENAMES_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_8_TYPENAMES_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_8_TYPENAMES_( T)}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 typename} T##0, {\cf17 typename} T##1, {\cf17 typename} T##2, \\\par
    typename T##3, {\cf17 typename} T##4, {\cf17 typename} T##5, {\cf17 typename} T##6, {\cf17 typename} T##7\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 100}}\par
}
{\xe \v GTEST_9_TUPLE_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_9_TUPLE_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_9_TUPLE_( T)}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     tuple<T##0, T##1, T##2, T##3, T##4, T##5, T##6, \\\par
    T##7, T##8, {\cf18 void}>\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 82}}\par
}
{\xe \v GTEST_9_TYPENAMES_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_9_TYPENAMES_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_9_TYPENAMES_( T)}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 typename} T##0, {\cf17 typename} T##1, {\cf17 typename} T##2, \\\par
    typename T##3, {\cf17 typename} T##4, {\cf17 typename} T##5, {\cf17 typename} T##6, \\\par
    typename T##7, {\cf17 typename} T##8\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 102}}\par
}
{\xe \v GTEST_ADD_REF_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_ADD_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_ADD_REF_( T)\~ typename {\b ::std::tr1::gtest_internal::AddRef}<T>::type}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 142}}\par
}
{\xe \v GTEST_BY_REF_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_BY_REF_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_BY_REF_( T)\~ typename {\b ::std::tr1::gtest_internal::ByRef}<T>::type}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 132}}\par
}
{\xe \v GTEST_DECLARE_TUPLE_AS_FRIEND_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_DECLARE_TUPLE_AS_FRIEND_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_DECLARE_TUPLE_AS_FRIEND_}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template} <GTEST_10_TYPENAMES_(U)> {\cf17 friend} {\cf17 class }tuple; \\\par
   private:\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 51}}\par
}
{\xe \v GTEST_TUPLE_ELEMENT_\:gtest-tuple.h}
{\xe \v gtest-tuple.h\:GTEST_TUPLE_ELEMENT_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_TUPLE_ELEMENT_( k,  Tuple)\~ typename tuple_element<k, Tuple >::type}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-tuple.h} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 801}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-tuple.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-tuple.h}
{\xe \v gtest/include/gtest/internal/gtest-tuple.h}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // This file was GENERATED by command:}\par
00002 {\cf20 //     pump.py gtest-tuple.h.pump}\par
00003 {\cf20 // DO NOT EDIT BY HAND!!!}\par
00004 \par
00005 {\cf20 // Copyright 2009 Google Inc.}\par
00006 {\cf20 // All Rights Reserved.}\par
00007 {\cf20 //}\par
00008 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00009 {\cf20 // modification, are permitted provided that the following conditions are}\par
00010 {\cf20 // met:}\par
00011 {\cf20 //}\par
00012 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00013 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00014 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00015 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00016 {\cf20 // in the documentation and/or other materials provided with the}\par
00017 {\cf20 // distribution.}\par
00018 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00019 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00020 {\cf20 // this software without specific prior written permission.}\par
00021 {\cf20 //}\par
00022 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00023 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00025 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00026 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00027 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00028 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00029 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00030 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00031 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00032 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00033 {\cf20 //}\par
00034 {\cf20 // Author: wan@google.com (Zhanyong Wan)}\par
00035 \par
00036 {\cf20 // Implements a subset of TR1 tuple needed by Google Test and Google Mock.}\par
00037 \par
00038 {\cf21 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TUPLE_H_}\par
00039 {\cf21 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TUPLE_H_}\par
00040 \par
00041 {\cf21 #include <utility>}  {\cf20 // For ::std::pair.}\par
00042 \par
00043 {\cf20 // The compiler used in Symbian has a bug that prevents us from declaring the}\par
00044 {\cf20 // tuple template as a friend (it complains that tuple is redefined).  This}\par
00045 {\cf20 // hack bypasses the bug by declaring the members that should otherwise be}\par
00046 {\cf20 // private as public.}\par
00047 {\cf20 // Sun Studio versions < 12 also have the above bug.}\par
00048 {\cf21 #if defined(__SYMBIAN32__) || (defined(__SUNPRO_CC) && __SUNPRO_CC < 0x590)}\par
00049 {\cf21 # define GTEST_DECLARE_TUPLE_AS_FRIEND_ public:}\par
00050 {\cf21 #else}\par
00051 {\cf21 # define GTEST_DECLARE_TUPLE_AS_FRIEND_ \\}\par
00052 {\cf21     template <GTEST_10_TYPENAMES_(U)> friend class tuple; \\}\par
00053 {\cf21    private:}\par
00054 {\cf21 #endif}\par
00055 \par
00056 {\cf20 // Visual Studio 2010, 2012, and 2013 define symbols in std::tr1 that conflict}\par
00057 {\cf20 // with our own definitions. Therefore using our own tuple does not work on}\par
00058 {\cf20 // those compilers.}\par
00059 {\cf21 #if defined(_MSC_VER) && _MSC_VER >= 1600  }{\cf20 /* 1600 is Visual Studio 2010 */}{\cf21 }\par
00060 {\cf21 # error "gtest's tuple doesn't compile on Visual Studio 2010 or later. \\}\par
00061 {\cf21 GTEST_USE_OWN_TR1_TUPLE must be set to 0 on those compilers."}\par
00062 {\cf21 #endif}\par
00063 \par
00064 {\cf20 // GTEST_n_TUPLE_(T) is the type of an n-tuple.}\par
00065 {\cf21 #define GTEST_0_TUPLE_(T) tuple<>}\par
00066 {\cf21 #define GTEST_1_TUPLE_(T) tuple<T##0, void, void, void, void, void, void, \\}\par
00067 {\cf21     void, void, void>}\par
00068 {\cf21 #define GTEST_2_TUPLE_(T) tuple<T##0, T##1, void, void, void, void, void, \\}\par
00069 {\cf21     void, void, void>}\par
00070 {\cf21 #define GTEST_3_TUPLE_(T) tuple<T##0, T##1, T##2, void, void, void, void, \\}\par
00071 {\cf21     void, void, void>}\par
00072 {\cf21 #define GTEST_4_TUPLE_(T) tuple<T##0, T##1, T##2, T##3, void, void, void, \\}\par
00073 {\cf21     void, void, void>}\par
00074 {\cf21 #define GTEST_5_TUPLE_(T) tuple<T##0, T##1, T##2, T##3, T##4, void, void, \\}\par
00075 {\cf21     void, void, void>}\par
00076 {\cf21 #define GTEST_6_TUPLE_(T) tuple<T##0, T##1, T##2, T##3, T##4, T##5, void, \\}\par
00077 {\cf21     void, void, void>}\par
00078 {\cf21 #define GTEST_7_TUPLE_(T) tuple<T##0, T##1, T##2, T##3, T##4, T##5, T##6, \\}\par
00079 {\cf21     void, void, void>}\par
00080 {\cf21 #define GTEST_8_TUPLE_(T) tuple<T##0, T##1, T##2, T##3, T##4, T##5, T##6, \\}\par
00081 {\cf21     T##7, void, void>}\par
00082 {\cf21 #define GTEST_9_TUPLE_(T) tuple<T##0, T##1, T##2, T##3, T##4, T##5, T##6, \\}\par
00083 {\cf21     T##7, T##8, void>}\par
00084 {\cf21 #define GTEST_10_TUPLE_(T) tuple<T##0, T##1, T##2, T##3, T##4, T##5, T##6, \\}\par
00085 {\cf21     T##7, T##8, T##9>}\par
00086 \par
00087 {\cf20 // GTEST_n_TYPENAMES_(T) declares a list of n typenames.}\par
00088 {\cf21 #define GTEST_0_TYPENAMES_(T)}\par
00089 {\cf21 #define GTEST_1_TYPENAMES_(T) typename T##0}\par
00090 {\cf21 #define GTEST_2_TYPENAMES_(T) typename T##0, typename T##1}\par
00091 {\cf21 #define GTEST_3_TYPENAMES_(T) typename T##0, typename T##1, typename T##2}\par
00092 {\cf21 #define GTEST_4_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \\}\par
00093 {\cf21     typename T##3}\par
00094 {\cf21 #define GTEST_5_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \\}\par
00095 {\cf21     typename T##3, typename T##4}\par
00096 {\cf21 #define GTEST_6_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \\}\par
00097 {\cf21     typename T##3, typename T##4, typename T##5}\par
00098 {\cf21 #define GTEST_7_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \\}\par
00099 {\cf21     typename T##3, typename T##4, typename T##5, typename T##6}\par
00100 {\cf21 #define GTEST_8_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \\}\par
00101 {\cf21     typename T##3, typename T##4, typename T##5, typename T##6, typename T##7}\par
00102 {\cf21 #define GTEST_9_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \\}\par
00103 {\cf21     typename T##3, typename T##4, typename T##5, typename T##6, \\}\par
00104 {\cf21     typename T##7, typename T##8}\par
00105 {\cf21 #define GTEST_10_TYPENAMES_(T) typename T##0, typename T##1, typename T##2, \\}\par
00106 {\cf21     typename T##3, typename T##4, typename T##5, typename T##6, \\}\par
00107 {\cf21     typename T##7, typename T##8, typename T##9}\par
00108 \par
00109 {\cf20 // In theory, defining stuff in the ::std namespace is undefined}\par
00110 {\cf20 // behavior.  We can do this as we are playing the role of a standard}\par
00111 {\cf20 // library vendor.}\par
00112 {\cf17 namespace }std \{\par
00113 {\cf17 namespace }tr1 \{\par
00114 \par
00115 {\cf17 template} <{\cf17 typename} T0 = void, {\cf17 typename} T1 = void, {\cf17 typename} T2 = void,\par
00116     {\cf17 typename} T3 = void, {\cf17 typename} T4 = void, {\cf17 typename} T5 = void,\par
00117     {\cf17 typename} T6 = void, {\cf17 typename} T7 = void, {\cf17 typename} T8 = void,\par
00118     {\cf17 typename} T9 = {\cf18 void}>\par
00119 {\cf17 class }tuple;\par
00120 \par
00121 {\cf20 // Anything in namespace gtest_internal is Google Test's INTERNAL}\par
00122 {\cf20 // IMPLEMENTATION DETAIL and MUST NOT BE USED DIRECTLY in user code.}\par
00123 {\cf17 namespace }gtest_internal \{\par
00124 \par
00125 {\cf20 // ByRef<T>::type is T if T is a reference; otherwise it's const T&.}\par
00126 {\cf17 template} <{\cf17 typename} T>\par
00127 {\cf17 struct }ByRef \{ {\cf17 typedef} {\cf17 const} T& type; \};  {\cf20 // NOLINT}\par
00128 {\cf17 template} <{\cf17 typename} T>\par
00129 {\cf17 struct }ByRef<T&> \{ {\cf17 typedef} T& type; \};  {\cf20 // NOLINT}\par
00130 \par
00131 {\cf20 // A handy wrapper for ByRef.}\par
00132 {\cf21 #define GTEST_BY_REF_(T) typename ::std::tr1::gtest_internal::ByRef<T>::type}\par
00133 \par
00134 {\cf20 // AddRef<T>::type is T if T is a reference; otherwise it's T&.  This}\par
00135 {\cf20 // is the same as tr1::add_reference<T>::type.}\par
00136 {\cf17 template} <{\cf17 typename} T>\par
00137 {\cf17 struct }AddRef \{ {\cf17 typedef} T& type; \};  {\cf20 // NOLINT}\par
00138 {\cf17 template} <{\cf17 typename} T>\par
00139 {\cf17 struct }AddRef<T&> \{ {\cf17 typedef} T& type; \};  {\cf20 // NOLINT}\par
00140 \par
00141 {\cf20 // A handy wrapper for AddRef.}\par
00142 {\cf21 #define GTEST_ADD_REF_(T) typename ::std::tr1::gtest_internal::AddRef<T>::type}\par
00143 \par
00144 {\cf20 // A helper for implementing get<k>().}\par
00145 {\cf17 template} <{\cf18 int} k> {\cf17 class }Get;\par
00146 \par
00147 {\cf20 // A helper for implementing tuple_element<k, T>.  kIndexValid is true}\par
00148 {\cf20 // iff k < the number of fields in tuple type T.}\par
00149 {\cf17 template} <{\cf18 bool} kIndexVal{\cf18 id}, {\cf18 int} kIndex, {\cf17 class} Tuple>\par
00150 {\cf17 struct }TupleElement;\par
00151 \par
00152 {\cf17 template} <GTEST_10_TYPENAMES_(T)>\par
00153 {\cf17 struct }TupleElement<true, 0, GTEST_10_TUPLE_(T) > \{\par
00154   {\cf17 typedef} T0 type;\par
00155 \};\par
00156 \par
00157 {\cf17 template} <GTEST_10_TYPENAMES_(T)>\par
00158 {\cf17 struct }TupleElement<true, 1, GTEST_10_TUPLE_(T) > \{\par
00159   {\cf17 typedef} T1 type;\par
00160 \};\par
00161 \par
00162 {\cf17 template} <GTEST_10_TYPENAMES_(T)>\par
00163 {\cf17 struct }TupleElement<true, 2, GTEST_10_TUPLE_(T) > \{\par
00164   {\cf17 typedef} T2 type;\par
00165 \};\par
00166 \par
00167 {\cf17 template} <GTEST_10_TYPENAMES_(T)>\par
00168 {\cf17 struct }TupleElement<true, 3, GTEST_10_TUPLE_(T) > \{\par
00169   {\cf17 typedef} T3 type;\par
00170 \};\par
00171 \par
00172 {\cf17 template} <GTEST_10_TYPENAMES_(T)>\par
00173 {\cf17 struct }TupleElement<true, 4, GTEST_10_TUPLE_(T) > \{\par
00174   {\cf17 typedef} T4 type;\par
00175 \};\par
00176 \par
00177 {\cf17 template} <GTEST_10_TYPENAMES_(T)>\par
00178 {\cf17 struct }TupleElement<true, 5, GTEST_10_TUPLE_(T) > \{\par
00179   {\cf17 typedef} T5 type;\par
00180 \};\par
00181 \par
00182 {\cf17 template} <GTEST_10_TYPENAMES_(T)>\par
00183 {\cf17 struct }TupleElement<true, 6, GTEST_10_TUPLE_(T) > \{\par
00184   {\cf17 typedef} T6 type;\par
00185 \};\par
00186 \par
00187 {\cf17 template} <GTEST_10_TYPENAMES_(T)>\par
00188 {\cf17 struct }TupleElement<true, 7, GTEST_10_TUPLE_(T) > \{\par
00189   {\cf17 typedef} T7 type;\par
00190 \};\par
00191 \par
00192 {\cf17 template} <GTEST_10_TYPENAMES_(T)>\par
00193 {\cf17 struct }TupleElement<true, 8, GTEST_10_TUPLE_(T) > \{\par
00194   {\cf17 typedef} T8 type;\par
00195 \};\par
00196 \par
00197 {\cf17 template} <GTEST_10_TYPENAMES_(T)>\par
00198 {\cf17 struct }TupleElement<true, 9, GTEST_10_TUPLE_(T) > \{\par
00199   {\cf17 typedef} T9 type;\par
00200 \};\par
00201 \par
00202 \}  {\cf20 // namespace gtest_internal}\par
00203 \par
00204 {\cf17 template} <>\par
00205 {\cf17 class }tuple<> \{\par
00206  {\cf17 public}:\par
00207   tuple() \{\}\par
00208   tuple({\cf17 const} tuple& {\cf20 /* t */})  \{\}\par
00209   tuple& operator=({\cf17 const} tuple& {\cf20 /* t */}) \{ {\cf19 return} *{\cf17 this}; \}\par
00210 \};\par
00211 \par
00212 {\cf17 template} <GTEST_1_TYPENAMES_(T)>\par
00213 {\cf17 class }GTEST_1_TUPLE_(T) \{\par
00214  {\cf17 public}:\par
00215   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00216 \par
00217   tuple() : f0_() \{\}\par
00218 \par
00219   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0) : f0_(f0) \{\}\par
00220 \par
00221   tuple({\cf17 const} tuple& t) : f0_(t.f0_) \{\}\par
00222 \par
00223   {\cf17 template} <GTEST_1_TYPENAMES_(U)>\par
00224   tuple({\cf17 const} GTEST_1_TUPLE_(U)& t) : f0_(t.f0_) \{\}\par
00225 \par
00226   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00227 \par
00228   {\cf17 template} <GTEST_1_TYPENAMES_(U)>\par
00229   tuple& operator=({\cf17 const} GTEST_1_TUPLE_(U)& t) \{\par
00230     {\cf19 return} CopyFrom(t);\par
00231   \}\par
00232 \par
00233   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00234 \par
00235   {\cf17 template} <GTEST_1_TYPENAMES_(U)>\par
00236   tuple& CopyFrom({\cf17 const} GTEST_1_TUPLE_(U)& t) \{\par
00237     f0_ = t.f0_;\par
00238     {\cf19 return} *{\cf17 this};\par
00239   \}\par
00240 \par
00241   T0 f0_;\par
00242 \};\par
00243 \par
00244 {\cf17 template} <GTEST_2_TYPENAMES_(T)>\par
00245 {\cf17 class }GTEST_2_TUPLE_(T) \{\par
00246  {\cf17 public}:\par
00247   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00248 \par
00249   tuple() : f0_(), f1_() \{\}\par
00250 \par
00251   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1) : f0_(f0),\par
00252       f1_(f1) \{\}\par
00253 \par
00254   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_) \{\}\par
00255 \par
00256   {\cf17 template} <GTEST_2_TYPENAMES_(U)>\par
00257   tuple({\cf17 const} GTEST_2_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_) \{\}\par
00258   {\cf17 template} <{\cf17 typename} U0, {\cf17 typename} U1>\par
00259   tuple(const ::std::pair<U0, U1>& p) : f0_(p.first), f1_(p.second) \{\}\par
00260 \par
00261   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00262 \par
00263   {\cf17 template} <GTEST_2_TYPENAMES_(U)>\par
00264   tuple& operator=({\cf17 const} GTEST_2_TUPLE_(U)& t) \{\par
00265     {\cf19 return} CopyFrom(t);\par
00266   \}\par
00267   {\cf17 template} <{\cf17 typename} U0, {\cf17 typename} U1>\par
00268   tuple& operator=(const ::std::pair<U0, U1>& p) \{\par
00269     f0_ = p.first;\par
00270     f1_ = p.second;\par
00271     {\cf19 return} *{\cf17 this};\par
00272   \}\par
00273 \par
00274   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00275 \par
00276   {\cf17 template} <GTEST_2_TYPENAMES_(U)>\par
00277   tuple& CopyFrom({\cf17 const} GTEST_2_TUPLE_(U)& t) \{\par
00278     f0_ = t.f0_;\par
00279     f1_ = t.f1_;\par
00280     {\cf19 return} *{\cf17 this};\par
00281   \}\par
00282 \par
00283   T0 f0_;\par
00284   T1 f1_;\par
00285 \};\par
00286 \par
00287 {\cf17 template} <GTEST_3_TYPENAMES_(T)>\par
00288 {\cf17 class }GTEST_3_TUPLE_(T) \{\par
00289  {\cf17 public}:\par
00290   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00291 \par
00292   tuple() : f0_(), f1_(), f2_() \{\}\par
00293 \par
00294   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00295       GTEST_BY_REF_(T2) f2) : f0_(f0), f1_(f1), f2_(f2) \{\}\par
00296 \par
00297   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_) \{\}\par
00298 \par
00299   {\cf17 template} <GTEST_3_TYPENAMES_(U)>\par
00300   tuple({\cf17 const} GTEST_3_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_) \{\}\par
00301 \par
00302   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00303 \par
00304   {\cf17 template} <GTEST_3_TYPENAMES_(U)>\par
00305   tuple& operator=({\cf17 const} GTEST_3_TUPLE_(U)& t) \{\par
00306     {\cf19 return} CopyFrom(t);\par
00307   \}\par
00308 \par
00309   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00310 \par
00311   {\cf17 template} <GTEST_3_TYPENAMES_(U)>\par
00312   tuple& CopyFrom({\cf17 const} GTEST_3_TUPLE_(U)& t) \{\par
00313     f0_ = t.f0_;\par
00314     f1_ = t.f1_;\par
00315     f2_ = t.f2_;\par
00316     {\cf19 return} *{\cf17 this};\par
00317   \}\par
00318 \par
00319   T0 f0_;\par
00320   T1 f1_;\par
00321   T2 f2_;\par
00322 \};\par
00323 \par
00324 {\cf17 template} <GTEST_4_TYPENAMES_(T)>\par
00325 {\cf17 class }GTEST_4_TUPLE_(T) \{\par
00326  {\cf17 public}:\par
00327   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00328 \par
00329   tuple() : f0_(), f1_(), f2_(), f3_() \{\}\par
00330 \par
00331   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00332       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3) : f0_(f0), f1_(f1), f2_(f2),\par
00333       f3_(f3) \{\}\par
00334 \par
00335   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_) \{\}\par
00336 \par
00337   {\cf17 template} <GTEST_4_TYPENAMES_(U)>\par
00338   tuple({\cf17 const} GTEST_4_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),\par
00339       f3_(t.f3_) \{\}\par
00340 \par
00341   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00342 \par
00343   {\cf17 template} <GTEST_4_TYPENAMES_(U)>\par
00344   tuple& operator=({\cf17 const} GTEST_4_TUPLE_(U)& t) \{\par
00345     {\cf19 return} CopyFrom(t);\par
00346   \}\par
00347 \par
00348   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00349 \par
00350   {\cf17 template} <GTEST_4_TYPENAMES_(U)>\par
00351   tuple& CopyFrom({\cf17 const} GTEST_4_TUPLE_(U)& t) \{\par
00352     f0_ = t.f0_;\par
00353     f1_ = t.f1_;\par
00354     f2_ = t.f2_;\par
00355     f3_ = t.f3_;\par
00356     {\cf19 return} *{\cf17 this};\par
00357   \}\par
00358 \par
00359   T0 f0_;\par
00360   T1 f1_;\par
00361   T2 f2_;\par
00362   T3 f3_;\par
00363 \};\par
00364 \par
00365 {\cf17 template} <GTEST_5_TYPENAMES_(T)>\par
00366 {\cf17 class }GTEST_5_TUPLE_(T) \{\par
00367  {\cf17 public}:\par
00368   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00369 \par
00370   tuple() : f0_(), f1_(), f2_(), f3_(), f4_() \{\}\par
00371 \par
00372   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00373       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3,\par
00374       GTEST_BY_REF_(T4) f4) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4) \{\}\par
00375 \par
00376   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),\par
00377       f4_(t.f4_) \{\}\par
00378 \par
00379   {\cf17 template} <GTEST_5_TYPENAMES_(U)>\par
00380   tuple({\cf17 const} GTEST_5_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),\par
00381       f3_(t.f3_), f4_(t.f4_) \{\}\par
00382 \par
00383   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00384 \par
00385   {\cf17 template} <GTEST_5_TYPENAMES_(U)>\par
00386   tuple& operator=({\cf17 const} GTEST_5_TUPLE_(U)& t) \{\par
00387     {\cf19 return} CopyFrom(t);\par
00388   \}\par
00389 \par
00390   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00391 \par
00392   {\cf17 template} <GTEST_5_TYPENAMES_(U)>\par
00393   tuple& CopyFrom({\cf17 const} GTEST_5_TUPLE_(U)& t) \{\par
00394     f0_ = t.f0_;\par
00395     f1_ = t.f1_;\par
00396     f2_ = t.f2_;\par
00397     f3_ = t.f3_;\par
00398     f4_ = t.f4_;\par
00399     {\cf19 return} *{\cf17 this};\par
00400   \}\par
00401 \par
00402   T0 f0_;\par
00403   T1 f1_;\par
00404   T2 f2_;\par
00405   T3 f3_;\par
00406   T4 f4_;\par
00407 \};\par
00408 \par
00409 {\cf17 template} <GTEST_6_TYPENAMES_(T)>\par
00410 {\cf17 class }GTEST_6_TUPLE_(T) \{\par
00411  {\cf17 public}:\par
00412   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00413 \par
00414   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_() \{\}\par
00415 \par
00416   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00417       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,\par
00418       GTEST_BY_REF_(T5) f5) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4),\par
00419       f5_(f5) \{\}\par
00420 \par
00421   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),\par
00422       f4_(t.f4_), f5_(t.f5_) \{\}\par
00423 \par
00424   {\cf17 template} <GTEST_6_TYPENAMES_(U)>\par
00425   tuple({\cf17 const} GTEST_6_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),\par
00426       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_) \{\}\par
00427 \par
00428   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00429 \par
00430   {\cf17 template} <GTEST_6_TYPENAMES_(U)>\par
00431   tuple& operator=({\cf17 const} GTEST_6_TUPLE_(U)& t) \{\par
00432     {\cf19 return} CopyFrom(t);\par
00433   \}\par
00434 \par
00435   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00436 \par
00437   {\cf17 template} <GTEST_6_TYPENAMES_(U)>\par
00438   tuple& CopyFrom({\cf17 const} GTEST_6_TUPLE_(U)& t) \{\par
00439     f0_ = t.f0_;\par
00440     f1_ = t.f1_;\par
00441     f2_ = t.f2_;\par
00442     f3_ = t.f3_;\par
00443     f4_ = t.f4_;\par
00444     f5_ = t.f5_;\par
00445     {\cf19 return} *{\cf17 this};\par
00446   \}\par
00447 \par
00448   T0 f0_;\par
00449   T1 f1_;\par
00450   T2 f2_;\par
00451   T3 f3_;\par
00452   T4 f4_;\par
00453   T5 f5_;\par
00454 \};\par
00455 \par
00456 {\cf17 template} <GTEST_7_TYPENAMES_(T)>\par
00457 {\cf17 class }GTEST_7_TUPLE_(T) \{\par
00458  {\cf17 public}:\par
00459   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00460 \par
00461   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_() \{\}\par
00462 \par
00463   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00464       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,\par
00465       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6) : f0_(f0), f1_(f1), f2_(f2),\par
00466       f3_(f3), f4_(f4), f5_(f5), f6_(f6) \{\}\par
00467 \par
00468   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),\par
00469       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_) \{\}\par
00470 \par
00471   {\cf17 template} <GTEST_7_TYPENAMES_(U)>\par
00472   tuple({\cf17 const} GTEST_7_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),\par
00473       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_) \{\}\par
00474 \par
00475   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00476 \par
00477   {\cf17 template} <GTEST_7_TYPENAMES_(U)>\par
00478   tuple& operator=({\cf17 const} GTEST_7_TUPLE_(U)& t) \{\par
00479     {\cf19 return} CopyFrom(t);\par
00480   \}\par
00481 \par
00482   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00483 \par
00484   {\cf17 template} <GTEST_7_TYPENAMES_(U)>\par
00485   tuple& CopyFrom({\cf17 const} GTEST_7_TUPLE_(U)& t) \{\par
00486     f0_ = t.f0_;\par
00487     f1_ = t.f1_;\par
00488     f2_ = t.f2_;\par
00489     f3_ = t.f3_;\par
00490     f4_ = t.f4_;\par
00491     f5_ = t.f5_;\par
00492     f6_ = t.f6_;\par
00493     {\cf19 return} *{\cf17 this};\par
00494   \}\par
00495 \par
00496   T0 f0_;\par
00497   T1 f1_;\par
00498   T2 f2_;\par
00499   T3 f3_;\par
00500   T4 f4_;\par
00501   T5 f5_;\par
00502   T6 f6_;\par
00503 \};\par
00504 \par
00505 {\cf17 template} <GTEST_8_TYPENAMES_(T)>\par
00506 {\cf17 class }GTEST_8_TUPLE_(T) \{\par
00507  {\cf17 public}:\par
00508   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00509 \par
00510   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_(), f7_() \{\}\par
00511 \par
00512   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00513       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,\par
00514       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6,\par
00515       GTEST_BY_REF_(T7) f7) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4),\par
00516       f5_(f5), f6_(f6), f7_(f7) \{\}\par
00517 \par
00518   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),\par
00519       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_) \{\}\par
00520 \par
00521   {\cf17 template} <GTEST_8_TYPENAMES_(U)>\par
00522   tuple({\cf17 const} GTEST_8_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),\par
00523       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_) \{\}\par
00524 \par
00525   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00526 \par
00527   {\cf17 template} <GTEST_8_TYPENAMES_(U)>\par
00528   tuple& operator=({\cf17 const} GTEST_8_TUPLE_(U)& t) \{\par
00529     {\cf19 return} CopyFrom(t);\par
00530   \}\par
00531 \par
00532   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00533 \par
00534   {\cf17 template} <GTEST_8_TYPENAMES_(U)>\par
00535   tuple& CopyFrom({\cf17 const} GTEST_8_TUPLE_(U)& t) \{\par
00536     f0_ = t.f0_;\par
00537     f1_ = t.f1_;\par
00538     f2_ = t.f2_;\par
00539     f3_ = t.f3_;\par
00540     f4_ = t.f4_;\par
00541     f5_ = t.f5_;\par
00542     f6_ = t.f6_;\par
00543     f7_ = t.f7_;\par
00544     {\cf19 return} *{\cf17 this};\par
00545   \}\par
00546 \par
00547   T0 f0_;\par
00548   T1 f1_;\par
00549   T2 f2_;\par
00550   T3 f3_;\par
00551   T4 f4_;\par
00552   T5 f5_;\par
00553   T6 f6_;\par
00554   T7 f7_;\par
00555 \};\par
00556 \par
00557 {\cf17 template} <GTEST_9_TYPENAMES_(T)>\par
00558 {\cf17 class }GTEST_9_TUPLE_(T) \{\par
00559  {\cf17 public}:\par
00560   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00561 \par
00562   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_(), f7_(), f8_() \{\}\par
00563 \par
00564   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00565       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,\par
00566       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6, GTEST_BY_REF_(T7) f7,\par
00567       GTEST_BY_REF_(T8) f8) : f0_(f0), f1_(f1), f2_(f2), f3_(f3), f4_(f4),\par
00568       f5_(f5), f6_(f6), f7_(f7), f8_(f8) \{\}\par
00569 \par
00570   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),\par
00571       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_) \{\}\par
00572 \par
00573   {\cf17 template} <GTEST_9_TYPENAMES_(U)>\par
00574   tuple({\cf17 const} GTEST_9_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),\par
00575       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_) \{\}\par
00576 \par
00577   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00578 \par
00579   {\cf17 template} <GTEST_9_TYPENAMES_(U)>\par
00580   tuple& operator=({\cf17 const} GTEST_9_TUPLE_(U)& t) \{\par
00581     {\cf19 return} CopyFrom(t);\par
00582   \}\par
00583 \par
00584   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00585 \par
00586   {\cf17 template} <GTEST_9_TYPENAMES_(U)>\par
00587   tuple& CopyFrom({\cf17 const} GTEST_9_TUPLE_(U)& t) \{\par
00588     f0_ = t.f0_;\par
00589     f1_ = t.f1_;\par
00590     f2_ = t.f2_;\par
00591     f3_ = t.f3_;\par
00592     f4_ = t.f4_;\par
00593     f5_ = t.f5_;\par
00594     f6_ = t.f6_;\par
00595     f7_ = t.f7_;\par
00596     f8_ = t.f8_;\par
00597     {\cf19 return} *{\cf17 this};\par
00598   \}\par
00599 \par
00600   T0 f0_;\par
00601   T1 f1_;\par
00602   T2 f2_;\par
00603   T3 f3_;\par
00604   T4 f4_;\par
00605   T5 f5_;\par
00606   T6 f6_;\par
00607   T7 f7_;\par
00608   T8 f8_;\par
00609 \};\par
00610 \par
00611 {\cf17 template} <GTEST_10_TYPENAMES_(T)>\par
00612 {\cf17 class }tuple \{\par
00613  {\cf17 public}:\par
00614   {\cf17 template} <{\cf18 int} k> {\cf17 friend} {\cf17 class }gtest_internal::Get;\par
00615 \par
00616   tuple() : f0_(), f1_(), f2_(), f3_(), f4_(), f5_(), f6_(), f7_(), f8_(),\par
00617       f9_() \{\}\par
00618 \par
00619   {\cf17 explicit} tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1,\par
00620       GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4,\par
00621       GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6, GTEST_BY_REF_(T7) f7,\par
00622       GTEST_BY_REF_(T8) f8, GTEST_BY_REF_(T9) f9) : f0_(f0), f1_(f1), f2_(f2),\par
00623       f3_(f3), f4_(f4), f5_(f5), f6_(f6), f7_(f7), f8_(f8), f9_(f9) \{\}\par
00624 \par
00625   tuple({\cf17 const} tuple& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_), f3_(t.f3_),\par
00626       f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_), f9_(t.f9_) \{\}\par
00627 \par
00628   {\cf17 template} <GTEST_10_TYPENAMES_(U)>\par
00629   tuple({\cf17 const} GTEST_10_TUPLE_(U)& t) : f0_(t.f0_), f1_(t.f1_), f2_(t.f2_),\par
00630       f3_(t.f3_), f4_(t.f4_), f5_(t.f5_), f6_(t.f6_), f7_(t.f7_), f8_(t.f8_),\par
00631       f9_(t.f9_) \{\}\par
00632 \par
00633   tuple& operator=({\cf17 const} tuple& t) \{ {\cf19 return} CopyFrom(t); \}\par
00634 \par
00635   {\cf17 template} <GTEST_10_TYPENAMES_(U)>\par
00636   tuple& operator=({\cf17 const} GTEST_10_TUPLE_(U)& t) \{\par
00637     {\cf19 return} CopyFrom(t);\par
00638   \}\par
00639 \par
00640   GTEST_DECLARE_TUPLE_AS_FRIEND_\par
00641 \par
00642   {\cf17 template} <GTEST_10_TYPENAMES_(U)>\par
00643   tuple& CopyFrom({\cf17 const} GTEST_10_TUPLE_(U)& t) \{\par
00644     f0_ = t.f0_;\par
00645     f1_ = t.f1_;\par
00646     f2_ = t.f2_;\par
00647     f3_ = t.f3_;\par
00648     f4_ = t.f4_;\par
00649     f5_ = t.f5_;\par
00650     f6_ = t.f6_;\par
00651     f7_ = t.f7_;\par
00652     f8_ = t.f8_;\par
00653     f9_ = t.f9_;\par
00654     {\cf19 return} *{\cf17 this};\par
00655   \}\par
00656 \par
00657   T0 f0_;\par
00658   T1 f1_;\par
00659   T2 f2_;\par
00660   T3 f3_;\par
00661   T4 f4_;\par
00662   T5 f5_;\par
00663   T6 f6_;\par
00664   T7 f7_;\par
00665   T8 f8_;\par
00666   T9 f9_;\par
00667 \};\par
00668 \par
00669 {\cf20 // 6.1.3.2 Tuple creation functions.}\par
00670 \par
00671 {\cf20 // Known limitations: we don't support passing an}\par
00672 {\cf20 // std::tr1::reference_wrapper<T> to make_tuple().  And we don't}\par
00673 {\cf20 // implement tie().}\par
00674 \par
00675 {\cf17 inline} tuple<> make_tuple() \{ {\cf19 return} tuple<>(); \}\par
00676 \par
00677 {\cf17 template} <GTEST_1_TYPENAMES_(T)>\par
00678 {\cf17 inline} GTEST_1_TUPLE_(T) make_tuple({\cf17 const} T0& f0) \{\par
00679   {\cf19 return} GTEST_1_TUPLE_(T)(f0);\par
00680 \}\par
00681 \par
00682 {\cf17 template} <GTEST_2_TYPENAMES_(T)>\par
00683 {\cf17 inline} GTEST_2_TUPLE_(T) make_tuple({\cf17 const} T0& f0, {\cf17 const} T1& f1) \{\par
00684   {\cf19 return} GTEST_2_TUPLE_(T)(f0, f1);\par
00685 \}\par
00686 \par
00687 {\cf17 template} <GTEST_3_TYPENAMES_(T)>\par
00688 {\cf17 inline} GTEST_3_TUPLE_(T) make_tuple({\cf17 const} T0& f0, {\cf17 const} T1& f1, {\cf17 const} T2& f2) \{\par
00689   {\cf19 return} GTEST_3_TUPLE_(T)(f0, f1, f2);\par
00690 \}\par
00691 \par
00692 {\cf17 template} <GTEST_4_TYPENAMES_(T)>\par
00693 {\cf17 inline} GTEST_4_TUPLE_(T) make_tuple({\cf17 const} T0& f0, {\cf17 const} T1& f1, {\cf17 const} T2& f2,\par
00694     {\cf17 const} T3& f3) \{\par
00695   {\cf19 return} GTEST_4_TUPLE_(T)(f0, f1, f2, f3);\par
00696 \}\par
00697 \par
00698 {\cf17 template} <GTEST_5_TYPENAMES_(T)>\par
00699 {\cf17 inline} GTEST_5_TUPLE_(T) make_tuple({\cf17 const} T0& f0, {\cf17 const} T1& f1, {\cf17 const} T2& f2,\par
00700     {\cf17 const} T3& f3, {\cf17 const} T4& f4) \{\par
00701   {\cf19 return} GTEST_5_TUPLE_(T)(f0, f1, f2, f3, f4);\par
00702 \}\par
00703 \par
00704 {\cf17 template} <GTEST_6_TYPENAMES_(T)>\par
00705 {\cf17 inline} GTEST_6_TUPLE_(T) make_tuple({\cf17 const} T0& f0, {\cf17 const} T1& f1, {\cf17 const} T2& f2,\par
00706     {\cf17 const} T3& f3, {\cf17 const} T4& f4, {\cf17 const} T5& f5) \{\par
00707   {\cf19 return} GTEST_6_TUPLE_(T)(f0, f1, f2, f3, f4, f5);\par
00708 \}\par
00709 \par
00710 {\cf17 template} <GTEST_7_TYPENAMES_(T)>\par
00711 {\cf17 inline} GTEST_7_TUPLE_(T) make_tuple({\cf17 const} T0& f0, {\cf17 const} T1& f1, {\cf17 const} T2& f2,\par
00712     {\cf17 const} T3& f3, {\cf17 const} T4& f4, {\cf17 const} T5& f5, {\cf17 const} T6& f6) \{\par
00713   {\cf19 return} GTEST_7_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6);\par
00714 \}\par
00715 \par
00716 {\cf17 template} <GTEST_8_TYPENAMES_(T)>\par
00717 {\cf17 inline} GTEST_8_TUPLE_(T) make_tuple({\cf17 const} T0& f0, {\cf17 const} T1& f1, {\cf17 const} T2& f2,\par
00718     {\cf17 const} T3& f3, {\cf17 const} T4& f4, {\cf17 const} T5& f5, {\cf17 const} T6& f6, {\cf17 const} T7& f7) \{\par
00719   {\cf19 return} GTEST_8_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6, f7);\par
00720 \}\par
00721 \par
00722 {\cf17 template} <GTEST_9_TYPENAMES_(T)>\par
00723 {\cf17 inline} GTEST_9_TUPLE_(T) make_tuple({\cf17 const} T0& f0, {\cf17 const} T1& f1, {\cf17 const} T2& f2,\par
00724     {\cf17 const} T3& f3, {\cf17 const} T4& f4, {\cf17 const} T5& f5, {\cf17 const} T6& f6, {\cf17 const} T7& f7,\par
00725     {\cf17 const} T8& f8) \{\par
00726   {\cf19 return} GTEST_9_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6, f7, f8);\par
00727 \}\par
00728 \par
00729 {\cf17 template} <GTEST_10_TYPENAMES_(T)>\par
00730 {\cf17 inline} GTEST_10_TUPLE_(T) make_tuple({\cf17 const} T0& f0, {\cf17 const} T1& f1, {\cf17 const} T2& f2,\par
00731     {\cf17 const} T3& f3, {\cf17 const} T4& f4, {\cf17 const} T5& f5, {\cf17 const} T6& f6, {\cf17 const} T7& f7,\par
00732     {\cf17 const} T8& f8, {\cf17 const} T9& f9) \{\par
00733   {\cf19 return} GTEST_10_TUPLE_(T)(f0, f1, f2, f3, f4, f5, f6, f7, f8, f9);\par
00734 \}\par
00735 \par
00736 {\cf20 // 6.1.3.3 Tuple helper classes.}\par
00737 \par
00738 {\cf17 template} <{\cf17 typename} Tuple> {\cf17 struct }tuple_size;\par
00739 \par
00740 {\cf17 template} <GTEST_0_TYPENAMES_(T)>\par
00741 {\cf17 struct }tuple_size<GTEST_0_TUPLE_(T) > \{\par
00742   {\cf17 static} {\cf17 const} {\cf18 int} value = 0;\par
00743 \};\par
00744 \par
00745 {\cf17 template} <GTEST_1_TYPENAMES_(T)>\par
00746 {\cf17 struct }tuple_size<GTEST_1_TUPLE_(T) > \{\par
00747   {\cf17 static} {\cf17 const} {\cf18 int} value = 1;\par
00748 \};\par
00749 \par
00750 {\cf17 template} <GTEST_2_TYPENAMES_(T)>\par
00751 {\cf17 struct }tuple_size<GTEST_2_TUPLE_(T) > \{\par
00752   {\cf17 static} {\cf17 const} {\cf18 int} value = 2;\par
00753 \};\par
00754 \par
00755 {\cf17 template} <GTEST_3_TYPENAMES_(T)>\par
00756 {\cf17 struct }tuple_size<GTEST_3_TUPLE_(T) > \{\par
00757   {\cf17 static} {\cf17 const} {\cf18 int} value = 3;\par
00758 \};\par
00759 \par
00760 {\cf17 template} <GTEST_4_TYPENAMES_(T)>\par
00761 {\cf17 struct }tuple_size<GTEST_4_TUPLE_(T) > \{\par
00762   {\cf17 static} {\cf17 const} {\cf18 int} value = 4;\par
00763 \};\par
00764 \par
00765 {\cf17 template} <GTEST_5_TYPENAMES_(T)>\par
00766 {\cf17 struct }tuple_size<GTEST_5_TUPLE_(T) > \{\par
00767   {\cf17 static} {\cf17 const} {\cf18 int} value = 5;\par
00768 \};\par
00769 \par
00770 {\cf17 template} <GTEST_6_TYPENAMES_(T)>\par
00771 {\cf17 struct }tuple_size<GTEST_6_TUPLE_(T) > \{\par
00772   {\cf17 static} {\cf17 const} {\cf18 int} value = 6;\par
00773 \};\par
00774 \par
00775 {\cf17 template} <GTEST_7_TYPENAMES_(T)>\par
00776 {\cf17 struct }tuple_size<GTEST_7_TUPLE_(T) > \{\par
00777   {\cf17 static} {\cf17 const} {\cf18 int} value = 7;\par
00778 \};\par
00779 \par
00780 {\cf17 template} <GTEST_8_TYPENAMES_(T)>\par
00781 {\cf17 struct }tuple_size<GTEST_8_TUPLE_(T) > \{\par
00782   {\cf17 static} {\cf17 const} {\cf18 int} value = 8;\par
00783 \};\par
00784 \par
00785 {\cf17 template} <GTEST_9_TYPENAMES_(T)>\par
00786 {\cf17 struct }tuple_size<GTEST_9_TUPLE_(T) > \{\par
00787   {\cf17 static} {\cf17 const} {\cf18 int} value = 9;\par
00788 \};\par
00789 \par
00790 {\cf17 template} <GTEST_10_TYPENAMES_(T)>\par
00791 {\cf17 struct }tuple_size<GTEST_10_TUPLE_(T) > \{\par
00792   {\cf17 static} {\cf17 const} {\cf18 int} value = 10;\par
00793 \};\par
00794 \par
00795 {\cf17 template} <{\cf18 int} k, {\cf17 class} Tuple>\par
00796 {\cf17 struct }tuple_element \{\par
00797   {\cf17 typedef} {\cf17 typename} gtest_internal::TupleElement<\par
00798       k < (tuple_size<Tuple>::value), k, Tuple>::type type;\par
00799 \};\par
00800 \par
00801 {\cf21 #define GTEST_TUPLE_ELEMENT_(k, Tuple) typename tuple_element<k, Tuple >::type}\par
00802 \par
00803 {\cf20 // 6.1.3.4 Element access.}\par
00804 \par
00805 {\cf17 namespace }gtest_internal \{\par
00806 \par
00807 {\cf17 template} <>\par
00808 {\cf17 class }Get<0> \{\par
00809  {\cf17 public}:\par
00810   {\cf17 template} <{\cf17 class} Tuple>\par
00811   {\cf17 static} GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(0, Tuple))\par
00812   Field(Tuple& t) \{ {\cf19 return} t.f0_; \}  {\cf20 // NOLINT}\par
00813 \par
00814   {\cf17 template} <{\cf17 class} Tuple>\par
00815   {\cf17 static} GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(0, Tuple))\par
00816   ConstField({\cf17 const} Tuple& t) \{ {\cf19 return} t.f0_; \}\par
00817 \};\par
00818 \par
00819 {\cf17 template} <>\par
00820 {\cf17 class }Get<1> \{\par
00821  {\cf17 public}:\par
00822   {\cf17 template} <{\cf17 class} Tuple>\par
00823   {\cf17 static} GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(1, Tuple))\par
00824   Field(Tuple& t) \{ {\cf19 return} t.f1_; \}  {\cf20 // NOLINT}\par
00825 \par
00826   {\cf17 template} <{\cf17 class} Tuple>\par
00827   {\cf17 static} GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(1, Tuple))\par
00828   ConstField({\cf17 const} Tuple& t) \{ {\cf19 return} t.f1_; \}\par
00829 \};\par
00830 \par
00831 {\cf17 template} <>\par
00832 {\cf17 class }Get<2> \{\par
00833  {\cf17 public}:\par
00834   {\cf17 template} <{\cf17 class} Tuple>\par
00835   {\cf17 static} GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(2, Tuple))\par
00836   Field(Tuple& t) \{ {\cf19 return} t.f2_; \}  {\cf20 // NOLINT}\par
00837 \par
00838   {\cf17 template} <{\cf17 class} Tuple>\par
00839   {\cf17 static} GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(2, Tuple))\par
00840   ConstField({\cf17 const} Tuple& t) \{ {\cf19 return} t.f2_; \}\par
00841 \};\par
00842 \par
00843 {\cf17 template} <>\par
00844 {\cf17 class }Get<3> \{\par
00845  {\cf17 public}:\par
00846   {\cf17 template} <{\cf17 class} Tuple>\par
00847   {\cf17 static} GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(3, Tuple))\par
00848   Field(Tuple& t) \{ {\cf19 return} t.f3_; \}  {\cf20 // NOLINT}\par
00849 \par
00850   {\cf17 template} <{\cf17 class} Tuple>\par
00851   {\cf17 static} GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(3, Tuple))\par
00852   ConstField({\cf17 const} Tuple& t) \{ {\cf19 return} t.f3_; \}\par
00853 \};\par
00854 \par
00855 {\cf17 template} <>\par
00856 {\cf17 class }Get<4> \{\par
00857  {\cf17 public}:\par
00858   {\cf17 template} <{\cf17 class} Tuple>\par
00859   {\cf17 static} GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(4, Tuple))\par
00860   Field(Tuple& t) \{ {\cf19 return} t.f4_; \}  {\cf20 // NOLINT}\par
00861 \par
00862   {\cf17 template} <{\cf17 class} Tuple>\par
00863   {\cf17 static} GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(4, Tuple))\par
00864   ConstField({\cf17 const} Tuple& t) \{ {\cf19 return} t.f4_; \}\par
00865 \};\par
00866 \par
00867 {\cf17 template} <>\par
00868 {\cf17 class }Get<5> \{\par
00869  {\cf17 public}:\par
00870   {\cf17 template} <{\cf17 class} Tuple>\par
00871   {\cf17 static} GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(5, Tuple))\par
00872   Field(Tuple& t) \{ {\cf19 return} t.f5_; \}  {\cf20 // NOLINT}\par
00873 \par
00874   {\cf17 template} <{\cf17 class} Tuple>\par
00875   {\cf17 static} GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(5, Tuple))\par
00876   ConstField({\cf17 const} Tuple& t) \{ {\cf19 return} t.f5_; \}\par
00877 \};\par
00878 \par
00879 {\cf17 template} <>\par
00880 {\cf17 class }Get<6> \{\par
00881  {\cf17 public}:\par
00882   {\cf17 template} <{\cf17 class} Tuple>\par
00883   {\cf17 static} GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(6, Tuple))\par
00884   Field(Tuple& t) \{ {\cf19 return} t.f6_; \}  {\cf20 // NOLINT}\par
00885 \par
00886   {\cf17 template} <{\cf17 class} Tuple>\par
00887   {\cf17 static} GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(6, Tuple))\par
00888   ConstField({\cf17 const} Tuple& t) \{ {\cf19 return} t.f6_; \}\par
00889 \};\par
00890 \par
00891 {\cf17 template} <>\par
00892 {\cf17 class }Get<7> \{\par
00893  {\cf17 public}:\par
00894   {\cf17 template} <{\cf17 class} Tuple>\par
00895   {\cf17 static} GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(7, Tuple))\par
00896   Field(Tuple& t) \{ {\cf19 return} t.f7_; \}  {\cf20 // NOLINT}\par
00897 \par
00898   {\cf17 template} <{\cf17 class} Tuple>\par
00899   {\cf17 static} GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(7, Tuple))\par
00900   ConstField({\cf17 const} Tuple& t) \{ {\cf19 return} t.f7_; \}\par
00901 \};\par
00902 \par
00903 {\cf17 template} <>\par
00904 {\cf17 class }Get<8> \{\par
00905  {\cf17 public}:\par
00906   {\cf17 template} <{\cf17 class} Tuple>\par
00907   {\cf17 static} GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(8, Tuple))\par
00908   Field(Tuple& t) \{ {\cf19 return} t.f8_; \}  {\cf20 // NOLINT}\par
00909 \par
00910   {\cf17 template} <{\cf17 class} Tuple>\par
00911   {\cf17 static} GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(8, Tuple))\par
00912   ConstField({\cf17 const} Tuple& t) \{ {\cf19 return} t.f8_; \}\par
00913 \};\par
00914 \par
00915 {\cf17 template} <>\par
00916 {\cf17 class }Get<9> \{\par
00917  {\cf17 public}:\par
00918   {\cf17 template} <{\cf17 class} Tuple>\par
00919   {\cf17 static} GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(9, Tuple))\par
00920   Field(Tuple& t) \{ {\cf19 return} t.f9_; \}  {\cf20 // NOLINT}\par
00921 \par
00922   {\cf17 template} <{\cf17 class} Tuple>\par
00923   {\cf17 static} GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(9, Tuple))\par
00924   ConstField({\cf17 const} Tuple& t) \{ {\cf19 return} t.f9_; \}\par
00925 \};\par
00926 \par
00927 \}  {\cf20 // namespace gtest_internal}\par
00928 \par
00929 {\cf17 template} <{\cf18 int} k, GTEST_10_TYPENAMES_(T)>\par
00930 GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(k, GTEST_10_TUPLE_(T)))\par
00931 get(GTEST_10_TUPLE_(T)& t) \{\par
00932   {\cf19 return} gtest_internal::Get<k>::Field(t);\par
00933 \}\par
00934 \par
00935 {\cf17 template} <{\cf18 int} k, GTEST_10_TYPENAMES_(T)>\par
00936 GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(k,  GTEST_10_TUPLE_(T)))\par
00937 get({\cf17 const} GTEST_10_TUPLE_(T)& t) \{\par
00938   {\cf19 return} gtest_internal::Get<k>::ConstField(t);\par
00939 \}\par
00940 \par
00941 {\cf20 // 6.1.3.5 Relational operators}\par
00942 \par
00943 {\cf20 // We only implement == and !=, as we don't have a need for the rest yet.}\par
00944 \par
00945 {\cf17 namespace }gtest_internal \{\par
00946 \par
00947 {\cf20 // SameSizeTuplePrefixComparator<k, k>::Eq(t1, t2) returns true if the}\par
00948 {\cf20 // first k fields of t1 equals the first k fields of t2.}\par
00949 {\cf20 // SameSizeTuplePrefixComparator(k1, k2) would be a compiler error if}\par
00950 {\cf20 // k1 != k2.}\par
00951 {\cf17 template} <{\cf18 int} kSize1, {\cf18 int} kSize2>\par
00952 {\cf17 struct }SameSizeTuplePrefixComparator;\par
00953 \par
00954 {\cf17 template} <>\par
00955 {\cf17 struct }SameSizeTuplePrefixComparator<0, 0> \{\par
00956   {\cf17 template} <{\cf17 class} Tuple1, {\cf17 class} Tuple2>\par
00957   {\cf17 static} {\cf18 bool} Eq({\cf17 const} Tuple1& {\cf20 /* t1 */}, {\cf17 const} Tuple2& {\cf20 /* t2 */}) \{\par
00958     {\cf19 return} {\cf17 true};\par
00959   \}\par
00960 \};\par
00961 \par
00962 {\cf17 template} <{\cf18 int} k>\par
00963 {\cf17 struct }SameSizeTuplePrefixComparator<k, k> \{\par
00964   {\cf17 template} <{\cf17 class} Tuple1, {\cf17 class} Tuple2>\par
00965   {\cf17 static} {\cf18 bool} Eq({\cf17 const} Tuple1& t1, {\cf17 const} Tuple2& t2) \{\par
00966     {\cf19 return} SameSizeTuplePrefixComparator<k - 1, k - 1>::Eq(t1, t2) &&\par
00967         ::std::tr1::get<k - 1>(t1) == ::std::tr1::get<k - 1>(t2);\par
00968   \}\par
00969 \};\par
00970 \par
00971 \}  {\cf20 // namespace gtest_internal}\par
00972 \par
00973 {\cf17 template} <GTEST_10_TYPENAMES_(T), GTEST_10_TYPENAMES_(U)>\par
00974 {\cf17 inline} {\cf18 bool} operator==({\cf17 const} GTEST_10_TUPLE_(T)& t,\par
00975                        {\cf17 const} GTEST_10_TUPLE_(U)& u) \{\par
00976   {\cf19 return} gtest_internal::SameSizeTuplePrefixComparator<\par
00977       tuple_size<GTEST_10_TUPLE_(T) >::value,\par
00978       tuple_size<GTEST_10_TUPLE_(U) >::value>::Eq(t, u);\par
00979 \}\par
00980 \par
00981 {\cf17 template} <GTEST_10_TYPENAMES_(T), GTEST_10_TYPENAMES_(U)>\par
00982 {\cf17 inline} {\cf18 bool} operator!=({\cf17 const} GTEST_10_TUPLE_(T)& t,\par
00983                        {\cf17 const} GTEST_10_TUPLE_(U)& u) \{ {\cf19 return} !(t == u); \}\par
00984 \par
00985 {\cf20 // 6.1.4 Pairs.}\par
00986 {\cf20 // Unimplemented.}\par
00987 \par
00988 \}  {\cf20 // namespace tr1}\par
00989 \}  {\cf20 // namespace std}\par
00990 \par
00991 {\cf21 #undef GTEST_0_TUPLE_}\par
00992 {\cf21 #undef GTEST_1_TUPLE_}\par
00993 {\cf21 #undef GTEST_2_TUPLE_}\par
00994 {\cf21 #undef GTEST_3_TUPLE_}\par
00995 {\cf21 #undef GTEST_4_TUPLE_}\par
00996 {\cf21 #undef GTEST_5_TUPLE_}\par
00997 {\cf21 #undef GTEST_6_TUPLE_}\par
00998 {\cf21 #undef GTEST_7_TUPLE_}\par
00999 {\cf21 #undef GTEST_8_TUPLE_}\par
01000 {\cf21 #undef GTEST_9_TUPLE_}\par
01001 {\cf21 #undef GTEST_10_TUPLE_}\par
01002 \par
01003 {\cf21 #undef GTEST_0_TYPENAMES_}\par
01004 {\cf21 #undef GTEST_1_TYPENAMES_}\par
01005 {\cf21 #undef GTEST_2_TYPENAMES_}\par
01006 {\cf21 #undef GTEST_3_TYPENAMES_}\par
01007 {\cf21 #undef GTEST_4_TYPENAMES_}\par
01008 {\cf21 #undef GTEST_5_TYPENAMES_}\par
01009 {\cf21 #undef GTEST_6_TYPENAMES_}\par
01010 {\cf21 #undef GTEST_7_TYPENAMES_}\par
01011 {\cf21 #undef GTEST_8_TYPENAMES_}\par
01012 {\cf21 #undef GTEST_9_TYPENAMES_}\par
01013 {\cf21 #undef GTEST_10_TYPENAMES_}\par
01014 \par
01015 {\cf21 #undef GTEST_DECLARE_TUPLE_AS_FRIEND_}\par
01016 {\cf21 #undef GTEST_BY_REF_}\par
01017 {\cf21 #undef GTEST_ADD_REF_}\par
01018 {\cf21 #undef GTEST_TUPLE_ELEMENT_}\par
01019 \par
01020 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TUPLE_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/include/gtest/internal/gtest-type-util.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-type-util.h}
{\xe \v gtest/include/gtest/internal/gtest-type-util.h}
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/internal/gtest-port.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::string {\b testing::internal::GetTypeName} ()\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-type-util.h\par \pard\plain 
{\tc\tcl2 \v gtest/include/gtest/internal/gtest-type-util.h}
{\xe \v gtest/include/gtest/internal/gtest-type-util.h}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // This file was GENERATED by command:}\par
00002 {\cf20 //     pump.py gtest-type-util.h.pump}\par
00003 {\cf20 // DO NOT EDIT BY HAND!!!}\par
00004 \par
00005 {\cf20 // Copyright 2008 Google Inc.}\par
00006 {\cf20 // All Rights Reserved.}\par
00007 {\cf20 //}\par
00008 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00009 {\cf20 // modification, are permitted provided that the following conditions are}\par
00010 {\cf20 // met:}\par
00011 {\cf20 //}\par
00012 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00013 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00014 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00015 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00016 {\cf20 // in the documentation and/or other materials provided with the}\par
00017 {\cf20 // distribution.}\par
00018 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00019 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00020 {\cf20 // this software without specific prior written permission.}\par
00021 {\cf20 //}\par
00022 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00023 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00025 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00026 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00027 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00028 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00029 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00030 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00031 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00032 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00033 {\cf20 //}\par
00034 {\cf20 // Author: wan@google.com (Zhanyong Wan)}\par
00035 \par
00036 {\cf20 // Type utilities needed for implementing typed and type-parameterized}\par
00037 {\cf20 // tests.  This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!}\par
00038 {\cf20 //}\par
00039 {\cf20 // Currently we support at most 50 types in a list, and at most 50}\par
00040 {\cf20 // type-parameterized tests in one type-parameterized test case.}\par
00041 {\cf20 // Please contact googletestframework@googlegroups.com if you need}\par
00042 {\cf20 // more.}\par
00043 \par
00044 {\cf21 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_}\par
00045 {\cf21 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_}\par
00046 \par
00047 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00048 \par
00049 {\cf20 // #ifdef __GNUC__ is too general here.  It is possible to use gcc without using}\par
00050 {\cf20 // libstdc++ (which is where cxxabi.h comes from).}\par
00051 {\cf21 # if GTEST_HAS_CXXABI_H_}\par
00052 {\cf21 #  include <cxxabi.h>}\par
00053 {\cf21 # elif defined(__HP_aCC)}\par
00054 {\cf21 #  include <acxx_demangle.h>}\par
00055 {\cf21 # endif  }{\cf20 // GTEST_HASH_CXXABI_H_}\par
00056 \par
00057 {\cf17 namespace }testing \{\par
00058 {\cf17 namespace }internal \{\par
00059 \par
00060 {\cf20 // GetTypeName<T>() returns a human-readable name of type T.}\par
00061 {\cf20 // NB: This function is also used in Google Mock, so don't move it inside of}\par
00062 {\cf20 // the typed-test-only section below.}\par
00063 {\cf17 template} <{\cf17 typename} T>\par
00064 std::string GetTypeName() \{\par
00065 {\cf21 # if GTEST_HAS_RTTI}\par
00066 \par
00067   {\cf17 const} {\cf18 char}* {\cf17 const} name = {\cf17 typeid}(T).name();\par
00068 {\cf21 #  if GTEST_HAS_CXXABI_H_ || defined(__HP_aCC)}\par
00069   {\cf18 int} status = 0;\par
00070   {\cf20 // gcc's implementation of typeid(T).name() mangles the type name,}\par
00071   {\cf20 // so we have to demangle it.}\par
00072 {\cf21 #   if GTEST_HAS_CXXABI_H_}\par
00073   {\cf17 using} abi::__cxa_demangle;\par
00074 {\cf21 #   endif  }{\cf20 // GTEST_HAS_CXXABI_H_}\par
00075   {\cf18 char}* {\cf17 const} readable_name = __cxa_demangle(name, 0, 0, &status);\par
00076   {\cf17 const} std::string name_str(status == 0 ? readable_name : name);\par
00077   free(readable_name);\par
00078   {\cf19 return} name_str;\par
00079 {\cf21 #  else}\par
00080   {\cf19 return} name;\par
00081 {\cf21 #  endif  }{\cf20 // GTEST_HAS_CXXABI_H_ || __HP_aCC}\par
00082 \par
00083 {\cf21 # else}\par
00084 \par
00085   {\cf19 return} {\cf22 "<type>"};\par
00086 \par
00087 {\cf21 # endif  }{\cf20 // GTEST_HAS_RTTI}\par
00088 \}\par
00089 \par
00090 {\cf21 #if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P}\par
00091 \par
00092 {\cf20 // AssertyTypeEq<T1, T2>::type is defined iff T1 and T2 are the same}\par
00093 {\cf20 // type.  This can be used as a compile-time assertion to ensure that}\par
00094 {\cf20 // two types are equal.}\par
00095 \par
00096 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
00097 {\cf17 struct }AssertTypeEq;\par
00098 \par
00099 {\cf17 template} <{\cf17 typename} T>\par
00100 {\cf17 struct }AssertTypeEq<T, T> \{\par
00101   {\cf17 typedef} {\cf18 bool} type;\par
00102 \};\par
00103 \par
00104 {\cf20 // A unique type used as the default value for the arguments of class}\par
00105 {\cf20 // template Types.  This allows us to simulate variadic templates}\par
00106 {\cf20 // (e.g. Types<int>, Type<int, double>, and etc), which C++ doesn't}\par
00107 {\cf20 // support directly.}\par
00108 {\cf17 struct }None \{\};\par
00109 \par
00110 {\cf20 // The following family of struct and struct templates are used to}\par
00111 {\cf20 // represent type lists.  In particular, TypesN<T1, T2, ..., TN>}\par
00112 {\cf20 // represents a type list with N types (T1, T2, ..., and TN) in it.}\par
00113 {\cf20 // Except for Types0, every struct in the family has two member types:}\par
00114 {\cf20 // Head for the first type in the list, and Tail for the rest of the}\par
00115 {\cf20 // list.}\par
00116 \par
00117 {\cf20 // The empty type list.}\par
00118 {\cf17 struct }Types0 \{\};\par
00119 \par
00120 {\cf20 // Type lists of length 1, 2, 3, and so on.}\par
00121 \par
00122 {\cf17 template} <{\cf17 typename} T1>\par
00123 {\cf17 struct }Types1 \{\par
00124   {\cf17 typedef} T1 Head;\par
00125   {\cf17 typedef} Types0 Tail;\par
00126 \};\par
00127 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
00128 {\cf17 struct }Types2 \{\par
00129   {\cf17 typedef} T1 Head;\par
00130   {\cf17 typedef} Types1<T2> Tail;\par
00131 \};\par
00132 \par
00133 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3>\par
00134 {\cf17 struct }Types3 \{\par
00135   {\cf17 typedef} T1 Head;\par
00136   {\cf17 typedef} Types2<T2, T3> Tail;\par
00137 \};\par
00138 \par
00139 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4>\par
00140 {\cf17 struct }Types4 \{\par
00141   {\cf17 typedef} T1 Head;\par
00142   {\cf17 typedef} Types3<T2, T3, T4> Tail;\par
00143 \};\par
00144 \par
00145 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5>\par
00146 {\cf17 struct }Types5 \{\par
00147   {\cf17 typedef} T1 Head;\par
00148   {\cf17 typedef} Types4<T2, T3, T4, T5> Tail;\par
00149 \};\par
00150 \par
00151 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00152     {\cf17 typename} T6>\par
00153 {\cf17 struct }Types6 \{\par
00154   {\cf17 typedef} T1 Head;\par
00155   {\cf17 typedef} Types5<T2, T3, T4, T5, T6> Tail;\par
00156 \};\par
00157 \par
00158 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00159     {\cf17 typename} T6, {\cf17 typename} T7>\par
00160 {\cf17 struct }Types7 \{\par
00161   {\cf17 typedef} T1 Head;\par
00162   {\cf17 typedef} Types6<T2, T3, T4, T5, T6, T7> Tail;\par
00163 \};\par
00164 \par
00165 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00166     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8>\par
00167 {\cf17 struct }Types8 \{\par
00168   {\cf17 typedef} T1 Head;\par
00169   {\cf17 typedef} Types7<T2, T3, T4, T5, T6, T7, T8> Tail;\par
00170 \};\par
00171 \par
00172 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00173     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9>\par
00174 {\cf17 struct }Types9 \{\par
00175   {\cf17 typedef} T1 Head;\par
00176   {\cf17 typedef} Types8<T2, T3, T4, T5, T6, T7, T8, T9> Tail;\par
00177 \};\par
00178 \par
00179 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00180     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10>\par
00181 {\cf17 struct }Types10 \{\par
00182   {\cf17 typedef} T1 Head;\par
00183   {\cf17 typedef} Types9<T2, T3, T4, T5, T6, T7, T8, T9, T10> Tail;\par
00184 \};\par
00185 \par
00186 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00187     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00188     {\cf17 typename} T11>\par
00189 {\cf17 struct }Types11 \{\par
00190   {\cf17 typedef} T1 Head;\par
00191   {\cf17 typedef} Types10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Tail;\par
00192 \};\par
00193 \par
00194 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00195     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00196     {\cf17 typename} T11, {\cf17 typename} T12>\par
00197 {\cf17 struct }Types12 \{\par
00198   {\cf17 typedef} T1 Head;\par
00199   {\cf17 typedef} Types11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Tail;\par
00200 \};\par
00201 \par
00202 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00203     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00204     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13>\par
00205 {\cf17 struct }Types13 \{\par
00206   {\cf17 typedef} T1 Head;\par
00207   {\cf17 typedef} Types12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Tail;\par
00208 \};\par
00209 \par
00210 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00211     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00212     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14>\par
00213 {\cf17 struct }Types14 \{\par
00214   {\cf17 typedef} T1 Head;\par
00215   {\cf17 typedef} Types13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Tail;\par
00216 \};\par
00217 \par
00218 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00219     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00220     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15>\par
00221 {\cf17 struct }Types15 \{\par
00222   {\cf17 typedef} T1 Head;\par
00223   {\cf17 typedef} Types14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
00224       T15> Tail;\par
00225 \};\par
00226 \par
00227 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00228     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00229     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00230     {\cf17 typename} T16>\par
00231 {\cf17 struct }Types16 \{\par
00232   {\cf17 typedef} T1 Head;\par
00233   {\cf17 typedef} Types15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00234       T16> Tail;\par
00235 \};\par
00236 \par
00237 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00238     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00239     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00240     {\cf17 typename} T16, {\cf17 typename} T17>\par
00241 {\cf17 struct }Types17 \{\par
00242   {\cf17 typedef} T1 Head;\par
00243   {\cf17 typedef} Types16<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00244       T16, T17> Tail;\par
00245 \};\par
00246 \par
00247 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00248     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00249     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00250     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18>\par
00251 {\cf17 struct }Types18 \{\par
00252   {\cf17 typedef} T1 Head;\par
00253   {\cf17 typedef} Types17<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00254       T16, T17, T18> Tail;\par
00255 \};\par
00256 \par
00257 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00258     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00259     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00260     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19>\par
00261 {\cf17 struct }Types19 \{\par
00262   {\cf17 typedef} T1 Head;\par
00263   {\cf17 typedef} Types18<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00264       T16, T17, T18, T19> Tail;\par
00265 \};\par
00266 \par
00267 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00268     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00269     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00270     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20>\par
00271 {\cf17 struct }Types20 \{\par
00272   {\cf17 typedef} T1 Head;\par
00273   {\cf17 typedef} Types19<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00274       T16, T17, T18, T19, T20> Tail;\par
00275 \};\par
00276 \par
00277 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00278     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00279     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00280     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00281     {\cf17 typename} T21>\par
00282 {\cf17 struct }Types21 \{\par
00283   {\cf17 typedef} T1 Head;\par
00284   {\cf17 typedef} Types20<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00285       T16, T17, T18, T19, T20, T21> Tail;\par
00286 \};\par
00287 \par
00288 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00289     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00290     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00291     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00292     {\cf17 typename} T21, {\cf17 typename} T22>\par
00293 {\cf17 struct }Types22 \{\par
00294   {\cf17 typedef} T1 Head;\par
00295   {\cf17 typedef} Types21<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00296       T16, T17, T18, T19, T20, T21, T22> Tail;\par
00297 \};\par
00298 \par
00299 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00300     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00301     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00302     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00303     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23>\par
00304 {\cf17 struct }Types23 \{\par
00305   {\cf17 typedef} T1 Head;\par
00306   {\cf17 typedef} Types22<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00307       T16, T17, T18, T19, T20, T21, T22, T23> Tail;\par
00308 \};\par
00309 \par
00310 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00311     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00312     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00313     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00314     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24>\par
00315 {\cf17 struct }Types24 \{\par
00316   {\cf17 typedef} T1 Head;\par
00317   {\cf17 typedef} Types23<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00318       T16, T17, T18, T19, T20, T21, T22, T23, T24> Tail;\par
00319 \};\par
00320 \par
00321 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00322     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00323     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00324     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00325     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25>\par
00326 {\cf17 struct }Types25 \{\par
00327   {\cf17 typedef} T1 Head;\par
00328   {\cf17 typedef} Types24<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00329       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Tail;\par
00330 \};\par
00331 \par
00332 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00333     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00334     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00335     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00336     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00337     {\cf17 typename} T26>\par
00338 {\cf17 struct }Types26 \{\par
00339   {\cf17 typedef} T1 Head;\par
00340   {\cf17 typedef} Types25<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00341       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> Tail;\par
00342 \};\par
00343 \par
00344 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00345     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00346     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00347     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00348     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00349     {\cf17 typename} T26, {\cf17 typename} T27>\par
00350 {\cf17 struct }Types27 \{\par
00351   {\cf17 typedef} T1 Head;\par
00352   {\cf17 typedef} Types26<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00353       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> Tail;\par
00354 \};\par
00355 \par
00356 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00357     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00358     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00359     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00360     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00361     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28>\par
00362 {\cf17 struct }Types28 \{\par
00363   {\cf17 typedef} T1 Head;\par
00364   {\cf17 typedef} Types27<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00365       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28> Tail;\par
00366 \};\par
00367 \par
00368 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00369     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00370     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00371     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00372     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00373     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29>\par
00374 {\cf17 struct }Types29 \{\par
00375   {\cf17 typedef} T1 Head;\par
00376   {\cf17 typedef} Types28<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00377       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
00378       T29> Tail;\par
00379 \};\par
00380 \par
00381 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00382     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00383     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00384     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00385     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00386     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30>\par
00387 {\cf17 struct }Types30 \{\par
00388   {\cf17 typedef} T1 Head;\par
00389   {\cf17 typedef} Types29<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00390       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00391       T30> Tail;\par
00392 \};\par
00393 \par
00394 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00395     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00396     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00397     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00398     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00399     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00400     {\cf17 typename} T31>\par
00401 {\cf17 struct }Types31 \{\par
00402   {\cf17 typedef} T1 Head;\par
00403   {\cf17 typedef} Types30<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00404       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00405       T30, T31> Tail;\par
00406 \};\par
00407 \par
00408 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00409     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00410     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00411     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00412     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00413     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00414     {\cf17 typename} T31, {\cf17 typename} T32>\par
00415 {\cf17 struct }Types32 \{\par
00416   {\cf17 typedef} T1 Head;\par
00417   {\cf17 typedef} Types31<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00418       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00419       T30, T31, T32> Tail;\par
00420 \};\par
00421 \par
00422 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00423     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00424     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00425     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00426     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00427     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00428     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33>\par
00429 {\cf17 struct }Types33 \{\par
00430   {\cf17 typedef} T1 Head;\par
00431   {\cf17 typedef} Types32<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00432       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00433       T30, T31, T32, T33> Tail;\par
00434 \};\par
00435 \par
00436 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00437     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00438     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00439     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00440     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00441     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00442     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34>\par
00443 {\cf17 struct }Types34 \{\par
00444   {\cf17 typedef} T1 Head;\par
00445   {\cf17 typedef} Types33<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00446       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00447       T30, T31, T32, T33, T34> Tail;\par
00448 \};\par
00449 \par
00450 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00451     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00452     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00453     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00454     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00455     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00456     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35>\par
00457 {\cf17 struct }Types35 \{\par
00458   {\cf17 typedef} T1 Head;\par
00459   {\cf17 typedef} Types34<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00460       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00461       T30, T31, T32, T33, T34, T35> Tail;\par
00462 \};\par
00463 \par
00464 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00465     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00466     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00467     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00468     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00469     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00470     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00471     {\cf17 typename} T36>\par
00472 {\cf17 struct }Types36 \{\par
00473   {\cf17 typedef} T1 Head;\par
00474   {\cf17 typedef} Types35<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00475       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00476       T30, T31, T32, T33, T34, T35, T36> Tail;\par
00477 \};\par
00478 \par
00479 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00480     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00481     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00482     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00483     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00484     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00485     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00486     {\cf17 typename} T36, {\cf17 typename} T37>\par
00487 {\cf17 struct }Types37 \{\par
00488   {\cf17 typedef} T1 Head;\par
00489   {\cf17 typedef} Types36<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00490       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00491       T30, T31, T32, T33, T34, T35, T36, T37> Tail;\par
00492 \};\par
00493 \par
00494 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00495     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00496     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00497     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00498     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00499     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00500     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00501     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38>\par
00502 {\cf17 struct }Types38 \{\par
00503   {\cf17 typedef} T1 Head;\par
00504   {\cf17 typedef} Types37<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00505       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00506       T30, T31, T32, T33, T34, T35, T36, T37, T38> Tail;\par
00507 \};\par
00508 \par
00509 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00510     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00511     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00512     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00513     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00514     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00515     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00516     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39>\par
00517 {\cf17 struct }Types39 \{\par
00518   {\cf17 typedef} T1 Head;\par
00519   {\cf17 typedef} Types38<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00520       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00521       T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Tail;\par
00522 \};\par
00523 \par
00524 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00525     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00526     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00527     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00528     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00529     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00530     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00531     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40>\par
00532 {\cf17 struct }Types40 \{\par
00533   {\cf17 typedef} T1 Head;\par
00534   {\cf17 typedef} Types39<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00535       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00536       T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Tail;\par
00537 \};\par
00538 \par
00539 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00540     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00541     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00542     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00543     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00544     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00545     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00546     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
00547     {\cf17 typename} T41>\par
00548 {\cf17 struct }Types41 \{\par
00549   {\cf17 typedef} T1 Head;\par
00550   {\cf17 typedef} Types40<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00551       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00552       T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41> Tail;\par
00553 \};\par
00554 \par
00555 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00556     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00557     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00558     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00559     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00560     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00561     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00562     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
00563     {\cf17 typename} T41, {\cf17 typename} T42>\par
00564 {\cf17 struct }Types42 \{\par
00565   {\cf17 typedef} T1 Head;\par
00566   {\cf17 typedef} Types41<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00567       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00568       T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42> Tail;\par
00569 \};\par
00570 \par
00571 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00572     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00573     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00574     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00575     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00576     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00577     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00578     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
00579     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43>\par
00580 {\cf17 struct }Types43 \{\par
00581   {\cf17 typedef} T1 Head;\par
00582   {\cf17 typedef} Types42<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00583       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00584       T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\par
00585       T43> Tail;\par
00586 \};\par
00587 \par
00588 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00589     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00590     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00591     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00592     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00593     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00594     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00595     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
00596     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44>\par
00597 {\cf17 struct }Types44 \{\par
00598   {\cf17 typedef} T1 Head;\par
00599   {\cf17 typedef} Types43<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00600       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00601       T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
00602       T44> Tail;\par
00603 \};\par
00604 \par
00605 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00606     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00607     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00608     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00609     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00610     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00611     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00612     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
00613     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45>\par
00614 {\cf17 struct }Types45 \{\par
00615   {\cf17 typedef} T1 Head;\par
00616   {\cf17 typedef} Types44<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00617       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00618       T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
00619       T44, T45> Tail;\par
00620 \};\par
00621 \par
00622 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00623     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00624     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00625     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00626     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00627     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00628     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00629     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
00630     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
00631     {\cf17 typename} T46>\par
00632 {\cf17 struct }Types46 \{\par
00633   {\cf17 typedef} T1 Head;\par
00634   {\cf17 typedef} Types45<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00635       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00636       T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
00637       T44, T45, T46> Tail;\par
00638 \};\par
00639 \par
00640 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00641     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00642     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00643     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00644     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00645     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00646     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00647     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
00648     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
00649     {\cf17 typename} T46, {\cf17 typename} T47>\par
00650 {\cf17 struct }Types47 \{\par
00651   {\cf17 typedef} T1 Head;\par
00652   {\cf17 typedef} Types46<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00653       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00654       T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
00655       T44, T45, T46, T47> Tail;\par
00656 \};\par
00657 \par
00658 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00659     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00660     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00661     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00662     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00663     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00664     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00665     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
00666     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
00667     {\cf17 typename} T46, {\cf17 typename} T47, {\cf17 typename} T48>\par
00668 {\cf17 struct }Types48 \{\par
00669   {\cf17 typedef} T1 Head;\par
00670   {\cf17 typedef} Types47<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00671       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00672       T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
00673       T44, T45, T46, T47, T48> Tail;\par
00674 \};\par
00675 \par
00676 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00677     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00678     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00679     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00680     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00681     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00682     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00683     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
00684     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
00685     {\cf17 typename} T46, {\cf17 typename} T47, {\cf17 typename} T48, {\cf17 typename} T49>\par
00686 {\cf17 struct }Types49 \{\par
00687   {\cf17 typedef} T1 Head;\par
00688   {\cf17 typedef} Types48<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00689       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00690       T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
00691       T44, T45, T46, T47, T48, T49> Tail;\par
00692 \};\par
00693 \par
00694 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00695     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00696     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
00697     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
00698     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
00699     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
00700     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
00701     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
00702     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
00703     {\cf17 typename} T46, {\cf17 typename} T47, {\cf17 typename} T48, {\cf17 typename} T49, {\cf17 typename} T50>\par
00704 {\cf17 struct }Types50 \{\par
00705   {\cf17 typedef} T1 Head;\par
00706   {\cf17 typedef} Types49<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
00707       T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
00708       T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
00709       T44, T45, T46, T47, T48, T49, T50> Tail;\par
00710 \};\par
00711 \par
00712 \par
00713 \}  {\cf20 // namespace internal}\par
00714 \par
00715 {\cf20 // We don't want to require the users to write TypesN<...> directly,}\par
00716 {\cf20 // as that would require them to count the length.  Types<...> is much}\par
00717 {\cf20 // easier to write, but generates horrible messages when there is a}\par
00718 {\cf20 // compiler error, as gcc insists on printing out each template}\par
00719 {\cf20 // argument, even if it has the default value (this means Types<int>}\par
00720 {\cf20 // will appear as Types<int, None, None, ..., None> in the compiler}\par
00721 {\cf20 // errors).}\par
00722 {\cf20 //}\par
00723 {\cf20 // Our solution is to combine the best part of the two approaches: a}\par
00724 {\cf20 // user would write Types<T1, ..., TN>, and Google Test will translate}\par
00725 {\cf20 // that to TypesN<T1, ..., TN> internally to make error messages}\par
00726 {\cf20 // readable.  The translation is done by the 'type' member of the}\par
00727 {\cf20 // Types template.}\par
00728 {\cf17 template} <{\cf17 typename} T1 = internal::None, {\cf17 typename} T2 = internal::None,\par
00729     {\cf17 typename} T3 = internal::None, {\cf17 typename} T4 = internal::None,\par
00730     {\cf17 typename} T5 = internal::None, {\cf17 typename} T6 = internal::None,\par
00731     {\cf17 typename} T7 = internal::None, {\cf17 typename} T8 = internal::None,\par
00732     {\cf17 typename} T9 = internal::None, {\cf17 typename} T10 = internal::None,\par
00733     {\cf17 typename} T11 = internal::None, {\cf17 typename} T12 = internal::None,\par
00734     {\cf17 typename} T13 = internal::None, {\cf17 typename} T14 = internal::None,\par
00735     {\cf17 typename} T15 = internal::None, {\cf17 typename} T16 = internal::None,\par
00736     {\cf17 typename} T17 = internal::None, {\cf17 typename} T18 = internal::None,\par
00737     {\cf17 typename} T19 = internal::None, {\cf17 typename} T20 = internal::None,\par
00738     {\cf17 typename} T21 = internal::None, {\cf17 typename} T22 = internal::None,\par
00739     {\cf17 typename} T23 = internal::None, {\cf17 typename} T24 = internal::None,\par
00740     {\cf17 typename} T25 = internal::None, {\cf17 typename} T26 = internal::None,\par
00741     {\cf17 typename} T27 = internal::None, {\cf17 typename} T28 = internal::None,\par
00742     {\cf17 typename} T29 = internal::None, {\cf17 typename} T30 = internal::None,\par
00743     {\cf17 typename} T31 = internal::None, {\cf17 typename} T32 = internal::None,\par
00744     {\cf17 typename} T33 = internal::None, {\cf17 typename} T34 = internal::None,\par
00745     {\cf17 typename} T35 = internal::None, {\cf17 typename} T36 = internal::None,\par
00746     {\cf17 typename} T37 = internal::None, {\cf17 typename} T38 = internal::None,\par
00747     {\cf17 typename} T39 = internal::None, {\cf17 typename} T40 = internal::None,\par
00748     {\cf17 typename} T41 = internal::None, {\cf17 typename} T42 = internal::None,\par
00749     {\cf17 typename} T43 = internal::None, {\cf17 typename} T44 = internal::None,\par
00750     {\cf17 typename} T45 = internal::None, {\cf17 typename} T46 = internal::None,\par
00751     {\cf17 typename} T47 = internal::None, {\cf17 typename} T48 = internal::None,\par
00752     {\cf17 typename} T49 = internal::None, {\cf17 typename} T50 = internal::None>\par
00753 {\cf17 struct }Types \{\par
00754   {\cf17 typedef} internal::Types50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
00755       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
00756       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\par
00757       T41, T42, T43, T44, T45, T46, T47, T48, T49, T50> type;\par
00758 \};\par
00759 \par
00760 {\cf17 template} <>\par
00761 {\cf17 struct }Types<internal::None, internal::None, internal::None, internal::None,\par
00762     internal::None, internal::None, internal::None, internal::None,\par
00763     internal::None, internal::None, internal::None, internal::None,\par
00764     internal::None, internal::None, internal::None, internal::None,\par
00765     internal::None, internal::None, internal::None, internal::None,\par
00766     internal::None, internal::None, internal::None, internal::None,\par
00767     internal::None, internal::None, internal::None, internal::None,\par
00768     internal::None, internal::None, internal::None, internal::None,\par
00769     internal::None, internal::None, internal::None, internal::None,\par
00770     internal::None, internal::None, internal::None, internal::None,\par
00771     internal::None, internal::None, internal::None, internal::None,\par
00772     internal::None, internal::None, internal::None, internal::None,\par
00773     internal::None, internal::None> \{\par
00774   {\cf17 typedef} internal::Types0 type;\par
00775 \};\par
00776 {\cf17 template} <{\cf17 typename} T1>\par
00777 {\cf17 struct }Types<T1, internal::None, internal::None, internal::None,\par
00778     internal::None, internal::None, internal::None, internal::None,\par
00779     internal::None, internal::None, internal::None, internal::None,\par
00780     internal::None, internal::None, internal::None, internal::None,\par
00781     internal::None, internal::None, internal::None, internal::None,\par
00782     internal::None, internal::None, internal::None, internal::None,\par
00783     internal::None, internal::None, internal::None, internal::None,\par
00784     internal::None, internal::None, internal::None, internal::None,\par
00785     internal::None, internal::None, internal::None, internal::None,\par
00786     internal::None, internal::None, internal::None, internal::None,\par
00787     internal::None, internal::None, internal::None, internal::None,\par
00788     internal::None, internal::None, internal::None, internal::None,\par
00789     internal::None, internal::None> \{\par
00790   {\cf17 typedef} internal::Types1<T1> type;\par
00791 \};\par
00792 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
00793 {\cf17 struct }Types<T1, T2, internal::None, internal::None, internal::None,\par
00794     internal::None, internal::None, internal::None, internal::None,\par
00795     internal::None, internal::None, internal::None, internal::None,\par
00796     internal::None, internal::None, internal::None, internal::None,\par
00797     internal::None, internal::None, internal::None, internal::None,\par
00798     internal::None, internal::None, internal::None, internal::None,\par
00799     internal::None, internal::None, internal::None, internal::None,\par
00800     internal::None, internal::None, internal::None, internal::None,\par
00801     internal::None, internal::None, internal::None, internal::None,\par
00802     internal::None, internal::None, internal::None, internal::None,\par
00803     internal::None, internal::None, internal::None, internal::None,\par
00804     internal::None, internal::None, internal::None, internal::None,\par
00805     internal::None> \{\par
00806   {\cf17 typedef} internal::Types2<T1, T2> type;\par
00807 \};\par
00808 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3>\par
00809 {\cf17 struct }Types<T1, T2, T3, internal::None, internal::None, internal::None,\par
00810     internal::None, internal::None, internal::None, internal::None,\par
00811     internal::None, internal::None, internal::None, internal::None,\par
00812     internal::None, internal::None, internal::None, internal::None,\par
00813     internal::None, internal::None, internal::None, internal::None,\par
00814     internal::None, internal::None, internal::None, internal::None,\par
00815     internal::None, internal::None, internal::None, internal::None,\par
00816     internal::None, internal::None, internal::None, internal::None,\par
00817     internal::None, internal::None, internal::None, internal::None,\par
00818     internal::None, internal::None, internal::None, internal::None,\par
00819     internal::None, internal::None, internal::None, internal::None,\par
00820     internal::None, internal::None, internal::None, internal::None> \{\par
00821   {\cf17 typedef} internal::Types3<T1, T2, T3> type;\par
00822 \};\par
00823 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4>\par
00824 {\cf17 struct }Types<T1, T2, T3, T4, internal::None, internal::None, internal::None,\par
00825     internal::None, internal::None, internal::None, internal::None,\par
00826     internal::None, internal::None, internal::None, internal::None,\par
00827     internal::None, internal::None, internal::None, internal::None,\par
00828     internal::None, internal::None, internal::None, internal::None,\par
00829     internal::None, internal::None, internal::None, internal::None,\par
00830     internal::None, internal::None, internal::None, internal::None,\par
00831     internal::None, internal::None, internal::None, internal::None,\par
00832     internal::None, internal::None, internal::None, internal::None,\par
00833     internal::None, internal::None, internal::None, internal::None,\par
00834     internal::None, internal::None, internal::None, internal::None,\par
00835     internal::None, internal::None, internal::None> \{\par
00836   {\cf17 typedef} internal::Types4<T1, T2, T3, T4> type;\par
00837 \};\par
00838 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5>\par
00839 {\cf17 struct }Types<T1, T2, T3, T4, T5, internal::None, internal::None,\par
00840     internal::None, internal::None, internal::None, internal::None,\par
00841     internal::None, internal::None, internal::None, internal::None,\par
00842     internal::None, internal::None, internal::None, internal::None,\par
00843     internal::None, internal::None, internal::None, internal::None,\par
00844     internal::None, internal::None, internal::None, internal::None,\par
00845     internal::None, internal::None, internal::None, internal::None,\par
00846     internal::None, internal::None, internal::None, internal::None,\par
00847     internal::None, internal::None, internal::None, internal::None,\par
00848     internal::None, internal::None, internal::None, internal::None,\par
00849     internal::None, internal::None, internal::None, internal::None,\par
00850     internal::None, internal::None, internal::None> \{\par
00851   {\cf17 typedef} internal::Types5<T1, T2, T3, T4, T5> type;\par
00852 \};\par
00853 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00854     {\cf17 typename} T6>\par
00855 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, internal::None, internal::None,\par
00856     internal::None, internal::None, internal::None, internal::None,\par
00857     internal::None, internal::None, internal::None, internal::None,\par
00858     internal::None, internal::None, internal::None, internal::None,\par
00859     internal::None, internal::None, internal::None, internal::None,\par
00860     internal::None, internal::None, internal::None, internal::None,\par
00861     internal::None, internal::None, internal::None, internal::None,\par
00862     internal::None, internal::None, internal::None, internal::None,\par
00863     internal::None, internal::None, internal::None, internal::None,\par
00864     internal::None, internal::None, internal::None, internal::None,\par
00865     internal::None, internal::None, internal::None, internal::None,\par
00866     internal::None, internal::None> \{\par
00867   {\cf17 typedef} internal::Types6<T1, T2, T3, T4, T5, T6> type;\par
00868 \};\par
00869 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00870     {\cf17 typename} T6, {\cf17 typename} T7>\par
00871 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, internal::None, internal::None,\par
00872     internal::None, internal::None, internal::None, internal::None,\par
00873     internal::None, internal::None, internal::None, internal::None,\par
00874     internal::None, internal::None, internal::None, internal::None,\par
00875     internal::None, internal::None, internal::None, internal::None,\par
00876     internal::None, internal::None, internal::None, internal::None,\par
00877     internal::None, internal::None, internal::None, internal::None,\par
00878     internal::None, internal::None, internal::None, internal::None,\par
00879     internal::None, internal::None, internal::None, internal::None,\par
00880     internal::None, internal::None, internal::None, internal::None,\par
00881     internal::None, internal::None, internal::None, internal::None,\par
00882     internal::None> \{\par
00883   {\cf17 typedef} internal::Types7<T1, T2, T3, T4, T5, T6, T7> type;\par
00884 \};\par
00885 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00886     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8>\par
00887 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, internal::None, internal::None,\par
00888     internal::None, internal::None, internal::None, internal::None,\par
00889     internal::None, internal::None, internal::None, internal::None,\par
00890     internal::None, internal::None, internal::None, internal::None,\par
00891     internal::None, internal::None, internal::None, internal::None,\par
00892     internal::None, internal::None, internal::None, internal::None,\par
00893     internal::None, internal::None, internal::None, internal::None,\par
00894     internal::None, internal::None, internal::None, internal::None,\par
00895     internal::None, internal::None, internal::None, internal::None,\par
00896     internal::None, internal::None, internal::None, internal::None,\par
00897     internal::None, internal::None, internal::None, internal::None> \{\par
00898   {\cf17 typedef} internal::Types8<T1, T2, T3, T4, T5, T6, T7, T8> type;\par
00899 \};\par
00900 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00901     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9>\par
00902 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, internal::None,\par
00903     internal::None, internal::None, internal::None, internal::None,\par
00904     internal::None, internal::None, internal::None, internal::None,\par
00905     internal::None, internal::None, internal::None, internal::None,\par
00906     internal::None, internal::None, internal::None, internal::None,\par
00907     internal::None, internal::None, internal::None, internal::None,\par
00908     internal::None, internal::None, internal::None, internal::None,\par
00909     internal::None, internal::None, internal::None, internal::None,\par
00910     internal::None, internal::None, internal::None, internal::None,\par
00911     internal::None, internal::None, internal::None, internal::None,\par
00912     internal::None, internal::None, internal::None, internal::None> \{\par
00913   {\cf17 typedef} internal::Types9<T1, T2, T3, T4, T5, T6, T7, T8, T9> type;\par
00914 \};\par
00915 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00916     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10>\par
00917 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, internal::None,\par
00918     internal::None, internal::None, internal::None, internal::None,\par
00919     internal::None, internal::None, internal::None, internal::None,\par
00920     internal::None, internal::None, internal::None, internal::None,\par
00921     internal::None, internal::None, internal::None, internal::None,\par
00922     internal::None, internal::None, internal::None, internal::None,\par
00923     internal::None, internal::None, internal::None, internal::None,\par
00924     internal::None, internal::None, internal::None, internal::None,\par
00925     internal::None, internal::None, internal::None, internal::None,\par
00926     internal::None, internal::None, internal::None, internal::None,\par
00927     internal::None, internal::None, internal::None> \{\par
00928   {\cf17 typedef} internal::Types10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> type;\par
00929 \};\par
00930 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00931     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00932     {\cf17 typename} T11>\par
00933 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, internal::None,\par
00934     internal::None, internal::None, internal::None, internal::None,\par
00935     internal::None, internal::None, internal::None, internal::None,\par
00936     internal::None, internal::None, internal::None, internal::None,\par
00937     internal::None, internal::None, internal::None, internal::None,\par
00938     internal::None, internal::None, internal::None, internal::None,\par
00939     internal::None, internal::None, internal::None, internal::None,\par
00940     internal::None, internal::None, internal::None, internal::None,\par
00941     internal::None, internal::None, internal::None, internal::None,\par
00942     internal::None, internal::None, internal::None, internal::None,\par
00943     internal::None, internal::None> \{\par
00944   {\cf17 typedef} internal::Types11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> type;\par
00945 \};\par
00946 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00947     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00948     {\cf17 typename} T11, {\cf17 typename} T12>\par
00949 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, internal::None,\par
00950     internal::None, internal::None, internal::None, internal::None,\par
00951     internal::None, internal::None, internal::None, internal::None,\par
00952     internal::None, internal::None, internal::None, internal::None,\par
00953     internal::None, internal::None, internal::None, internal::None,\par
00954     internal::None, internal::None, internal::None, internal::None,\par
00955     internal::None, internal::None, internal::None, internal::None,\par
00956     internal::None, internal::None, internal::None, internal::None,\par
00957     internal::None, internal::None, internal::None, internal::None,\par
00958     internal::None, internal::None, internal::None, internal::None,\par
00959     internal::None> \{\par
00960   {\cf17 typedef} internal::Types12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\par
00961       T12> type;\par
00962 \};\par
00963 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00964     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00965     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13>\par
00966 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
00967     internal::None, internal::None, internal::None, internal::None,\par
00968     internal::None, internal::None, internal::None, internal::None,\par
00969     internal::None, internal::None, internal::None, internal::None,\par
00970     internal::None, internal::None, internal::None, internal::None,\par
00971     internal::None, internal::None, internal::None, internal::None,\par
00972     internal::None, internal::None, internal::None, internal::None,\par
00973     internal::None, internal::None, internal::None, internal::None,\par
00974     internal::None, internal::None, internal::None, internal::None,\par
00975     internal::None, internal::None, internal::None, internal::None,\par
00976     internal::None> \{\par
00977   {\cf17 typedef} internal::Types13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
00978       T13> type;\par
00979 \};\par
00980 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00981     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00982     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14>\par
00983 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
00984     internal::None, internal::None, internal::None, internal::None,\par
00985     internal::None, internal::None, internal::None, internal::None,\par
00986     internal::None, internal::None, internal::None, internal::None,\par
00987     internal::None, internal::None, internal::None, internal::None,\par
00988     internal::None, internal::None, internal::None, internal::None,\par
00989     internal::None, internal::None, internal::None, internal::None,\par
00990     internal::None, internal::None, internal::None, internal::None,\par
00991     internal::None, internal::None, internal::None, internal::None,\par
00992     internal::None, internal::None, internal::None, internal::None> \{\par
00993   {\cf17 typedef} internal::Types14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
00994       T13, T14> type;\par
00995 \};\par
00996 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
00997     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
00998     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15>\par
00999 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01000     internal::None, internal::None, internal::None, internal::None,\par
01001     internal::None, internal::None, internal::None, internal::None,\par
01002     internal::None, internal::None, internal::None, internal::None,\par
01003     internal::None, internal::None, internal::None, internal::None,\par
01004     internal::None, internal::None, internal::None, internal::None,\par
01005     internal::None, internal::None, internal::None, internal::None,\par
01006     internal::None, internal::None, internal::None, internal::None,\par
01007     internal::None, internal::None, internal::None, internal::None,\par
01008     internal::None, internal::None, internal::None> \{\par
01009   {\cf17 typedef} internal::Types15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01010       T13, T14, T15> type;\par
01011 \};\par
01012 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01013     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01014     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01015     {\cf17 typename} T16>\par
01016 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01017     T16, internal::None, internal::None, internal::None, internal::None,\par
01018     internal::None, internal::None, internal::None, internal::None,\par
01019     internal::None, internal::None, internal::None, internal::None,\par
01020     internal::None, internal::None, internal::None, internal::None,\par
01021     internal::None, internal::None, internal::None, internal::None,\par
01022     internal::None, internal::None, internal::None, internal::None,\par
01023     internal::None, internal::None, internal::None, internal::None,\par
01024     internal::None, internal::None, internal::None, internal::None,\par
01025     internal::None, internal::None> \{\par
01026   {\cf17 typedef} internal::Types16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01027       T13, T14, T15, T16> type;\par
01028 \};\par
01029 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01030     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01031     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01032     {\cf17 typename} T16, {\cf17 typename} T17>\par
01033 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01034     T16, T17, internal::None, internal::None, internal::None, internal::None,\par
01035     internal::None, internal::None, internal::None, internal::None,\par
01036     internal::None, internal::None, internal::None, internal::None,\par
01037     internal::None, internal::None, internal::None, internal::None,\par
01038     internal::None, internal::None, internal::None, internal::None,\par
01039     internal::None, internal::None, internal::None, internal::None,\par
01040     internal::None, internal::None, internal::None, internal::None,\par
01041     internal::None, internal::None, internal::None, internal::None,\par
01042     internal::None> \{\par
01043   {\cf17 typedef} internal::Types17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01044       T13, T14, T15, T16, T17> type;\par
01045 \};\par
01046 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01047     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01048     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01049     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18>\par
01050 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01051     T16, T17, T18, internal::None, internal::None, internal::None,\par
01052     internal::None, internal::None, internal::None, internal::None,\par
01053     internal::None, internal::None, internal::None, internal::None,\par
01054     internal::None, internal::None, internal::None, internal::None,\par
01055     internal::None, internal::None, internal::None, internal::None,\par
01056     internal::None, internal::None, internal::None, internal::None,\par
01057     internal::None, internal::None, internal::None, internal::None,\par
01058     internal::None, internal::None, internal::None, internal::None,\par
01059     internal::None> \{\par
01060   {\cf17 typedef} internal::Types18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01061       T13, T14, T15, T16, T17, T18> type;\par
01062 \};\par
01063 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01064     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01065     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01066     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19>\par
01067 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01068     T16, T17, T18, T19, internal::None, internal::None, internal::None,\par
01069     internal::None, internal::None, internal::None, internal::None,\par
01070     internal::None, internal::None, internal::None, internal::None,\par
01071     internal::None, internal::None, internal::None, internal::None,\par
01072     internal::None, internal::None, internal::None, internal::None,\par
01073     internal::None, internal::None, internal::None, internal::None,\par
01074     internal::None, internal::None, internal::None, internal::None,\par
01075     internal::None, internal::None, internal::None, internal::None> \{\par
01076   {\cf17 typedef} internal::Types19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01077       T13, T14, T15, T16, T17, T18, T19> type;\par
01078 \};\par
01079 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01080     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01081     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01082     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20>\par
01083 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01084     T16, T17, T18, T19, T20, internal::None, internal::None, internal::None,\par
01085     internal::None, internal::None, internal::None, internal::None,\par
01086     internal::None, internal::None, internal::None, internal::None,\par
01087     internal::None, internal::None, internal::None, internal::None,\par
01088     internal::None, internal::None, internal::None, internal::None,\par
01089     internal::None, internal::None, internal::None, internal::None,\par
01090     internal::None, internal::None, internal::None, internal::None,\par
01091     internal::None, internal::None, internal::None> \{\par
01092   {\cf17 typedef} internal::Types20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01093       T13, T14, T15, T16, T17, T18, T19, T20> type;\par
01094 \};\par
01095 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01096     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01097     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01098     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01099     {\cf17 typename} T21>\par
01100 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01101     T16, T17, T18, T19, T20, T21, internal::None, internal::None,\par
01102     internal::None, internal::None, internal::None, internal::None,\par
01103     internal::None, internal::None, internal::None, internal::None,\par
01104     internal::None, internal::None, internal::None, internal::None,\par
01105     internal::None, internal::None, internal::None, internal::None,\par
01106     internal::None, internal::None, internal::None, internal::None,\par
01107     internal::None, internal::None, internal::None, internal::None,\par
01108     internal::None, internal::None, internal::None> \{\par
01109   {\cf17 typedef} internal::Types21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01110       T13, T14, T15, T16, T17, T18, T19, T20, T21> type;\par
01111 \};\par
01112 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01113     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01114     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01115     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01116     {\cf17 typename} T21, {\cf17 typename} T22>\par
01117 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01118     T16, T17, T18, T19, T20, T21, T22, internal::None, internal::None,\par
01119     internal::None, internal::None, internal::None, internal::None,\par
01120     internal::None, internal::None, internal::None, internal::None,\par
01121     internal::None, internal::None, internal::None, internal::None,\par
01122     internal::None, internal::None, internal::None, internal::None,\par
01123     internal::None, internal::None, internal::None, internal::None,\par
01124     internal::None, internal::None, internal::None, internal::None,\par
01125     internal::None, internal::None> \{\par
01126   {\cf17 typedef} internal::Types22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01127       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> type;\par
01128 \};\par
01129 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01130     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01131     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01132     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01133     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23>\par
01134 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01135     T16, T17, T18, T19, T20, T21, T22, T23, internal::None, internal::None,\par
01136     internal::None, internal::None, internal::None, internal::None,\par
01137     internal::None, internal::None, internal::None, internal::None,\par
01138     internal::None, internal::None, internal::None, internal::None,\par
01139     internal::None, internal::None, internal::None, internal::None,\par
01140     internal::None, internal::None, internal::None, internal::None,\par
01141     internal::None, internal::None, internal::None, internal::None,\par
01142     internal::None> \{\par
01143   {\cf17 typedef} internal::Types23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01144       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> type;\par
01145 \};\par
01146 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01147     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01148     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01149     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01150     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24>\par
01151 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01152     T16, T17, T18, T19, T20, T21, T22, T23, T24, internal::None,\par
01153     internal::None, internal::None, internal::None, internal::None,\par
01154     internal::None, internal::None, internal::None, internal::None,\par
01155     internal::None, internal::None, internal::None, internal::None,\par
01156     internal::None, internal::None, internal::None, internal::None,\par
01157     internal::None, internal::None, internal::None, internal::None,\par
01158     internal::None, internal::None, internal::None, internal::None,\par
01159     internal::None> \{\par
01160   {\cf17 typedef} internal::Types24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01161       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> type;\par
01162 \};\par
01163 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01164     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01165     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01166     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01167     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25>\par
01168 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01169     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, internal::None,\par
01170     internal::None, internal::None, internal::None, internal::None,\par
01171     internal::None, internal::None, internal::None, internal::None,\par
01172     internal::None, internal::None, internal::None, internal::None,\par
01173     internal::None, internal::None, internal::None, internal::None,\par
01174     internal::None, internal::None, internal::None, internal::None,\par
01175     internal::None, internal::None, internal::None, internal::None> \{\par
01176   {\cf17 typedef} internal::Types25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01177       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> type;\par
01178 \};\par
01179 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01180     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01181     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01182     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01183     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01184     {\cf17 typename} T26>\par
01185 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01186     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, internal::None,\par
01187     internal::None, internal::None, internal::None, internal::None,\par
01188     internal::None, internal::None, internal::None, internal::None,\par
01189     internal::None, internal::None, internal::None, internal::None,\par
01190     internal::None, internal::None, internal::None, internal::None,\par
01191     internal::None, internal::None, internal::None, internal::None,\par
01192     internal::None, internal::None, internal::None> \{\par
01193   {\cf17 typedef} internal::Types26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01194       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\par
01195       T26> type;\par
01196 \};\par
01197 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01198     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01199     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01200     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01201     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01202     {\cf17 typename} T26, {\cf17 typename} T27>\par
01203 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01204     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, internal::None,\par
01205     internal::None, internal::None, internal::None, internal::None,\par
01206     internal::None, internal::None, internal::None, internal::None,\par
01207     internal::None, internal::None, internal::None, internal::None,\par
01208     internal::None, internal::None, internal::None, internal::None,\par
01209     internal::None, internal::None, internal::None, internal::None,\par
01210     internal::None, internal::None> \{\par
01211   {\cf17 typedef} internal::Types27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01212       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01213       T27> type;\par
01214 \};\par
01215 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01216     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01217     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01218     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01219     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01220     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28>\par
01221 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01222     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
01223     internal::None, internal::None, internal::None, internal::None,\par
01224     internal::None, internal::None, internal::None, internal::None,\par
01225     internal::None, internal::None, internal::None, internal::None,\par
01226     internal::None, internal::None, internal::None, internal::None,\par
01227     internal::None, internal::None, internal::None, internal::None,\par
01228     internal::None, internal::None> \{\par
01229   {\cf17 typedef} internal::Types28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01230       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01231       T27, T28> type;\par
01232 \};\par
01233 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01234     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01235     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01236     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01237     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01238     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29>\par
01239 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01240     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
01241     internal::None, internal::None, internal::None, internal::None,\par
01242     internal::None, internal::None, internal::None, internal::None,\par
01243     internal::None, internal::None, internal::None, internal::None,\par
01244     internal::None, internal::None, internal::None, internal::None,\par
01245     internal::None, internal::None, internal::None, internal::None,\par
01246     internal::None> \{\par
01247   {\cf17 typedef} internal::Types29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01248       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01249       T27, T28, T29> type;\par
01250 \};\par
01251 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01252     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01253     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01254     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01255     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01256     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30>\par
01257 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01258     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01259     internal::None, internal::None, internal::None, internal::None,\par
01260     internal::None, internal::None, internal::None, internal::None,\par
01261     internal::None, internal::None, internal::None, internal::None,\par
01262     internal::None, internal::None, internal::None, internal::None,\par
01263     internal::None, internal::None, internal::None, internal::None> \{\par
01264   {\cf17 typedef} internal::Types30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01265       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01266       T27, T28, T29, T30> type;\par
01267 \};\par
01268 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01269     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01270     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01271     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01272     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01273     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01274     {\cf17 typename} T31>\par
01275 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01276     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01277     T31, internal::None, internal::None, internal::None, internal::None,\par
01278     internal::None, internal::None, internal::None, internal::None,\par
01279     internal::None, internal::None, internal::None, internal::None,\par
01280     internal::None, internal::None, internal::None, internal::None,\par
01281     internal::None, internal::None, internal::None> \{\par
01282   {\cf17 typedef} internal::Types31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01283       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01284       T27, T28, T29, T30, T31> type;\par
01285 \};\par
01286 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01287     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01288     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01289     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01290     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01291     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01292     {\cf17 typename} T31, {\cf17 typename} T32>\par
01293 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01294     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01295     T31, T32, internal::None, internal::None, internal::None, internal::None,\par
01296     internal::None, internal::None, internal::None, internal::None,\par
01297     internal::None, internal::None, internal::None, internal::None,\par
01298     internal::None, internal::None, internal::None, internal::None,\par
01299     internal::None, internal::None> \{\par
01300   {\cf17 typedef} internal::Types32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01301       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01302       T27, T28, T29, T30, T31, T32> type;\par
01303 \};\par
01304 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01305     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01306     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01307     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01308     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01309     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01310     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33>\par
01311 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01312     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01313     T31, T32, T33, internal::None, internal::None, internal::None,\par
01314     internal::None, internal::None, internal::None, internal::None,\par
01315     internal::None, internal::None, internal::None, internal::None,\par
01316     internal::None, internal::None, internal::None, internal::None,\par
01317     internal::None, internal::None> \{\par
01318   {\cf17 typedef} internal::Types33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01319       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01320       T27, T28, T29, T30, T31, T32, T33> type;\par
01321 \};\par
01322 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01323     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01324     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01325     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01326     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01327     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01328     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34>\par
01329 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01330     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01331     T31, T32, T33, T34, internal::None, internal::None, internal::None,\par
01332     internal::None, internal::None, internal::None, internal::None,\par
01333     internal::None, internal::None, internal::None, internal::None,\par
01334     internal::None, internal::None, internal::None, internal::None,\par
01335     internal::None> \{\par
01336   {\cf17 typedef} internal::Types34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01337       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01338       T27, T28, T29, T30, T31, T32, T33, T34> type;\par
01339 \};\par
01340 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01341     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01342     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01343     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01344     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01345     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01346     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35>\par
01347 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01348     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01349     T31, T32, T33, T34, T35, internal::None, internal::None, internal::None,\par
01350     internal::None, internal::None, internal::None, internal::None,\par
01351     internal::None, internal::None, internal::None, internal::None,\par
01352     internal::None, internal::None, internal::None, internal::None> \{\par
01353   {\cf17 typedef} internal::Types35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01354       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01355       T27, T28, T29, T30, T31, T32, T33, T34, T35> type;\par
01356 \};\par
01357 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01358     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01359     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01360     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01361     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01362     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01363     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01364     {\cf17 typename} T36>\par
01365 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01366     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01367     T31, T32, T33, T34, T35, T36, internal::None, internal::None,\par
01368     internal::None, internal::None, internal::None, internal::None,\par
01369     internal::None, internal::None, internal::None, internal::None,\par
01370     internal::None, internal::None, internal::None, internal::None> \{\par
01371   {\cf17 typedef} internal::Types36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01372       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01373       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36> type;\par
01374 \};\par
01375 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01376     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01377     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01378     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01379     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01380     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01381     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01382     {\cf17 typename} T36, {\cf17 typename} T37>\par
01383 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01384     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01385     T31, T32, T33, T34, T35, T36, T37, internal::None, internal::None,\par
01386     internal::None, internal::None, internal::None, internal::None,\par
01387     internal::None, internal::None, internal::None, internal::None,\par
01388     internal::None, internal::None, internal::None> \{\par
01389   {\cf17 typedef} internal::Types37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01390       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01391       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37> type;\par
01392 \};\par
01393 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01394     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01395     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01396     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01397     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01398     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01399     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01400     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38>\par
01401 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01402     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01403     T31, T32, T33, T34, T35, T36, T37, T38, internal::None, internal::None,\par
01404     internal::None, internal::None, internal::None, internal::None,\par
01405     internal::None, internal::None, internal::None, internal::None,\par
01406     internal::None, internal::None> \{\par
01407   {\cf17 typedef} internal::Types38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01408       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01409       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> type;\par
01410 \};\par
01411 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01412     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01413     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01414     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01415     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01416     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01417     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01418     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39>\par
01419 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01420     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01421     T31, T32, T33, T34, T35, T36, T37, T38, T39, internal::None,\par
01422     internal::None, internal::None, internal::None, internal::None,\par
01423     internal::None, internal::None, internal::None, internal::None,\par
01424     internal::None, internal::None> \{\par
01425   {\cf17 typedef} internal::Types39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01426       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01427       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> type;\par
01428 \};\par
01429 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01430     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01431     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01432     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01433     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01434     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01435     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01436     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40>\par
01437 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01438     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01439     T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, internal::None,\par
01440     internal::None, internal::None, internal::None, internal::None,\par
01441     internal::None, internal::None, internal::None, internal::None,\par
01442     internal::None> \{\par
01443   {\cf17 typedef} internal::Types40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01444       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01445       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\par
01446       T40> type;\par
01447 \};\par
01448 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01449     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01450     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01451     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01452     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01453     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01454     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01455     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01456     {\cf17 typename} T41>\par
01457 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01458     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01459     T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, internal::None,\par
01460     internal::None, internal::None, internal::None, internal::None,\par
01461     internal::None, internal::None, internal::None, internal::None> \{\par
01462   {\cf17 typedef} internal::Types41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01463       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01464       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\par
01465       T41> type;\par
01466 \};\par
01467 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01468     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01469     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01470     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01471     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01472     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01473     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01474     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01475     {\cf17 typename} T41, {\cf17 typename} T42>\par
01476 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01477     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01478     T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, internal::None,\par
01479     internal::None, internal::None, internal::None, internal::None,\par
01480     internal::None, internal::None, internal::None> \{\par
01481   {\cf17 typedef} internal::Types42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01482       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01483       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\par
01484       T41, T42> type;\par
01485 \};\par
01486 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01487     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01488     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01489     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01490     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01491     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01492     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01493     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01494     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43>\par
01495 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01496     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01497     T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
01498     internal::None, internal::None, internal::None, internal::None,\par
01499     internal::None, internal::None, internal::None> \{\par
01500   {\cf17 typedef} internal::Types43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01501       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01502       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\par
01503       T41, T42, T43> type;\par
01504 \};\par
01505 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01506     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01507     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01508     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01509     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01510     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01511     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01512     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01513     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44>\par
01514 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01515     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01516     T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\par
01517     internal::None, internal::None, internal::None, internal::None,\par
01518     internal::None, internal::None> \{\par
01519   {\cf17 typedef} internal::Types44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01520       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01521       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\par
01522       T41, T42, T43, T44> type;\par
01523 \};\par
01524 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01525     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01526     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01527     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01528     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01529     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01530     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01531     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01532     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45>\par
01533 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01534     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01535     T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\par
01536     internal::None, internal::None, internal::None, internal::None,\par
01537     internal::None> \{\par
01538   {\cf17 typedef} internal::Types45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01539       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01540       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\par
01541       T41, T42, T43, T44, T45> type;\par
01542 \};\par
01543 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01544     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01545     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01546     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01547     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01548     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01549     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01550     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01551     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
01552     {\cf17 typename} T46>\par
01553 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01554     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01555     T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\par
01556     T46, internal::None, internal::None, internal::None, internal::None> \{\par
01557   {\cf17 typedef} internal::Types46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01558       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01559       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\par
01560       T41, T42, T43, T44, T45, T46> type;\par
01561 \};\par
01562 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01563     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01564     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01565     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01566     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01567     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01568     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01569     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01570     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
01571     {\cf17 typename} T46, {\cf17 typename} T47>\par
01572 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01573     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01574     T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\par
01575     T46, T47, internal::None, internal::None, internal::None> \{\par
01576   {\cf17 typedef} internal::Types47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01577       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01578       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\par
01579       T41, T42, T43, T44, T45, T46, T47> type;\par
01580 \};\par
01581 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01582     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01583     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01584     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01585     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01586     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01587     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01588     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01589     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
01590     {\cf17 typename} T46, {\cf17 typename} T47, {\cf17 typename} T48>\par
01591 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01592     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01593     T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\par
01594     T46, T47, T48, internal::None, internal::None> \{\par
01595   {\cf17 typedef} internal::Types48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01596       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01597       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\par
01598       T41, T42, T43, T44, T45, T46, T47, T48> type;\par
01599 \};\par
01600 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
01601     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
01602     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
01603     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
01604     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
01605     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
01606     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
01607     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
01608     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
01609     {\cf17 typename} T46, {\cf17 typename} T47, {\cf17 typename} T48, {\cf17 typename} T49>\par
01610 {\cf17 struct }Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\par
01611     T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\par
01612     T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\par
01613     T46, T47, T48, T49, internal::None> \{\par
01614   {\cf17 typedef} internal::Types49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
01615       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
01616       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\par
01617       T41, T42, T43, T44, T45, T46, T47, T48, T49> type;\par
01618 \};\par
01619 \par
01620 {\cf17 namespace }internal \{\par
01621 \par
01622 {\cf21 # define GTEST_TEMPLATE_ template <typename T> class}\par
01623 \par
01624 {\cf20 // The template "selector" struct TemplateSel<Tmpl> is used to}\par
01625 {\cf20 // represent Tmpl, which must be a class template with one type}\par
01626 {\cf20 // parameter, as a type.  TemplateSel<Tmpl>::Bind<T>::type is defined}\par
01627 {\cf20 // as the type Tmpl<T>.  This allows us to actually instantiate the}\par
01628 {\cf20 // template "selected" by TemplateSel<Tmpl>.}\par
01629 {\cf20 //}\par
01630 {\cf20 // This trick is necessary for simulating typedef for class templates,}\par
01631 {\cf20 // which C++ doesn't support directly.}\par
01632 {\cf17 template} <GTEST_TEMPLATE_ Tmpl>\par
01633 {\cf17 struct }TemplateSel \{\par
01634   {\cf17 template} <{\cf17 typename} T>\par
01635   {\cf17 struct }Bind \{\par
01636     {\cf17 typedef} Tmpl<T> type;\par
01637   \};\par
01638 \};\par
01639 \par
01640 {\cf21 # define GTEST_BIND_(TmplSel, T) \\}\par
01641 {\cf21   TmplSel::template Bind<T>::type}\par
01642 \par
01643 {\cf20 // A unique struct template used as the default value for the}\par
01644 {\cf20 // arguments of class template Templates.  This allows us to simulate}\par
01645 {\cf20 // variadic templates (e.g. Templates<int>, Templates<int, double>,}\par
01646 {\cf20 // and etc), which C++ doesn't support directly.}\par
01647 {\cf17 template} <{\cf17 typename} T>\par
01648 {\cf17 struct }NoneT \{\};\par
01649 \par
01650 {\cf20 // The following family of struct and struct templates are used to}\par
01651 {\cf20 // represent template lists.  In particular, TemplatesN<T1, T2, ...,}\par
01652 {\cf20 // TN> represents a list of N templates (T1, T2, ..., and TN).  Except}\par
01653 {\cf20 // for Templates0, every struct in the family has two member types:}\par
01654 {\cf20 // Head for the selector of the first template in the list, and Tail}\par
01655 {\cf20 // for the rest of the list.}\par
01656 \par
01657 {\cf20 // The empty template list.}\par
01658 {\cf17 struct }Templates0 \{\};\par
01659 \par
01660 {\cf20 // Template lists of length 1, 2, 3, and so on.}\par
01661 \par
01662 {\cf17 template} <GTEST_TEMPLATE_ T1>\par
01663 {\cf17 struct }Templates1 \{\par
01664   {\cf17 typedef} TemplateSel<T1> Head;\par
01665   {\cf17 typedef} Templates0 Tail;\par
01666 \};\par
01667 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2>\par
01668 {\cf17 struct }Templates2 \{\par
01669   {\cf17 typedef} TemplateSel<T1> Head;\par
01670   {\cf17 typedef} Templates1<T2> Tail;\par
01671 \};\par
01672 \par
01673 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3>\par
01674 {\cf17 struct }Templates3 \{\par
01675   {\cf17 typedef} TemplateSel<T1> Head;\par
01676   {\cf17 typedef} Templates2<T2, T3> Tail;\par
01677 \};\par
01678 \par
01679 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01680     GTEST_TEMPLATE_ T4>\par
01681 {\cf17 struct }Templates4 \{\par
01682   {\cf17 typedef} TemplateSel<T1> Head;\par
01683   {\cf17 typedef} Templates3<T2, T3, T4> Tail;\par
01684 \};\par
01685 \par
01686 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01687     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5>\par
01688 {\cf17 struct }Templates5 \{\par
01689   {\cf17 typedef} TemplateSel<T1> Head;\par
01690   {\cf17 typedef} Templates4<T2, T3, T4, T5> Tail;\par
01691 \};\par
01692 \par
01693 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01694     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6>\par
01695 {\cf17 struct }Templates6 \{\par
01696   {\cf17 typedef} TemplateSel<T1> Head;\par
01697   {\cf17 typedef} Templates5<T2, T3, T4, T5, T6> Tail;\par
01698 \};\par
01699 \par
01700 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01701     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01702     GTEST_TEMPLATE_ T7>\par
01703 {\cf17 struct }Templates7 \{\par
01704   {\cf17 typedef} TemplateSel<T1> Head;\par
01705   {\cf17 typedef} Templates6<T2, T3, T4, T5, T6, T7> Tail;\par
01706 \};\par
01707 \par
01708 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01709     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01710     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8>\par
01711 {\cf17 struct }Templates8 \{\par
01712   {\cf17 typedef} TemplateSel<T1> Head;\par
01713   {\cf17 typedef} Templates7<T2, T3, T4, T5, T6, T7, T8> Tail;\par
01714 \};\par
01715 \par
01716 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01717     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01718     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9>\par
01719 {\cf17 struct }Templates9 \{\par
01720   {\cf17 typedef} TemplateSel<T1> Head;\par
01721   {\cf17 typedef} Templates8<T2, T3, T4, T5, T6, T7, T8, T9> Tail;\par
01722 \};\par
01723 \par
01724 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01725     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01726     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01727     GTEST_TEMPLATE_ T10>\par
01728 {\cf17 struct }Templates10 \{\par
01729   {\cf17 typedef} TemplateSel<T1> Head;\par
01730   {\cf17 typedef} Templates9<T2, T3, T4, T5, T6, T7, T8, T9, T10> Tail;\par
01731 \};\par
01732 \par
01733 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01734     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01735     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01736     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11>\par
01737 {\cf17 struct }Templates11 \{\par
01738   {\cf17 typedef} TemplateSel<T1> Head;\par
01739   {\cf17 typedef} Templates10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Tail;\par
01740 \};\par
01741 \par
01742 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01743     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01744     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01745     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12>\par
01746 {\cf17 struct }Templates12 \{\par
01747   {\cf17 typedef} TemplateSel<T1> Head;\par
01748   {\cf17 typedef} Templates11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Tail;\par
01749 \};\par
01750 \par
01751 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01752     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01753     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01754     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01755     GTEST_TEMPLATE_ T13>\par
01756 {\cf17 struct }Templates13 \{\par
01757   {\cf17 typedef} TemplateSel<T1> Head;\par
01758   {\cf17 typedef} Templates12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Tail;\par
01759 \};\par
01760 \par
01761 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01762     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01763     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01764     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01765     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14>\par
01766 {\cf17 struct }Templates14 \{\par
01767   {\cf17 typedef} TemplateSel<T1> Head;\par
01768   {\cf17 typedef} Templates13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
01769       T14> Tail;\par
01770 \};\par
01771 \par
01772 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01773     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01774     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01775     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01776     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15>\par
01777 {\cf17 struct }Templates15 \{\par
01778   {\cf17 typedef} TemplateSel<T1> Head;\par
01779   {\cf17 typedef} Templates14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01780       T15> Tail;\par
01781 \};\par
01782 \par
01783 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01784     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01785     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01786     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01787     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01788     GTEST_TEMPLATE_ T16>\par
01789 {\cf17 struct }Templates16 \{\par
01790   {\cf17 typedef} TemplateSel<T1> Head;\par
01791   {\cf17 typedef} Templates15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01792       T15, T16> Tail;\par
01793 \};\par
01794 \par
01795 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01796     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01797     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01798     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01799     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01800     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17>\par
01801 {\cf17 struct }Templates17 \{\par
01802   {\cf17 typedef} TemplateSel<T1> Head;\par
01803   {\cf17 typedef} Templates16<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01804       T15, T16, T17> Tail;\par
01805 \};\par
01806 \par
01807 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01808     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01809     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01810     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01811     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01812     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18>\par
01813 {\cf17 struct }Templates18 \{\par
01814   {\cf17 typedef} TemplateSel<T1> Head;\par
01815   {\cf17 typedef} Templates17<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01816       T15, T16, T17, T18> Tail;\par
01817 \};\par
01818 \par
01819 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01820     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01821     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01822     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01823     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01824     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
01825     GTEST_TEMPLATE_ T19>\par
01826 {\cf17 struct }Templates19 \{\par
01827   {\cf17 typedef} TemplateSel<T1> Head;\par
01828   {\cf17 typedef} Templates18<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01829       T15, T16, T17, T18, T19> Tail;\par
01830 \};\par
01831 \par
01832 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01833     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01834     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01835     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01836     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01837     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
01838     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20>\par
01839 {\cf17 struct }Templates20 \{\par
01840   {\cf17 typedef} TemplateSel<T1> Head;\par
01841   {\cf17 typedef} Templates19<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01842       T15, T16, T17, T18, T19, T20> Tail;\par
01843 \};\par
01844 \par
01845 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01846     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01847     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01848     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01849     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01850     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
01851     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21>\par
01852 {\cf17 struct }Templates21 \{\par
01853   {\cf17 typedef} TemplateSel<T1> Head;\par
01854   {\cf17 typedef} Templates20<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01855       T15, T16, T17, T18, T19, T20, T21> Tail;\par
01856 \};\par
01857 \par
01858 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01859     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01860     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01861     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01862     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01863     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
01864     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
01865     GTEST_TEMPLATE_ T22>\par
01866 {\cf17 struct }Templates22 \{\par
01867   {\cf17 typedef} TemplateSel<T1> Head;\par
01868   {\cf17 typedef} Templates21<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01869       T15, T16, T17, T18, T19, T20, T21, T22> Tail;\par
01870 \};\par
01871 \par
01872 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01873     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01874     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01875     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01876     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01877     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
01878     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
01879     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23>\par
01880 {\cf17 struct }Templates23 \{\par
01881   {\cf17 typedef} TemplateSel<T1> Head;\par
01882   {\cf17 typedef} Templates22<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01883       T15, T16, T17, T18, T19, T20, T21, T22, T23> Tail;\par
01884 \};\par
01885 \par
01886 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01887     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01888     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01889     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01890     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01891     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
01892     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
01893     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24>\par
01894 {\cf17 struct }Templates24 \{\par
01895   {\cf17 typedef} TemplateSel<T1> Head;\par
01896   {\cf17 typedef} Templates23<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01897       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> Tail;\par
01898 \};\par
01899 \par
01900 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01901     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01902     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01903     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01904     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01905     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
01906     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
01907     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
01908     GTEST_TEMPLATE_ T25>\par
01909 {\cf17 struct }Templates25 \{\par
01910   {\cf17 typedef} TemplateSel<T1> Head;\par
01911   {\cf17 typedef} Templates24<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01912       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Tail;\par
01913 \};\par
01914 \par
01915 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01916     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01917     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01918     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01919     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01920     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
01921     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
01922     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
01923     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26>\par
01924 {\cf17 struct }Templates26 \{\par
01925   {\cf17 typedef} TemplateSel<T1> Head;\par
01926   {\cf17 typedef} Templates25<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01927       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> Tail;\par
01928 \};\par
01929 \par
01930 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01931     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01932     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01933     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01934     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01935     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
01936     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
01937     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
01938     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27>\par
01939 {\cf17 struct }Templates27 \{\par
01940   {\cf17 typedef} TemplateSel<T1> Head;\par
01941   {\cf17 typedef} Templates26<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01942       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> Tail;\par
01943 \};\par
01944 \par
01945 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01946     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01947     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01948     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01949     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01950     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
01951     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
01952     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
01953     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
01954     GTEST_TEMPLATE_ T28>\par
01955 {\cf17 struct }Templates28 \{\par
01956   {\cf17 typedef} TemplateSel<T1> Head;\par
01957   {\cf17 typedef} Templates27<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01958       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
01959       T28> Tail;\par
01960 \};\par
01961 \par
01962 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01963     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01964     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01965     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01966     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01967     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
01968     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
01969     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
01970     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
01971     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29>\par
01972 {\cf17 struct }Templates29 \{\par
01973   {\cf17 typedef} TemplateSel<T1> Head;\par
01974   {\cf17 typedef} Templates28<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01975       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
01976       T29> Tail;\par
01977 \};\par
01978 \par
01979 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01980     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01981     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01982     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
01983     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
01984     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
01985     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
01986     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
01987     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
01988     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30>\par
01989 {\cf17 struct }Templates30 \{\par
01990   {\cf17 typedef} TemplateSel<T1> Head;\par
01991   {\cf17 typedef} Templates29<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
01992       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
01993       T29, T30> Tail;\par
01994 \};\par
01995 \par
01996 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
01997     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
01998     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
01999     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02000     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02001     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02002     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02003     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02004     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02005     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02006     GTEST_TEMPLATE_ T31>\par
02007 {\cf17 struct }Templates31 \{\par
02008   {\cf17 typedef} TemplateSel<T1> Head;\par
02009   {\cf17 typedef} Templates30<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02010       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02011       T29, T30, T31> Tail;\par
02012 \};\par
02013 \par
02014 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02015     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02016     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02017     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02018     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02019     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02020     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02021     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02022     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02023     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02024     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32>\par
02025 {\cf17 struct }Templates32 \{\par
02026   {\cf17 typedef} TemplateSel<T1> Head;\par
02027   {\cf17 typedef} Templates31<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02028       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02029       T29, T30, T31, T32> Tail;\par
02030 \};\par
02031 \par
02032 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02033     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02034     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02035     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02036     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02037     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02038     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02039     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02040     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02041     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02042     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33>\par
02043 {\cf17 struct }Templates33 \{\par
02044   {\cf17 typedef} TemplateSel<T1> Head;\par
02045   {\cf17 typedef} Templates32<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02046       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02047       T29, T30, T31, T32, T33> Tail;\par
02048 \};\par
02049 \par
02050 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02051     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02052     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02053     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02054     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02055     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02056     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02057     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02058     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02059     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02060     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02061     GTEST_TEMPLATE_ T34>\par
02062 {\cf17 struct }Templates34 \{\par
02063   {\cf17 typedef} TemplateSel<T1> Head;\par
02064   {\cf17 typedef} Templates33<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02065       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02066       T29, T30, T31, T32, T33, T34> Tail;\par
02067 \};\par
02068 \par
02069 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02070     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02071     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02072     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02073     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02074     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02075     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02076     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02077     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02078     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02079     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02080     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35>\par
02081 {\cf17 struct }Templates35 \{\par
02082   {\cf17 typedef} TemplateSel<T1> Head;\par
02083   {\cf17 typedef} Templates34<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02084       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02085       T29, T30, T31, T32, T33, T34, T35> Tail;\par
02086 \};\par
02087 \par
02088 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02089     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02090     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02091     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02092     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02093     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02094     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02095     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02096     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02097     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02098     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02099     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36>\par
02100 {\cf17 struct }Templates36 \{\par
02101   {\cf17 typedef} TemplateSel<T1> Head;\par
02102   {\cf17 typedef} Templates35<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02103       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02104       T29, T30, T31, T32, T33, T34, T35, T36> Tail;\par
02105 \};\par
02106 \par
02107 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02108     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02109     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02110     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02111     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02112     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02113     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02114     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02115     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02116     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02117     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02118     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
02119     GTEST_TEMPLATE_ T37>\par
02120 {\cf17 struct }Templates37 \{\par
02121   {\cf17 typedef} TemplateSel<T1> Head;\par
02122   {\cf17 typedef} Templates36<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02123       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02124       T29, T30, T31, T32, T33, T34, T35, T36, T37> Tail;\par
02125 \};\par
02126 \par
02127 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02128     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02129     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02130     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02131     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02132     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02133     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02134     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02135     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02136     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02137     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02138     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
02139     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38>\par
02140 {\cf17 struct }Templates38 \{\par
02141   {\cf17 typedef} TemplateSel<T1> Head;\par
02142   {\cf17 typedef} Templates37<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02143       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02144       T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> Tail;\par
02145 \};\par
02146 \par
02147 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02148     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02149     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02150     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02151     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02152     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02153     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02154     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02155     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02156     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02157     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02158     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
02159     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39>\par
02160 {\cf17 struct }Templates39 \{\par
02161   {\cf17 typedef} TemplateSel<T1> Head;\par
02162   {\cf17 typedef} Templates38<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02163       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02164       T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Tail;\par
02165 \};\par
02166 \par
02167 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02168     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02169     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02170     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02171     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02172     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02173     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02174     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02175     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02176     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02177     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02178     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
02179     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
02180     GTEST_TEMPLATE_ T40>\par
02181 {\cf17 struct }Templates40 \{\par
02182   {\cf17 typedef} TemplateSel<T1> Head;\par
02183   {\cf17 typedef} Templates39<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02184       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02185       T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Tail;\par
02186 \};\par
02187 \par
02188 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02189     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02190     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02191     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02192     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02193     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02194     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02195     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02196     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02197     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02198     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02199     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
02200     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
02201     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41>\par
02202 {\cf17 struct }Templates41 \{\par
02203   {\cf17 typedef} TemplateSel<T1> Head;\par
02204   {\cf17 typedef} Templates40<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02205       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02206       T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41> Tail;\par
02207 \};\par
02208 \par
02209 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02210     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02211     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02212     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02213     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02214     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02215     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02216     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02217     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02218     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02219     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02220     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
02221     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
02222     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42>\par
02223 {\cf17 struct }Templates42 \{\par
02224   {\cf17 typedef} TemplateSel<T1> Head;\par
02225   {\cf17 typedef} Templates41<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02226       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02227       T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\par
02228       T42> Tail;\par
02229 \};\par
02230 \par
02231 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02232     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02233     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02234     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02235     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02236     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02237     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02238     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02239     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02240     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02241     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02242     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
02243     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
02244     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
02245     GTEST_TEMPLATE_ T43>\par
02246 {\cf17 struct }Templates43 \{\par
02247   {\cf17 typedef} TemplateSel<T1> Head;\par
02248   {\cf17 typedef} Templates42<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02249       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02250       T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\par
02251       T43> Tail;\par
02252 \};\par
02253 \par
02254 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02255     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02256     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02257     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02258     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02259     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02260     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02261     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02262     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02263     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02264     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02265     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
02266     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
02267     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
02268     GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44>\par
02269 {\cf17 struct }Templates44 \{\par
02270   {\cf17 typedef} TemplateSel<T1> Head;\par
02271   {\cf17 typedef} Templates43<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02272       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02273       T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\par
02274       T43, T44> Tail;\par
02275 \};\par
02276 \par
02277 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02278     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02279     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02280     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02281     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02282     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02283     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02284     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02285     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02286     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02287     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02288     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
02289     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
02290     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
02291     GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45>\par
02292 {\cf17 struct }Templates45 \{\par
02293   {\cf17 typedef} TemplateSel<T1> Head;\par
02294   {\cf17 typedef} Templates44<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02295       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02296       T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\par
02297       T43, T44, T45> Tail;\par
02298 \};\par
02299 \par
02300 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02301     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02302     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02303     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02304     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02305     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02306     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02307     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02308     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02309     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02310     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02311     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
02312     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
02313     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
02314     GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\par
02315     GTEST_TEMPLATE_ T46>\par
02316 {\cf17 struct }Templates46 \{\par
02317   {\cf17 typedef} TemplateSel<T1> Head;\par
02318   {\cf17 typedef} Templates45<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02319       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02320       T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\par
02321       T43, T44, T45, T46> Tail;\par
02322 \};\par
02323 \par
02324 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02325     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02326     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02327     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02328     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02329     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02330     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02331     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02332     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02333     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02334     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02335     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
02336     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
02337     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
02338     GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\par
02339     GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47>\par
02340 {\cf17 struct }Templates47 \{\par
02341   {\cf17 typedef} TemplateSel<T1> Head;\par
02342   {\cf17 typedef} Templates46<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02343       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02344       T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\par
02345       T43, T44, T45, T46, T47> Tail;\par
02346 \};\par
02347 \par
02348 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02349     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02350     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02351     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02352     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02353     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02354     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02355     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02356     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02357     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02358     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02359     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
02360     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
02361     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
02362     GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\par
02363     GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48>\par
02364 {\cf17 struct }Templates48 \{\par
02365   {\cf17 typedef} TemplateSel<T1> Head;\par
02366   {\cf17 typedef} Templates47<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02367       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02368       T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\par
02369       T43, T44, T45, T46, T47, T48> Tail;\par
02370 \};\par
02371 \par
02372 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02373     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02374     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02375     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02376     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02377     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02378     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02379     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02380     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02381     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02382     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02383     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
02384     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
02385     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
02386     GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\par
02387     GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48,\par
02388     GTEST_TEMPLATE_ T49>\par
02389 {\cf17 struct }Templates49 \{\par
02390   {\cf17 typedef} TemplateSel<T1> Head;\par
02391   {\cf17 typedef} Templates48<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02392       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02393       T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\par
02394       T43, T44, T45, T46, T47, T48, T49> Tail;\par
02395 \};\par
02396 \par
02397 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02398     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02399     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02400     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02401     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02402     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02403     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02404     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02405     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02406     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02407     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02408     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
02409     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
02410     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
02411     GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\par
02412     GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48,\par
02413     GTEST_TEMPLATE_ T49, GTEST_TEMPLATE_ T50>\par
02414 {\cf17 struct }Templates50 \{\par
02415   {\cf17 typedef} TemplateSel<T1> Head;\par
02416   {\cf17 typedef} Templates49<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02417       T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02418       T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\par
02419       T43, T44, T45, T46, T47, T48, T49, T50> Tail;\par
02420 \};\par
02421 \par
02422 \par
02423 {\cf20 // We don't want to require the users to write TemplatesN<...> directly,}\par
02424 {\cf20 // as that would require them to count the length.  Templates<...> is much}\par
02425 {\cf20 // easier to write, but generates horrible messages when there is a}\par
02426 {\cf20 // compiler error, as gcc insists on printing out each template}\par
02427 {\cf20 // argument, even if it has the default value (this means Templates<list>}\par
02428 {\cf20 // will appear as Templates<list, NoneT, NoneT, ..., NoneT> in the compiler}\par
02429 {\cf20 // errors).}\par
02430 {\cf20 //}\par
02431 {\cf20 // Our solution is to combine the best part of the two approaches: a}\par
02432 {\cf20 // user would write Templates<T1, ..., TN>, and Google Test will translate}\par
02433 {\cf20 // that to TemplatesN<T1, ..., TN> internally to make error messages}\par
02434 {\cf20 // readable.  The translation is done by the 'type' member of the}\par
02435 {\cf20 // Templates template.}\par
02436 {\cf17 template} <GTEST_TEMPLATE_ T1 = NoneT, GTEST_TEMPLATE_ T2 = NoneT,\par
02437     GTEST_TEMPLATE_ T3 = NoneT, GTEST_TEMPLATE_ T4 = NoneT,\par
02438     GTEST_TEMPLATE_ T5 = NoneT, GTEST_TEMPLATE_ T6 = NoneT,\par
02439     GTEST_TEMPLATE_ T7 = NoneT, GTEST_TEMPLATE_ T8 = NoneT,\par
02440     GTEST_TEMPLATE_ T9 = NoneT, GTEST_TEMPLATE_ T10 = NoneT,\par
02441     GTEST_TEMPLATE_ T11 = NoneT, GTEST_TEMPLATE_ T12 = NoneT,\par
02442     GTEST_TEMPLATE_ T13 = NoneT, GTEST_TEMPLATE_ T14 = NoneT,\par
02443     GTEST_TEMPLATE_ T15 = NoneT, GTEST_TEMPLATE_ T16 = NoneT,\par
02444     GTEST_TEMPLATE_ T17 = NoneT, GTEST_TEMPLATE_ T18 = NoneT,\par
02445     GTEST_TEMPLATE_ T19 = NoneT, GTEST_TEMPLATE_ T20 = NoneT,\par
02446     GTEST_TEMPLATE_ T21 = NoneT, GTEST_TEMPLATE_ T22 = NoneT,\par
02447     GTEST_TEMPLATE_ T23 = NoneT, GTEST_TEMPLATE_ T24 = NoneT,\par
02448     GTEST_TEMPLATE_ T25 = NoneT, GTEST_TEMPLATE_ T26 = NoneT,\par
02449     GTEST_TEMPLATE_ T27 = NoneT, GTEST_TEMPLATE_ T28 = NoneT,\par
02450     GTEST_TEMPLATE_ T29 = NoneT, GTEST_TEMPLATE_ T30 = NoneT,\par
02451     GTEST_TEMPLATE_ T31 = NoneT, GTEST_TEMPLATE_ T32 = NoneT,\par
02452     GTEST_TEMPLATE_ T33 = NoneT, GTEST_TEMPLATE_ T34 = NoneT,\par
02453     GTEST_TEMPLATE_ T35 = NoneT, GTEST_TEMPLATE_ T36 = NoneT,\par
02454     GTEST_TEMPLATE_ T37 = NoneT, GTEST_TEMPLATE_ T38 = NoneT,\par
02455     GTEST_TEMPLATE_ T39 = NoneT, GTEST_TEMPLATE_ T40 = NoneT,\par
02456     GTEST_TEMPLATE_ T41 = NoneT, GTEST_TEMPLATE_ T42 = NoneT,\par
02457     GTEST_TEMPLATE_ T43 = NoneT, GTEST_TEMPLATE_ T44 = NoneT,\par
02458     GTEST_TEMPLATE_ T45 = NoneT, GTEST_TEMPLATE_ T46 = NoneT,\par
02459     GTEST_TEMPLATE_ T47 = NoneT, GTEST_TEMPLATE_ T48 = NoneT,\par
02460     GTEST_TEMPLATE_ T49 = NoneT, GTEST_TEMPLATE_ T50 = NoneT>\par
02461 {\cf17 struct }Templates \{\par
02462   {\cf17 typedef} Templates50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02463       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
02464       T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\par
02465       T42, T43, T44, T45, T46, T47, T48, T49, T50> type;\par
02466 \};\par
02467 \par
02468 {\cf17 template} <>\par
02469 {\cf17 struct }Templates<NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02470     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02471     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02472     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02473     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02474     NoneT> \{\par
02475   {\cf17 typedef} Templates0 type;\par
02476 \};\par
02477 {\cf17 template} <GTEST_TEMPLATE_ T1>\par
02478 {\cf17 struct }Templates<T1, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02479     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02480     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02481     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02482     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02483     NoneT> \{\par
02484   {\cf17 typedef} Templates1<T1> type;\par
02485 \};\par
02486 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2>\par
02487 {\cf17 struct }Templates<T1, T2, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02488     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02489     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02490     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02491     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02492     NoneT> \{\par
02493   {\cf17 typedef} Templates2<T1, T2> type;\par
02494 \};\par
02495 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3>\par
02496 {\cf17 struct }Templates<T1, T2, T3, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02497     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02498     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02499     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02500     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02501   {\cf17 typedef} Templates3<T1, T2, T3> type;\par
02502 \};\par
02503 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02504     GTEST_TEMPLATE_ T4>\par
02505 {\cf17 struct }Templates<T1, T2, T3, T4, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02506     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02507     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02508     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02509     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02510   {\cf17 typedef} Templates4<T1, T2, T3, T4> type;\par
02511 \};\par
02512 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02513     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5>\par
02514 {\cf17 struct }Templates<T1, T2, T3, T4, T5, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02515     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02516     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02517     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02518     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02519   {\cf17 typedef} Templates5<T1, T2, T3, T4, T5> type;\par
02520 \};\par
02521 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02522     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6>\par
02523 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02524     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02525     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02526     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02527     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02528   {\cf17 typedef} Templates6<T1, T2, T3, T4, T5, T6> type;\par
02529 \};\par
02530 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02531     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02532     GTEST_TEMPLATE_ T7>\par
02533 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02534     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02535     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02536     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02537     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02538   {\cf17 typedef} Templates7<T1, T2, T3, T4, T5, T6, T7> type;\par
02539 \};\par
02540 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02541     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02542     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8>\par
02543 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, NoneT, NoneT, NoneT, NoneT,\par
02544     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02545     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02546     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02547     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02548   {\cf17 typedef} Templates8<T1, T2, T3, T4, T5, T6, T7, T8> type;\par
02549 \};\par
02550 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02551     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02552     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9>\par
02553 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, NoneT, NoneT, NoneT,\par
02554     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02555     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02556     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02557     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02558   {\cf17 typedef} Templates9<T1, T2, T3, T4, T5, T6, T7, T8, T9> type;\par
02559 \};\par
02560 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02561     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02562     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02563     GTEST_TEMPLATE_ T10>\par
02564 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, NoneT, NoneT, NoneT,\par
02565     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02566     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02567     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02568     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02569   {\cf17 typedef} Templates10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> type;\par
02570 \};\par
02571 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02572     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02573     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02574     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11>\par
02575 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, NoneT, NoneT,\par
02576     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02577     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02578     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02579     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02580   {\cf17 typedef} Templates11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> type;\par
02581 \};\par
02582 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02583     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02584     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02585     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12>\par
02586 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, NoneT,\par
02587     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02588     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02589     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02590     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02591   {\cf17 typedef} Templates12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> type;\par
02592 \};\par
02593 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02594     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02595     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02596     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02597     GTEST_TEMPLATE_ T13>\par
02598 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, NoneT,\par
02599     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02600     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02601     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02602     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02603   {\cf17 typedef} Templates13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
02604       T13> type;\par
02605 \};\par
02606 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02607     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02608     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02609     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02610     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14>\par
02611 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02612     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02613     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02614     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02615     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02616   {\cf17 typedef} Templates14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02617       T14> type;\par
02618 \};\par
02619 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02620     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02621     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02622     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02623     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15>\par
02624 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02625     T15, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02626     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02627     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02628     NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02629   {\cf17 typedef} Templates15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02630       T14, T15> type;\par
02631 \};\par
02632 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02633     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02634     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02635     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02636     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02637     GTEST_TEMPLATE_ T16>\par
02638 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02639     T15, T16, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02640     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02641     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02642     NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02643   {\cf17 typedef} Templates16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02644       T14, T15, T16> type;\par
02645 \};\par
02646 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02647     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02648     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02649     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02650     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02651     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17>\par
02652 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02653     T15, T16, T17, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02654     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02655     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02656     NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02657   {\cf17 typedef} Templates17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02658       T14, T15, T16, T17> type;\par
02659 \};\par
02660 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02661     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02662     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02663     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02664     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02665     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18>\par
02666 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02667     T15, T16, T17, T18, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02668     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02669     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02670     NoneT, NoneT, NoneT, NoneT> \{\par
02671   {\cf17 typedef} Templates18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02672       T14, T15, T16, T17, T18> type;\par
02673 \};\par
02674 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02675     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02676     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02677     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02678     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02679     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02680     GTEST_TEMPLATE_ T19>\par
02681 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02682     T15, T16, T17, T18, T19, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02683     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02684     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02685     NoneT, NoneT, NoneT, NoneT> \{\par
02686   {\cf17 typedef} Templates19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02687       T14, T15, T16, T17, T18, T19> type;\par
02688 \};\par
02689 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02690     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02691     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02692     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02693     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02694     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02695     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20>\par
02696 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02697     T15, T16, T17, T18, T19, T20, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02698     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02699     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02700     NoneT, NoneT, NoneT, NoneT> \{\par
02701   {\cf17 typedef} Templates20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02702       T14, T15, T16, T17, T18, T19, T20> type;\par
02703 \};\par
02704 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02705     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02706     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02707     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02708     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02709     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02710     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21>\par
02711 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02712     T15, T16, T17, T18, T19, T20, T21, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02713     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02714     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02715     NoneT, NoneT, NoneT, NoneT> \{\par
02716   {\cf17 typedef} Templates21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02717       T14, T15, T16, T17, T18, T19, T20, T21> type;\par
02718 \};\par
02719 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02720     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02721     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02722     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02723     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02724     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02725     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02726     GTEST_TEMPLATE_ T22>\par
02727 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02728     T15, T16, T17, T18, T19, T20, T21, T22, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02729     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02730     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02731     NoneT, NoneT, NoneT> \{\par
02732   {\cf17 typedef} Templates22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02733       T14, T15, T16, T17, T18, T19, T20, T21, T22> type;\par
02734 \};\par
02735 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02736     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02737     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02738     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02739     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02740     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02741     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02742     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23>\par
02743 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02744     T15, T16, T17, T18, T19, T20, T21, T22, T23, NoneT, NoneT, NoneT, NoneT,\par
02745     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02746     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02747     NoneT, NoneT, NoneT> \{\par
02748   {\cf17 typedef} Templates23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02749       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> type;\par
02750 \};\par
02751 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02752     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02753     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02754     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02755     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02756     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02757     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02758     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24>\par
02759 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02760     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, NoneT, NoneT, NoneT,\par
02761     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02762     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02763     NoneT, NoneT, NoneT> \{\par
02764   {\cf17 typedef} Templates24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02765       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> type;\par
02766 \};\par
02767 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02768     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02769     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02770     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02771     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02772     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02773     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02774     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02775     GTEST_TEMPLATE_ T25>\par
02776 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02777     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, NoneT, NoneT, NoneT,\par
02778     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02779     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02780     NoneT, NoneT> \{\par
02781   {\cf17 typedef} Templates25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02782       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> type;\par
02783 \};\par
02784 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02785     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02786     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02787     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02788     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02789     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02790     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02791     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02792     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26>\par
02793 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02794     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, NoneT, NoneT,\par
02795     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02796     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02797     NoneT, NoneT> \{\par
02798   {\cf17 typedef} Templates26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02799       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> type;\par
02800 \};\par
02801 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02802     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02803     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02804     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02805     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02806     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02807     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02808     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02809     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27>\par
02810 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02811     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, NoneT,\par
02812     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02813     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02814     NoneT, NoneT> \{\par
02815   {\cf17 typedef} Templates27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02816       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
02817       T27> type;\par
02818 \};\par
02819 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02820     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02821     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02822     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02823     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02824     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02825     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02826     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02827     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02828     GTEST_TEMPLATE_ T28>\par
02829 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02830     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
02831     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02832     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02833     NoneT, NoneT> \{\par
02834   {\cf17 typedef} Templates28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02835       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
02836       T28> type;\par
02837 \};\par
02838 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02839     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02840     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02841     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02842     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02843     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02844     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02845     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02846     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02847     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29>\par
02848 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02849     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
02850     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02851     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02852     NoneT> \{\par
02853   {\cf17 typedef} Templates29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02854       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
02855       T28, T29> type;\par
02856 \};\par
02857 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02858     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02859     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02860     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02861     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02862     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02863     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02864     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02865     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02866     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30>\par
02867 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02868     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
02869     T30, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02870     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02871   {\cf17 typedef} Templates30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02872       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
02873       T28, T29, T30> type;\par
02874 \};\par
02875 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02876     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02877     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02878     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02879     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02880     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02881     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02882     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02883     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02884     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02885     GTEST_TEMPLATE_ T31>\par
02886 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02887     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
02888     T30, T31, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02889     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02890   {\cf17 typedef} Templates31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02891       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
02892       T28, T29, T30, T31> type;\par
02893 \};\par
02894 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02895     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02896     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02897     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02898     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02899     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02900     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02901     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02902     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02903     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02904     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32>\par
02905 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02906     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
02907     T30, T31, T32, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02908     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02909   {\cf17 typedef} Templates32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02910       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
02911       T28, T29, T30, T31, T32> type;\par
02912 \};\par
02913 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02914     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02915     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02916     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02917     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02918     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02919     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02920     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02921     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02922     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02923     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33>\par
02924 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02925     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
02926     T30, T31, T32, T33, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02927     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02928   {\cf17 typedef} Templates33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02929       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
02930       T28, T29, T30, T31, T32, T33> type;\par
02931 \};\par
02932 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02933     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02934     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02935     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02936     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02937     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02938     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02939     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02940     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02941     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02942     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02943     GTEST_TEMPLATE_ T34>\par
02944 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02945     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
02946     T30, T31, T32, T33, T34, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02947     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02948   {\cf17 typedef} Templates34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02949       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
02950       T28, T29, T30, T31, T32, T33, T34> type;\par
02951 \};\par
02952 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02953     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02954     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02955     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02956     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02957     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02958     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02959     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02960     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02961     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02962     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02963     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35>\par
02964 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02965     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
02966     T30, T31, T32, T33, T34, T35, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02967     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02968   {\cf17 typedef} Templates35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02969       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
02970       T28, T29, T30, T31, T32, T33, T34, T35> type;\par
02971 \};\par
02972 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02973     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02974     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02975     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02976     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02977     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02978     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02979     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
02980     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
02981     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
02982     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
02983     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36>\par
02984 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
02985     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
02986     T30, T31, T32, T33, T34, T35, T36, NoneT, NoneT, NoneT, NoneT, NoneT,\par
02987     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
02988   {\cf17 typedef} Templates36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
02989       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
02990       T28, T29, T30, T31, T32, T33, T34, T35, T36> type;\par
02991 \};\par
02992 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
02993     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
02994     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
02995     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
02996     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
02997     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
02998     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
02999     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
03000     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
03001     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
03002     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
03003     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
03004     GTEST_TEMPLATE_ T37>\par
03005 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
03006     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
03007     T30, T31, T32, T33, T34, T35, T36, T37, NoneT, NoneT, NoneT, NoneT, NoneT,\par
03008     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
03009   {\cf17 typedef} Templates37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
03010       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
03011       T28, T29, T30, T31, T32, T33, T34, T35, T36, T37> type;\par
03012 \};\par
03013 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
03014     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
03015     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
03016     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
03017     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
03018     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
03019     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
03020     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
03021     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
03022     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
03023     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
03024     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
03025     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38>\par
03026 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
03027     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
03028     T30, T31, T32, T33, T34, T35, T36, T37, T38, NoneT, NoneT, NoneT, NoneT,\par
03029     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
03030   {\cf17 typedef} Templates38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
03031       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
03032       T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> type;\par
03033 \};\par
03034 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
03035     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
03036     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
03037     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
03038     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
03039     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
03040     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
03041     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
03042     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
03043     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
03044     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
03045     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
03046     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39>\par
03047 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
03048     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
03049     T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, NoneT, NoneT, NoneT,\par
03050     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
03051   {\cf17 typedef} Templates39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
03052       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
03053       T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> type;\par
03054 \};\par
03055 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
03056     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
03057     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
03058     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
03059     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
03060     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
03061     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
03062     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
03063     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
03064     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
03065     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
03066     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
03067     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
03068     GTEST_TEMPLATE_ T40>\par
03069 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
03070     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
03071     T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, NoneT, NoneT, NoneT,\par
03072     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
03073   {\cf17 typedef} Templates40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
03074       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
03075       T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> type;\par
03076 \};\par
03077 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
03078     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
03079     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
03080     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
03081     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
03082     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
03083     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
03084     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
03085     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
03086     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
03087     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
03088     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
03089     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
03090     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41>\par
03091 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
03092     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
03093     T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, NoneT, NoneT,\par
03094     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
03095   {\cf17 typedef} Templates41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
03096       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
03097       T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\par
03098       T41> type;\par
03099 \};\par
03100 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
03101     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
03102     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
03103     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
03104     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
03105     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
03106     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
03107     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
03108     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
03109     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
03110     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
03111     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
03112     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
03113     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42>\par
03114 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
03115     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
03116     T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, NoneT,\par
03117     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
03118   {\cf17 typedef} Templates42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
03119       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
03120       T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\par
03121       T42> type;\par
03122 \};\par
03123 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
03124     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
03125     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
03126     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
03127     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
03128     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
03129     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
03130     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
03131     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
03132     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
03133     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
03134     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
03135     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
03136     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
03137     GTEST_TEMPLATE_ T43>\par
03138 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
03139     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
03140     T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
03141     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
03142   {\cf17 typedef} Templates43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
03143       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
03144       T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\par
03145       T42, T43> type;\par
03146 \};\par
03147 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
03148     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
03149     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
03150     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
03151     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
03152     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
03153     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
03154     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
03155     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
03156     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
03157     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
03158     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
03159     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
03160     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
03161     GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44>\par
03162 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
03163     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
03164     T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\par
03165     NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
03166   {\cf17 typedef} Templates44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
03167       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
03168       T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\par
03169       T42, T43, T44> type;\par
03170 \};\par
03171 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
03172     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
03173     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
03174     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
03175     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
03176     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
03177     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
03178     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
03179     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
03180     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
03181     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
03182     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
03183     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
03184     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
03185     GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45>\par
03186 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
03187     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
03188     T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\par
03189     T45, NoneT, NoneT, NoneT, NoneT, NoneT> \{\par
03190   {\cf17 typedef} Templates45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
03191       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
03192       T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\par
03193       T42, T43, T44, T45> type;\par
03194 \};\par
03195 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
03196     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
03197     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
03198     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
03199     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
03200     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
03201     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
03202     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
03203     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
03204     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
03205     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
03206     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
03207     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
03208     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
03209     GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\par
03210     GTEST_TEMPLATE_ T46>\par
03211 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
03212     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
03213     T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\par
03214     T45, T46, NoneT, NoneT, NoneT, NoneT> \{\par
03215   {\cf17 typedef} Templates46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
03216       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
03217       T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\par
03218       T42, T43, T44, T45, T46> type;\par
03219 \};\par
03220 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
03221     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
03222     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
03223     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
03224     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
03225     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
03226     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
03227     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
03228     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
03229     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
03230     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
03231     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
03232     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
03233     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
03234     GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\par
03235     GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47>\par
03236 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
03237     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
03238     T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\par
03239     T45, T46, T47, NoneT, NoneT, NoneT> \{\par
03240   {\cf17 typedef} Templates47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
03241       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
03242       T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\par
03243       T42, T43, T44, T45, T46, T47> type;\par
03244 \};\par
03245 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
03246     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
03247     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
03248     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
03249     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
03250     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
03251     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
03252     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
03253     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
03254     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
03255     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
03256     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
03257     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
03258     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
03259     GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\par
03260     GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48>\par
03261 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
03262     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
03263     T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\par
03264     T45, T46, T47, T48, NoneT, NoneT> \{\par
03265   {\cf17 typedef} Templates48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
03266       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
03267       T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\par
03268       T42, T43, T44, T45, T46, T47, T48> type;\par
03269 \};\par
03270 {\cf17 template} <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\par
03271     GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\par
03272     GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\par
03273     GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\par
03274     GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\par
03275     GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\par
03276     GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\par
03277     GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\par
03278     GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\par
03279     GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\par
03280     GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\par
03281     GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\par
03282     GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\par
03283     GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\par
03284     GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\par
03285     GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48,\par
03286     GTEST_TEMPLATE_ T49>\par
03287 {\cf17 struct }Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\par
03288     T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\par
03289     T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\par
03290     T45, T46, T47, T48, T49, NoneT> \{\par
03291   {\cf17 typedef} Templates49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
03292       T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\par
03293       T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\par
03294       T42, T43, T44, T45, T46, T47, T48, T49> type;\par
03295 \};\par
03296 \par
03297 {\cf20 // The TypeList template makes it possible to use either a single type}\par
03298 {\cf20 // or a Types<...> list in TYPED_TEST_CASE() and}\par
03299 {\cf20 // INSTANTIATE_TYPED_TEST_CASE_P().}\par
03300 \par
03301 {\cf17 template} <{\cf17 typename} T>\par
03302 {\cf17 struct }TypeList \{\par
03303   {\cf17 typedef} Types1<T> type;\par
03304 \};\par
03305 \par
03306 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2, {\cf17 typename} T3, {\cf17 typename} T4, {\cf17 typename} T5,\par
03307     {\cf17 typename} T6, {\cf17 typename} T7, {\cf17 typename} T8, {\cf17 typename} T9, {\cf17 typename} T10,\par
03308     {\cf17 typename} T11, {\cf17 typename} T12, {\cf17 typename} T13, {\cf17 typename} T14, {\cf17 typename} T15,\par
03309     {\cf17 typename} T16, {\cf17 typename} T17, {\cf17 typename} T18, {\cf17 typename} T19, {\cf17 typename} T20,\par
03310     {\cf17 typename} T21, {\cf17 typename} T22, {\cf17 typename} T23, {\cf17 typename} T24, {\cf17 typename} T25,\par
03311     {\cf17 typename} T26, {\cf17 typename} T27, {\cf17 typename} T28, {\cf17 typename} T29, {\cf17 typename} T30,\par
03312     {\cf17 typename} T31, {\cf17 typename} T32, {\cf17 typename} T33, {\cf17 typename} T34, {\cf17 typename} T35,\par
03313     {\cf17 typename} T36, {\cf17 typename} T37, {\cf17 typename} T38, {\cf17 typename} T39, {\cf17 typename} T40,\par
03314     {\cf17 typename} T41, {\cf17 typename} T42, {\cf17 typename} T43, {\cf17 typename} T44, {\cf17 typename} T45,\par
03315     {\cf17 typename} T46, {\cf17 typename} T47, {\cf17 typename} T48, {\cf17 typename} T49, {\cf17 typename} T50>\par
03316 {\cf17 struct }TypeList<Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\par
03317     T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\par
03318     T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\par
03319     T44, T45, T46, T47, T48, T49, T50> > \{\par
03320   {\cf17 typedef} {\cf17 typename} Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\par
03321       T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\par
03322       T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\par
03323       T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>::type type;\par
03324 \};\par
03325 \par
03326 {\cf21 #endif  }{\cf20 // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P}\par
03327 \par
03328 \}  {\cf20 // namespace internal}\par
03329 \}  {\cf20 // namespace testing}\par
03330 \par
03331 {\cf21 #endif  }{\cf20 // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/src/gtest-all.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-all.cc}
{\xe \v gtest/src/gtest-all.cc}
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/gtest.h"}\par
{\f2 #include "src/gtest.cc"}\par
{\f2 #include "src/gtest-death-test.cc"}\par
{\f2 #include "src/gtest-filepath.cc"}\par
{\f2 #include "src/gtest-port.cc"}\par
{\f2 #include "src/gtest-printers.cc"}\par
{\f2 #include "src/gtest-test-part.cc"}\par
{\f2 #include "src/gtest-typed-test.cc"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-all.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-all.cc}
{\xe \v gtest/src/gtest-all.cc}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2008, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: mheule@google.com (Markus Heule)}\par
00031 {\cf20 //}\par
00032 {\cf20 // Google C++ Testing Framework (Google Test)}\par
00033 {\cf20 //}\par
00034 {\cf20 // Sometimes it's desirable to build Google Test by compiling a single file.}\par
00035 {\cf20 // This file serves this purpose.}\par
00036 \par
00037 {\cf20 // This line ensures that gtest.h can be compiled on its own, even}\par
00038 {\cf20 // when it's fused.}\par
00039 {\cf21 #include "gtest/gtest.h"}\par
00040 \par
00041 {\cf20 // The following lines pull in the real gtest *.cc files.}\par
00042 {\cf21 #include "src/gtest.cc"}\par
00043 {\cf21 #include "src/gtest-death-test.cc"}\par
00044 {\cf21 #include "src/gtest-filepath.cc"}\par
00045 {\cf21 #include "src/gtest-port.cc"}\par
00046 {\cf21 #include "src/gtest-printers.cc"}\par
00047 {\cf21 #include "src/gtest-test-part.cc"}\par
00048 {\cf21 #include "src/gtest-typed-test.cc"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/src/gtest-death-test.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-death-test.cc}
{\xe \v gtest/src/gtest-death-test.cc}
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/gtest-death-test.h"}\par
{\f2 #include "gtest/internal/gtest-port.h"}\par
{\f2 #include "gtest/internal/custom/gtest.h"}\par
{\f2 #include "gtest/gtest-message.h"}\par
{\f2 #include "gtest/internal/gtest-string.h"}\par
{\f2 #include "src/gtest-internal-inl.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_IMPLEMENTATION_}\~ 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_string_} (death_test_style, internal::StringFromGTestEnv("death_test_style", kDefaultDeathTestStyle), "Indicates how to run a death test in a forked child process: " "\\"threadsafe\\" (child process re-executes the test binary " "from the beginning, running only the specific death test) or " "\\"fast\\" (child process runs the death test immediately " "after forking).")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_bool_} (death_test_use_fork, internal::BoolFromGTestEnv("death_test_use_fork", false), "Instructs to use fork()/_exit() instead of clone() in death tests. " "Ignored and always uses fork() on POSIX systems where clone() is not " "implemented. Useful when running under valgrind or similar tools if " "those do not support clone(). Valgrind 3.3.1 will just fail if " "it sees an unsupported combination of clone() flags. " "It is not recommended to use this flag w/o valgrind though it will " "work in 99% of the cases. Once valgrind is fixed, this flag will " "most likely be removed.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::internal::GTEST_DEFINE_string_} (internal_run_death_test, "", "Indicates the file, line number, temporal index of " "the single death test to run, and a file descriptor to " "which a success code may be sent, all separated by " "the '|' characters.  This flag is specified if and only if the current " "process is a sub-process launched for running a thread-safe " "death test.  FOR INTERNAL USE ONLY.")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v GTEST_IMPLEMENTATION_\:gtest-death-test.cc}
{\xe \v gtest-death-test.cc\:GTEST_IMPLEMENTATION_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_IMPLEMENTATION_\~ 1}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-death-test.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 75}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-death-test.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-death-test.cc}
{\xe \v gtest/src/gtest-death-test.cc}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2005, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: wan@google.com (Zhanyong Wan), vladl@google.com (Vlad Losev)}\par
00031 {\cf20 //}\par
00032 {\cf20 // This file implements death tests.}\par
00033 \par
00034 {\cf21 #include "gtest/gtest-death-test.h"}\par
00035 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00036 {\cf21 #include "gtest/internal/custom/gtest.h"}\par
00037 \par
00038 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
00039 \par
00040 {\cf21 # if GTEST_OS_MAC}\par
00041 {\cf21 #  include <crt_externs.h>}\par
00042 {\cf21 # endif  }{\cf20 // GTEST_OS_MAC}\par
00043 \par
00044 {\cf21 # include <errno.h>}\par
00045 {\cf21 # include <fcntl.h>}\par
00046 {\cf21 # include <limits.h>}\par
00047 \par
00048 {\cf21 # if GTEST_OS_LINUX}\par
00049 {\cf21 #  include <signal.h>}\par
00050 {\cf21 # endif  }{\cf20 // GTEST_OS_LINUX}\par
00051 \par
00052 {\cf21 # include <stdarg.h>}\par
00053 \par
00054 {\cf21 # if GTEST_OS_WINDOWS}\par
00055 {\cf21 #  include <windows.h>}\par
00056 {\cf21 # else}\par
00057 {\cf21 #  include <sys/mman.h>}\par
00058 {\cf21 #  include <sys/wait.h>}\par
00059 {\cf21 # endif  }{\cf20 // GTEST_OS_WINDOWS}\par
00060 \par
00061 {\cf21 # if GTEST_OS_QNX}\par
00062 {\cf21 #  include <spawn.h>}\par
00063 {\cf21 # endif  }{\cf20 // GTEST_OS_QNX}\par
00064 \par
00065 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
00066 \par
00067 {\cf21 #include "gtest/gtest-message.h"}\par
00068 {\cf21 #include "gtest/internal/gtest-string.h"}\par
00069 \par
00070 {\cf20 // Indicates that this translation unit is part of Google Test's}\par
00071 {\cf20 // implementation.  It must come before gtest-internal-inl.h is}\par
00072 {\cf20 // included, or there will be a compiler error.  This trick exists to}\par
00073 {\cf20 // prevent the accidental inclusion of gtest-internal-inl.h in the}\par
00074 {\cf20 // user's code.}\par
00075 {\cf21 #define GTEST_IMPLEMENTATION_ 1}\par
00076 {\cf21 #include "src/gtest-internal-inl.h"}\par
00077 {\cf21 #undef GTEST_IMPLEMENTATION_}\par
00078 \par
00079 {\cf17 namespace }testing \{\par
00080 \par
00081 {\cf20 // Constants.}\par
00082 \par
00083 {\cf20 // The default death test style.}\par
00084 {\cf17 static} {\cf17 const} {\cf18 char} kDefaultDeathTestStyle[] = {\cf22 "fast"};\par
00085 \par
00086 GTEST_DEFINE_string_(\par
00087     death_test_style,\par
00088     internal::StringFromGTestEnv({\cf22 "death_test_style"}, kDefaultDeathTestStyle),\par
00089     {\cf22 "Indicates how to run a death test in a forked child process: "}\par
00090     {\cf22 "\\"threadsafe\\" (child process re-executes the test binary "}\par
00091     {\cf22 "from the beginning, running only the specific death test) or "}\par
00092     {\cf22 "\\"fast\\" (child process runs the death test immediately "}\par
00093     {\cf22 "after forking)."});\par
00094 \par
00095 GTEST_DEFINE_bool_(\par
00096     death_test_use_fork,\par
00097     internal::BoolFromGTestEnv({\cf22 "death_test_use_fork"}, {\cf17 false}),\par
00098     {\cf22 "Instructs to use fork()/_exit() instead of clone() in death tests. "}\par
00099     {\cf22 "Ignored and always uses fork() on POSIX systems where clone() is not "}\par
00100     {\cf22 "implemented. Useful when running under valgrind or similar tools if "}\par
00101     {\cf22 "those do not support clone(). Valgrind 3.3.1 will just fail if "}\par
00102     {\cf22 "it sees an unsupported combination of clone() flags. "}\par
00103     {\cf22 "It is not recommended to use this flag w/o valgrind though it will "}\par
00104     {\cf22 "work in 99% of the cases. Once valgrind is fixed, this flag will "}\par
00105     {\cf22 "most likely be removed."});\par
00106 \par
00107 {\cf17 namespace }internal \{\par
00108 GTEST_DEFINE_string_(\par
00109     internal_run_death_test, {\cf22 ""},\par
00110     {\cf22 "Indicates the file, line number, temporal index of "}\par
00111     {\cf22 "the single death test to run, and a file descriptor to "}\par
00112     {\cf22 "which a success code may be sent, all separated by "}\par
00113     {\cf22 "the '|' characters.  This flag is specified if and only if the current "}\par
00114     {\cf22 "process is a sub-process launched for running a thread-safe "}\par
00115     {\cf22 "death test.  FOR INTERNAL USE ONLY."});\par
00116 \}  {\cf20 // namespace internal}\par
00117 \par
00118 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
00119 \par
00120 {\cf17 namespace }internal \{\par
00121 \par
00122 {\cf20 // Valid only for fast death tests. Indicates the code is running in the}\par
00123 {\cf20 // child process of a fast style death test.}\par
00124 {\cf21 # if !GTEST_OS_WINDOWS}\par
00125 {\cf17 static} {\cf18 bool} g_in_fast_death_test_child = {\cf17 false};\par
00126 {\cf21 # endif}\par
00127 \par
00128 {\cf20 // Returns a Boolean value indicating whether the caller is currently}\par
00129 {\cf20 // executing in the context of the death test child process.  Tools such as}\par
00130 {\cf20 // Valgrind heap checkers may need this to modify their behavior in death}\par
00131 {\cf20 // tests.  IMPORTANT: This is an internal utility.  Using it may break the}\par
00132 {\cf20 // implementation of death tests.  User code MUST NOT use it.}\par
00133 {\cf18 bool} InDeathTestChild() \{\par
00134 {\cf21 # if GTEST_OS_WINDOWS}\par
00135 \par
00136   {\cf20 // On Windows, death tests are thread-safe regardless of the value of the}\par
00137   {\cf20 // death_test_style flag.}\par
00138   {\cf19 return} !GTEST_FLAG(internal_run_death_test).empty();\par
00139 \par
00140 {\cf21 # else}\par
00141 \par
00142   {\cf19 if} (GTEST_FLAG(death_test_style) == {\cf22 "threadsafe"})\par
00143     {\cf19 return} !GTEST_FLAG(internal_run_death_test).empty();\par
00144   {\cf19 else}\par
00145     {\cf19 return} g_in_fast_death_test_child;\par
00146 {\cf21 #endif}\par
00147 \}\par
00148 \par
00149 \}  {\cf20 // namespace internal}\par
00150 \par
00151 {\cf20 // ExitedWithCode constructor.}\par
00152 ExitedWithCode::ExitedWithCode({\cf18 int} exit_code) : exit_code_(exit_code) \{\par
00153 \}\par
00154 \par
00155 {\cf20 // ExitedWithCode function-call operator.}\par
00156 {\cf18 bool} ExitedWithCode::operator()({\cf18 int} exit_status){\cf17  const }\{\par
00157 {\cf21 # if GTEST_OS_WINDOWS}\par
00158 \par
00159   {\cf19 return} exit_status == exit_code_;\par
00160 \par
00161 {\cf21 # else}\par
00162 \par
00163   {\cf19 return} WIFEXITED(exit_status) && WEXITSTATUS(exit_status) == exit_code_;\par
00164 \par
00165 {\cf21 # endif  }{\cf20 // GTEST_OS_WINDOWS}\par
00166 \}\par
00167 \par
00168 {\cf21 # if !GTEST_OS_WINDOWS}\par
00169 {\cf20 // KilledBySignal constructor.}\par
00170 KilledBySignal::KilledBySignal({\cf18 int} signum) : signum_(signum) \{\par
00171 \}\par
00172 \par
00173 {\cf20 // KilledBySignal function-call operator.}\par
00174 {\cf18 bool} KilledBySignal::operator()({\cf18 int} exit_status){\cf17  const }\{\par
00175 {\cf21 #  if defined(GTEST_KILLED_BY_SIGNAL_OVERRIDE_)}\par
00176   \{\par
00177     {\cf18 bool} result;\par
00178     {\cf19 if} (GTEST_KILLED_BY_SIGNAL_OVERRIDE_(signum_, exit_status, &result)) \{\par
00179       {\cf19 return} result;\par
00180     \}\par
00181   \}\par
00182 {\cf21 #  endif  }{\cf20 // defined(GTEST_KILLED_BY_SIGNAL_OVERRIDE_)}\par
00183   {\cf19 return} WIFSIGNALED(exit_status) && WTERMSIG(exit_status) == signum_;\par
00184 \}\par
00185 {\cf21 # endif  }{\cf20 // !GTEST_OS_WINDOWS}\par
00186 \par
00187 {\cf17 namespace }internal \{\par
00188 \par
00189 {\cf20 // Utilities needed for death tests.}\par
00190 \par
00191 {\cf20 // Generates a textual description of a given exit code, in the format}\par
00192 {\cf20 // specified by wait(2).}\par
00193 {\cf17 static} std::string ExitSummary({\cf18 int} exit_code) \{\par
00194   Message m;\par
00195 \par
00196 {\cf21 # if GTEST_OS_WINDOWS}\par
00197 \par
00198   m << {\cf22 "Exited with exit status "} << exit_code;\par
00199 \par
00200 {\cf21 # else}\par
00201 \par
00202   {\cf19 if} (WIFEXITED(exit_code)) \{\par
00203     m << {\cf22 "Exited with exit status "} << WEXITSTATUS(exit_code);\par
00204   \} {\cf19 else} {\cf19 if} (WIFSIGNALED(exit_code)) \{\par
00205     m << {\cf22 "Terminated by signal "} << WTERMSIG(exit_code);\par
00206   \}\par
00207 {\cf21 #  ifdef WCOREDUMP}\par
00208   {\cf19 if} (WCOREDUMP(exit_code)) \{\par
00209     m << {\cf22 " (core dumped)"};\par
00210   \}\par
00211 {\cf21 #  endif}\par
00212 {\cf21 # endif  }{\cf20 // GTEST_OS_WINDOWS}\par
00213 \par
00214   {\cf19 return} m.GetString();\par
00215 \}\par
00216 \par
00217 {\cf20 // Returns true if exit_status describes a process that was terminated}\par
00218 {\cf20 // by a signal, or exited normally with a nonzero exit code.}\par
00219 {\cf18 bool} ExitedUnsuccessfully({\cf18 int} exit_status) \{\par
00220   {\cf19 return} !ExitedWithCode(0)(exit_status);\par
00221 \}\par
00222 \par
00223 {\cf21 # if !GTEST_OS_WINDOWS}\par
00224 {\cf20 // Generates a textual failure message when a death test finds more than}\par
00225 {\cf20 // one thread running, or cannot determine the number of threads, prior}\par
00226 {\cf20 // to executing the given statement.  It is the responsibility of the}\par
00227 {\cf20 // caller not to pass a thread_count of 1.}\par
00228 {\cf17 static} std::string DeathTestThreadWarning({\cf18 size_t} thread_count) \{\par
00229   Message msg;\par
00230   msg << {\cf22 "Death tests use fork(), which is unsafe particularly"}\par
00231       << {\cf22 " in a threaded context. For this test, "} << GTEST_NAME_ << {\cf22 " "};\par
00232   {\cf19 if} (thread_count == 0)\par
00233     msg << {\cf22 "couldn't detect the number of threads."};\par
00234   {\cf19 else}\par
00235     msg << {\cf22 "detected "} << thread_count << {\cf22 " threads."};\par
00236   {\cf19 return} msg.GetString();\par
00237 \}\par
00238 {\cf21 # endif  }{\cf20 // !GTEST_OS_WINDOWS}\par
00239 \par
00240 {\cf20 // Flag characters for reporting a death test that did not die.}\par
00241 {\cf17 static} {\cf17 const} {\cf18 char} kDeathTestLived = {\cf23 'L'};\par
00242 {\cf17 static} {\cf17 const} {\cf18 char} kDeathTestReturned = {\cf23 'R'};\par
00243 {\cf17 static} {\cf17 const} {\cf18 char} kDeathTestThrew = {\cf23 'T'};\par
00244 {\cf17 static} {\cf17 const} {\cf18 char} kDeathTestInternalError = {\cf23 'I'};\par
00245 \par
00246 {\cf20 // An enumeration describing all of the possible ways that a death test can}\par
00247 {\cf20 // conclude.  DIED means that the process died while executing the test}\par
00248 {\cf20 // code; LIVED means that process lived beyond the end of the test code;}\par
00249 {\cf20 // RETURNED means that the test statement attempted to execute a return}\par
00250 {\cf20 // statement, which is not allowed; THREW means that the test statement}\par
00251 {\cf20 // returned control by throwing an exception.  IN_PROGRESS means the test}\par
00252 {\cf20 // has not yet concluded.}\par
00253 {\cf20 // TODO(vladl@google.com): Unify names and possibly values for}\par
00254 {\cf20 // AbortReason, DeathTestOutcome, and flag characters above.}\par
00255 {\cf17 enum} DeathTestOutcome \{ IN_PROGRESS, DIED, LIVED, RETURNED, THREW \};\par
00256 \par
00257 {\cf20 // Routine for aborting the program which is safe to call from an}\par
00258 {\cf20 // exec-style death test child process, in which case the error}\par
00259 {\cf20 // message is propagated back to the parent process.  Otherwise, the}\par
00260 {\cf20 // message is simply printed to stderr.  In either case, the program}\par
00261 {\cf20 // then exits with status 1.}\par
00262 {\cf18 void} DeathTestAbort({\cf17 const} std::string& message) \{\par
00263   {\cf20 // On a POSIX system, this function may be called from a threadsafe-style}\par
00264   {\cf20 // death test child process, which operates on a very small stack.  Use}\par
00265   {\cf20 // the heap for any additional non-minuscule memory requirements.}\par
00266   {\cf17 const} InternalRunDeathTestFlag* {\cf17 const} flag =\par
00267       GetUnitTestImpl()->internal_run_death_test_flag();\par
00268   {\cf19 if} (flag != NULL) \{\par
00269     FILE* parent = posix::FDOpen(flag->write_fd(), {\cf22 "w"});\par
00270     fputc(kDeathTestInternalError, parent);\par
00271     fprintf(parent, {\cf22 "%s"}, message.c_str());\par
00272     fflush(parent);\par
00273     _exit(1);\par
00274   \} {\cf19 else} \{\par
00275     fprintf(stderr, {\cf22 "%s"}, message.c_str());\par
00276     fflush(stderr);\par
00277     posix::Abort();\par
00278   \}\par
00279 \}\par
00280 \par
00281 {\cf20 // A replacement for CHECK that calls DeathTestAbort if the assertion}\par
00282 {\cf20 // fails.}\par
00283 {\cf21 # define GTEST_DEATH_TEST_CHECK_(expression) \\}\par
00284 {\cf21   do \{ \\}\par
00285 {\cf21     if (!::testing::internal::IsTrue(expression)) \{ \\}\par
00286 {\cf21       DeathTestAbort( \\}\par
00287 {\cf21           ::std::string("CHECK failed: File "}) + __FILE__ +  ", line " \\\par
00288           + ::testing::internal::StreamableToString(__LINE__) + ": " \\\par
00289           + #expression); \\\par
00290     \} \\\par
00291   \} while (::testing::internal::AlwaysFalse())\par
00292 \par
00293 {\cf20 // This macro is similar to GTEST_DEATH_TEST_CHECK_, but it is meant for}\par
00294 {\cf20 // evaluating any system call that fulfills two conditions: it must return}\par
00295 {\cf20 // -1 on failure, and set errno to EINTR when it is interrupted and}\par
00296 {\cf20 // should be tried again.  The macro expands to a loop that repeatedly}\par
00297 {\cf20 // evaluates the expression as long as it evaluates to -1 and sets}\par
00298 {\cf20 // errno to EINTR.  If the expression evaluates to -1 but errno is}\par
00299 {\cf20 // something other than EINTR, DeathTestAbort is called.}\par
00300 {\cf21 # define GTEST_DEATH_TEST_CHECK_SYSCALL_(expression) \\}\par
00301 {\cf21   do \{ \\}\par
00302 {\cf21     int gtest_retval; \\}\par
00303 {\cf21     do \{ \\}\par
00304 {\cf21       gtest_retval = (expression); \\}\par
00305 {\cf21     \} while (gtest_retval == -1 && errno == EINTR); \\}\par
00306 {\cf21     if (gtest_retval == -1) \{ \\}\par
00307 {\cf21       DeathTestAbort( \\}\par
00308 {\cf21           ::std::string("CHECK failed: File "}) + __FILE__ + ", line " \\\par
00309           + ::testing::internal::StreamableToString(__LINE__) + ": " \\\par
00310           + #expression + " != -1"); \\\par
00311     \} \\\par
00312   \} while (::testing::internal::AlwaysFalse())\par
00313 \par
00314 {\cf20 // Returns the message describing the last system error in errno.}\par
00315 std::string GetLastErrnoDescription() \{\par
00316     {\cf19 return} errno == 0 ? {\cf22 ""} : posix::StrError(errno);\par
00317 \}\par
00318 \par
00319 {\cf20 // This is called from a death test parent process to read a failure}\par
00320 {\cf20 // message from the death test child process and log it with the FATAL}\par
00321 {\cf20 // severity. On Windows, the message is read from a pipe handle. On other}\par
00322 {\cf20 // platforms, it is read from a file descriptor.}\par
00323 {\cf17 static} {\cf18 void} FailFromInternalError({\cf18 int} fd) \{\par
00324   Message error;\par
00325   {\cf18 char} buffer[256];\par
00326   {\cf18 int} num_read;\par
00327 \par
00328   {\cf19 do} \{\par
00329     {\cf19 while} ((num_read = posix::Read(fd, buffer, 255)) > 0) \{\par
00330       buffer[num_read] = {\cf23 '\\0'};\par
00331       error << buffer;\par
00332     \}\par
00333   \} {\cf19 while} (num_read == -1 && errno == EINTR);\par
00334 \par
00335   {\cf19 if} (num_read == 0) \{\par
00336     GTEST_LOG_(FATAL) << error.GetString();\par
00337   \} {\cf19 else} \{\par
00338     {\cf17 const} {\cf18 int} last_error = errno;\par
00339     GTEST_LOG_(FATAL) << {\cf22 "Error while reading death test internal: "}\par
00340                       << GetLastErrnoDescription() << {\cf22 " ["} << last_error << {\cf22 "]"};\par
00341   \}\par
00342 \}\par
00343 \par
00344 {\cf20 // Death test constructor.  Increments the running death test count}\par
00345 {\cf20 // for the current test.}\par
00346 DeathTest::DeathTest() \{\par
00347   TestInfo* {\cf17 const} info = GetUnitTestImpl()->current_test_info();\par
00348   {\cf19 if} (info == NULL) \{\par
00349     DeathTestAbort({\cf22 "Cannot run a death test outside of a TEST or "}\par
00350                    {\cf22 "TEST_F construct"});\par
00351   \}\par
00352 \}\par
00353 \par
00354 {\cf20 // Creates and returns a death test by dispatching to the current}\par
00355 {\cf20 // death test factory.}\par
00356 {\cf18 bool} DeathTest::Create({\cf17 const} {\cf18 char}* statement, {\cf17 const} RE* regex,\par
00357                        {\cf17 const} {\cf18 char}* file, {\cf18 int} line, DeathTest** test) \{\par
00358   {\cf19 return} GetUnitTestImpl()->death_test_factory()->Create(\par
00359       statement, regex, file, line, test);\par
00360 \}\par
00361 \par
00362 {\cf17 const} {\cf18 char}* DeathTest::LastMessage() \{\par
00363   {\cf19 return} last_death_test_message_.c_str();\par
00364 \}\par
00365 \par
00366 {\cf18 void} DeathTest::set_last_death_test_message({\cf17 const} std::string& message) \{\par
00367   last_death_test_message_ = message;\par
00368 \}\par
00369 \par
00370 std::string DeathTest::last_death_test_message_;\par
00371 \par
00372 {\cf20 // Provides cross platform implementation for some death functionality.}\par
00373 {\cf17 class }DeathTestImpl : {\cf17 public} DeathTest \{\par
00374  {\cf17 protected}:\par
00375   DeathTestImpl({\cf17 const} {\cf18 char}* a_statement, {\cf17 const} RE* a_regex)\par
00376       : statement_(a_statement),\par
00377         regex_(a_regex),\par
00378         spawned_(false),\par
00379         status_(-1),\par
00380         outcome_(IN_PROGRESS),\par
00381         read_fd_(-1),\par
00382         write_fd_(-1) \{\}\par
00383 \par
00384   {\cf20 // read_fd_ is expected to be closed and cleared by a derived class.}\par
00385   ~DeathTestImpl() \{ GTEST_DEATH_TEST_CHECK_(read_fd_ == -1); \}\par
00386 \par
00387   {\cf18 void} Abort(AbortReason reason);\par
00388   {\cf17 virtual} {\cf18 bool} Passed({\cf18 bool} status_ok);\par
00389 \par
00390   {\cf17 const} {\cf18 char}* statement(){\cf17  const }\{ {\cf19 return} statement_; \}\par
00391   {\cf17 const} RE* regex(){\cf17  const }\{ {\cf19 return} regex_; \}\par
00392   {\cf18 bool} spawned(){\cf17  const }\{ {\cf19 return} spawned_; \}\par
00393   {\cf18 void} set_spawned({\cf18 bool} is_spawned) \{ spawned_ = is_spawned; \}\par
00394   {\cf18 int} status(){\cf17  const }\{ {\cf19 return} status_; \}\par
00395   {\cf18 void} set_status({\cf18 int} a_status) \{ status_ = a_status; \}\par
00396   DeathTestOutcome outcome(){\cf17  const }\{ {\cf19 return} outcome_; \}\par
00397   {\cf18 void} set_outcome(DeathTestOutcome an_outcome) \{ outcome_ = an_outcome; \}\par
00398   {\cf18 int} read_fd(){\cf17  const }\{ {\cf19 return} read_fd_; \}\par
00399   {\cf18 void} set_read_fd({\cf18 int} fd) \{ read_fd_ = fd; \}\par
00400   {\cf18 int} write_fd(){\cf17  const }\{ {\cf19 return} write_fd_; \}\par
00401   {\cf18 void} set_write_fd({\cf18 int} fd) \{ write_fd_ = fd; \}\par
00402 \par
00403   {\cf20 // Called in the parent process only. Reads the result code of the death}\par
00404   {\cf20 // test child process via a pipe, interprets it to set the outcome_}\par
00405   {\cf20 // member, and closes read_fd_.  Outputs diagnostics and terminates in}\par
00406   {\cf20 // case of unexpected codes.}\par
00407   {\cf18 void} ReadAndInterpretStatusByte();\par
00408 \par
00409  {\cf17 private}:\par
00410   {\cf20 // The textual content of the code this object is testing.  This class}\par
00411   {\cf20 // doesn't own this string and should not attempt to delete it.}\par
00412   {\cf17 const} {\cf18 char}* {\cf17 const} statement_;\par
00413   {\cf20 // The regular expression which test output must match.  DeathTestImpl}\par
00414   {\cf20 // doesn't own this object and should not attempt to delete it.}\par
00415   {\cf17 const} RE* {\cf17 const} regex_;\par
00416   {\cf20 // True if the death test child process has been successfully spawned.}\par
00417   {\cf18 bool} spawned_;\par
00418   {\cf20 // The exit status of the child process.}\par
00419   {\cf18 int} status_;\par
00420   {\cf20 // How the death test concluded.}\par
00421   DeathTestOutcome outcome_;\par
00422   {\cf20 // Descriptor to the read end of the pipe to the child process.  It is}\par
00423   {\cf20 // always -1 in the child process.  The child keeps its write end of the}\par
00424   {\cf20 // pipe in write_fd_.}\par
00425   {\cf18 int} read_fd_;\par
00426   {\cf20 // Descriptor to the child's write end of the pipe to the parent process.}\par
00427   {\cf20 // It is always -1 in the parent process.  The parent keeps its end of the}\par
00428   {\cf20 // pipe in read_fd_.}\par
00429   {\cf18 int} write_fd_;\par
00430 \};\par
00431 \par
00432 {\cf20 // Called in the parent process only. Reads the result code of the death}\par
00433 {\cf20 // test child process via a pipe, interprets it to set the outcome_}\par
00434 {\cf20 // member, and closes read_fd_.  Outputs diagnostics and terminates in}\par
00435 {\cf20 // case of unexpected codes.}\par
00436 {\cf18 void} DeathTestImpl::ReadAndInterpretStatusByte() \{\par
00437   {\cf18 char} flag;\par
00438   {\cf18 int} bytes_read;\par
00439 \par
00440   {\cf20 // The read() here blocks until data is available (signifying the}\par
00441   {\cf20 // failure of the death test) or until the pipe is closed (signifying}\par
00442   {\cf20 // its success), so it's okay to call this in the parent before}\par
00443   {\cf20 // the child process has exited.}\par
00444   {\cf19 do} \{\par
00445     bytes_read = posix::Read(read_fd(), &flag, 1);\par
00446   \} {\cf19 while} (bytes_read == -1 && errno == EINTR);\par
00447 \par
00448   {\cf19 if} (bytes_read == 0) \{\par
00449     set_outcome(DIED);\par
00450   \} {\cf19 else} {\cf19 if} (bytes_read == 1) \{\par
00451     {\cf19 switch} (flag) \{\par
00452       {\cf19 case} kDeathTestReturned:\par
00453         set_outcome(RETURNED);\par
00454         {\cf19 break};\par
00455       {\cf19 case} kDeathTestThrew:\par
00456         set_outcome(THREW);\par
00457         {\cf19 break};\par
00458       {\cf19 case} kDeathTestLived:\par
00459         set_outcome(LIVED);\par
00460         {\cf19 break};\par
00461       {\cf19 case} kDeathTestInternalError:\par
00462         FailFromInternalError(read_fd());  {\cf20 // Does not return.}\par
00463         {\cf19 break};\par
00464       {\cf19 default}:\par
00465         GTEST_LOG_(FATAL) << {\cf22 "Death test child process reported "}\par
00466                           << {\cf22 "unexpected status byte ("}\par
00467                           << {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(flag) << {\cf22 ")"};\par
00468     \}\par
00469   \} {\cf19 else} \{\par
00470     GTEST_LOG_(FATAL) << {\cf22 "Read from death test child process failed: "}\par
00471                       << GetLastErrnoDescription();\par
00472   \}\par
00473   GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Close(read_fd()));\par
00474   set_read_fd(-1);\par
00475 \}\par
00476 \par
00477 {\cf20 // Signals that the death test code which should have exited, didn't.}\par
00478 {\cf20 // Should be called only in a death test child process.}\par
00479 {\cf20 // Writes a status byte to the child's status file descriptor, then}\par
00480 {\cf20 // calls _exit(1).}\par
00481 {\cf18 void} DeathTestImpl::Abort(AbortReason reason) \{\par
00482   {\cf20 // The parent process considers the death test to be a failure if}\par
00483   {\cf20 // it finds any data in our pipe.  So, here we write a single flag byte}\par
00484   {\cf20 // to the pipe, then exit.}\par
00485   {\cf17 const} {\cf18 char} status_ch =\par
00486       reason == TEST_DID_NOT_DIE ? kDeathTestLived :\par
00487       reason == TEST_THREW_EXCEPTION ? kDeathTestThrew : kDeathTestReturned;\par
00488 \par
00489   GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Write(write_fd(), &status_ch, 1));\par
00490   {\cf20 // We are leaking the descriptor here because on some platforms (i.e.,}\par
00491   {\cf20 // when built as Windows DLL), destructors of global objects will still}\par
00492   {\cf20 // run after calling _exit(). On such systems, write_fd_ will be}\par
00493   {\cf20 // indirectly closed from the destructor of UnitTestImpl, causing double}\par
00494   {\cf20 // close if it is also closed here. On debug configurations, double close}\par
00495   {\cf20 // may assert. As there are no in-process buffers to flush here, we are}\par
00496   {\cf20 // relying on the OS to close the descriptor after the process terminates}\par
00497   {\cf20 // when the destructors are not run.}\par
00498   _exit(1);  {\cf20 // Exits w/o any normal exit hooks (we were supposed to crash)}\par
00499 \}\par
00500 \par
00501 {\cf20 // Returns an indented copy of stderr output for a death test.}\par
00502 {\cf20 // This makes distinguishing death test output lines from regular log lines}\par
00503 {\cf20 // much easier.}\par
00504 static ::std::string FormatDeathTestOutput(const ::std::string& output) \{\par
00505   ::std::string ret;\par
00506   {\cf19 for} ({\cf18 size_t} at = 0; ; ) \{\par
00507     {\cf17 const} {\cf18 size_t} line_end = output.find({\cf23 '\\n'}, at);\par
00508     ret += {\cf22 "[  DEATH   ] "};\par
00509     {\cf19 if} (line_end == ::std::string::npos) \{\par
00510       ret += output.substr(at);\par
00511       {\cf19 break};\par
00512     \}\par
00513     ret += output.substr(at, line_end + 1 - at);\par
00514     at = line_end + 1;\par
00515   \}\par
00516   {\cf19 return} ret;\par
00517 \}\par
00518 \par
00519 {\cf20 // Assesses the success or failure of a death test, using both private}\par
00520 {\cf20 // members which have previously been set, and one argument:}\par
00521 {\cf20 //}\par
00522 {\cf20 // Private data members:}\par
00523 {\cf20 //   outcome:  An enumeration describing how the death test}\par
00524 {\cf20 //             concluded: DIED, LIVED, THREW, or RETURNED.  The death test}\par
00525 {\cf20 //             fails in the latter three cases.}\par
00526 {\cf20 //   status:   The exit status of the child process. On *nix, it is in the}\par
00527 {\cf20 //             in the format specified by wait(2). On Windows, this is the}\par
00528 {\cf20 //             value supplied to the ExitProcess() API or a numeric code}\par
00529 {\cf20 //             of the exception that terminated the program.}\par
00530 {\cf20 //   regex:    A regular expression object to be applied to}\par
00531 {\cf20 //             the test's captured standard error output; the death test}\par
00532 {\cf20 //             fails if it does not match.}\par
00533 {\cf20 //}\par
00534 {\cf20 // Argument:}\par
00535 {\cf20 //   status_ok: true if exit_status is acceptable in the context of}\par
00536 {\cf20 //              this particular death test, which fails if it is false}\par
00537 {\cf20 //}\par
00538 {\cf20 // Returns true iff all of the above conditions are met.  Otherwise, the}\par
00539 {\cf20 // first failing condition, in the order given above, is the one that is}\par
00540 {\cf20 // reported. Also sets the last death test message string.}\par
00541 {\cf18 bool} DeathTestImpl::Passed({\cf18 bool} status_ok) \{\par
00542   {\cf19 if} (!spawned())\par
00543     {\cf19 return} {\cf17 false};\par
00544 \par
00545   {\cf17 const} std::string error_message = GetCapturedStderr();\par
00546 \par
00547   {\cf18 bool} success = {\cf17 false};\par
00548   Message buffer;\par
00549 \par
00550   buffer << {\cf22 "Death test: "} << statement() << {\cf22 "\\n"};\par
00551   {\cf19 switch} (outcome()) \{\par
00552     {\cf19 case} LIVED:\par
00553       buffer << {\cf22 "    Result: failed to die.\\n"}\par
00554              << {\cf22 " Error msg:\\n"} << FormatDeathTestOutput(error_message);\par
00555       {\cf19 break};\par
00556     {\cf19 case} THREW:\par
00557       buffer << {\cf22 "    Result: threw an exception.\\n"}\par
00558              << {\cf22 " Error msg:\\n"} << FormatDeathTestOutput(error_message);\par
00559       {\cf19 break};\par
00560     {\cf19 case} RETURNED:\par
00561       buffer << {\cf22 "    Result: illegal return in test statement.\\n"}\par
00562              << {\cf22 " Error msg:\\n"} << FormatDeathTestOutput(error_message);\par
00563       {\cf19 break};\par
00564     {\cf19 case} DIED:\par
00565       {\cf19 if} (status_ok) \{\par
00566         {\cf17 const} {\cf18 bool} matched = RE::PartialMatch(error_message.c_str(), *regex());\par
00567         {\cf19 if} (matched) \{\par
00568           success = {\cf17 true};\par
00569         \} {\cf19 else} \{\par
00570           buffer << {\cf22 "    Result: died but not with expected error.\\n"}\par
00571                  << {\cf22 "  Expected: "} << regex()->pattern() << {\cf22 "\\n"}\par
00572                  << {\cf22 "Actual msg:\\n"} << FormatDeathTestOutput(error_message);\par
00573         \}\par
00574       \} {\cf19 else} \{\par
00575         buffer << {\cf22 "    Result: died but not with expected exit code:\\n"}\par
00576                << {\cf22 "            "} << ExitSummary(status()) << {\cf22 "\\n"}\par
00577                << {\cf22 "Actual msg:\\n"} << FormatDeathTestOutput(error_message);\par
00578       \}\par
00579       {\cf19 break};\par
00580     {\cf19 case} IN_PROGRESS:\par
00581     {\cf19 default}:\par
00582       GTEST_LOG_(FATAL)\par
00583           << {\cf22 "DeathTest::Passed somehow called before conclusion of test"};\par
00584   \}\par
00585 \par
00586   DeathTest::set_last_death_test_message(buffer.GetString());\par
00587   {\cf19 return} success;\par
00588 \}\par
00589 \par
00590 {\cf21 # if GTEST_OS_WINDOWS}\par
00591 {\cf20 // WindowsDeathTest implements death tests on Windows. Due to the}\par
00592 {\cf20 // specifics of starting new processes on Windows, death tests there are}\par
00593 {\cf20 // always threadsafe, and Google Test considers the}\par
00594 {\cf20 // --gtest_death_test_style=fast setting to be equivalent to}\par
00595 {\cf20 // --gtest_death_test_style=threadsafe there.}\par
00596 {\cf20 //}\par
00597 {\cf20 // A few implementation notes:  Like the Linux version, the Windows}\par
00598 {\cf20 // implementation uses pipes for child-to-parent communication. But due to}\par
00599 {\cf20 // the specifics of pipes on Windows, some extra steps are required:}\par
00600 {\cf20 //}\par
00601 {\cf20 // 1. The parent creates a communication pipe and stores handles to both}\par
00602 {\cf20 //    ends of it.}\par
00603 {\cf20 // 2. The parent starts the child and provides it with the information}\par
00604 {\cf20 //    necessary to acquire the handle to the write end of the pipe.}\par
00605 {\cf20 // 3. The child acquires the write end of the pipe and signals the parent}\par
00606 {\cf20 //    using a Windows event.}\par
00607 {\cf20 // 4. Now the parent can release the write end of the pipe on its side. If}\par
00608 {\cf20 //    this is done before step 3, the object's reference count goes down to}\par
00609 {\cf20 //    0 and it is destroyed, preventing the child from acquiring it. The}\par
00610 {\cf20 //    parent now has to release it, or read operations on the read end of}\par
00611 {\cf20 //    the pipe will not return when the child terminates.}\par
00612 {\cf20 // 5. The parent reads child's output through the pipe (outcome code and}\par
00613 {\cf20 //    any possible error messages) from the pipe, and its stderr and then}\par
00614 {\cf20 //    determines whether to fail the test.}\par
00615 {\cf20 //}\par
00616 {\cf20 // Note: to distinguish Win32 API calls from the local method and function}\par
00617 {\cf20 // calls, the former are explicitly resolved in the global namespace.}\par
00618 {\cf20 //}\par
00619 {\cf17 class }WindowsDeathTest : {\cf17 public} DeathTestImpl \{\par
00620  {\cf17 public}:\par
00621   WindowsDeathTest({\cf17 const} {\cf18 char}* a_statement,\par
00622                    {\cf17 const} RE* a_regex,\par
00623                    {\cf17 const} {\cf18 char}* file,\par
00624                    {\cf18 int} line)\par
00625       : DeathTestImpl(a_statement, a_regex), file_(file), line_(line) \{\}\par
00626 \par
00627   {\cf20 // All of these virtual functions are inherited from DeathTest.}\par
00628   {\cf17 virtual} {\cf18 int} Wait();\par
00629   {\cf17 virtual} TestRole AssumeRole();\par
00630 \par
00631  {\cf17 private}:\par
00632   {\cf20 // The name of the file in which the death test is located.}\par
00633   {\cf17 const} {\cf18 char}* {\cf17 const} file_;\par
00634   {\cf20 // The line number on which the death test is located.}\par
00635   {\cf17 const} {\cf18 int} line_;\par
00636   {\cf20 // Handle to the write end of the pipe to the child process.}\par
00637   AutoHandle write_handle_;\par
00638   {\cf20 // Child process handle.}\par
00639   AutoHandle child_handle_;\par
00640   {\cf20 // Event the child process uses to signal the parent that it has}\par
00641   {\cf20 // acquired the handle to the write end of the pipe. After seeing this}\par
00642   {\cf20 // event the parent can release its own handles to make sure its}\par
00643   {\cf20 // ReadFile() calls return when the child terminates.}\par
00644   AutoHandle event_handle_;\par
00645 \};\par
00646 \par
00647 {\cf20 // Waits for the child in a death test to exit, returning its exit}\par
00648 {\cf20 // status, or 0 if no child process exists.  As a side effect, sets the}\par
00649 {\cf20 // outcome data member.}\par
00650 {\cf18 int} WindowsDeathTest::Wait() \{\par
00651   {\cf19 if} (!spawned())\par
00652     {\cf19 return} 0;\par
00653 \par
00654   {\cf20 // Wait until the child either signals that it has acquired the write end}\par
00655   {\cf20 // of the pipe or it dies.}\par
00656   {\cf17 const} HANDLE wait_handles[2] = \{ child_handle_.Get(), event_handle_.Get() \};\par
00657   {\cf19 switch} (::WaitForMultipleObjects(2,\par
00658                                    wait_handles,\par
00659                                    FALSE,  {\cf20 // Waits for any of the handles.}\par
00660                                    INFINITE)) \{\par
00661     {\cf19 case} WAIT_OBJECT_0:\par
00662     {\cf19 case} WAIT_OBJECT_0 + 1:\par
00663       {\cf19 break};\par
00664     {\cf19 default}:\par
00665       GTEST_DEATH_TEST_CHECK_({\cf17 false});  {\cf20 // Should not get here.}\par
00666   \}\par
00667 \par
00668   {\cf20 // The child has acquired the write end of the pipe or exited.}\par
00669   {\cf20 // We release the handle on our side and continue.}\par
00670   write_handle_.Reset();\par
00671   event_handle_.Reset();\par
00672 \par
00673   ReadAndInterpretStatusByte();\par
00674 \par
00675   {\cf20 // Waits for the child process to exit if it haven't already. This}\par
00676   {\cf20 // returns immediately if the child has already exited, regardless of}\par
00677   {\cf20 // whether previous calls to WaitForMultipleObjects synchronized on this}\par
00678   {\cf20 // handle or not.}\par
00679   GTEST_DEATH_TEST_CHECK_(\par
00680       WAIT_OBJECT_0 == ::WaitForSingleObject(child_handle_.Get(),\par
00681                                              INFINITE));\par
00682   DWORD status_code;\par
00683   GTEST_DEATH_TEST_CHECK_(\par
00684       ::GetExitCodeProcess(child_handle_.Get(), &status_code) != FALSE);\par
00685   child_handle_.Reset();\par
00686   set_status({\cf17 static_cast<}{\cf18 int}{\cf17 >}(status_code));\par
00687   {\cf19 return} status();\par
00688 \}\par
00689 \par
00690 {\cf20 // The AssumeRole process for a Windows death test.  It creates a child}\par
00691 {\cf20 // process with the same executable as the current process to run the}\par
00692 {\cf20 // death test.  The child process is given the --gtest_filter and}\par
00693 {\cf20 // --gtest_internal_run_death_test flags such that it knows to run the}\par
00694 {\cf20 // current death test only.}\par
00695 DeathTest::TestRole WindowsDeathTest::AssumeRole() \{\par
00696   {\cf17 const} UnitTestImpl* {\cf17 const} impl = GetUnitTestImpl();\par
00697   {\cf17 const} InternalRunDeathTestFlag* {\cf17 const} flag =\par
00698       impl->internal_run_death_test_flag();\par
00699   {\cf17 const} TestInfo* {\cf17 const} info = impl->current_test_info();\par
00700   {\cf17 const} {\cf18 int} death_test_index = info->result()->death_test_count();\par
00701 \par
00702   {\cf19 if} (flag != NULL) \{\par
00703     {\cf20 // ParseInternalRunDeathTestFlag() has performed all the necessary}\par
00704     {\cf20 // processing.}\par
00705     set_write_fd(flag->write_fd());\par
00706     {\cf19 return} EXECUTE_TEST;\par
00707   \}\par
00708 \par
00709   {\cf20 // WindowsDeathTest uses an anonymous pipe to communicate results of}\par
00710   {\cf20 // a death test.}\par
00711   SECURITY_ATTRIBUTES handles_are_inheritable = \{\par
00712     {\cf17 sizeof}(SECURITY_ATTRIBUTES), NULL, TRUE \};\par
00713   HANDLE read_handle, write_handle;\par
00714   GTEST_DEATH_TEST_CHECK_(\par
00715       ::CreatePipe(&read_handle, &write_handle, &handles_are_inheritable,\par
00716                    0)  {\cf20 // Default buffer size.}\par
00717       != FALSE);\par
00718   set_read_fd(::_open_osfhandle({\cf17 reinterpret_cast<}intptr_t{\cf17 >}(read_handle),\par
00719                                 O_RDONLY));\par
00720   write_handle_.Reset(write_handle);\par
00721   event_handle_.Reset(::CreateEvent(\par
00722       &handles_are_inheritable,\par
00723       TRUE,    {\cf20 // The event will automatically reset to non-signaled state.}\par
00724       FALSE,   {\cf20 // The initial state is non-signalled.}\par
00725       NULL));  {\cf20 // The even is unnamed.}\par
00726   GTEST_DEATH_TEST_CHECK_(event_handle_.Get() != NULL);\par
00727   {\cf17 const} std::string filter_flag =\par
00728       std::string({\cf22 "--"}) + GTEST_FLAG_PREFIX_ + kFilterFlag + {\cf22 "="} +\par
00729       info->test_case_name() + {\cf22 "."} + info->name();\par
00730   {\cf17 const} std::string internal_flag =\par
00731       std::string({\cf22 "--"}) + GTEST_FLAG_PREFIX_ + kInternalRunDeathTestFlag +\par
00732       {\cf22 "="} + file_ + {\cf22 "|"} + StreamableToString(line_) + {\cf22 "|"} +\par
00733       StreamableToString(death_test_index) + {\cf22 "|"} +\par
00734       StreamableToString({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(::GetCurrentProcessId())) +\par
00735       {\cf20 // size_t has the same width as pointers on both 32-bit and 64-bit}\par
00736       {\cf20 // Windows platforms.}\par
00737       {\cf20 // See http://msdn.microsoft.com/en-us/library/tcxf1dw6.aspx.}\par
00738       {\cf22 "|"} + StreamableToString({\cf17 reinterpret_cast<}{\cf18 size_t}{\cf17 >}(write_handle)) +\par
00739       {\cf22 "|"} + StreamableToString({\cf17 reinterpret_cast<}{\cf18 size_t}{\cf17 >}(event_handle_.Get()));\par
00740 \par
00741   {\cf18 char} executable_path[_MAX_PATH + 1];  {\cf20 // NOLINT}\par
00742   GTEST_DEATH_TEST_CHECK_(\par
00743       _MAX_PATH + 1 != ::GetModuleFileNameA(NULL,\par
00744                                             executable_path,\par
00745                                             _MAX_PATH));\par
00746 \par
00747   std::string command_line =\par
00748       std::string(::GetCommandLineA()) + {\cf22 " "} + filter_flag + {\cf22 " \\""} +\par
00749       internal_flag + {\cf22 "\\""};\par
00750 \par
00751   DeathTest::set_last_death_test_message({\cf22 ""});\par
00752 \par
00753   CaptureStderr();\par
00754   {\cf20 // Flush the log buffers since the log streams are shared with the child.}\par
00755   FlushInfoLog();\par
00756 \par
00757   {\cf20 // The child process will share the standard handles with the parent.}\par
00758   STARTUPINFOA startup_info;\par
00759   memset(&startup_info, 0, {\cf17 sizeof}(STARTUPINFO));\par
00760   startup_info.dwFlags = STARTF_USESTDHANDLES;\par
00761   startup_info.hStdInput = ::GetStdHandle(STD_INPUT_HANDLE);\par
00762   startup_info.hStdOutput = ::GetStdHandle(STD_OUTPUT_HANDLE);\par
00763   startup_info.hStdError = ::GetStdHandle(STD_ERROR_HANDLE);\par
00764 \par
00765   PROCESS_INFORMATION process_info;\par
00766   GTEST_DEATH_TEST_CHECK_(::CreateProcessA(\par
00767       executable_path,\par
00768       {\cf17 const_cast<}{\cf18 char}*{\cf17 >}(command_line.c_str()),\par
00769       NULL,   {\cf20 // Retuned process handle is not inheritable.}\par
00770       NULL,   {\cf20 // Retuned thread handle is not inheritable.}\par
00771       TRUE,   {\cf20 // Child inherits all inheritable handles (for write_handle_).}\par
00772       0x0,    {\cf20 // Default creation flags.}\par
00773       NULL,   {\cf20 // Inherit the parent's environment.}\par
00774       UnitTest::GetInstance()->original_working_dir(),\par
00775       &startup_info,\par
00776       &process_info) != FALSE);\par
00777   child_handle_.Reset(process_info.hProcess);\par
00778   ::CloseHandle(process_info.hThread);\par
00779   set_spawned({\cf17 true});\par
00780   {\cf19 return} OVERSEE_TEST;\par
00781 \}\par
00782 {\cf21 # else  }{\cf20 // We are not on Windows.}\par
00783 \par
00784 {\cf20 // ForkingDeathTest provides implementations for most of the abstract}\par
00785 {\cf20 // methods of the DeathTest interface.  Only the AssumeRole method is}\par
00786 {\cf20 // left undefined.}\par
00787 {\cf17 class }ForkingDeathTest : {\cf17 public} DeathTestImpl \{\par
00788  {\cf17 public}:\par
00789   ForkingDeathTest({\cf17 const} {\cf18 char}* statement, {\cf17 const} RE* regex);\par
00790 \par
00791   {\cf20 // All of these virtual functions are inherited from DeathTest.}\par
00792   {\cf17 virtual} {\cf18 int} Wait();\par
00793 \par
00794  {\cf17 protected}:\par
00795   {\cf18 void} set_child_pid(pid_t child_pid) \{ child_pid_ = child_pid; \}\par
00796 \par
00797  {\cf17 private}:\par
00798   {\cf20 // PID of child process during death test; 0 in the child process itself.}\par
00799   pid_t child_pid_;\par
00800 \};\par
00801 \par
00802 {\cf20 // Constructs a ForkingDeathTest.}\par
00803 ForkingDeathTest::ForkingDeathTest({\cf17 const} {\cf18 char}* a_statement, {\cf17 const} RE* a_regex)\par
00804     : DeathTestImpl(a_statement, a_regex),\par
00805       child_pid_(-1) \{\}\par
00806 \par
00807 {\cf20 // Waits for the child in a death test to exit, returning its exit}\par
00808 {\cf20 // status, or 0 if no child process exists.  As a side effect, sets the}\par
00809 {\cf20 // outcome data member.}\par
00810 {\cf18 int} ForkingDeathTest::Wait() \{\par
00811   {\cf19 if} (!spawned())\par
00812     {\cf19 return} 0;\par
00813 \par
00814   ReadAndInterpretStatusByte();\par
00815 \par
00816   {\cf18 int} status_value;\par
00817   GTEST_DEATH_TEST_CHECK_SYSCALL_(waitpid(child_pid_, &status_value, 0));\par
00818   set_status(status_value);\par
00819   {\cf19 return} status_value;\par
00820 \}\par
00821 \par
00822 {\cf20 // A concrete death test class that forks, then immediately runs the test}\par
00823 {\cf20 // in the child process.}\par
00824 {\cf17 class }NoExecDeathTest : {\cf17 public} ForkingDeathTest \{\par
00825  {\cf17 public}:\par
00826   NoExecDeathTest({\cf17 const} {\cf18 char}* a_statement, {\cf17 const} RE* a_regex) :\par
00827       ForkingDeathTest(a_statement, a_regex) \{ \}\par
00828   {\cf17 virtual} TestRole AssumeRole();\par
00829 \};\par
00830 \par
00831 {\cf20 // The AssumeRole process for a fork-and-run death test.  It implements a}\par
00832 {\cf20 // straightforward fork, with a simple pipe to transmit the status byte.}\par
00833 DeathTest::TestRole NoExecDeathTest::AssumeRole() \{\par
00834   {\cf17 const} {\cf18 size_t} thread_count = GetThreadCount();\par
00835   {\cf19 if} (thread_count != 1) \{\par
00836     GTEST_LOG_(WARNING) << DeathTestThreadWarning(thread_count);\par
00837   \}\par
00838 \par
00839   {\cf18 int} pipe_fd[2];\par
00840   GTEST_DEATH_TEST_CHECK_(pipe(pipe_fd) != -1);\par
00841 \par
00842   DeathTest::set_last_death_test_message({\cf22 ""});\par
00843   CaptureStderr();\par
00844   {\cf20 // When we fork the process below, the log file buffers are copied, but the}\par
00845   {\cf20 // file descriptors are shared.  We flush all log files here so that closing}\par
00846   {\cf20 // the file descriptors in the child process doesn't throw off the}\par
00847   {\cf20 // synchronization between descriptors and buffers in the parent process.}\par
00848   {\cf20 // This is as close to the fork as possible to avoid a race condition in case}\par
00849   {\cf20 // there are multiple threads running before the death test, and another}\par
00850   {\cf20 // thread writes to the log file.}\par
00851   FlushInfoLog();\par
00852 \par
00853   {\cf17 const} pid_t child_pid = fork();\par
00854   GTEST_DEATH_TEST_CHECK_(child_pid != -1);\par
00855   set_child_pid(child_pid);\par
00856   {\cf19 if} (child_pid == 0) \{\par
00857     GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[0]));\par
00858     set_write_fd(pipe_fd[1]);\par
00859     {\cf20 // Redirects all logging to stderr in the child process to prevent}\par
00860     {\cf20 // concurrent writes to the log files.  We capture stderr in the parent}\par
00861     {\cf20 // process and append the child process' output to a log.}\par
00862     LogToStderr();\par
00863     {\cf20 // Event forwarding to the listeners of event listener API mush be shut}\par
00864     {\cf20 // down in death test subprocesses.}\par
00865     GetUnitTestImpl()->listeners()->SuppressEventForwarding();\par
00866     g_in_fast_death_test_child = {\cf17 true};\par
00867     {\cf19 return} EXECUTE_TEST;\par
00868   \} {\cf19 else} \{\par
00869     GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[1]));\par
00870     set_read_fd(pipe_fd[0]);\par
00871     set_spawned({\cf17 true});\par
00872     {\cf19 return} OVERSEE_TEST;\par
00873   \}\par
00874 \}\par
00875 \par
00876 {\cf20 // A concrete death test class that forks and re-executes the main}\par
00877 {\cf20 // program from the beginning, with command-line flags set that cause}\par
00878 {\cf20 // only this specific death test to be run.}\par
00879 {\cf17 class }ExecDeathTest : {\cf17 public} ForkingDeathTest \{\par
00880  {\cf17 public}:\par
00881   ExecDeathTest({\cf17 const} {\cf18 char}* a_statement, {\cf17 const} RE* a_regex,\par
00882                 {\cf17 const} {\cf18 char}* file, {\cf18 int} line) :\par
00883       ForkingDeathTest(a_statement, a_regex), file_(file), line_(line) \{ \}\par
00884   {\cf17 virtual} TestRole AssumeRole();\par
00885  {\cf17 private}:\par
00886   static ::std::vector<std::string> GetArgvsForDeathTestChildProcess() \{\par
00887     ::std::vector<std::string> args = GetInjectableArgvs();\par
00888 {\cf21 #  if defined(GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_)}\par
00889     ::std::vector<std::string> extra_args =\par
00890         GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_();\par
00891     args.insert(args.end(), extra_args.begin(), extra_args.end());\par
00892 {\cf21 #  endif  }{\cf20 // defined(GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_)}\par
00893     {\cf19 return} args;\par
00894   \}\par
00895   {\cf20 // The name of the file in which the death test is located.}\par
00896   {\cf17 const} {\cf18 char}* {\cf17 const} file_;\par
00897   {\cf20 // The line number on which the death test is located.}\par
00898   {\cf17 const} {\cf18 int} line_;\par
00899 \};\par
00900 \par
00901 {\cf20 // Utility class for accumulating command-line arguments.}\par
00902 {\cf17 class }Arguments \{\par
00903  {\cf17 public}:\par
00904   Arguments() \{\par
00905     args_.push_back(NULL);\par
00906   \}\par
00907 \par
00908   ~Arguments() \{\par
00909     {\cf19 for} (std::vector<char*>::iterator i = args_.begin(); i != args_.end();\par
00910          ++i) \{\par
00911       free(*i);\par
00912     \}\par
00913   \}\par
00914   {\cf18 void} AddArgument({\cf17 const} {\cf18 char}* argument) \{\par
00915     args_.insert(args_.end() - 1, posix::StrDup(argument));\par
00916   \}\par
00917 \par
00918   {\cf17 template} <{\cf17 typename} Str>\par
00919   {\cf18 void} AddArguments(const ::std::vector<Str>& arguments) \{\par
00920     {\cf19 for} (typename ::std::vector<Str>::const_iterator i = arguments.begin();\par
00921          i != arguments.end();\par
00922          ++i) \{\par
00923       args_.insert(args_.end() - 1, posix::StrDup(i->c_str()));\par
00924     \}\par
00925   \}\par
00926   {\cf18 char}* {\cf17 const}* Argv() \{\par
00927     {\cf19 return} &args_[0];\par
00928   \}\par
00929 \par
00930  {\cf17 private}:\par
00931   std::vector<char*> args_;\par
00932 \};\par
00933 \par
00934 {\cf20 // A struct that encompasses the arguments to the child process of a}\par
00935 {\cf20 // threadsafe-style death test process.}\par
00936 {\cf17 struct }ExecDeathTestArgs \{\par
00937   {\cf18 char}* {\cf17 const}* argv;  {\cf20 // Command-line arguments for the child's call to exec}\par
00938   {\cf18 int} close_fd;       {\cf20 // File descriptor to close; the read end of a pipe}\par
00939 \};\par
00940 \par
00941 {\cf21 #  if GTEST_OS_MAC}\par
00942 {\cf17 inline} {\cf18 char}** GetEnviron() \{\par
00943   {\cf20 // When Google Test is built as a framework on MacOS X, the environ variable}\par
00944   {\cf20 // is unavailable. Apple's documentation (man environ) recommends using}\par
00945   {\cf20 // _NSGetEnviron() instead.}\par
00946   {\cf19 return} *_NSGetEnviron();\par
00947 \}\par
00948 {\cf21 #  else}\par
00949 {\cf20 // Some POSIX platforms expect you to declare environ. extern "C" makes}\par
00950 {\cf20 // it reside in the global namespace.}\par
00951 {\cf17 extern} {\cf22 "C"} {\cf18 char}** environ;\par
00952 {\cf17 inline} {\cf18 char}** GetEnviron() \{ {\cf19 return} environ; \}\par
00953 {\cf21 #  endif  }{\cf20 // GTEST_OS_MAC}\par
00954 \par
00955 {\cf21 #  if !GTEST_OS_QNX}\par
00956 {\cf20 // The main function for a threadsafe-style death test child process.}\par
00957 {\cf20 // This function is called in a clone()-ed process and thus must avoid}\par
00958 {\cf20 // any potentially unsafe operations like malloc or libc functions.}\par
00959 {\cf17 static} {\cf18 int} ExecDeathTestChildMain({\cf18 void}* child_arg) \{\par
00960   ExecDeathTestArgs* {\cf17 const} args = {\cf17 static_cast<}ExecDeathTestArgs*{\cf17 >}(child_arg);\par
00961   GTEST_DEATH_TEST_CHECK_SYSCALL_(close(args->close_fd));\par
00962 \par
00963   {\cf20 // We need to execute the test program in the same environment where}\par
00964   {\cf20 // it was originally invoked.  Therefore we change to the original}\par
00965   {\cf20 // working directory first.}\par
00966   {\cf17 const} {\cf18 char}* {\cf17 const} original_dir =\par
00967       UnitTest::GetInstance()->original_working_dir();\par
00968   {\cf20 // We can safely call chdir() as it's a direct system call.}\par
00969   {\cf19 if} (chdir(original_dir) != 0) \{\par
00970     DeathTestAbort(std::string({\cf22 "chdir(\\""}) + original_dir + {\cf22 "\\") failed: "} +\par
00971                    GetLastErrnoDescription());\par
00972     {\cf19 return} EXIT_FAILURE;\par
00973   \}\par
00974 \par
00975   {\cf20 // We can safely call execve() as it's a direct system call.  We}\par
00976   {\cf20 // cannot use execvp() as it's a libc function and thus potentially}\par
00977   {\cf20 // unsafe.  Since execve() doesn't search the PATH, the user must}\par
00978   {\cf20 // invoke the test program via a valid path that contains at least}\par
00979   {\cf20 // one path separator.}\par
00980   execve(args->argv[0], args->argv, GetEnviron());\par
00981   DeathTestAbort(std::string({\cf22 "execve("}) + args->argv[0] + {\cf22 ", ...) in "} +\par
00982                  original_dir + {\cf22 " failed: "} +\par
00983                  GetLastErrnoDescription());\par
00984   {\cf19 return} EXIT_FAILURE;\par
00985 \}\par
00986 {\cf21 #  endif  }{\cf20 // !GTEST_OS_QNX}\par
00987 \par
00988 {\cf20 // Two utility routines that together determine the direction the stack}\par
00989 {\cf20 // grows.}\par
00990 {\cf20 // This could be accomplished more elegantly by a single recursive}\par
00991 {\cf20 // function, but we want to guard against the unlikely possibility of}\par
00992 {\cf20 // a smart compiler optimizing the recursion away.}\par
00993 {\cf20 //}\par
00994 {\cf20 // GTEST_NO_INLINE_ is required to prevent GCC 4.6 from inlining}\par
00995 {\cf20 // StackLowerThanAddress into StackGrowsDown, which then doesn't give}\par
00996 {\cf20 // correct answer.}\par
00997 {\cf18 void} StackLowerThanAddress({\cf17 const} {\cf18 void}* ptr, {\cf18 bool}* result) GTEST_NO_INLINE_;\par
00998 {\cf18 void} StackLowerThanAddress({\cf17 const} {\cf18 void}* ptr, {\cf18 bool}* result) \{\par
00999   {\cf18 int} dummy;\par
01000   *result = (&dummy < ptr);\par
01001 \}\par
01002 \par
01003 {\cf20 // Make sure AddressSanitizer does not tamper with the stack here.}\par
01004 GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\par
01005 {\cf18 bool} StackGrowsDown() \{\par
01006   {\cf18 int} dummy;\par
01007   {\cf18 bool} result;\par
01008   StackLowerThanAddress(&dummy, &result);\par
01009   {\cf19 return} result;\par
01010 \}\par
01011 \par
01012 {\cf20 // Spawns a child process with the same executable as the current process in}\par
01013 {\cf20 // a thread-safe manner and instructs it to run the death test.  The}\par
01014 {\cf20 // implementation uses fork(2) + exec.  On systems where clone(2) is}\par
01015 {\cf20 // available, it is used instead, being slightly more thread-safe.  On QNX,}\par
01016 {\cf20 // fork supports only single-threaded environments, so this function uses}\par
01017 {\cf20 // spawn(2) there instead.  The function dies with an error message if}\par
01018 {\cf20 // anything goes wrong.}\par
01019 {\cf17 static} pid_t ExecDeathTestSpawnChild({\cf18 char}* {\cf17 const}* argv, {\cf18 int} close_fd) \{\par
01020   ExecDeathTestArgs args = \{ argv, close_fd \};\par
01021   pid_t child_pid = -1;\par
01022 \par
01023 {\cf21 #  if GTEST_OS_QNX}\par
01024   {\cf20 // Obtains the current directory and sets it to be closed in the child}\par
01025   {\cf20 // process.}\par
01026   {\cf17 const} {\cf18 int} cwd_fd = open({\cf22 "."}, O_RDONLY);\par
01027   GTEST_DEATH_TEST_CHECK_(cwd_fd != -1);\par
01028   GTEST_DEATH_TEST_CHECK_SYSCALL_(fcntl(cwd_fd, F_SETFD, FD_CLOEXEC));\par
01029   {\cf20 // We need to execute the test program in the same environment where}\par
01030   {\cf20 // it was originally invoked.  Therefore we change to the original}\par
01031   {\cf20 // working directory first.}\par
01032   {\cf17 const} {\cf18 char}* {\cf17 const} original_dir =\par
01033       UnitTest::GetInstance()->original_working_dir();\par
01034   {\cf20 // We can safely call chdir() as it's a direct system call.}\par
01035   {\cf19 if} (chdir(original_dir) != 0) \{\par
01036     DeathTestAbort(std::string({\cf22 "chdir(\\""}) + original_dir + {\cf22 "\\") failed: "} +\par
01037                    GetLastErrnoDescription());\par
01038     {\cf19 return} EXIT_FAILURE;\par
01039   \}\par
01040 \par
01041   {\cf18 int} fd_flags;\par
01042   {\cf20 // Set close_fd to be closed after spawn.}\par
01043   GTEST_DEATH_TEST_CHECK_SYSCALL_(fd_flags = fcntl(close_fd, F_GETFD));\par
01044   GTEST_DEATH_TEST_CHECK_SYSCALL_(fcntl(close_fd, F_SETFD,\par
01045                                         fd_flags | FD_CLOEXEC));\par
01046   {\cf17 struct }inheritance inherit = \{0\};\par
01047   {\cf20 // spawn is a system call.}\par
01048   child_pid = spawn(args.argv[0], 0, NULL, &inherit, args.argv, GetEnviron());\par
01049   {\cf20 // Restores the current working directory.}\par
01050   GTEST_DEATH_TEST_CHECK_(fchdir(cwd_fd) != -1);\par
01051   GTEST_DEATH_TEST_CHECK_SYSCALL_(close(cwd_fd));\par
01052 \par
01053 {\cf21 #  else   }{\cf20 // GTEST_OS_QNX}\par
01054 {\cf21 #   if GTEST_OS_LINUX}\par
01055   {\cf20 // When a SIGPROF signal is received while fork() or clone() are executing,}\par
01056   {\cf20 // the process may hang. To avoid this, we ignore SIGPROF here and re-enable}\par
01057   {\cf20 // it after the call to fork()/clone() is complete.}\par
01058   {\cf17 struct }sigaction saved_sigprof_action;\par
01059   {\cf17 struct }sigaction ignore_sigprof_action;\par
01060   memset(&ignore_sigprof_action, 0, {\cf17 sizeof}(ignore_sigprof_action));\par
01061   sigemptyset(&ignore_sigprof_action.sa_mask);\par
01062   ignore_sigprof_action.sa_handler = SIG_IGN;\par
01063   GTEST_DEATH_TEST_CHECK_SYSCALL_(sigaction(\par
01064       SIGPROF, &ignore_sigprof_action, &saved_sigprof_action));\par
01065 {\cf21 #   endif  }{\cf20 // GTEST_OS_LINUX}\par
01066 \par
01067 {\cf21 #   if GTEST_HAS_CLONE}\par
01068   {\cf17 const} {\cf18 bool} use_fork = GTEST_FLAG(death_test_use_fork);\par
01069 \par
01070   {\cf19 if} (!use_fork) \{\par
01071     {\cf17 static} {\cf17 const} {\cf18 bool} stack_grows_down = StackGrowsDown();\par
01072     {\cf17 const} {\cf18 size_t} stack_size = getpagesize();\par
01073     {\cf20 // MMAP_ANONYMOUS is not defined on Mac, so we use MAP_ANON instead.}\par
01074     {\cf18 void}* {\cf17 const} stack = mmap(NULL, stack_size, PROT_READ | PROT_WRITE,\par
01075                              MAP_ANON | MAP_PRIVATE, -1, 0);\par
01076     GTEST_DEATH_TEST_CHECK_(stack != MAP_FAILED);\par
01077 \par
01078     {\cf20 // Maximum stack alignment in bytes:  For a downward-growing stack, this}\par
01079     {\cf20 // amount is subtracted from size of the stack space to get an address}\par
01080     {\cf20 // that is within the stack space and is aligned on all systems we care}\par
01081     {\cf20 // about.  As far as I know there is no ABI with stack alignment greater}\par
01082     {\cf20 // than 64.  We assume stack and stack_size already have alignment of}\par
01083     {\cf20 // kMaxStackAlignment.}\par
01084     {\cf17 const} {\cf18 size_t} kMaxStackAlignment = 64;\par
01085     {\cf18 void}* {\cf17 const} stack_top =\par
01086         {\cf17 static_cast<}{\cf18 char}*{\cf17 >}(stack) +\par
01087             (stack_grows_down ? stack_size - kMaxStackAlignment : 0);\par
01088     GTEST_DEATH_TEST_CHECK_(stack_size > kMaxStackAlignment &&\par
01089         {\cf17 reinterpret_cast<}intptr_t{\cf17 >}(stack_top) % kMaxStackAlignment == 0);\par
01090 \par
01091     child_pid = clone(&ExecDeathTestChildMain, stack_top, SIGCHLD, &args);\par
01092 \par
01093     GTEST_DEATH_TEST_CHECK_(munmap(stack, stack_size) != -1);\par
01094   \}\par
01095 {\cf21 #   else}\par
01096   {\cf17 const} {\cf18 bool} use_fork = {\cf17 true};\par
01097 {\cf21 #   endif  }{\cf20 // GTEST_HAS_CLONE}\par
01098 \par
01099   {\cf19 if} (use_fork && (child_pid = fork()) == 0) \{\par
01100       ExecDeathTestChildMain(&args);\par
01101       _exit(0);\par
01102   \}\par
01103 {\cf21 #  endif  }{\cf20 // GTEST_OS_QNX}\par
01104 {\cf21 #  if GTEST_OS_LINUX}\par
01105   GTEST_DEATH_TEST_CHECK_SYSCALL_(\par
01106       sigaction(SIGPROF, &saved_sigprof_action, NULL));\par
01107 {\cf21 #  endif  }{\cf20 // GTEST_OS_LINUX}\par
01108 \par
01109   GTEST_DEATH_TEST_CHECK_(child_pid != -1);\par
01110   {\cf19 return} child_pid;\par
01111 \}\par
01112 \par
01113 {\cf20 // The AssumeRole process for a fork-and-exec death test.  It re-executes the}\par
01114 {\cf20 // main program from the beginning, setting the --gtest_filter}\par
01115 {\cf20 // and --gtest_internal_run_death_test flags to cause only the current}\par
01116 {\cf20 // death test to be re-run.}\par
01117 DeathTest::TestRole ExecDeathTest::AssumeRole() \{\par
01118   {\cf17 const} UnitTestImpl* {\cf17 const} impl = GetUnitTestImpl();\par
01119   {\cf17 const} InternalRunDeathTestFlag* {\cf17 const} flag =\par
01120       impl->internal_run_death_test_flag();\par
01121   {\cf17 const} TestInfo* {\cf17 const} info = impl->current_test_info();\par
01122   {\cf17 const} {\cf18 int} death_test_index = info->result()->death_test_count();\par
01123 \par
01124   {\cf19 if} (flag != NULL) \{\par
01125     set_write_fd(flag->write_fd());\par
01126     {\cf19 return} EXECUTE_TEST;\par
01127   \}\par
01128 \par
01129   {\cf18 int} pipe_fd[2];\par
01130   GTEST_DEATH_TEST_CHECK_(pipe(pipe_fd) != -1);\par
01131   {\cf20 // Clear the close-on-exec flag on the write end of the pipe, lest}\par
01132   {\cf20 // it be closed when the child process does an exec:}\par
01133   GTEST_DEATH_TEST_CHECK_(fcntl(pipe_fd[1], F_SETFD, 0) != -1);\par
01134 \par
01135   {\cf17 const} std::string filter_flag =\par
01136       std::string({\cf22 "--"}) + GTEST_FLAG_PREFIX_ + kFilterFlag + {\cf22 "="}\par
01137       + info->test_case_name() + {\cf22 "."} + info->name();\par
01138   {\cf17 const} std::string internal_flag =\par
01139       std::string({\cf22 "--"}) + GTEST_FLAG_PREFIX_ + kInternalRunDeathTestFlag + {\cf22 "="}\par
01140       + file_ + {\cf22 "|"} + StreamableToString(line_) + {\cf22 "|"}\par
01141       + StreamableToString(death_test_index) + {\cf22 "|"}\par
01142       + StreamableToString(pipe_fd[1]);\par
01143   Arguments args;\par
01144   args.AddArguments(GetArgvsForDeathTestChildProcess());\par
01145   args.AddArgument(filter_flag.c_str());\par
01146   args.AddArgument(internal_flag.c_str());\par
01147 \par
01148   DeathTest::set_last_death_test_message({\cf22 ""});\par
01149 \par
01150   CaptureStderr();\par
01151   {\cf20 // See the comment in NoExecDeathTest::AssumeRole for why the next line}\par
01152   {\cf20 // is necessary.}\par
01153   FlushInfoLog();\par
01154 \par
01155   {\cf17 const} pid_t child_pid = ExecDeathTestSpawnChild(args.Argv(), pipe_fd[0]);\par
01156   GTEST_DEATH_TEST_CHECK_SYSCALL_(close(pipe_fd[1]));\par
01157   set_child_pid(child_pid);\par
01158   set_read_fd(pipe_fd[0]);\par
01159   set_spawned({\cf17 true});\par
01160   {\cf19 return} OVERSEE_TEST;\par
01161 \}\par
01162 \par
01163 {\cf21 # endif  }{\cf20 // !GTEST_OS_WINDOWS}\par
01164 \par
01165 {\cf20 // Creates a concrete DeathTest-derived class that depends on the}\par
01166 {\cf20 // --gtest_death_test_style flag, and sets the pointer pointed to}\par
01167 {\cf20 // by the "test" argument to its address.  If the test should be}\par
01168 {\cf20 // skipped, sets that pointer to NULL.  Returns true, unless the}\par
01169 {\cf20 // flag is set to an invalid value.}\par
01170 {\cf18 bool} DefaultDeathTestFactory::Create({\cf17 const} {\cf18 char}* statement, {\cf17 const} RE* regex,\par
01171                                      {\cf17 const} {\cf18 char}* file, {\cf18 int} line,\par
01172                                      DeathTest** test) \{\par
01173   UnitTestImpl* {\cf17 const} impl = GetUnitTestImpl();\par
01174   {\cf17 const} InternalRunDeathTestFlag* {\cf17 const} flag =\par
01175       impl->internal_run_death_test_flag();\par
01176   {\cf17 const} {\cf18 int} death_test_index = impl->current_test_info()\par
01177       ->increment_death_test_count();\par
01178 \par
01179   {\cf19 if} (flag != NULL) \{\par
01180     {\cf19 if} (death_test_index > flag->index()) \{\par
01181       DeathTest::set_last_death_test_message(\par
01182           {\cf22 "Death test count ("} + StreamableToString(death_test_index)\par
01183           + {\cf22 ") somehow exceeded expected maximum ("}\par
01184           + StreamableToString(flag->index()) + {\cf22 ")"});\par
01185       {\cf19 return} {\cf17 false};\par
01186     \}\par
01187 \par
01188     {\cf19 if} (!(flag->file() == file && flag->line() == line &&\par
01189           flag->index() == death_test_index)) \{\par
01190       *test = NULL;\par
01191       {\cf19 return} {\cf17 true};\par
01192     \}\par
01193   \}\par
01194 \par
01195 {\cf21 # if GTEST_OS_WINDOWS}\par
01196 \par
01197   {\cf19 if} (GTEST_FLAG(death_test_style) == {\cf22 "threadsafe"} ||\par
01198       GTEST_FLAG(death_test_style) == {\cf22 "fast"}) \{\par
01199     *test = {\cf17 new} WindowsDeathTest(statement, regex, file, line);\par
01200   \}\par
01201 \par
01202 {\cf21 # else}\par
01203 \par
01204   {\cf19 if} (GTEST_FLAG(death_test_style) == {\cf22 "threadsafe"}) \{\par
01205     *test = {\cf17 new} ExecDeathTest(statement, regex, file, line);\par
01206   \} {\cf19 else} {\cf19 if} (GTEST_FLAG(death_test_style) == {\cf22 "fast"}) \{\par
01207     *test = {\cf17 new} NoExecDeathTest(statement, regex);\par
01208   \}\par
01209 \par
01210 {\cf21 # endif  }{\cf20 // GTEST_OS_WINDOWS}\par
01211 \par
01212   {\cf19 else} \{  {\cf20 // NOLINT - this is more readable than unbalanced brackets inside #if.}\par
01213     DeathTest::set_last_death_test_message(\par
01214         {\cf22 "Unknown death test style \\""} + GTEST_FLAG(death_test_style)\par
01215         + {\cf22 "\\" encountered"});\par
01216     {\cf19 return} {\cf17 false};\par
01217   \}\par
01218 \par
01219   {\cf19 return} {\cf17 true};\par
01220 \}\par
01221 \par
01222 {\cf21 # if GTEST_OS_WINDOWS}\par
01223 {\cf20 // Recreates the pipe and event handles from the provided parameters,}\par
01224 {\cf20 // signals the event, and returns a file descriptor wrapped around the pipe}\par
01225 {\cf20 // handle. This function is called in the child process only.}\par
01226 {\cf18 int} GetStatusFileDescriptor({\cf18 unsigned} {\cf18 int} parent_process_id,\par
01227                             {\cf18 size_t} write_handle_as_size_t,\par
01228                             {\cf18 size_t} event_handle_as_size_t) \{\par
01229   AutoHandle parent_process_handle(::OpenProcess(PROCESS_DUP_HANDLE,\par
01230                                                    FALSE,  {\cf20 // Non-inheritable.}\par
01231                                                    parent_process_id));\par
01232   {\cf19 if} (parent_process_handle.Get() == INVALID_HANDLE_VALUE) \{\par
01233     DeathTestAbort({\cf22 "Unable to open parent process "} +\par
01234                    StreamableToString(parent_process_id));\par
01235   \}\par
01236 \par
01237   {\cf20 // TODO(vladl@google.com): Replace the following check with a}\par
01238   {\cf20 // compile-time assertion when available.}\par
01239   GTEST_CHECK_({\cf17 sizeof}(HANDLE) <= {\cf17 sizeof}({\cf18 size_t}));\par
01240 \par
01241   {\cf17 const} HANDLE write_handle =\par
01242       {\cf17 reinterpret_cast<}HANDLE{\cf17 >}(write_handle_as_size_t);\par
01243   HANDLE dup_write_handle;\par
01244 \par
01245   {\cf20 // The newly initialized handle is accessible only in in the parent}\par
01246   {\cf20 // process. To obtain one accessible within the child, we need to use}\par
01247   {\cf20 // DuplicateHandle.}\par
01248   {\cf19 if} (!::DuplicateHandle(parent_process_handle.Get(), write_handle,\par
01249                          ::GetCurrentProcess(), &dup_write_handle,\par
01250                          0x0,    {\cf20 // Requested privileges ignored since}\par
01251                                  {\cf20 // DUPLICATE_SAME_ACCESS is used.}\par
01252                          FALSE,  {\cf20 // Request non-inheritable handler.}\par
01253                          DUPLICATE_SAME_ACCESS)) \{\par
01254     DeathTestAbort({\cf22 "Unable to duplicate the pipe handle "} +\par
01255                    StreamableToString(write_handle_as_size_t) +\par
01256                    {\cf22 " from the parent process "} +\par
01257                    StreamableToString(parent_process_id));\par
01258   \}\par
01259 \par
01260   {\cf17 const} HANDLE event_handle = {\cf17 reinterpret_cast<}HANDLE{\cf17 >}(event_handle_as_size_t);\par
01261   HANDLE dup_event_handle;\par
01262 \par
01263   {\cf19 if} (!::DuplicateHandle(parent_process_handle.Get(), event_handle,\par
01264                          ::GetCurrentProcess(), &dup_event_handle,\par
01265                          0x0,\par
01266                          FALSE,\par
01267                          DUPLICATE_SAME_ACCESS)) \{\par
01268     DeathTestAbort({\cf22 "Unable to duplicate the event handle "} +\par
01269                    StreamableToString(event_handle_as_size_t) +\par
01270                    {\cf22 " from the parent process "} +\par
01271                    StreamableToString(parent_process_id));\par
01272   \}\par
01273 \par
01274   {\cf17 const} {\cf18 int} write_fd =\par
01275       ::_open_osfhandle({\cf17 reinterpret_cast<}intptr_t{\cf17 >}(dup_write_handle), O_APPEND);\par
01276   {\cf19 if} (write_fd == -1) \{\par
01277     DeathTestAbort({\cf22 "Unable to convert pipe handle "} +\par
01278                    StreamableToString(write_handle_as_size_t) +\par
01279                    {\cf22 " to a file descriptor"});\par
01280   \}\par
01281 \par
01282   {\cf20 // Signals the parent that the write end of the pipe has been acquired}\par
01283   {\cf20 // so the parent can release its own write end.}\par
01284   ::SetEvent(dup_event_handle);\par
01285 \par
01286   {\cf19 return} write_fd;\par
01287 \}\par
01288 {\cf21 # endif  }{\cf20 // GTEST_OS_WINDOWS}\par
01289 \par
01290 {\cf20 // Returns a newly created InternalRunDeathTestFlag object with fields}\par
01291 {\cf20 // initialized from the GTEST_FLAG(internal_run_death_test) flag if}\par
01292 {\cf20 // the flag is specified; otherwise returns NULL.}\par
01293 InternalRunDeathTestFlag* ParseInternalRunDeathTestFlag() \{\par
01294   {\cf19 if} (GTEST_FLAG(internal_run_death_test) == {\cf22 ""}) {\cf19 return} NULL;\par
01295 \par
01296   {\cf20 // GTEST_HAS_DEATH_TEST implies that we have ::std::string, so we}\par
01297   {\cf20 // can use it here.}\par
01298   {\cf18 int} line = -1;\par
01299   {\cf18 int} index = -1;\par
01300   ::std::vector< ::std::string> fields;\par
01301   SplitString(GTEST_FLAG(internal_run_death_test).c_str(), {\cf23 '|'}, &fields);\par
01302   {\cf18 int} write_fd = -1;\par
01303 \par
01304 {\cf21 # if GTEST_OS_WINDOWS}\par
01305 \par
01306   {\cf18 unsigned} {\cf18 int} parent_process_id = 0;\par
01307   {\cf18 size_t} write_handle_as_size_t = 0;\par
01308   {\cf18 size_t} event_handle_as_size_t = 0;\par
01309 \par
01310   {\cf19 if} (fields.size() != 6\par
01311       || !ParseNaturalNumber(fields[1], &line)\par
01312       || !ParseNaturalNumber(fields[2], &index)\par
01313       || !ParseNaturalNumber(fields[3], &parent_process_id)\par
01314       || !ParseNaturalNumber(fields[4], &write_handle_as_size_t)\par
01315       || !ParseNaturalNumber(fields[5], &event_handle_as_size_t)) \{\par
01316     DeathTestAbort({\cf22 "Bad --gtest_internal_run_death_test flag: "} +\par
01317                    GTEST_FLAG(internal_run_death_test));\par
01318   \}\par
01319   write_fd = GetStatusFileDescriptor(parent_process_id,\par
01320                                      write_handle_as_size_t,\par
01321                                      event_handle_as_size_t);\par
01322 {\cf21 # else}\par
01323 \par
01324   {\cf19 if} (fields.size() != 4\par
01325       || !ParseNaturalNumber(fields[1], &line)\par
01326       || !ParseNaturalNumber(fields[2], &index)\par
01327       || !ParseNaturalNumber(fields[3], &write_fd)) \{\par
01328     DeathTestAbort({\cf22 "Bad --gtest_internal_run_death_test flag: "}\par
01329         + GTEST_FLAG(internal_run_death_test));\par
01330   \}\par
01331 \par
01332 {\cf21 # endif  }{\cf20 // GTEST_OS_WINDOWS}\par
01333 \par
01334   {\cf19 return} {\cf17 new} InternalRunDeathTestFlag(fields[0], line, index, write_fd);\par
01335 \}\par
01336 \par
01337 \}  {\cf20 // namespace internal}\par
01338 \par
01339 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
01340 \par
01341 \}  {\cf20 // namespace testing}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/src/gtest-filepath.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-filepath.cc}
{\xe \v gtest/src/gtest-filepath.cc}
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/gtest-message.h"}\par
{\f2 #include "gtest/internal/gtest-filepath.h"}\par
{\f2 #include "gtest/internal/gtest-port.h"}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <limits.h>}\par
{\f2 #include <climits>}\par
{\f2 #include "gtest/internal/gtest-string.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_PATH_MAX_}\~ _POSIX_PATH_MAX\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kPathSeparator} = '/'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kCurrentDirectoryString} [] = "./"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v GTEST_PATH_MAX_\:gtest-filepath.cc}
{\xe \v gtest-filepath.cc\:GTEST_PATH_MAX_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_PATH_MAX_\~ _POSIX_PATH_MAX}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-filepath.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 58}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-filepath.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-filepath.cc}
{\xe \v gtest/src/gtest-filepath.cc}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2008, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Authors: keith.ray@gmail.com (Keith Ray)}\par
00031 \par
00032 {\cf21 #include "gtest/gtest-message.h"}\par
00033 {\cf21 #include "gtest/internal/gtest-filepath.h"}\par
00034 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00035 \par
00036 {\cf21 #include <stdlib.h>}\par
00037 \par
00038 {\cf21 #if GTEST_OS_WINDOWS_MOBILE}\par
00039 {\cf21 # include <windows.h>}\par
00040 {\cf21 #elif GTEST_OS_WINDOWS}\par
00041 {\cf21 # include <direct.h>}\par
00042 {\cf21 # include <io.h>}\par
00043 {\cf21 #elif GTEST_OS_SYMBIAN}\par
00044 {\cf20 // Symbian OpenC has PATH_MAX in sys/syslimits.h}\par
00045 {\cf21 # include <sys/syslimits.h>}\par
00046 {\cf21 #else}\par
00047 {\cf21 # include <limits.h>}\par
00048 {\cf21 # include <climits>}  {\cf20 // Some Linux distributions define PATH_MAX here.}\par
00049 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
00050 \par
00051 {\cf21 #if GTEST_OS_WINDOWS}\par
00052 {\cf21 # define GTEST_PATH_MAX_ _MAX_PATH}\par
00053 {\cf21 #elif defined(PATH_MAX)}\par
00054 {\cf21 # define GTEST_PATH_MAX_ PATH_MAX}\par
00055 {\cf21 #elif defined(_XOPEN_PATH_MAX)}\par
00056 {\cf21 # define GTEST_PATH_MAX_ _XOPEN_PATH_MAX}\par
00057 {\cf21 #else}\par
00058 {\cf21 # define GTEST_PATH_MAX_ _POSIX_PATH_MAX}\par
00059 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
00060 \par
00061 {\cf21 #include "gtest/internal/gtest-string.h"}\par
00062 \par
00063 {\cf17 namespace }testing \{\par
00064 {\cf17 namespace }internal \{\par
00065 \par
00066 {\cf21 #if GTEST_OS_WINDOWS}\par
00067 {\cf20 // On Windows, '\\\\' is the standard path separator, but many tools and the}\par
00068 {\cf20 // Windows API also accept '/' as an alternate path separator. Unless otherwise}\par
00069 {\cf20 // noted, a file path can contain either kind of path separators, or a mixture}\par
00070 {\cf20 // of them.}\par
00071 {\cf17 const} {\cf18 char} kPathSeparator = {\cf23 '\\\\'};\par
00072 {\cf17 const} {\cf18 char} kAlternatePathSeparator = {\cf23 '/'};\par
00073 {\cf17 const} {\cf18 char} kAlternatePathSeparatorString[] = {\cf22 "/"};\par
00074 {\cf21 # if GTEST_OS_WINDOWS_MOBILE}\par
00075 {\cf20 // Windows CE doesn't have a current directory. You should not use}\par
00076 {\cf20 // the current directory in tests on Windows CE, but this at least}\par
00077 {\cf20 // provides a reasonable fallback.}\par
00078 {\cf17 const} {\cf18 char} kCurrentDirectoryString[] = {\cf22 "\\\\"};\par
00079 {\cf20 // Windows CE doesn't define INVALID_FILE_ATTRIBUTES}\par
00080 {\cf17 const} DWORD kInvalidFileAttributes = 0xffffffff;\par
00081 {\cf21 # else}\par
00082 {\cf17 const} {\cf18 char} kCurrentDirectoryString[] = {\cf22 ".\\\\"};\par
00083 {\cf21 # endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
00084 {\cf21 #else}\par
00085 {\cf17 const} {\cf18 char} kPathSeparator = {\cf23 '/'};\par
00086 {\cf17 const} {\cf18 char} kCurrentDirectoryString[] = {\cf22 "./"};\par
00087 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
00088 \par
00089 {\cf20 // Returns whether the given character is a valid path separator.}\par
00090 {\cf17 static} {\cf18 bool} IsPathSeparator({\cf18 char} c) \{\par
00091 {\cf21 #if GTEST_HAS_ALT_PATH_SEP_}\par
00092   {\cf19 return} (c == kPathSeparator) || (c == kAlternatePathSeparator);\par
00093 {\cf21 #else}\par
00094   {\cf19 return} c == kPathSeparator;\par
00095 {\cf21 #endif}\par
00096 \}\par
00097 \par
00098 {\cf20 // Returns the current working directory, or "" if unsuccessful.}\par
00099 FilePath FilePath::GetCurrentDir() \{\par
00100 {\cf21 #if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT}\par
00101   {\cf20 // Windows CE doesn't have a current directory, so we just return}\par
00102   {\cf20 // something reasonable.}\par
00103   {\cf19 return} FilePath(kCurrentDirectoryString);\par
00104 {\cf21 #elif GTEST_OS_WINDOWS}\par
00105   {\cf18 char} cwd[GTEST_PATH_MAX_ + 1] = \{ {\cf23 '\\0'} \};\par
00106   {\cf19 return} FilePath(_getcwd(cwd, {\cf17 sizeof}(cwd)) == NULL ? {\cf22 ""} : cwd);\par
00107 {\cf21 #else}\par
00108   {\cf18 char} cwd[GTEST_PATH_MAX_ + 1] = \{ {\cf23 '\\0'} \};\par
00109   {\cf18 char}* result = getcwd(cwd, {\cf17 sizeof}(cwd));\par
00110 {\cf21 # if GTEST_OS_NACL}\par
00111   {\cf20 // getcwd will likely fail in NaCl due to the sandbox, so return something}\par
00112   {\cf20 // reasonable. The user may have provided a shim implementation for getcwd,}\par
00113   {\cf20 // however, so fallback only when failure is detected.}\par
00114   {\cf19 return} FilePath(result == NULL ? kCurrentDirectoryString : cwd);\par
00115 {\cf21 # endif  }{\cf20 // GTEST_OS_NACL}\par
00116   {\cf19 return} FilePath(result == NULL ? {\cf22 ""} : cwd);\par
00117 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
00118 \}\par
00119 \par
00120 {\cf20 // Returns a copy of the FilePath with the case-insensitive extension removed.}\par
00121 {\cf20 // Example: FilePath("dir/file.exe").RemoveExtension("EXE") returns}\par
00122 {\cf20 // FilePath("dir/file"). If a case-insensitive extension is not}\par
00123 {\cf20 // found, returns a copy of the original FilePath.}\par
00124 FilePath FilePath::RemoveExtension({\cf17 const} {\cf18 char}* extension){\cf17  const }\{\par
00125   {\cf17 const} std::string dot_extension = std::string({\cf22 "."}) + extension;\par
00126   {\cf19 if} (String::EndsWithCaseInsensitive(pathname_, dot_extension)) \{\par
00127     {\cf19 return} FilePath(pathname_.substr(\par
00128         0, pathname_.length() - dot_extension.length()));\par
00129   \}\par
00130   {\cf19 return} *{\cf17 this};\par
00131 \}\par
00132 \par
00133 {\cf20 // Returns a pointer to the last occurence of a valid path separator in}\par
00134 {\cf20 // the FilePath. On Windows, for example, both '/' and '\\' are valid path}\par
00135 {\cf20 // separators. Returns NULL if no path separator was found.}\par
00136 {\cf17 const} {\cf18 char}* FilePath::FindLastPathSeparator(){\cf17  const }\{\par
00137   {\cf17 const} {\cf18 char}* {\cf17 const} last_sep = strrchr(c_str(), kPathSeparator);\par
00138 {\cf21 #if GTEST_HAS_ALT_PATH_SEP_}\par
00139   {\cf17 const} {\cf18 char}* {\cf17 const} last_alt_sep = strrchr(c_str(), kAlternatePathSeparator);\par
00140   {\cf20 // Comparing two pointers of which only one is NULL is undefined.}\par
00141   {\cf19 if} (last_alt_sep != NULL &&\par
00142       (last_sep == NULL || last_alt_sep > last_sep)) \{\par
00143     {\cf19 return} last_alt_sep;\par
00144   \}\par
00145 {\cf21 #endif}\par
00146   {\cf19 return} last_sep;\par
00147 \}\par
00148 \par
00149 {\cf20 // Returns a copy of the FilePath with the directory part removed.}\par
00150 {\cf20 // Example: FilePath("path/to/file").RemoveDirectoryName() returns}\par
00151 {\cf20 // FilePath("file"). If there is no directory part ("just_a_file"), it returns}\par
00152 {\cf20 // the FilePath unmodified. If there is no file part ("just_a_dir/") it}\par
00153 {\cf20 // returns an empty FilePath ("").}\par
00154 {\cf20 // On Windows platform, '\\' is the path separator, otherwise it is '/'.}\par
00155 FilePath FilePath::RemoveDirectoryName(){\cf17  const }\{\par
00156   {\cf17 const} {\cf18 char}* {\cf17 const} last_sep = FindLastPathSeparator();\par
00157   {\cf19 return} last_sep ? FilePath(last_sep + 1) : *{\cf17 this};\par
00158 \}\par
00159 \par
00160 {\cf20 // RemoveFileName returns the directory path with the filename removed.}\par
00161 {\cf20 // Example: FilePath("path/to/file").RemoveFileName() returns "path/to/".}\par
00162 {\cf20 // If the FilePath is "a_file" or "/a_file", RemoveFileName returns}\par
00163 {\cf20 // FilePath("./") or, on Windows, FilePath(".\\\\"). If the filepath does}\par
00164 {\cf20 // not have a file, like "just/a/dir/", it returns the FilePath unmodified.}\par
00165 {\cf20 // On Windows platform, '\\' is the path separator, otherwise it is '/'.}\par
00166 FilePath FilePath::RemoveFileName(){\cf17  const }\{\par
00167   {\cf17 const} {\cf18 char}* {\cf17 const} last_sep = FindLastPathSeparator();\par
00168   std::string dir;\par
00169   {\cf19 if} (last_sep) \{\par
00170     dir = std::string(c_str(), last_sep + 1 - c_str());\par
00171   \} {\cf19 else} \{\par
00172     dir = kCurrentDirectoryString;\par
00173   \}\par
00174   {\cf19 return} FilePath(dir);\par
00175 \}\par
00176 \par
00177 {\cf20 // Helper functions for naming files in a directory for xml output.}\par
00178 \par
00179 {\cf20 // Given directory = "dir", base_name = "test", number = 0,}\par
00180 {\cf20 // extension = "xml", returns "dir/test.xml". If number is greater}\par
00181 {\cf20 // than zero (e.g., 12), returns "dir/test_12.xml".}\par
00182 {\cf20 // On Windows platform, uses \\ as the separator rather than /.}\par
00183 FilePath FilePath::MakeFileName({\cf17 const} FilePath& directory,\par
00184                                 {\cf17 const} FilePath& base_name,\par
00185                                 {\cf18 int} number,\par
00186                                 {\cf17 const} {\cf18 char}* extension) \{\par
00187   std::string file;\par
00188   {\cf19 if} (number == 0) \{\par
00189     file = base_name.string() + {\cf22 "."} + extension;\par
00190   \} {\cf19 else} \{\par
00191     file = base_name.string() + {\cf22 "_"} + StreamableToString(number)\par
00192         + {\cf22 "."} + extension;\par
00193   \}\par
00194   {\cf19 return} ConcatPaths(directory, FilePath(file));\par
00195 \}\par
00196 \par
00197 {\cf20 // Given directory = "dir", relative_path = "test.xml", returns "dir/test.xml".}\par
00198 {\cf20 // On Windows, uses \\ as the separator rather than /.}\par
00199 FilePath FilePath::ConcatPaths({\cf17 const} FilePath& directory,\par
00200                                {\cf17 const} FilePath& relative_path) \{\par
00201   {\cf19 if} (directory.IsEmpty())\par
00202     {\cf19 return} relative_path;\par
00203   {\cf17 const} FilePath dir(directory.RemoveTrailingPathSeparator());\par
00204   {\cf19 return} FilePath(dir.string() + kPathSeparator + relative_path.string());\par
00205 \}\par
00206 \par
00207 {\cf20 // Returns true if pathname describes something findable in the file-system,}\par
00208 {\cf20 // either a file, directory, or whatever.}\par
00209 {\cf18 bool} FilePath::FileOrDirectoryExists(){\cf17  const }\{\par
00210 {\cf21 #if GTEST_OS_WINDOWS_MOBILE}\par
00211   LPCWSTR unicode = String::AnsiToUtf16(pathname_.c_str());\par
00212   {\cf17 const} DWORD attributes = GetFileAttributes(unicode);\par
00213   {\cf17 delete} [] unicode;\par
00214   {\cf19 return} attributes != kInvalidFileAttributes;\par
00215 {\cf21 #else}\par
00216   posix::StatStruct file_stat;\par
00217   {\cf19 return} posix::Stat(pathname_.c_str(), &file_stat) == 0;\par
00218 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
00219 \}\par
00220 \par
00221 {\cf20 // Returns true if pathname describes a directory in the file-system}\par
00222 {\cf20 // that exists.}\par
00223 {\cf18 bool} FilePath::DirectoryExists(){\cf17  const }\{\par
00224   {\cf18 bool} result = {\cf17 false};\par
00225 {\cf21 #if GTEST_OS_WINDOWS}\par
00226   {\cf20 // Don't strip off trailing separator if path is a root directory on}\par
00227   {\cf20 // Windows (like "C:\\\\").}\par
00228   {\cf17 const} FilePath& path(IsRootDirectory() ? *{\cf17 this} :\par
00229                                            RemoveTrailingPathSeparator());\par
00230 {\cf21 #else}\par
00231   {\cf17 const} FilePath& path(*{\cf17 this});\par
00232 {\cf21 #endif}\par
00233 \par
00234 {\cf21 #if GTEST_OS_WINDOWS_MOBILE}\par
00235   LPCWSTR unicode = String::AnsiToUtf16(path.c_str());\par
00236   {\cf17 const} DWORD attributes = GetFileAttributes(unicode);\par
00237   {\cf17 delete} [] unicode;\par
00238   {\cf19 if} ((attributes != kInvalidFileAttributes) &&\par
00239       (attributes & FILE_ATTRIBUTE_DIRECTORY)) \{\par
00240     result = {\cf17 true};\par
00241   \}\par
00242 {\cf21 #else}\par
00243   posix::StatStruct file_stat;\par
00244   result = posix::Stat(path.c_str(), &file_stat) == 0 &&\par
00245       posix::IsDir(file_stat);\par
00246 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
00247 \par
00248   {\cf19 return} result;\par
00249 \}\par
00250 \par
00251 {\cf20 // Returns true if pathname describes a root directory. (Windows has one}\par
00252 {\cf20 // root directory per disk drive.)}\par
00253 {\cf18 bool} FilePath::IsRootDirectory(){\cf17  const }\{\par
00254 {\cf21 #if GTEST_OS_WINDOWS}\par
00255   {\cf20 // TODO(wan@google.com): on Windows a network share like}\par
00256   {\cf20 // \\\\server\\share can be a root directory, although it cannot be the}\par
00257   {\cf20 // current directory.  Handle this properly.}\par
00258   {\cf19 return} pathname_.length() == 3 && IsAbsolutePath();\par
00259 {\cf21 #else}\par
00260   {\cf19 return} pathname_.length() == 1 && IsPathSeparator(pathname_.c_str()[0]);\par
00261 {\cf21 #endif}\par
00262 \}\par
00263 \par
00264 {\cf20 // Returns true if pathname describes an absolute path.}\par
00265 {\cf18 bool} FilePath::IsAbsolutePath(){\cf17  const }\{\par
00266   {\cf17 const} {\cf18 char}* {\cf17 const} name = pathname_.c_str();\par
00267 {\cf21 #if GTEST_OS_WINDOWS}\par
00268   {\cf19 return} pathname_.length() >= 3 &&\par
00269      ((name[0] >= {\cf23 'a'} && name[0] <= {\cf23 'z'}) ||\par
00270       (name[0] >= {\cf23 'A'} && name[0] <= {\cf23 'Z'})) &&\par
00271      name[1] == {\cf23 ':'} &&\par
00272      IsPathSeparator(name[2]);\par
00273 {\cf21 #else}\par
00274   {\cf19 return} IsPathSeparator(name[0]);\par
00275 {\cf21 #endif}\par
00276 \}\par
00277 \par
00278 {\cf20 // Returns a pathname for a file that does not currently exist. The pathname}\par
00279 {\cf20 // will be directory/base_name.extension or}\par
00280 {\cf20 // directory/base_name_<number>.extension if directory/base_name.extension}\par
00281 {\cf20 // already exists. The number will be incremented until a pathname is found}\par
00282 {\cf20 // that does not already exist.}\par
00283 {\cf20 // Examples: 'dir/foo_test.xml' or 'dir/foo_test_1.xml'.}\par
00284 {\cf20 // There could be a race condition if two or more processes are calling this}\par
00285 {\cf20 // function at the same time -- they could both pick the same filename.}\par
00286 FilePath FilePath::GenerateUniqueFileName({\cf17 const} FilePath& directory,\par
00287                                           {\cf17 const} FilePath& base_name,\par
00288                                           {\cf17 const} {\cf18 char}* extension) \{\par
00289   FilePath full_pathname;\par
00290   {\cf18 int} number = 0;\par
00291   {\cf19 do} \{\par
00292     full_pathname.Set(MakeFileName(directory, base_name, number++, extension));\par
00293   \} {\cf19 while} (full_pathname.FileOrDirectoryExists());\par
00294   {\cf19 return} full_pathname;\par
00295 \}\par
00296 \par
00297 {\cf20 // Returns true if FilePath ends with a path separator, which indicates that}\par
00298 {\cf20 // it is intended to represent a directory. Returns false otherwise.}\par
00299 {\cf20 // This does NOT check that a directory (or file) actually exists.}\par
00300 {\cf18 bool} FilePath::IsDirectory(){\cf17  const }\{\par
00301   {\cf19 return} !pathname_.empty() &&\par
00302          IsPathSeparator(pathname_.c_str()[pathname_.length() - 1]);\par
00303 \}\par
00304 \par
00305 {\cf20 // Create directories so that path exists. Returns true if successful or if}\par
00306 {\cf20 // the directories already exist; returns false if unable to create directories}\par
00307 {\cf20 // for any reason.}\par
00308 {\cf18 bool} FilePath::CreateDirectoriesRecursively(){\cf17  const }\{\par
00309   {\cf19 if} (!this->IsDirectory()) \{\par
00310     {\cf19 return} {\cf17 false};\par
00311   \}\par
00312 \par
00313   {\cf19 if} (pathname_.length() == 0 || this->DirectoryExists()) \{\par
00314     {\cf19 return} {\cf17 true};\par
00315   \}\par
00316 \par
00317   {\cf17 const} FilePath parent(this->RemoveTrailingPathSeparator().RemoveFileName());\par
00318   {\cf19 return} parent.CreateDirectoriesRecursively() && this->CreateFolder();\par
00319 \}\par
00320 \par
00321 {\cf20 // Create the directory so that path exists. Returns true if successful or}\par
00322 {\cf20 // if the directory already exists; returns false if unable to create the}\par
00323 {\cf20 // directory for any reason, including if the parent directory does not}\par
00324 {\cf20 // exist. Not named "CreateDirectory" because that's a macro on Windows.}\par
00325 {\cf18 bool} FilePath::CreateFolder(){\cf17  const }\{\par
00326 {\cf21 #if GTEST_OS_WINDOWS_MOBILE}\par
00327   FilePath removed_sep(this->RemoveTrailingPathSeparator());\par
00328   LPCWSTR unicode = String::AnsiToUtf16(removed_sep.c_str());\par
00329   {\cf18 int} result = CreateDirectory(unicode, NULL) ? 0 : -1;\par
00330   {\cf17 delete} [] unicode;\par
00331 {\cf21 #elif GTEST_OS_WINDOWS}\par
00332   {\cf18 int} result = _mkdir(pathname_.c_str());\par
00333 {\cf21 #else}\par
00334   {\cf18 int} result = mkdir(pathname_.c_str(), 0777);\par
00335 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
00336 \par
00337   {\cf19 if} (result == -1) \{\par
00338     {\cf19 return} this->DirectoryExists();  {\cf20 // An error is OK if the directory exists.}\par
00339   \}\par
00340   {\cf19 return} {\cf17 true};  {\cf20 // No error.}\par
00341 \}\par
00342 \par
00343 {\cf20 // If input name has a trailing separator character, remove it and return the}\par
00344 {\cf20 // name, otherwise return the name string unmodified.}\par
00345 {\cf20 // On Windows platform, uses \\ as the separator, other platforms use /.}\par
00346 FilePath FilePath::RemoveTrailingPathSeparator(){\cf17  const }\{\par
00347   {\cf19 return} IsDirectory()\par
00348       ? FilePath(pathname_.substr(0, pathname_.length() - 1))\par
00349       : *{\cf17 this};\par
00350 \}\par
00351 \par
00352 {\cf20 // Removes any redundant separators that might be in the pathname.}\par
00353 {\cf20 // For example, "bar///foo" becomes "bar/foo". Does not eliminate other}\par
00354 {\cf20 // redundancies that might be in a pathname involving "." or "..".}\par
00355 {\cf20 // TODO(wan@google.com): handle Windows network shares (e.g. \\\\server\\share).}\par
00356 {\cf18 void} FilePath::Normalize() \{\par
00357   {\cf19 if} (pathname_.c_str() == NULL) \{\par
00358     pathname_ = {\cf22 ""};\par
00359     {\cf19 return};\par
00360   \}\par
00361   {\cf17 const} {\cf18 char}* src = pathname_.c_str();\par
00362   {\cf18 char}* {\cf17 const} dest = {\cf17 new} {\cf18 char}[pathname_.length() + 1];\par
00363   {\cf18 char}* dest_ptr = dest;\par
00364   memset(dest_ptr, 0, pathname_.length() + 1);\par
00365 \par
00366   {\cf19 while} (*src != {\cf23 '\\0'}) \{\par
00367     *dest_ptr = *src;\par
00368     {\cf19 if} (!IsPathSeparator(*src)) \{\par
00369       src++;\par
00370     \} {\cf19 else} \{\par
00371 {\cf21 #if GTEST_HAS_ALT_PATH_SEP_}\par
00372       {\cf19 if} (*dest_ptr == kAlternatePathSeparator) \{\par
00373         *dest_ptr = kPathSeparator;\par
00374       \}\par
00375 {\cf21 #endif}\par
00376       {\cf19 while} (IsPathSeparator(*src))\par
00377         src++;\par
00378     \}\par
00379     dest_ptr++;\par
00380   \}\par
00381   *dest_ptr = {\cf23 '\\0'};\par
00382   pathname_ = dest;\par
00383   {\cf17 delete}[] dest;\par
00384 \}\par
00385 \par
00386 \}  {\cf20 // namespace internal}\par
00387 \}  {\cf20 // namespace testing}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/src/gtest-internal-inl.h\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-internal-inl.h}
{\xe \v gtest/src/gtest-internal-inl.h}
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <errno.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <string>}\par
{\f2 #include <vector>}\par
{\f2 #include "gtest/internal/gtest-port.h"}\par
{\f2 #include "gtest/gtest.h"}\par
{\f2 #include "gtest/gtest-spi.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::GTestFlagSaver}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::TestPropertyKeyIs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::UnitTestOptions}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::OsStackTraceGetterInterface}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::OsStackTraceGetter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b testing::internal::TraceInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::DefaultGlobalTestPartResultReporter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::DefaultPerThreadTestPartResultReporter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::UnitTestImpl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::TestResultAccessor}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DECLARE_bool_} (death_test_use_fork)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} TimeInMillis {\b testing::internal::GetTimeInMillis} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::ShouldUseColor} (bool stdout_is_tty)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::FormatTimeInMillisAsSeconds} (TimeInMillis ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::FormatEpochTimeInMillisAsIso8601} (TimeInMillis ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::ParseInt32Flag} (const char *str, const char *flag, Int32 *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b testing::internal::GetRandomSeedFromFlag} (Int32 random_seed_flag)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b testing::internal::GetNextRandomSeed} (int seed)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::CodePointToUtf8} (UInt32 code_point)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::WideStringToUtf8} (const wchar_t *str, int num_chars)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::WriteToShardStatusFileIfNeeded} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::ShouldShard} (const char *total_shards_str, const char *shard_index_str, bool in_subprocess_for_death_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} Int32 {\b testing::internal::Int32FromEnvOrDie} (const char *env_var, Int32 default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::ShouldRunTestOnShard} (int total_shards, int shard_index, int test_id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Container , typename Predicate > int {\b testing::internal::CountIf} (const Container &c, Predicate predicate)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Container , typename Functor > void {\b testing::internal::ForEach} (const Container &c, Functor functor)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename E > E {\b testing::internal::GetElementOr} (const std::vector< E > &v, int i, E default_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename E > void {\b testing::internal::ShuffleRange} (internal::Random *random, int begin, int end, std::vector< E > *v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename E > void {\b testing::internal::Shuffle} (internal::Random *random, std::vector< E > *v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} FilePath {\b testing::internal::GetCurrentExecutableName} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class UnitTestImpl * {\b testing::internal::GetUnitTestImpl} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::ParseGoogleTestFlagsOnly} (int *argc, char **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::ParseGoogleTestFlagsOnly} (int *argc, wchar_t **argv)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} const TypeId {\b testing::internal::kTestTypeIdInGoogleTest} = GetTestTypeId()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kAlsoRunDisabledTestsFlag} [] = "also_run_disabled_tests"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kBreakOnFailureFlag} [] = "break_on_failure"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kCatchExceptionsFlag} [] = "catch_exceptions"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kColorFlag} [] = "color"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kFilterFlag} [] = "filter"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kListTestsFlag} [] = "list_tests"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kOutputFlag} [] = "output"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kPrintTimeFlag} [] = "print_time"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kRandomSeedFlag} [] = "random_seed"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kRepeatFlag} [] = "repeat"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kShuffleFlag} [] = "shuffle"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kStackTraceDepthFlag} [] = "stack_trace_depth"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kStreamResultToFlag} [] = "stream_result_to"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kThrowOnFailureFlag} [] = "throw_on_failure"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kFlagfileFlag} [] = "flagfile"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b testing::internal::kMaxRandomSeed} = 99999\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::g_help_flag} = false\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-internal-inl.h\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-internal-inl.h}
{\xe \v gtest/src/gtest-internal-inl.h}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2005, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 \par
00030 {\cf20 // Utility functions and classes used by the Google C++ testing framework.}\par
00031 {\cf20 //}\par
00032 {\cf20 // Author: wan@google.com (Zhanyong Wan)}\par
00033 {\cf20 //}\par
00034 {\cf20 // This file contains purely Google Test's internal implementation.  Please}\par
00035 {\cf20 // DO NOT #INCLUDE IT IN A USER PROGRAM.}\par
00036 \par
00037 {\cf21 #ifndef GTEST_SRC_GTEST_INTERNAL_INL_H_}\par
00038 {\cf21 #define GTEST_SRC_GTEST_INTERNAL_INL_H_}\par
00039 \par
00040 {\cf20 // GTEST_IMPLEMENTATION_ is defined to 1 iff the current translation unit is}\par
00041 {\cf20 // part of Google Test's implementation; otherwise it's undefined.}\par
00042 {\cf21 #if !GTEST_IMPLEMENTATION_}\par
00043 {\cf20 // If this file is included from the user's code, just say no.}\par
00044 {\cf21 # error "gtest-internal-inl.h is part of Google Test's internal implementation."}\par
00045 {\cf21 # error "It must not be included except by Google Test itself."}\par
00046 {\cf21 #endif  }{\cf20 // GTEST_IMPLEMENTATION_}\par
00047 \par
00048 {\cf21 #ifndef _WIN32_WCE}\par
00049 {\cf21 # include <errno.h>}\par
00050 {\cf21 #endif  }{\cf20 // !_WIN32_WCE}\par
00051 {\cf21 #include <stddef.h>}\par
00052 {\cf21 #include <stdlib.h>}  {\cf20 // For strtoll/_strtoul64/malloc/free.}\par
00053 {\cf21 #include <string.h>}  {\cf20 // For memmove.}\par
00054 \par
00055 {\cf21 #include <algorithm>}\par
00056 {\cf21 #include <string>}\par
00057 {\cf21 #include <vector>}\par
00058 \par
00059 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00060 \par
00061 {\cf21 #if GTEST_CAN_STREAM_RESULTS_}\par
00062 {\cf21 # include <arpa/inet.h>}  {\cf20 // NOLINT}\par
00063 {\cf21 # include <netdb.h>}  {\cf20 // NOLINT}\par
00064 {\cf21 #endif}\par
00065 \par
00066 {\cf21 #if GTEST_OS_WINDOWS}\par
00067 {\cf21 # include <windows.h>}  {\cf20 // NOLINT}\par
00068 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
00069 \par
00070 {\cf21 #include "gtest/gtest.h"}  {\cf20 // NOLINT}\par
00071 {\cf21 #include "gtest/gtest-spi.h"}\par
00072 \par
00073 {\cf17 namespace }testing \{\par
00074 \par
00075 {\cf20 // Declares the flags.}\par
00076 {\cf20 //}\par
00077 {\cf20 // We don't want the users to modify this flag in the code, but want}\par
00078 {\cf20 // Google Test's own unit tests to be able to access it. Therefore we}\par
00079 {\cf20 // declare it here as opposed to in gtest.h.}\par
00080 GTEST_DECLARE_bool_(death_test_use_fork);\par
00081 \par
00082 {\cf17 namespace }internal \{\par
00083 \par
00084 {\cf20 // The value of GetTestTypeId() as seen from within the Google Test}\par
00085 {\cf20 // library.  This is solely for testing GetTestTypeId().}\par
00086 GTEST_API_ {\cf17 extern} {\cf17 const} TypeId kTestTypeIdInGoogleTest;\par
00087 \par
00088 {\cf20 // Names of the flags (needed for parsing Google Test flags).}\par
00089 {\cf17 const} {\cf18 char} kAlsoRunDisabledTestsFlag[] = {\cf22 "also_run_disabled_tests"};\par
00090 {\cf17 const} {\cf18 char} kBreakOnFailureFlag[] = {\cf22 "break_on_failure"};\par
00091 {\cf17 const} {\cf18 char} kCatchExceptionsFlag[] = {\cf22 "catch_exceptions"};\par
00092 {\cf17 const} {\cf18 char} kColorFlag[] = {\cf22 "color"};\par
00093 {\cf17 const} {\cf18 char} kFilterFlag[] = {\cf22 "filter"};\par
00094 {\cf17 const} {\cf18 char} kListTestsFlag[] = {\cf22 "list_tests"};\par
00095 {\cf17 const} {\cf18 char} kOutputFlag[] = {\cf22 "output"};\par
00096 {\cf17 const} {\cf18 char} kPrintTimeFlag[] = {\cf22 "print_time"};\par
00097 {\cf17 const} {\cf18 char} kRandomSeedFlag[] = {\cf22 "random_seed"};\par
00098 {\cf17 const} {\cf18 char} kRepeatFlag[] = {\cf22 "repeat"};\par
00099 {\cf17 const} {\cf18 char} kShuffleFlag[] = {\cf22 "shuffle"};\par
00100 {\cf17 const} {\cf18 char} kStackTraceDepthFlag[] = {\cf22 "stack_trace_depth"};\par
00101 {\cf17 const} {\cf18 char} kStreamResultToFlag[] = {\cf22 "stream_result_to"};\par
00102 {\cf17 const} {\cf18 char} kThrowOnFailureFlag[] = {\cf22 "throw_on_failure"};\par
00103 {\cf17 const} {\cf18 char} kFlagfileFlag[] = {\cf22 "flagfile"};\par
00104 \par
00105 {\cf20 // A valid random seed must be in [1, kMaxRandomSeed].}\par
00106 {\cf17 const} {\cf18 int} kMaxRandomSeed = 99999;\par
00107 \par
00108 {\cf20 // g_help_flag is true iff the --help flag or an equivalent form is}\par
00109 {\cf20 // specified on the command line.}\par
00110 GTEST_API_ {\cf17 extern} {\cf18 bool} g_help_flag;\par
00111 \par
00112 {\cf20 // Returns the current time in milliseconds.}\par
00113 GTEST_API_ TimeInMillis GetTimeInMillis();\par
00114 \par
00115 {\cf20 // Returns true iff Google Test should use colors in the output.}\par
00116 GTEST_API_ {\cf18 bool} ShouldUseColor({\cf18 bool} stdout_is_tty);\par
00117 \par
00118 {\cf20 // Formats the given time in milliseconds as seconds.}\par
00119 GTEST_API_ std::string FormatTimeInMillisAsSeconds(TimeInMillis ms);\par
00120 \par
00121 {\cf20 // Converts the given time in milliseconds to a date string in the ISO 8601}\par
00122 {\cf20 // format, without the timezone information.  N.B.: due to the use the}\par
00123 {\cf20 // non-reentrant localtime() function, this function is not thread safe.  Do}\par
00124 {\cf20 // not use it in any code that can be called from multiple threads.}\par
00125 GTEST_API_ std::string FormatEpochTimeInMillisAsIso8601(TimeInMillis ms);\par
00126 \par
00127 {\cf20 // Parses a string for an Int32 flag, in the form of "--flag=value".}\par
00128 {\cf20 //}\par
00129 {\cf20 // On success, stores the value of the flag in *value, and returns}\par
00130 {\cf20 // true.  On failure, returns false without changing *value.}\par
00131 GTEST_API_ {\cf18 bool} ParseInt32Flag(\par
00132     {\cf17 const} {\cf18 char}* str, {\cf17 const} {\cf18 char}* flag, Int32* value);\par
00133 \par
00134 {\cf20 // Returns a random seed in range [1, kMaxRandomSeed] based on the}\par
00135 {\cf20 // given --gtest_random_seed flag value.}\par
00136 {\cf17 inline} {\cf18 int} GetRandomSeedFromFlag(Int32 random_seed_flag) \{\par
00137   {\cf17 const} {\cf18 unsigned} {\cf18 int} raw_seed = (random_seed_flag == 0) ?\par
00138       {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(GetTimeInMillis()) :\par
00139       {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(random_seed_flag);\par
00140 \par
00141   {\cf20 // Normalizes the actual seed to range [1, kMaxRandomSeed] such that}\par
00142   {\cf20 // it's easy to type.}\par
00143   {\cf17 const} {\cf18 int} normalized_seed =\par
00144       {\cf17 static_cast<}{\cf18 int}{\cf17 >}((raw_seed - 1U) %\par
00145                        {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(kMaxRandomSeed)) + 1;\par
00146   {\cf19 return} normalized_seed;\par
00147 \}\par
00148 \par
00149 {\cf20 // Returns the first valid random seed after 'seed'.  The behavior is}\par
00150 {\cf20 // undefined if 'seed' is invalid.  The seed after kMaxRandomSeed is}\par
00151 {\cf20 // considered to be 1.}\par
00152 {\cf17 inline} {\cf18 int} GetNextRandomSeed({\cf18 int} seed) \{\par
00153   GTEST_CHECK_(1 <= seed && seed <= kMaxRandomSeed)\par
00154       << {\cf22 "Invalid random seed "} << seed << {\cf22 " - must be in [1, "}\par
00155       << kMaxRandomSeed << {\cf22 "]."};\par
00156   {\cf17 const} {\cf18 int} next_seed = seed + 1;\par
00157   {\cf19 return} (next_seed > kMaxRandomSeed) ? 1 : next_seed;\par
00158 \}\par
00159 \par
00160 {\cf20 // This class saves the values of all Google Test flags in its c'tor, and}\par
00161 {\cf20 // restores them in its d'tor.}\par
00162 {\cf17 class }GTestFlagSaver \{\par
00163  {\cf17 public}:\par
00164   {\cf20 // The c'tor.}\par
00165   GTestFlagSaver() \{\par
00166     also_run_disabled_tests_ = GTEST_FLAG(also_run_disabled_tests);\par
00167     break_on_failure_ = GTEST_FLAG(break_on_failure);\par
00168     catch_exceptions_ = GTEST_FLAG(catch_exceptions);\par
00169     color_ = GTEST_FLAG(color);\par
00170     death_test_style_ = GTEST_FLAG(death_test_style);\par
00171     death_test_use_fork_ = GTEST_FLAG(death_test_use_fork);\par
00172     filter_ = GTEST_FLAG(filter);\par
00173     internal_run_death_test_ = GTEST_FLAG(internal_run_death_test);\par
00174     list_tests_ = GTEST_FLAG(list_tests);\par
00175     output_ = GTEST_FLAG(output);\par
00176     print_time_ = GTEST_FLAG(print_time);\par
00177     random_seed_ = GTEST_FLAG(random_seed);\par
00178     repeat_ = GTEST_FLAG(repeat);\par
00179     shuffle_ = GTEST_FLAG(shuffle);\par
00180     stack_trace_depth_ = GTEST_FLAG(stack_trace_depth);\par
00181     stream_result_to_ = GTEST_FLAG(stream_result_to);\par
00182     throw_on_failure_ = GTEST_FLAG(throw_on_failure);\par
00183   \}\par
00184 \par
00185   {\cf20 // The d'tor is not virtual.  DO NOT INHERIT FROM THIS CLASS.}\par
00186   ~GTestFlagSaver() \{\par
00187     GTEST_FLAG(also_run_disabled_tests) = also_run_disabled_tests_;\par
00188     GTEST_FLAG(break_on_failure) = break_on_failure_;\par
00189     GTEST_FLAG(catch_exceptions) = catch_exceptions_;\par
00190     GTEST_FLAG(color) = color_;\par
00191     GTEST_FLAG(death_test_style) = death_test_style_;\par
00192     GTEST_FLAG(death_test_use_fork) = death_test_use_fork_;\par
00193     GTEST_FLAG(filter) = filter_;\par
00194     GTEST_FLAG(internal_run_death_test) = internal_run_death_test_;\par
00195     GTEST_FLAG(list_tests) = list_tests_;\par
00196     GTEST_FLAG(output) = output_;\par
00197     GTEST_FLAG(print_time) = print_time_;\par
00198     GTEST_FLAG(random_seed) = random_seed_;\par
00199     GTEST_FLAG(repeat) = repeat_;\par
00200     GTEST_FLAG(shuffle) = shuffle_;\par
00201     GTEST_FLAG(stack_trace_depth) = stack_trace_depth_;\par
00202     GTEST_FLAG(stream_result_to) = stream_result_to_;\par
00203     GTEST_FLAG(throw_on_failure) = throw_on_failure_;\par
00204   \}\par
00205 \par
00206  {\cf17 private}:\par
00207   {\cf20 // Fields for saving the original values of flags.}\par
00208   {\cf18 bool} also_run_disabled_tests_;\par
00209   {\cf18 bool} break_on_failure_;\par
00210   {\cf18 bool} catch_exceptions_;\par
00211   std::string color_;\par
00212   std::string death_test_style_;\par
00213   {\cf18 bool} death_test_use_fork_;\par
00214   std::string filter_;\par
00215   std::string internal_run_death_test_;\par
00216   {\cf18 bool} list_tests_;\par
00217   std::string output_;\par
00218   {\cf18 bool} print_time_;\par
00219   internal::Int32 random_seed_;\par
00220   internal::Int32 repeat_;\par
00221   {\cf18 bool} shuffle_;\par
00222   internal::Int32 stack_trace_depth_;\par
00223   std::string stream_result_to_;\par
00224   {\cf18 bool} throw_on_failure_;\par
00225 \} GTEST_ATTRIBUTE_UNUSED_;\par
00226 \par
00227 {\cf20 // Converts a Unicode code point to a narrow string in UTF-8 encoding.}\par
00228 {\cf20 // code_point parameter is of type UInt32 because wchar_t may not be}\par
00229 {\cf20 // wide enough to contain a code point.}\par
00230 {\cf20 // If the code_point is not a valid Unicode code point}\par
00231 {\cf20 // (i.e. outside of Unicode range U+0 to U+10FFFF) it will be converted}\par
00232 {\cf20 // to "(Invalid Unicode 0xXXXXXXXX)".}\par
00233 GTEST_API_ std::string CodePointToUtf8(UInt32 code_point);\par
00234 \par
00235 {\cf20 // Converts a wide string to a narrow string in UTF-8 encoding.}\par
00236 {\cf20 // The wide string is assumed to have the following encoding:}\par
00237 {\cf20 //   UTF-16 if sizeof(wchar_t) == 2 (on Windows, Cygwin, Symbian OS)}\par
00238 {\cf20 //   UTF-32 if sizeof(wchar_t) == 4 (on Linux)}\par
00239 {\cf20 // Parameter str points to a null-terminated wide string.}\par
00240 {\cf20 // Parameter num_chars may additionally limit the number}\par
00241 {\cf20 // of wchar_t characters processed. -1 is used when the entire string}\par
00242 {\cf20 // should be processed.}\par
00243 {\cf20 // If the string contains code points that are not valid Unicode code points}\par
00244 {\cf20 // (i.e. outside of Unicode range U+0 to U+10FFFF) they will be output}\par
00245 {\cf20 // as '(Invalid Unicode 0xXXXXXXXX)'. If the string is in UTF16 encoding}\par
00246 {\cf20 // and contains invalid UTF-16 surrogate pairs, values in those pairs}\par
00247 {\cf20 // will be encoded as individual Unicode characters from Basic Normal Plane.}\par
00248 GTEST_API_ std::string WideStringToUtf8({\cf17 const} {\cf18 wchar_t}* str, {\cf18 int} num_chars);\par
00249 \par
00250 {\cf20 // Reads the GTEST_SHARD_STATUS_FILE environment variable, and creates the file}\par
00251 {\cf20 // if the variable is present. If a file already exists at this location, this}\par
00252 {\cf20 // function will write over it. If the variable is present, but the file cannot}\par
00253 {\cf20 // be created, prints an error and exits.}\par
00254 {\cf18 void} WriteToShardStatusFileIfNeeded();\par
00255 \par
00256 {\cf20 // Checks whether sharding is enabled by examining the relevant}\par
00257 {\cf20 // environment variable values. If the variables are present,}\par
00258 {\cf20 // but inconsistent (e.g., shard_index >= total_shards), prints}\par
00259 {\cf20 // an error and exits. If in_subprocess_for_death_test, sharding is}\par
00260 {\cf20 // disabled because it must only be applied to the original test}\par
00261 {\cf20 // process. Otherwise, we could filter out death tests we intended to execute.}\par
00262 GTEST_API_ {\cf18 bool} ShouldShard({\cf17 const} {\cf18 char}* total_shards_str,\par
00263                             {\cf17 const} {\cf18 char}* shard_index_str,\par
00264                             {\cf18 bool} in_subprocess_for_death_test);\par
00265 \par
00266 {\cf20 // Parses the environment variable var as an Int32. If it is unset,}\par
00267 {\cf20 // returns default_val. If it is not an Int32, prints an error and}\par
00268 {\cf20 // and aborts.}\par
00269 GTEST_API_ Int32 Int32FromEnvOrDie({\cf17 const} {\cf18 char}* env_var, Int32 default_val);\par
00270 \par
00271 {\cf20 // Given the total number of shards, the shard index, and the test id,}\par
00272 {\cf20 // returns true iff the test should be run on this shard. The test id is}\par
00273 {\cf20 // some arbitrary but unique non-negative integer assigned to each test}\par
00274 {\cf20 // method. Assumes that 0 <= shard_index < total_shards.}\par
00275 GTEST_API_ {\cf18 bool} ShouldRunTestOnShard(\par
00276     {\cf18 int} total_shards, {\cf18 int} shard_index, {\cf18 int} test_id);\par
00277 \par
00278 {\cf20 // STL container utilities.}\par
00279 \par
00280 {\cf20 // Returns the number of elements in the given container that satisfy}\par
00281 {\cf20 // the given predicate.}\par
00282 {\cf17 template} <{\cf17 class} Container, {\cf17 typename} Predicate>\par
00283 {\cf17 inline} {\cf18 int} CountIf({\cf17 const} Container& c, Predicate predicate) \{\par
00284   {\cf20 // Implemented as an explicit loop since std::count_if() in libCstd on}\par
00285   {\cf20 // Solaris has a non-standard signature.}\par
00286   {\cf18 int} count = 0;\par
00287   {\cf19 for} ({\cf17 typename} Container::const_iterator it = c.begin(); it != c.end(); ++it) \{\par
00288     {\cf19 if} (predicate(*it))\par
00289       ++count;\par
00290   \}\par
00291   {\cf19 return} count;\par
00292 \}\par
00293 \par
00294 {\cf20 // Applies a function/functor to each element in the container.}\par
00295 {\cf17 template} <{\cf17 class} Container, {\cf17 typename} Functor>\par
00296 {\cf18 void} ForEach({\cf17 const} Container& c, Functor functor) \{\par
00297   std::for_each(c.begin(), c.end(), functor);\par
00298 \}\par
00299 \par
00300 {\cf20 // Returns the i-th element of the vector, or default_value if i is not}\par
00301 {\cf20 // in range [0, v.size()).}\par
00302 {\cf17 template} <{\cf17 typename} E>\par
00303 {\cf17 inline} E GetElementOr({\cf17 const} std::vector<E>& v, {\cf18 int} i, E default_value) \{\par
00304   {\cf19 return} (i < 0 || i >= {\cf17 static_cast<}{\cf18 int}{\cf17 >}(v.size())) ? default_value : v[i];\par
00305 \}\par
00306 \par
00307 {\cf20 // Performs an in-place shuffle of a range of the vector's elements.}\par
00308 {\cf20 // 'begin' and 'end' are element indices as an STL-style range;}\par
00309 {\cf20 // i.e. [begin, end) are shuffled, where 'end' == size() means to}\par
00310 {\cf20 // shuffle to the end of the vector.}\par
00311 {\cf17 template} <{\cf17 typename} E>\par
00312 {\cf18 void} ShuffleRange(internal::Random* random, {\cf18 int} begin, {\cf18 int} end,\par
00313                   std::vector<E>* v) \{\par
00314   {\cf17 const} {\cf18 int} size = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(v->size());\par
00315   GTEST_CHECK_(0 <= begin && begin <= size)\par
00316       << {\cf22 "Invalid shuffle range start "} << begin << {\cf22 ": must be in range [0, "}\par
00317       << size << {\cf22 "]."};\par
00318   GTEST_CHECK_(begin <= end && end <= size)\par
00319       << {\cf22 "Invalid shuffle range finish "} << end << {\cf22 ": must be in range ["}\par
00320       << begin << {\cf22 ", "} << size << {\cf22 "]."};\par
00321 \par
00322   {\cf20 // Fisher-Yates shuffle, from}\par
00323   {\cf20 // http://en.wikipedia.org/wiki/Fisher-Yates_shuffle}\par
00324   {\cf19 for} ({\cf18 int} range_width = end - begin; range_width >= 2; range_width--) \{\par
00325     {\cf17 const} {\cf18 int} last_in_range = begin + range_width - 1;\par
00326     {\cf17 const} {\cf18 int} selected = begin + random->Generate(range_width);\par
00327     std::swap((*v)[selected], (*v)[last_in_range]);\par
00328   \}\par
00329 \}\par
00330 \par
00331 {\cf20 // Performs an in-place shuffle of the vector's elements.}\par
00332 {\cf17 template} <{\cf17 typename} E>\par
00333 {\cf17 inline} {\cf18 void} Shuffle(internal::Random* random, std::vector<E>* v) \{\par
00334   ShuffleRange(random, 0, {\cf17 static_cast<}{\cf18 int}{\cf17 >}(v->size()), v);\par
00335 \}\par
00336 \par
00337 {\cf20 // A function for deleting an object.  Handy for being used as a}\par
00338 {\cf20 // functor.}\par
00339 {\cf17 template} <{\cf17 typename} T>\par
00340 {\cf17 static} {\cf18 void} Delete(T* x) \{\par
00341   {\cf17 delete} x;\par
00342 \}\par
00343 \par
00344 {\cf20 // A predicate that checks the key of a TestProperty against a known key.}\par
00345 {\cf20 //}\par
00346 {\cf20 // TestPropertyKeyIs is copyable.}\par
00347 {\cf17 class }TestPropertyKeyIs \{\par
00348  {\cf17 public}:\par
00349   {\cf20 // Constructor.}\par
00350   {\cf20 //}\par
00351   {\cf20 // TestPropertyKeyIs has NO default constructor.}\par
00352   {\cf17 explicit} TestPropertyKeyIs({\cf17 const} std::string& key) : key_(key) \{\}\par
00353 \par
00354   {\cf20 // Returns true iff the test name of test property matches on key_.}\par
00355   {\cf18 bool} operator()({\cf17 const} TestProperty& test_property){\cf17  const }\{\par
00356     {\cf19 return} test_property.key() == key_;\par
00357   \}\par
00358 \par
00359  {\cf17 private}:\par
00360   std::string key_;\par
00361 \};\par
00362 \par
00363 {\cf20 // Class UnitTestOptions.}\par
00364 {\cf20 //}\par
00365 {\cf20 // This class contains functions for processing options the user}\par
00366 {\cf20 // specifies when running the tests.  It has only static members.}\par
00367 {\cf20 //}\par
00368 {\cf20 // In most cases, the user can specify an option using either an}\par
00369 {\cf20 // environment variable or a command line flag.  E.g. you can set the}\par
00370 {\cf20 // test filter using either GTEST_FILTER or --gtest_filter.  If both}\par
00371 {\cf20 // the variable and the flag are present, the latter overrides the}\par
00372 {\cf20 // former.}\par
00373 {\cf17 class }GTEST_API_ UnitTestOptions \{\par
00374  {\cf17 public}:\par
00375   {\cf20 // Functions for processing the gtest_output flag.}\par
00376 \par
00377   {\cf20 // Returns the output format, or "" for normal printed output.}\par
00378   {\cf17 static} std::string GetOutputFormat();\par
00379 \par
00380   {\cf20 // Returns the absolute path of the requested output file, or the}\par
00381   {\cf20 // default (test_detail.xml in the original working directory) if}\par
00382   {\cf20 // none was explicitly specified.}\par
00383   {\cf17 static} std::string GetAbsolutePathToOutputFile();\par
00384 \par
00385   {\cf20 // Functions for processing the gtest_filter flag.}\par
00386 \par
00387   {\cf20 // Returns true iff the wildcard pattern matches the string.  The}\par
00388   {\cf20 // first ':' or '\\0' character in pattern marks the end of it.}\par
00389   {\cf20 //}\par
00390   {\cf20 // This recursive algorithm isn't very efficient, but is clear and}\par
00391   {\cf20 // works well enough for matching test names, which are short.}\par
00392   {\cf17 static} {\cf18 bool} PatternMatchesString({\cf17 const} {\cf18 char} *pattern, {\cf17 const} {\cf18 char} *str);\par
00393 \par
00394   {\cf20 // Returns true iff the user-specified filter matches the test case}\par
00395   {\cf20 // name and the test name.}\par
00396   {\cf17 static} {\cf18 bool} FilterMatchesTest({\cf17 const} std::string &test_case_name,\par
00397                                 {\cf17 const} std::string &test_name);\par
00398 \par
00399 {\cf21 #if GTEST_OS_WINDOWS}\par
00400   {\cf20 // Function for supporting the gtest_catch_exception flag.}\par
00401 \par
00402   {\cf20 // Returns EXCEPTION_EXECUTE_HANDLER if Google Test should handle the}\par
00403   {\cf20 // given SEH exception, or EXCEPTION_CONTINUE_SEARCH otherwise.}\par
00404   {\cf20 // This function is useful as an __except condition.}\par
00405   {\cf17 static} {\cf18 int} GTestShouldProcessSEH(DWORD exception_code);\par
00406 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
00407 \par
00408   {\cf20 // Returns true if "name" matches the ':' separated list of glob-style}\par
00409   {\cf20 // filters in "filter".}\par
00410   {\cf17 static} {\cf18 bool} MatchesFilter({\cf17 const} std::string& name, {\cf17 const} {\cf18 char}* filter);\par
00411 \};\par
00412 \par
00413 {\cf20 // Returns the current application's name, removing directory path if that}\par
00414 {\cf20 // is present.  Used by UnitTestOptions::GetOutputFile.}\par
00415 GTEST_API_ FilePath GetCurrentExecutableName();\par
00416 \par
00417 {\cf20 // The role interface for getting the OS stack trace as a string.}\par
00418 {\cf17 class }OsStackTraceGetterInterface \{\par
00419  {\cf17 public}:\par
00420   OsStackTraceGetterInterface() \{\}\par
00421   {\cf17 virtual} ~OsStackTraceGetterInterface() \{\}\par
00422 \par
00423   {\cf20 // Returns the current OS stack trace as an std::string.  Parameters:}\par
00424   {\cf20 //}\par
00425   {\cf20 //   max_depth  - the maximum number of stack frames to be included}\par
00426   {\cf20 //                in the trace.}\par
00427   {\cf20 //   skip_count - the number of top frames to be skipped; doesn't count}\par
00428   {\cf20 //                against max_depth.}\par
00429   {\cf17 virtual} std::string CurrentStackTrace({\cf18 int} max_depth, {\cf18 int} skip_count) = 0;\par
00430 \par
00431   {\cf20 // UponLeavingGTest() should be called immediately before Google Test calls}\par
00432   {\cf20 // user code. It saves some information about the current stack that}\par
00433   {\cf20 // CurrentStackTrace() will use to find and hide Google Test stack frames.}\par
00434   {\cf17 virtual} {\cf18 void} UponLeavingGTest() = 0;\par
00435 \par
00436   {\cf20 // This string is inserted in place of stack frames that are part of}\par
00437   {\cf20 // Google Test's implementation.}\par
00438   {\cf17 static} {\cf17 const} {\cf18 char}* {\cf17 const} kElidedFramesMarker;\par
00439 \par
00440  {\cf17 private}:\par
00441   GTEST_DISALLOW_COPY_AND_ASSIGN_(OsStackTraceGetterInterface);\par
00442 \};\par
00443 \par
00444 {\cf20 // A working implementation of the OsStackTraceGetterInterface interface.}\par
00445 {\cf17 class }OsStackTraceGetter : {\cf17 public} OsStackTraceGetterInterface \{\par
00446  {\cf17 public}:\par
00447   OsStackTraceGetter() \{\}\par
00448 \par
00449   {\cf17 virtual} std::string CurrentStackTrace({\cf18 int} max_depth, {\cf18 int} skip_count);\par
00450   {\cf17 virtual} {\cf18 void} UponLeavingGTest();\par
00451 \par
00452  {\cf17 private}:\par
00453   GTEST_DISALLOW_COPY_AND_ASSIGN_(OsStackTraceGetter);\par
00454 \};\par
00455 \par
00456 {\cf20 // Information about a Google Test trace point.}\par
00457 {\cf17 struct }TraceInfo \{\par
00458   {\cf17 const} {\cf18 char}* file;\par
00459   {\cf18 int} line;\par
00460   std::string message;\par
00461 \};\par
00462 \par
00463 {\cf20 // This is the default global test part result reporter used in UnitTestImpl.}\par
00464 {\cf20 // This class should only be used by UnitTestImpl.}\par
00465 {\cf17 class }DefaultGlobalTestPartResultReporter\par
00466   : {\cf17 public} TestPartResultReporterInterface \{\par
00467  {\cf17 public}:\par
00468   {\cf17 explicit} DefaultGlobalTestPartResultReporter(UnitTestImpl* unit_test);\par
00469   {\cf20 // Implements the TestPartResultReporterInterface. Reports the test part}\par
00470   {\cf20 // result in the current test.}\par
00471   {\cf17 virtual} {\cf18 void} ReportTestPartResult({\cf17 const} TestPartResult& result);\par
00472 \par
00473  {\cf17 private}:\par
00474   UnitTestImpl* {\cf17 const} unit_test_;\par
00475 \par
00476   GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultGlobalTestPartResultReporter);\par
00477 \};\par
00478 \par
00479 {\cf20 // This is the default per thread test part result reporter used in}\par
00480 {\cf20 // UnitTestImpl. This class should only be used by UnitTestImpl.}\par
00481 {\cf17 class }DefaultPerThreadTestPartResultReporter\par
00482     : {\cf17 public} TestPartResultReporterInterface \{\par
00483  {\cf17 public}:\par
00484   {\cf17 explicit} DefaultPerThreadTestPartResultReporter(UnitTestImpl* unit_test);\par
00485   {\cf20 // Implements the TestPartResultReporterInterface. The implementation just}\par
00486   {\cf20 // delegates to the current global test part result reporter of *unit_test_.}\par
00487   {\cf17 virtual} {\cf18 void} ReportTestPartResult({\cf17 const} TestPartResult& result);\par
00488 \par
00489  {\cf17 private}:\par
00490   UnitTestImpl* {\cf17 const} unit_test_;\par
00491 \par
00492   GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultPerThreadTestPartResultReporter);\par
00493 \};\par
00494 \par
00495 {\cf20 // The private implementation of the UnitTest class.  We don't protect}\par
00496 {\cf20 // the methods under a mutex, as this class is not accessible by a}\par
00497 {\cf20 // user and the UnitTest class that delegates work to this class does}\par
00498 {\cf20 // proper locking.}\par
00499 {\cf17 class }GTEST_API_ UnitTestImpl \{\par
00500  {\cf17 public}:\par
00501   {\cf17 explicit} UnitTestImpl(UnitTest* parent);\par
00502   {\cf17 virtual} ~UnitTestImpl();\par
00503 \par
00504   {\cf20 // There are two different ways to register your own TestPartResultReporter.}\par
00505   {\cf20 // You can register your own repoter to listen either only for test results}\par
00506   {\cf20 // from the current thread or for results from all threads.}\par
00507   {\cf20 // By default, each per-thread test result repoter just passes a new}\par
00508   {\cf20 // TestPartResult to the global test result reporter, which registers the}\par
00509   {\cf20 // test part result for the currently running test.}\par
00510 \par
00511   {\cf20 // Returns the global test part result reporter.}\par
00512   TestPartResultReporterInterface* GetGlobalTestPartResultReporter();\par
00513 \par
00514   {\cf20 // Sets the global test part result reporter.}\par
00515   {\cf18 void} SetGlobalTestPartResultReporter(\par
00516       TestPartResultReporterInterface* reporter);\par
00517 \par
00518   {\cf20 // Returns the test part result reporter for the current thread.}\par
00519   TestPartResultReporterInterface* GetTestPartResultReporterForCurrentThread();\par
00520 \par
00521   {\cf20 // Sets the test part result reporter for the current thread.}\par
00522   {\cf18 void} SetTestPartResultReporterForCurrentThread(\par
00523       TestPartResultReporterInterface* reporter);\par
00524 \par
00525   {\cf20 // Gets the number of successful test cases.}\par
00526   {\cf18 int} successful_test_case_count() {\cf17 const};\par
00527 \par
00528   {\cf20 // Gets the number of failed test cases.}\par
00529   {\cf18 int} failed_test_case_count() {\cf17 const};\par
00530 \par
00531   {\cf20 // Gets the number of all test cases.}\par
00532   {\cf18 int} total_test_case_count() {\cf17 const};\par
00533 \par
00534   {\cf20 // Gets the number of all test cases that contain at least one test}\par
00535   {\cf20 // that should run.}\par
00536   {\cf18 int} test_case_to_run_count() {\cf17 const};\par
00537 \par
00538   {\cf20 // Gets the number of successful tests.}\par
00539   {\cf18 int} successful_test_count() {\cf17 const};\par
00540 \par
00541   {\cf20 // Gets the number of failed tests.}\par
00542   {\cf18 int} failed_test_count() {\cf17 const};\par
00543 \par
00544   {\cf20 // Gets the number of disabled tests that will be reported in the XML report.}\par
00545   {\cf18 int} reportable_disabled_test_count() {\cf17 const};\par
00546 \par
00547   {\cf20 // Gets the number of disabled tests.}\par
00548   {\cf18 int} disabled_test_count() {\cf17 const};\par
00549 \par
00550   {\cf20 // Gets the number of tests to be printed in the XML report.}\par
00551   {\cf18 int} reportable_test_count() {\cf17 const};\par
00552 \par
00553   {\cf20 // Gets the number of all tests.}\par
00554   {\cf18 int} total_test_count() {\cf17 const};\par
00555 \par
00556   {\cf20 // Gets the number of tests that should run.}\par
00557   {\cf18 int} test_to_run_count() {\cf17 const};\par
00558 \par
00559   {\cf20 // Gets the time of the test program start, in ms from the start of the}\par
00560   {\cf20 // UNIX epoch.}\par
00561   TimeInMillis start_timestamp(){\cf17  const }\{ {\cf19 return} start_timestamp_; \}\par
00562 \par
00563   {\cf20 // Gets the elapsed time, in milliseconds.}\par
00564   TimeInMillis elapsed_time(){\cf17  const }\{ {\cf19 return} elapsed_time_; \}\par
00565 \par
00566   {\cf20 // Returns true iff the unit test passed (i.e. all test cases passed).}\par
00567   {\cf18 bool} Passed(){\cf17  const }\{ {\cf19 return} !Failed(); \}\par
00568 \par
00569   {\cf20 // Returns true iff the unit test failed (i.e. some test case failed}\par
00570   {\cf20 // or something outside of all tests failed).}\par
00571   {\cf18 bool} Failed(){\cf17  const }\{\par
00572     {\cf19 return} failed_test_case_count() > 0 || ad_hoc_test_result()->Failed();\par
00573   \}\par
00574 \par
00575   {\cf20 // Gets the i-th test case among all the test cases. i can range from 0 to}\par
00576   {\cf20 // total_test_case_count() - 1. If i is not in that range, returns NULL.}\par
00577   {\cf17 const} TestCase* GetTestCase({\cf18 int} i){\cf17  const }\{\par
00578     {\cf17 const} {\cf18 int} index = GetElementOr(test_case_indices_, i, -1);\par
00579     {\cf19 return} index < 0 ? NULL : test_cases_[i];\par
00580   \}\par
00581 \par
00582   {\cf20 // Gets the i-th test case among all the test cases. i can range from 0 to}\par
00583   {\cf20 // total_test_case_count() - 1. If i is not in that range, returns NULL.}\par
00584   TestCase* GetMutableTestCase({\cf18 int} i) \{\par
00585     {\cf17 const} {\cf18 int} index = GetElementOr(test_case_indices_, i, -1);\par
00586     {\cf19 return} index < 0 ? NULL : test_cases_[index];\par
00587   \}\par
00588 \par
00589   {\cf20 // Provides access to the event listener list.}\par
00590   TestEventListeners* listeners() \{ {\cf19 return} &listeners_; \}\par
00591 \par
00592   {\cf20 // Returns the TestResult for the test that's currently running, or}\par
00593   {\cf20 // the TestResult for the ad hoc test if no test is running.}\par
00594   TestResult* current_test_result();\par
00595 \par
00596   {\cf20 // Returns the TestResult for the ad hoc test.}\par
00597   {\cf17 const} TestResult* ad_hoc_test_result(){\cf17  const }\{ {\cf19 return} &ad_hoc_test_result_; \}\par
00598 \par
00599   {\cf20 // Sets the OS stack trace getter.}\par
00600   {\cf20 //}\par
00601   {\cf20 // Does nothing if the input and the current OS stack trace getter}\par
00602   {\cf20 // are the same; otherwise, deletes the old getter and makes the}\par
00603   {\cf20 // input the current getter.}\par
00604   {\cf18 void} set_os_stack_trace_getter(OsStackTraceGetterInterface* getter);\par
00605 \par
00606   {\cf20 // Returns the current OS stack trace getter if it is not NULL;}\par
00607   {\cf20 // otherwise, creates an OsStackTraceGetter, makes it the current}\par
00608   {\cf20 // getter, and returns it.}\par
00609   OsStackTraceGetterInterface* os_stack_trace_getter();\par
00610 \par
00611   {\cf20 // Returns the current OS stack trace as an std::string.}\par
00612   {\cf20 //}\par
00613   {\cf20 // The maximum number of stack frames to be included is specified by}\par
00614   {\cf20 // the gtest_stack_trace_depth flag.  The skip_count parameter}\par
00615   {\cf20 // specifies the number of top frames to be skipped, which doesn't}\par
00616   {\cf20 // count against the number of frames to be included.}\par
00617   {\cf20 //}\par
00618   {\cf20 // For example, if Foo() calls Bar(), which in turn calls}\par
00619   {\cf20 // CurrentOsStackTraceExceptTop(1), Foo() will be included in the}\par
00620   {\cf20 // trace but Bar() and CurrentOsStackTraceExceptTop() won't.}\par
00621   std::string CurrentOsStackTraceExceptTop({\cf18 int} skip_count) GTEST_NO_INLINE_;\par
00622 \par
00623   {\cf20 // Finds and returns a TestCase with the given name.  If one doesn't}\par
00624   {\cf20 // exist, creates one and returns it.}\par
00625   {\cf20 //}\par
00626   {\cf20 // Arguments:}\par
00627   {\cf20 //}\par
00628   {\cf20 //   test_case_name: name of the test case}\par
00629   {\cf20 //   type_param:     the name of the test's type parameter, or NULL if}\par
00630   {\cf20 //                   this is not a typed or a type-parameterized test.}\par
00631   {\cf20 //   set_up_tc:      pointer to the function that sets up the test case}\par
00632   {\cf20 //   tear_down_tc:   pointer to the function that tears down the test case}\par
00633   TestCase* GetTestCase({\cf17 const} {\cf18 char}* test_case_name,\par
00634                         {\cf17 const} {\cf18 char}* type_param,\par
00635                         Test::SetUpTestCaseFunc set_up_tc,\par
00636                         Test::TearDownTestCaseFunc tear_down_tc);\par
00637 \par
00638   {\cf20 // Adds a TestInfo to the unit test.}\par
00639   {\cf20 //}\par
00640   {\cf20 // Arguments:}\par
00641   {\cf20 //}\par
00642   {\cf20 //   set_up_tc:    pointer to the function that sets up the test case}\par
00643   {\cf20 //   tear_down_tc: pointer to the function that tears down the test case}\par
00644   {\cf20 //   test_info:    the TestInfo object}\par
00645   {\cf18 void} AddTestInfo(Test::SetUpTestCaseFunc set_up_tc,\par
00646                    Test::TearDownTestCaseFunc tear_down_tc,\par
00647                    TestInfo* test_info) \{\par
00648     {\cf20 // In order to support thread-safe death tests, we need to}\par
00649     {\cf20 // remember the original working directory when the test program}\par
00650     {\cf20 // was first invoked.  We cannot do this in RUN_ALL_TESTS(), as}\par
00651     {\cf20 // the user may have changed the current directory before calling}\par
00652     {\cf20 // RUN_ALL_TESTS().  Therefore we capture the current directory in}\par
00653     {\cf20 // AddTestInfo(), which is called to register a TEST or TEST_F}\par
00654     {\cf20 // before main() is reached.}\par
00655     {\cf19 if} (original_working_dir_.IsEmpty()) \{\par
00656       original_working_dir_.Set(FilePath::GetCurrentDir());\par
00657       GTEST_CHECK_(!original_working_dir_.IsEmpty())\par
00658           << {\cf22 "Failed to get the current working directory."};\par
00659     \}\par
00660 \par
00661     GetTestCase(test_info->test_case_name(),\par
00662                 test_info->type_param(),\par
00663                 set_up_tc,\par
00664                 tear_down_tc)->AddTestInfo(test_info);\par
00665   \}\par
00666 \par
00667 {\cf21 #if GTEST_HAS_PARAM_TEST}\par
00668   {\cf20 // Returns ParameterizedTestCaseRegistry object used to keep track of}\par
00669   {\cf20 // value-parameterized tests and instantiate and register them.}\par
00670   internal::ParameterizedTestCaseRegistry& parameterized_test_registry() \{\par
00671     {\cf19 return} parameterized_test_registry_;\par
00672   \}\par
00673 {\cf21 #endif  }{\cf20 // GTEST_HAS_PARAM_TEST}\par
00674 \par
00675   {\cf20 // Sets the TestCase object for the test that's currently running.}\par
00676   {\cf18 void} set_current_test_case(TestCase* a_current_test_case) \{\par
00677     current_test_case_ = a_current_test_case;\par
00678   \}\par
00679 \par
00680   {\cf20 // Sets the TestInfo object for the test that's currently running.  If}\par
00681   {\cf20 // current_test_info is NULL, the assertion results will be stored in}\par
00682   {\cf20 // ad_hoc_test_result_.}\par
00683   {\cf18 void} set_current_test_info(TestInfo* a_current_test_info) \{\par
00684     current_test_info_ = a_current_test_info;\par
00685   \}\par
00686 \par
00687   {\cf20 // Registers all parameterized tests defined using TEST_P and}\par
00688   {\cf20 // INSTANTIATE_TEST_CASE_P, creating regular tests for each test/parameter}\par
00689   {\cf20 // combination. This method can be called more then once; it has guards}\par
00690   {\cf20 // protecting from registering the tests more then once.  If}\par
00691   {\cf20 // value-parameterized tests are disabled, RegisterParameterizedTests is}\par
00692   {\cf20 // present but does nothing.}\par
00693   {\cf18 void} RegisterParameterizedTests();\par
00694 \par
00695   {\cf20 // Runs all tests in this UnitTest object, prints the result, and}\par
00696   {\cf20 // returns true if all tests are successful.  If any exception is}\par
00697   {\cf20 // thrown during a test, this test is considered to be failed, but}\par
00698   {\cf20 // the rest of the tests will still be run.}\par
00699   {\cf18 bool} RunAllTests();\par
00700 \par
00701   {\cf20 // Clears the results of all tests, except the ad hoc tests.}\par
00702   {\cf18 void} ClearNonAdHocTestResult() \{\par
00703     ForEach(test_cases_, TestCase::ClearTestCaseResult);\par
00704   \}\par
00705 \par
00706   {\cf20 // Clears the results of ad-hoc test assertions.}\par
00707   {\cf18 void} ClearAdHocTestResult() \{\par
00708     ad_hoc_test_result_.Clear();\par
00709   \}\par
00710 \par
00711   {\cf20 // Adds a TestProperty to the current TestResult object when invoked in a}\par
00712   {\cf20 // context of a test or a test case, or to the global property set. If the}\par
00713   {\cf20 // result already contains a property with the same key, the value will be}\par
00714   {\cf20 // updated.}\par
00715   {\cf18 void} RecordProperty({\cf17 const} TestProperty& test_property);\par
00716 \par
00717   {\cf17 enum} ReactionToSharding \{\par
00718     HONOR_SHARDING_PROTOCOL,\par
00719     IGNORE_SHARDING_PROTOCOL\par
00720   \};\par
00721 \par
00722   {\cf20 // Matches the full name of each test against the user-specified}\par
00723   {\cf20 // filter to decide whether the test should run, then records the}\par
00724   {\cf20 // result in each TestCase and TestInfo object.}\par
00725   {\cf20 // If shard_tests == HONOR_SHARDING_PROTOCOL, further filters tests}\par
00726   {\cf20 // based on sharding variables in the environment.}\par
00727   {\cf20 // Returns the number of tests that should run.}\par
00728   {\cf18 int} FilterTests(ReactionToSharding shard_tests);\par
00729 \par
00730   {\cf20 // Prints the names of the tests matching the user-specified filter flag.}\par
00731   {\cf18 void} ListTestsMatchingFilter();\par
00732 \par
00733   {\cf17 const} TestCase* current_test_case(){\cf17  const }\{ {\cf19 return} current_test_case_; \}\par
00734   TestInfo* current_test_info() \{ {\cf19 return} current_test_info_; \}\par
00735   {\cf17 const} TestInfo* current_test_info(){\cf17  const }\{ {\cf19 return} current_test_info_; \}\par
00736 \par
00737   {\cf20 // Returns the vector of environments that need to be set-up/torn-down}\par
00738   {\cf20 // before/after the tests are run.}\par
00739   std::vector<Environment*>& environments() \{ {\cf19 return} environments_; \}\par
00740 \par
00741   {\cf20 // Getters for the per-thread Google Test trace stack.}\par
00742   std::vector<TraceInfo>& gtest_trace_stack() \{\par
00743     {\cf19 return} *(gtest_trace_stack_.pointer());\par
00744   \}\par
00745   {\cf17 const} std::vector<TraceInfo>& gtest_trace_stack(){\cf17  const }\{\par
00746     {\cf19 return} gtest_trace_stack_.get();\par
00747   \}\par
00748 \par
00749 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
00750   {\cf18 void} InitDeathTestSubprocessControlInfo() \{\par
00751     internal_run_death_test_flag_.reset(ParseInternalRunDeathTestFlag());\par
00752   \}\par
00753   {\cf20 // Returns a pointer to the parsed --gtest_internal_run_death_test}\par
00754   {\cf20 // flag, or NULL if that flag was not specified.}\par
00755   {\cf20 // This information is useful only in a death test child process.}\par
00756   {\cf20 // Must not be called before a call to InitGoogleTest.}\par
00757   {\cf17 const} InternalRunDeathTestFlag* internal_run_death_test_flag(){\cf17  const }\{\par
00758     {\cf19 return} internal_run_death_test_flag_.get();\par
00759   \}\par
00760 \par
00761   {\cf20 // Returns a pointer to the current death test factory.}\par
00762   internal::DeathTestFactory* death_test_factory() \{\par
00763     {\cf19 return} death_test_factory_.get();\par
00764   \}\par
00765 \par
00766   {\cf18 void} SuppressTestEventsIfInSubprocess();\par
00767 \par
00768   {\cf17 friend} {\cf17 class }ReplaceDeathTestFactory;\par
00769 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
00770 \par
00771   {\cf20 // Initializes the event listener performing XML output as specified by}\par
00772   {\cf20 // UnitTestOptions. Must not be called before InitGoogleTest.}\par
00773   {\cf18 void} ConfigureXmlOutput();\par
00774 \par
00775 {\cf21 #if GTEST_CAN_STREAM_RESULTS_}\par
00776   {\cf20 // Initializes the event listener for streaming test results to a socket.}\par
00777   {\cf20 // Must not be called before InitGoogleTest.}\par
00778   {\cf18 void} ConfigureStreamingOutput();\par
00779 {\cf21 #endif}\par
00780 \par
00781   {\cf20 // Performs initialization dependent upon flag values obtained in}\par
00782   {\cf20 // ParseGoogleTestFlagsOnly.  Is called from InitGoogleTest after the call to}\par
00783   {\cf20 // ParseGoogleTestFlagsOnly.  In case a user neglects to call InitGoogleTest}\par
00784   {\cf20 // this function is also called from RunAllTests.  Since this function can be}\par
00785   {\cf20 // called more than once, it has to be idempotent.}\par
00786   {\cf18 void} PostFlagParsingInit();\par
00787 \par
00788   {\cf20 // Gets the random seed used at the start of the current test iteration.}\par
00789   {\cf18 int} random_seed(){\cf17  const }\{ {\cf19 return} random_seed_; \}\par
00790 \par
00791   {\cf20 // Gets the random number generator.}\par
00792   internal::Random* random() \{ {\cf19 return} &random_; \}\par
00793 \par
00794   {\cf20 // Shuffles all test cases, and the tests within each test case,}\par
00795   {\cf20 // making sure that death tests are still run first.}\par
00796   {\cf18 void} ShuffleTests();\par
00797 \par
00798   {\cf20 // Restores the test cases and tests to their order before the first shuffle.}\par
00799   {\cf18 void} UnshuffleTests();\par
00800 \par
00801   {\cf20 // Returns the value of GTEST_FLAG(catch_exceptions) at the moment}\par
00802   {\cf20 // UnitTest::Run() starts.}\par
00803   {\cf18 bool} catch_exceptions(){\cf17  const }\{ {\cf19 return} catch_exceptions_; \}\par
00804 \par
00805  {\cf17 private}:\par
00806   {\cf17 friend} class ::testing::UnitTest;\par
00807 \par
00808   {\cf20 // Used by UnitTest::Run() to capture the state of}\par
00809   {\cf20 // GTEST_FLAG(catch_exceptions) at the moment it starts.}\par
00810   {\cf18 void} set_catch_exceptions({\cf18 bool} value) \{ catch_exceptions_ = value; \}\par
00811 \par
00812   {\cf20 // The UnitTest object that owns this implementation object.}\par
00813   UnitTest* {\cf17 const} parent_;\par
00814 \par
00815   {\cf20 // The working directory when the first TEST() or TEST_F() was}\par
00816   {\cf20 // executed.}\par
00817   internal::FilePath original_working_dir_;\par
00818 \par
00819   {\cf20 // The default test part result reporters.}\par
00820   DefaultGlobalTestPartResultReporter default_global_test_part_result_reporter_;\par
00821   DefaultPerThreadTestPartResultReporter\par
00822       default_per_thread_test_part_result_reporter_;\par
00823 \par
00824   {\cf20 // Points to (but doesn't own) the global test part result reporter.}\par
00825   TestPartResultReporterInterface* global_test_part_result_repoter_;\par
00826 \par
00827   {\cf20 // Protects read and write access to global_test_part_result_reporter_.}\par
00828   internal::Mutex global_test_part_result_reporter_mutex_;\par
00829 \par
00830   {\cf20 // Points to (but doesn't own) the per-thread test part result reporter.}\par
00831   internal::ThreadLocal<TestPartResultReporterInterface*>\par
00832       per_thread_test_part_result_reporter_;\par
00833 \par
00834   {\cf20 // The vector of environments that need to be set-up/torn-down}\par
00835   {\cf20 // before/after the tests are run.}\par
00836   std::vector<Environment*> environments_;\par
00837 \par
00838   {\cf20 // The vector of TestCases in their original order.  It owns the}\par
00839   {\cf20 // elements in the vector.}\par
00840   std::vector<TestCase*> test_cases_;\par
00841 \par
00842   {\cf20 // Provides a level of indirection for the test case list to allow}\par
00843   {\cf20 // easy shuffling and restoring the test case order.  The i-th}\par
00844   {\cf20 // element of this vector is the index of the i-th test case in the}\par
00845   {\cf20 // shuffled order.}\par
00846   std::vector<int> test_case_indices_;\par
00847 \par
00848 {\cf21 #if GTEST_HAS_PARAM_TEST}\par
00849   {\cf20 // ParameterizedTestRegistry object used to register value-parameterized}\par
00850   {\cf20 // tests.}\par
00851   internal::ParameterizedTestCaseRegistry parameterized_test_registry_;\par
00852 \par
00853   {\cf20 // Indicates whether RegisterParameterizedTests() has been called already.}\par
00854   {\cf18 bool} parameterized_tests_registered_;\par
00855 {\cf21 #endif  }{\cf20 // GTEST_HAS_PARAM_TEST}\par
00856 \par
00857   {\cf20 // Index of the last death test case registered.  Initially -1.}\par
00858   {\cf18 int} last_death_test_case_;\par
00859 \par
00860   {\cf20 // This points to the TestCase for the currently running test.  It}\par
00861   {\cf20 // changes as Google Test goes through one test case after another.}\par
00862   {\cf20 // When no test is running, this is set to NULL and Google Test}\par
00863   {\cf20 // stores assertion results in ad_hoc_test_result_.  Initially NULL.}\par
00864   TestCase* current_test_case_;\par
00865 \par
00866   {\cf20 // This points to the TestInfo for the currently running test.  It}\par
00867   {\cf20 // changes as Google Test goes through one test after another.  When}\par
00868   {\cf20 // no test is running, this is set to NULL and Google Test stores}\par
00869   {\cf20 // assertion results in ad_hoc_test_result_.  Initially NULL.}\par
00870   TestInfo* current_test_info_;\par
00871 \par
00872   {\cf20 // Normally, a user only writes assertions inside a TEST or TEST_F,}\par
00873   {\cf20 // or inside a function called by a TEST or TEST_F.  Since Google}\par
00874   {\cf20 // Test keeps track of which test is current running, it can}\par
00875   {\cf20 // associate such an assertion with the test it belongs to.}\par
00876   {\cf20 //}\par
00877   {\cf20 // If an assertion is encountered when no TEST or TEST_F is running,}\par
00878   {\cf20 // Google Test attributes the assertion result to an imaginary "ad hoc"}\par
00879   {\cf20 // test, and records the result in ad_hoc_test_result_.}\par
00880   TestResult ad_hoc_test_result_;\par
00881 \par
00882   {\cf20 // The list of event listeners that can be used to track events inside}\par
00883   {\cf20 // Google Test.}\par
00884   TestEventListeners listeners_;\par
00885 \par
00886   {\cf20 // The OS stack trace getter.  Will be deleted when the UnitTest}\par
00887   {\cf20 // object is destructed.  By default, an OsStackTraceGetter is used,}\par
00888   {\cf20 // but the user can set this field to use a custom getter if that is}\par
00889   {\cf20 // desired.}\par
00890   OsStackTraceGetterInterface* os_stack_trace_getter_;\par
00891 \par
00892   {\cf20 // True iff PostFlagParsingInit() has been called.}\par
00893   {\cf18 bool} post_flag_parse_init_performed_;\par
00894 \par
00895   {\cf20 // The random number seed used at the beginning of the test run.}\par
00896   {\cf18 int} random_seed_;\par
00897 \par
00898   {\cf20 // Our random number generator.}\par
00899   internal::Random random_;\par
00900 \par
00901   {\cf20 // The time of the test program start, in ms from the start of the}\par
00902   {\cf20 // UNIX epoch.}\par
00903   TimeInMillis start_timestamp_;\par
00904 \par
00905   {\cf20 // How long the test took to run, in milliseconds.}\par
00906   TimeInMillis elapsed_time_;\par
00907 \par
00908 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
00909   {\cf20 // The decomposed components of the gtest_internal_run_death_test flag,}\par
00910   {\cf20 // parsed when RUN_ALL_TESTS is called.}\par
00911   internal::scoped_ptr<InternalRunDeathTestFlag> internal_run_death_test_flag_;\par
00912   internal::scoped_ptr<internal::DeathTestFactory> death_test_factory_;\par
00913 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
00914 \par
00915   {\cf20 // A per-thread stack of traces created by the SCOPED_TRACE() macro.}\par
00916   internal::ThreadLocal<std::vector<TraceInfo> > gtest_trace_stack_;\par
00917 \par
00918   {\cf20 // The value of GTEST_FLAG(catch_exceptions) at the moment RunAllTests()}\par
00919   {\cf20 // starts.}\par
00920   {\cf18 bool} catch_exceptions_;\par
00921 \par
00922   GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTestImpl);\par
00923 \};  {\cf20 // class UnitTestImpl}\par
00924 \par
00925 {\cf20 // Convenience function for accessing the global UnitTest}\par
00926 {\cf20 // implementation object.}\par
00927 {\cf17 inline} UnitTestImpl* GetUnitTestImpl() \{\par
00928   {\cf19 return} UnitTest::GetInstance()->impl();\par
00929 \}\par
00930 \par
00931 {\cf21 #if GTEST_USES_SIMPLE_RE}\par
00932 \par
00933 {\cf20 // Internal helper functions for implementing the simple regular}\par
00934 {\cf20 // expression matcher.}\par
00935 GTEST_API_ {\cf18 bool} IsInSet({\cf18 char} ch, {\cf17 const} {\cf18 char}* str);\par
00936 GTEST_API_ {\cf18 bool} IsAsciiDigit({\cf18 char} ch);\par
00937 GTEST_API_ {\cf18 bool} IsAsciiPunct({\cf18 char} ch);\par
00938 GTEST_API_ {\cf18 bool} IsRepeat({\cf18 char} ch);\par
00939 GTEST_API_ {\cf18 bool} IsAsciiWhiteSpace({\cf18 char} ch);\par
00940 GTEST_API_ {\cf18 bool} IsAsciiWordChar({\cf18 char} ch);\par
00941 GTEST_API_ {\cf18 bool} IsValidEscape({\cf18 char} ch);\par
00942 GTEST_API_ {\cf18 bool} AtomMatchesChar({\cf18 bool} escaped, {\cf18 char} pattern, {\cf18 char} ch);\par
00943 GTEST_API_ {\cf18 bool} ValidateRegex({\cf17 const} {\cf18 char}* regex);\par
00944 GTEST_API_ {\cf18 bool} MatchRegexAtHead({\cf17 const} {\cf18 char}* regex, {\cf17 const} {\cf18 char}* str);\par
00945 GTEST_API_ {\cf18 bool} MatchRepetitionAndRegexAtHead(\par
00946     {\cf18 bool} escaped, {\cf18 char} ch, {\cf18 char} repeat, {\cf17 const} {\cf18 char}* regex, {\cf17 const} {\cf18 char}* str);\par
00947 GTEST_API_ {\cf18 bool} MatchRegexAnywhere({\cf17 const} {\cf18 char}* regex, {\cf17 const} {\cf18 char}* str);\par
00948 \par
00949 {\cf21 #endif  }{\cf20 // GTEST_USES_SIMPLE_RE}\par
00950 \par
00951 {\cf20 // Parses the command line for Google Test flags, without initializing}\par
00952 {\cf20 // other parts of Google Test.}\par
00953 GTEST_API_ {\cf18 void} ParseGoogleTestFlagsOnly({\cf18 int}* argc, {\cf18 char}** argv);\par
00954 GTEST_API_ {\cf18 void} ParseGoogleTestFlagsOnly({\cf18 int}* argc, {\cf18 wchar_t}** argv);\par
00955 \par
00956 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
00957 \par
00958 {\cf20 // Returns the message describing the last system error, regardless of the}\par
00959 {\cf20 // platform.}\par
00960 GTEST_API_ std::string GetLastErrnoDescription();\par
00961 \par
00962 {\cf20 // Attempts to parse a string into a positive integer pointed to by the}\par
00963 {\cf20 // number parameter.  Returns true if that is possible.}\par
00964 {\cf20 // GTEST_HAS_DEATH_TEST implies that we have ::std::string, so we can use}\par
00965 {\cf20 // it here.}\par
00966 {\cf17 template} <{\cf17 typename} Integer>\par
00967 {\cf18 bool} ParseNaturalNumber(const ::std::string& str, Integer* number) \{\par
00968   {\cf20 // Fail fast if the given string does not begin with a digit;}\par
00969   {\cf20 // this bypasses strtoXXX's "optional leading whitespace and plus}\par
00970   {\cf20 // or minus sign" semantics, which are undesirable here.}\par
00971   {\cf19 if} (str.empty() || !IsDigit(str[0])) \{\par
00972     {\cf19 return} {\cf17 false};\par
00973   \}\par
00974   errno = 0;\par
00975 \par
00976   {\cf18 char}* end;\par
00977   {\cf20 // BiggestConvertible is the largest integer type that system-provided}\par
00978   {\cf20 // string-to-number conversion routines can return.}\par
00979 \par
00980 {\cf21 # if GTEST_OS_WINDOWS && !defined(__GNUC__)}\par
00981 \par
00982   {\cf20 // MSVC and C++ Builder define __int64 instead of the standard long long.}\par
00983   {\cf17 typedef} {\cf18 unsigned} __int64 BiggestConvertible;\par
00984   {\cf17 const} BiggestConvertible parsed = _strtoui64(str.c_str(), &end, 10);\par
00985 \par
00986 {\cf21 # else}\par
00987 \par
00988   {\cf17 typedef} {\cf18 unsigned} {\cf18 long} {\cf18 long} BiggestConvertible;  {\cf20 // NOLINT}\par
00989   {\cf17 const} BiggestConvertible parsed = strtoull(str.c_str(), &end, 10);\par
00990 \par
00991 {\cf21 # endif  }{\cf20 // GTEST_OS_WINDOWS && !defined(__GNUC__)}\par
00992 \par
00993   {\cf17 const} {\cf18 bool} parse_success = *end == {\cf23 '\\0'} && errno == 0;\par
00994 \par
00995   {\cf20 // TODO(vladl@google.com): Convert this to compile time assertion when it is}\par
00996   {\cf20 // available.}\par
00997   GTEST_CHECK_({\cf17 sizeof}(Integer) <= {\cf17 sizeof}(parsed));\par
00998 \par
00999   {\cf17 const} Integer result = {\cf17 static_cast<}Integer{\cf17 >}(parsed);\par
01000   {\cf19 if} (parse_success && {\cf17 static_cast<}BiggestConvertible{\cf17 >}(result) == parsed) \{\par
01001     *number = result;\par
01002     {\cf19 return} {\cf17 true};\par
01003   \}\par
01004   {\cf19 return} {\cf17 false};\par
01005 \}\par
01006 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
01007 \par
01008 {\cf20 // TestResult contains some private methods that should be hidden from}\par
01009 {\cf20 // Google Test user but are required for testing. This class allow our tests}\par
01010 {\cf20 // to access them.}\par
01011 {\cf20 //}\par
01012 {\cf20 // This class is supplied only for the purpose of testing Google Test's own}\par
01013 {\cf20 // constructs. Do not use it in user tests, either directly or indirectly.}\par
01014 {\cf17 class }TestResultAccessor \{\par
01015  {\cf17 public}:\par
01016   {\cf17 static} {\cf18 void} RecordProperty(TestResult* test_result,\par
01017                              {\cf17 const} std::string& xml_element,\par
01018                              {\cf17 const} TestProperty& property) \{\par
01019     test_result->RecordProperty(xml_element, property);\par
01020   \}\par
01021 \par
01022   {\cf17 static} {\cf18 void} ClearTestPartResults(TestResult* test_result) \{\par
01023     test_result->ClearTestPartResults();\par
01024   \}\par
01025 \par
01026   {\cf17 static} {\cf17 const} std::vector<testing::TestPartResult>& test_part_results(\par
01027       {\cf17 const} TestResult& test_result) \{\par
01028     {\cf19 return} test_result.test_part_results();\par
01029   \}\par
01030 \};\par
01031 \par
01032 {\cf21 #if GTEST_CAN_STREAM_RESULTS_}\par
01033 \par
01034 {\cf20 // Streams test results to the given port on the given host machine.}\par
01035 {\cf17 class }GTEST_API_ StreamingListener : {\cf17 public} EmptyTestEventListener \{\par
01036  {\cf17 public}:\par
01037   {\cf20 // Abstract base class for writing strings to a socket.}\par
01038   {\cf17 class }AbstractSocketWriter \{\par
01039    {\cf17 public}:\par
01040     {\cf17 virtual} ~AbstractSocketWriter() \{\}\par
01041 \par
01042     {\cf20 // Sends a string to the socket.}\par
01043     {\cf17 virtual} {\cf18 void} Send({\cf17 const} std::string& message) = 0;\par
01044 \par
01045     {\cf20 // Closes the socket.}\par
01046     {\cf17 virtual} {\cf18 void} CloseConnection() \{\}\par
01047 \par
01048     {\cf20 // Sends a string and a newline to the socket.}\par
01049     {\cf18 void} SendLn({\cf17 const} std::string& message) \{ Send(message + {\cf22 "\\n"}); \}\par
01050   \};\par
01051 \par
01052   {\cf20 // Concrete class for actually writing strings to a socket.}\par
01053   {\cf17 class }SocketWriter : {\cf17 public} AbstractSocketWriter \{\par
01054    {\cf17 public}:\par
01055     SocketWriter({\cf17 const} std::string& host, {\cf17 const} std::string& port)\par
01056         : sockfd_(-1), host_name_(host), port_num_(port) \{\par
01057       MakeConnection();\par
01058     \}\par
01059 \par
01060     {\cf17 virtual} ~SocketWriter() \{\par
01061       {\cf19 if} (sockfd_ != -1)\par
01062         CloseConnection();\par
01063     \}\par
01064 \par
01065     {\cf20 // Sends a string to the socket.}\par
01066     {\cf17 virtual} {\cf18 void} Send({\cf17 const} std::string& message) \{\par
01067       GTEST_CHECK_(sockfd_ != -1)\par
01068           << {\cf22 "Send() can be called only when there is a connection."};\par
01069 \par
01070       {\cf17 const} {\cf18 int} len = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(message.length());\par
01071       {\cf19 if} (write(sockfd_, message.c_str(), len) != len) \{\par
01072         GTEST_LOG_(WARNING)\par
01073             << {\cf22 "stream_result_to: failed to stream to "}\par
01074             << host_name_ << {\cf22 ":"} << port_num_;\par
01075       \}\par
01076     \}\par
01077 \par
01078    {\cf17 private}:\par
01079     {\cf20 // Creates a client socket and connects to the server.}\par
01080     {\cf18 void} MakeConnection();\par
01081 \par
01082     {\cf20 // Closes the socket.}\par
01083     {\cf18 void} CloseConnection() \{\par
01084       GTEST_CHECK_(sockfd_ != -1)\par
01085           << {\cf22 "CloseConnection() can be called only when there is a connection."};\par
01086 \par
01087       close(sockfd_);\par
01088       sockfd_ = -1;\par
01089     \}\par
01090 \par
01091     {\cf18 int} sockfd_;  {\cf20 // socket file descriptor}\par
01092     {\cf17 const} std::string host_name_;\par
01093     {\cf17 const} std::string port_num_;\par
01094 \par
01095     GTEST_DISALLOW_COPY_AND_ASSIGN_(SocketWriter);\par
01096   \};  {\cf20 // class SocketWriter}\par
01097 \par
01098   {\cf20 // Escapes '=', '&', '%', and '\\n' characters in str as "%xx".}\par
01099   {\cf17 static} std::string UrlEncode({\cf17 const} {\cf18 char}* str);\par
01100 \par
01101   StreamingListener({\cf17 const} std::string& host, {\cf17 const} std::string& port)\par
01102       : socket_writer_(new SocketWriter(host, port)) \{\par
01103     Start();\par
01104   \}\par
01105 \par
01106   {\cf17 explicit} StreamingListener(AbstractSocketWriter* socket_writer)\par
01107       : socket_writer_(socket_writer) \{ Start(); \}\par
01108 \par
01109   {\cf18 void} OnTestProgramStart({\cf17 const} UnitTest& {\cf20 /* unit_test */}) \{\par
01110     SendLn({\cf22 "event=TestProgramStart"});\par
01111   \}\par
01112 \par
01113   {\cf18 void} OnTestProgramEnd({\cf17 const} UnitTest& unit_test) \{\par
01114     {\cf20 // Note that Google Test current only report elapsed time for each}\par
01115     {\cf20 // test iteration, not for the entire test program.}\par
01116     SendLn({\cf22 "event=TestProgramEnd&passed="} + FormatBool(unit_test.Passed()));\par
01117 \par
01118     {\cf20 // Notify the streaming server to stop.}\par
01119     socket_writer_->CloseConnection();\par
01120   \}\par
01121 \par
01122   {\cf18 void} OnTestIterationStart({\cf17 const} UnitTest& {\cf20 /* unit_test */}, {\cf18 int} iteration) \{\par
01123     SendLn({\cf22 "event=TestIterationStart&iteration="} +\par
01124            StreamableToString(iteration));\par
01125   \}\par
01126 \par
01127   {\cf18 void} OnTestIterationEnd({\cf17 const} UnitTest& unit_test, {\cf18 int} {\cf20 /* iteration */}) \{\par
01128     SendLn({\cf22 "event=TestIterationEnd&passed="} +\par
01129            FormatBool(unit_test.Passed()) + {\cf22 "&elapsed_time="} +\par
01130            StreamableToString(unit_test.elapsed_time()) + {\cf22 "ms"});\par
01131   \}\par
01132 \par
01133   {\cf18 void} OnTestCaseStart({\cf17 const} TestCase& test_case) \{\par
01134     SendLn(std::string({\cf22 "event=TestCaseStart&name="}) + test_case.name());\par
01135   \}\par
01136 \par
01137   {\cf18 void} OnTestCaseEnd({\cf17 const} TestCase& test_case) \{\par
01138     SendLn({\cf22 "event=TestCaseEnd&passed="} + FormatBool(test_case.Passed())\par
01139            + {\cf22 "&elapsed_time="} + StreamableToString(test_case.elapsed_time())\par
01140            + {\cf22 "ms"});\par
01141   \}\par
01142 \par
01143   {\cf18 void} OnTestStart({\cf17 const} TestInfo& test_info) \{\par
01144     SendLn(std::string({\cf22 "event=TestStart&name="}) + test_info.name());\par
01145   \}\par
01146 \par
01147   {\cf18 void} OnTestEnd({\cf17 const} TestInfo& test_info) \{\par
01148     SendLn({\cf22 "event=TestEnd&passed="} +\par
01149            FormatBool((test_info.result())->Passed()) +\par
01150            {\cf22 "&elapsed_time="} +\par
01151            StreamableToString((test_info.result())->elapsed_time()) + {\cf22 "ms"});\par
01152   \}\par
01153 \par
01154   {\cf18 void} OnTestPartResult({\cf17 const} TestPartResult& test_part_result) \{\par
01155     {\cf17 const} {\cf18 char}* file_name = test_part_result.file_name();\par
01156     {\cf19 if} (file_name == NULL)\par
01157       file_name = {\cf22 ""};\par
01158     SendLn({\cf22 "event=TestPartResult&file="} + UrlEncode(file_name) +\par
01159            {\cf22 "&line="} + StreamableToString(test_part_result.line_number()) +\par
01160            {\cf22 "&message="} + UrlEncode(test_part_result.message()));\par
01161   \}\par
01162 \par
01163  {\cf17 private}:\par
01164   {\cf20 // Sends the given message and a newline to the socket.}\par
01165   {\cf18 void} SendLn({\cf17 const} std::string& message) \{ socket_writer_->SendLn(message); \}\par
01166 \par
01167   {\cf20 // Called at the start of streaming to notify the receiver what}\par
01168   {\cf20 // protocol we are using.}\par
01169   {\cf18 void} Start() \{ SendLn({\cf22 "gtest_streaming_protocol_version=1.0"}); \}\par
01170 \par
01171   std::string FormatBool({\cf18 bool} value) \{ {\cf19 return} value ? {\cf22 "1"} : {\cf22 "0"}; \}\par
01172 \par
01173   {\cf17 const} scoped_ptr<AbstractSocketWriter> socket_writer_;\par
01174 \par
01175   GTEST_DISALLOW_COPY_AND_ASSIGN_(StreamingListener);\par
01176 \};  {\cf20 // class StreamingListener}\par
01177 \par
01178 {\cf21 #endif  }{\cf20 // GTEST_CAN_STREAM_RESULTS_}\par
01179 \par
01180 \}  {\cf20 // namespace internal}\par
01181 \}  {\cf20 // namespace testing}\par
01182 \par
01183 {\cf21 #endif  }{\cf20 // GTEST_SRC_GTEST_INTERNAL_INL_H_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/src/gtest-port.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-port.cc}
{\xe \v gtest/src/gtest-port.cc}
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/internal/gtest-port.h"}\par
{\f2 #include <limits.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <fstream>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include "gtest/gtest-spi.h"}\par
{\f2 #include "gtest/gtest-message.h"}\par
{\f2 #include "gtest/internal/gtest-internal.h"}\par
{\f2 #include "gtest/internal/gtest-string.h"}\par
{\f2 #include "src/gtest-internal-inl.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_IMPLEMENTATION_}\~ 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} size_t {\b testing::internal::GetThreadCount} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GTEST_API_::std::string {\b testing::internal::FormatFileLocation} (const char *file, int line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GTEST_API_::std::string {\b testing::internal::FormatCompilerIndependentFileLocation} (const char *file, int line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} size_t {\b testing::internal::GetFileSize} (FILE *file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::ReadEntireFile} (FILE *file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::ParseInt32} (const Message &src_text, const char *str, Int32 *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::BoolFromGTestEnv} (const char *flag, bool default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} Int32 {\b testing::internal::Int32FromGTestEnv} (const char *flag, Int32 default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b testing::internal::StringFromGTestEnv} (const char *flag, const char *default_val)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b testing::internal::kStdOutFileno} = STDOUT_FILENO\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b testing::internal::kStdErrFileno} = STDERR_FILENO\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b testing::internal::kUnknownFile} [] = "unknown file"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v GTEST_IMPLEMENTATION_\:gtest-port.cc}
{\xe \v gtest-port.cc\:GTEST_IMPLEMENTATION_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_IMPLEMENTATION_\~ 1}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-port.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 76}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-port.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-port.cc}
{\xe \v gtest/src/gtest-port.cc}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2008, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: wan@google.com (Zhanyong Wan)}\par
00031 \par
00032 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00033 \par
00034 {\cf21 #include <limits.h>}\par
00035 {\cf21 #include <stdlib.h>}\par
00036 {\cf21 #include <stdio.h>}\par
00037 {\cf21 #include <string.h>}\par
00038 {\cf21 #include <fstream>}\par
00039 \par
00040 {\cf21 #if GTEST_OS_WINDOWS}\par
00041 {\cf21 # include <windows.h>}\par
00042 {\cf21 # include <io.h>}\par
00043 {\cf21 # include <sys/stat.h>}\par
00044 {\cf21 # include <map>}  {\cf20 // Used in ThreadLocal.}\par
00045 {\cf21 #else}\par
00046 {\cf21 # include <unistd.h>}\par
00047 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
00048 \par
00049 {\cf21 #if GTEST_OS_MAC}\par
00050 {\cf21 # include <mach/mach_init.h>}\par
00051 {\cf21 # include <mach/task.h>}\par
00052 {\cf21 # include <mach/vm_map.h>}\par
00053 {\cf21 #endif  }{\cf20 // GTEST_OS_MAC}\par
00054 \par
00055 {\cf21 #if GTEST_OS_QNX}\par
00056 {\cf21 # include <devctl.h>}\par
00057 {\cf21 # include <fcntl.h>}\par
00058 {\cf21 # include <sys/procfs.h>}\par
00059 {\cf21 #endif  }{\cf20 // GTEST_OS_QNX}\par
00060 \par
00061 {\cf21 #if GTEST_OS_AIX}\par
00062 {\cf21 # include <procinfo.h>}\par
00063 {\cf21 # include <sys/types.h>}\par
00064 {\cf21 #endif  }{\cf20 // GTEST_OS_AIX}\par
00065 \par
00066 {\cf21 #include "gtest/gtest-spi.h"}\par
00067 {\cf21 #include "gtest/gtest-message.h"}\par
00068 {\cf21 #include "gtest/internal/gtest-internal.h"}\par
00069 {\cf21 #include "gtest/internal/gtest-string.h"}\par
00070 \par
00071 {\cf20 // Indicates that this translation unit is part of Google Test's}\par
00072 {\cf20 // implementation.  It must come before gtest-internal-inl.h is}\par
00073 {\cf20 // included, or there will be a compiler error.  This trick exists to}\par
00074 {\cf20 // prevent the accidental inclusion of gtest-internal-inl.h in the}\par
00075 {\cf20 // user's code.}\par
00076 {\cf21 #define GTEST_IMPLEMENTATION_ 1}\par
00077 {\cf21 #include "src/gtest-internal-inl.h"}\par
00078 {\cf21 #undef GTEST_IMPLEMENTATION_}\par
00079 \par
00080 {\cf17 namespace }testing \{\par
00081 {\cf17 namespace }internal \{\par
00082 \par
00083 {\cf21 #if defined(_MSC_VER) || defined(__BORLANDC__)}\par
00084 {\cf20 // MSVC and C++Builder do not provide a definition of STDERR_FILENO.}\par
00085 {\cf17 const} {\cf18 int} kStdOutFileno = 1;\par
00086 {\cf17 const} {\cf18 int} kStdErrFileno = 2;\par
00087 {\cf21 #else}\par
00088 {\cf17 const} {\cf18 int} kStdOutFileno = STDOUT_FILENO;\par
00089 {\cf17 const} {\cf18 int} kStdErrFileno = STDERR_FILENO;\par
00090 {\cf21 #endif  }{\cf20 // _MSC_VER}\par
00091 \par
00092 {\cf21 #if GTEST_OS_LINUX}\par
00093 \par
00094 {\cf17 namespace }\{\par
00095 {\cf17 template} <{\cf17 typename} T>\par
00096 T ReadProcFileField({\cf17 const} std::string& filename, {\cf18 int} field) \{\par
00097   std::string dummy;\par
00098   std::ifstream file(filename.c_str());\par
00099   {\cf19 while} (field-- > 0) \{\par
00100     file >> dummy;\par
00101   \}\par
00102   T output = 0;\par
00103   file >> output;\par
00104   {\cf19 return} output;\par
00105 \}\par
00106 \}  {\cf20 // namespace}\par
00107 \par
00108 {\cf20 // Returns the number of active threads, or 0 when there is an error.}\par
00109 {\cf18 size_t} GetThreadCount() \{\par
00110   {\cf17 const} std::string filename =\par
00111       (Message() << {\cf22 "/proc/"} << getpid() << {\cf22 "/stat"}).GetString();\par
00112   {\cf19 return} ReadProcFileField<int>(filename, 19);\par
00113 \}\par
00114 \par
00115 {\cf21 #elif GTEST_OS_MAC}\par
00116 \par
00117 {\cf18 size_t} GetThreadCount() \{\par
00118   {\cf17 const} task_t task = mach_task_self();\par
00119   mach_msg_type_number_t thread_count;\par
00120   thread_act_array_t thread_list;\par
00121   {\cf17 const} kern_return_t status = task_threads(task, &thread_list, &thread_count);\par
00122   {\cf19 if} (status == KERN_SUCCESS) \{\par
00123     {\cf20 // task_threads allocates resources in thread_list and we need to free them}\par
00124     {\cf20 // to avoid leaks.}\par
00125     vm_deallocate(task,\par
00126                   {\cf17 reinterpret_cast<}vm_address_t{\cf17 >}(thread_list),\par
00127                   {\cf17 sizeof}(thread_t) * thread_count);\par
00128     {\cf19 return} {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(thread_count);\par
00129   \} {\cf19 else} \{\par
00130     {\cf19 return} 0;\par
00131   \}\par
00132 \}\par
00133 \par
00134 {\cf21 #elif GTEST_OS_QNX}\par
00135 \par
00136 {\cf20 // Returns the number of threads running in the process, or 0 to indicate that}\par
00137 {\cf20 // we cannot detect it.}\par
00138 {\cf18 size_t} GetThreadCount() \{\par
00139   {\cf17 const} {\cf18 int} fd = open({\cf22 "/proc/self/as"}, O_RDONLY);\par
00140   {\cf19 if} (fd < 0) \{\par
00141     {\cf19 return} 0;\par
00142   \}\par
00143   procfs_info process_info;\par
00144   {\cf17 const} {\cf18 int} status =\par
00145       devctl(fd, DCMD_PROC_INFO, &process_info, {\cf17 sizeof}(process_info), NULL);\par
00146   close(fd);\par
00147   {\cf19 if} (status == EOK) \{\par
00148     {\cf19 return} {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(process_info.num_threads);\par
00149   \} {\cf19 else} \{\par
00150     {\cf19 return} 0;\par
00151   \}\par
00152 \}\par
00153 \par
00154 {\cf21 #elif GTEST_OS_AIX}\par
00155 \par
00156 {\cf18 size_t} GetThreadCount() \{\par
00157   {\cf17 struct }procentry64 entry;\par
00158   pid_t pid = getpid();\par
00159   {\cf18 int} status = getprocs64(&entry, {\cf17 sizeof}(entry), NULL, 0, &pid, 1);\par
00160   {\cf19 if} (status == 1) \{\par
00161     {\cf19 return} entry.pi_thcount;\par
00162   \} {\cf19 else} \{\par
00163     {\cf19 return} 0;\par
00164   \}\par
00165 \}\par
00166 \par
00167 {\cf21 #else}\par
00168 \par
00169 {\cf18 size_t} GetThreadCount() \{\par
00170   {\cf20 // There's no portable way to detect the number of threads, so we just}\par
00171   {\cf20 // return 0 to indicate that we cannot detect it.}\par
00172   {\cf19 return} 0;\par
00173 \}\par
00174 \par
00175 {\cf21 #endif  }{\cf20 // GTEST_OS_LINUX}\par
00176 \par
00177 {\cf21 #if GTEST_IS_THREADSAFE && GTEST_OS_WINDOWS}\par
00178 \par
00179 {\cf18 void} SleepMilliseconds({\cf18 int} n) \{\par
00180   ::Sleep(n);\par
00181 \}\par
00182 \par
00183 AutoHandle::AutoHandle()\par
00184     : handle_(INVALID_HANDLE_VALUE) \{\}\par
00185 \par
00186 AutoHandle::AutoHandle(Handle handle)\par
00187     : handle_(handle) \{\}\par
00188 \par
00189 AutoHandle::~AutoHandle() \{\par
00190   Reset();\par
00191 \}\par
00192 \par
00193 AutoHandle::Handle AutoHandle::Get(){\cf17  const }\{\par
00194   {\cf19 return} handle_;\par
00195 \}\par
00196 \par
00197 {\cf18 void} AutoHandle::Reset() \{\par
00198   Reset(INVALID_HANDLE_VALUE);\par
00199 \}\par
00200 \par
00201 {\cf18 void} AutoHandle::Reset(HANDLE handle) \{\par
00202   {\cf20 // Resetting with the same handle we already own is invalid.}\par
00203   {\cf19 if} (handle_ != handle) \{\par
00204     {\cf19 if} (IsCloseable()) \{\par
00205       ::CloseHandle(handle_);\par
00206     \}\par
00207     handle_ = handle;\par
00208   \} {\cf19 else} \{\par
00209     GTEST_CHECK_(!IsCloseable())\par
00210         << {\cf22 "Resetting a valid handle to itself is likely a programmer error "}\par
00211             {\cf22 "and thus not allowed."};\par
00212   \}\par
00213 \}\par
00214 \par
00215 {\cf18 bool} AutoHandle::IsCloseable(){\cf17  const }\{\par
00216   {\cf20 // Different Windows APIs may use either of these values to represent an}\par
00217   {\cf20 // invalid handle.}\par
00218   {\cf19 return} handle_ != NULL && handle_ != INVALID_HANDLE_VALUE;\par
00219 \}\par
00220 \par
00221 Notification::Notification()\par
00222     : event_(::CreateEvent(NULL,   {\cf20 // Default security attributes.}\par
00223                            TRUE,   {\cf20 // Do not reset automatically.}\par
00224                            FALSE,  {\cf20 // Initially unset.}\par
00225                            NULL)) \{  {\cf20 // Anonymous event.}\par
00226   GTEST_CHECK_(event_.Get() != NULL);\par
00227 \}\par
00228 \par
00229 {\cf18 void} Notification::Notify() \{\par
00230   GTEST_CHECK_(::SetEvent(event_.Get()) != FALSE);\par
00231 \}\par
00232 \par
00233 {\cf18 void} Notification::WaitForNotification() \{\par
00234   GTEST_CHECK_(\par
00235       ::WaitForSingleObject(event_.Get(), INFINITE) == WAIT_OBJECT_0);\par
00236 \}\par
00237 \par
00238 Mutex::Mutex()\par
00239     : owner_thread_id_(0),\par
00240       type_(kDynamic),\par
00241       critical_section_init_phase_(0),\par
00242       critical_section_(new CRITICAL_SECTION) \{\par
00243   ::InitializeCriticalSection(critical_section_);\par
00244 \}\par
00245 \par
00246 Mutex::~Mutex() \{\par
00247   {\cf20 // Static mutexes are leaked intentionally. It is not thread-safe to try}\par
00248   {\cf20 // to clean them up.}\par
00249   {\cf20 // TODO(yukawa): Switch to Slim Reader/Writer (SRW) Locks, which requires}\par
00250   {\cf20 // nothing to clean it up but is available only on Vista and later.}\par
00251   {\cf20 // http://msdn.microsoft.com/en-us/library/windows/desktop/aa904937.aspx}\par
00252   {\cf19 if} (type_ == kDynamic) \{\par
00253     ::DeleteCriticalSection(critical_section_);\par
00254     {\cf17 delete} critical_section_;\par
00255     critical_section_ = NULL;\par
00256   \}\par
00257 \}\par
00258 \par
00259 {\cf18 void} Mutex::Lock() \{\par
00260   ThreadSafeLazyInit();\par
00261   ::EnterCriticalSection(critical_section_);\par
00262   owner_thread_id_ = ::GetCurrentThreadId();\par
00263 \}\par
00264 \par
00265 {\cf18 void} Mutex::Unlock() \{\par
00266   ThreadSafeLazyInit();\par
00267   {\cf20 // We don't protect writing to owner_thread_id_ here, as it's the}\par
00268   {\cf20 // caller's responsibility to ensure that the current thread holds the}\par
00269   {\cf20 // mutex when this is called.}\par
00270   owner_thread_id_ = 0;\par
00271   ::LeaveCriticalSection(critical_section_);\par
00272 \}\par
00273 \par
00274 {\cf20 // Does nothing if the current thread holds the mutex. Otherwise, crashes}\par
00275 {\cf20 // with high probability.}\par
00276 {\cf18 void} Mutex::AssertHeld() \{\par
00277   ThreadSafeLazyInit();\par
00278   GTEST_CHECK_(owner_thread_id_ == ::GetCurrentThreadId())\par
00279       << {\cf22 "The current thread is not holding the mutex @"} << {\cf17 this};\par
00280 \}\par
00281 \par
00282 {\cf20 // Initializes owner_thread_id_ and critical_section_ in static mutexes.}\par
00283 {\cf18 void} Mutex::ThreadSafeLazyInit() \{\par
00284   {\cf20 // Dynamic mutexes are initialized in the constructor.}\par
00285   {\cf19 if} (type_ == kStatic) \{\par
00286     {\cf19 switch} (\par
00287         ::InterlockedCompareExchange(&critical_section_init_phase_, 1L, 0L)) \{\par
00288       {\cf19 case} 0:\par
00289         {\cf20 // If critical_section_init_phase_ was 0 before the exchange, we}\par
00290         {\cf20 // are the first to test it and need to perform the initialization.}\par
00291         owner_thread_id_ = 0;\par
00292         critical_section_ = {\cf17 new} CRITICAL_SECTION;\par
00293         ::InitializeCriticalSection(critical_section_);\par
00294         {\cf20 // Updates the critical_section_init_phase_ to 2 to signal}\par
00295         {\cf20 // initialization complete.}\par
00296         GTEST_CHECK_(::InterlockedCompareExchange(\par
00297                           &critical_section_init_phase_, 2L, 1L) ==\par
00298                       1L);\par
00299         {\cf19 break};\par
00300       {\cf19 case} 1:\par
00301         {\cf20 // Somebody else is already initializing the mutex; spin until they}\par
00302         {\cf20 // are done.}\par
00303         {\cf19 while} (::InterlockedCompareExchange(&critical_section_init_phase_,\par
00304                                             2L,\par
00305                                             2L) != 2L) \{\par
00306           {\cf20 // Possibly yields the rest of the thread's time slice to other}\par
00307           {\cf20 // threads.}\par
00308           ::Sleep(0);\par
00309         \}\par
00310         {\cf19 break};\par
00311 \par
00312       {\cf19 case} 2:\par
00313         {\cf19 break};  {\cf20 // The mutex is already initialized and ready for use.}\par
00314 \par
00315       {\cf19 default}:\par
00316         GTEST_CHECK_({\cf17 false})\par
00317             << {\cf22 "Unexpected value of critical_section_init_phase_ "}\par
00318             << {\cf22 "while initializing a static mutex."};\par
00319     \}\par
00320   \}\par
00321 \}\par
00322 \par
00323 {\cf17 namespace }\{\par
00324 \par
00325 {\cf17 class }ThreadWithParamSupport : {\cf17 public} ThreadWithParamBase \{\par
00326  {\cf17 public}:\par
00327   {\cf17 static} HANDLE CreateThread(Runnable* runnable,\par
00328                              Notification* thread_can_start) \{\par
00329     ThreadMainParam* param = {\cf17 new} ThreadMainParam(runnable, thread_can_start);\par
00330     DWORD thread_id;\par
00331     {\cf20 // TODO(yukawa): Consider to use _beginthreadex instead.}\par
00332     HANDLE thread_handle = ::CreateThread(\par
00333         NULL,    {\cf20 // Default security.}\par
00334         0,       {\cf20 // Default stack size.}\par
00335         &ThreadWithParamSupport::ThreadMain,\par
00336         param,   {\cf20 // Parameter to ThreadMainStatic}\par
00337         0x0,     {\cf20 // Default creation flags.}\par
00338         &thread_id);  {\cf20 // Need a valid pointer for the call to work under Win98.}\par
00339     GTEST_CHECK_(thread_handle != NULL) << {\cf22 "CreateThread failed with error "}\par
00340                                         << ::GetLastError() << {\cf22 "."};\par
00341     {\cf19 if} (thread_handle == NULL) \{\par
00342       {\cf17 delete} param;\par
00343     \}\par
00344     {\cf19 return} thread_handle;\par
00345   \}\par
00346 \par
00347  {\cf17 private}:\par
00348   {\cf17 struct }ThreadMainParam \{\par
00349     ThreadMainParam(Runnable* runnable, Notification* thread_can_start)\par
00350         : runnable_(runnable),\par
00351           thread_can_start_(thread_can_start) \{\par
00352     \}\par
00353     scoped_ptr<Runnable> runnable_;\par
00354     {\cf20 // Does not own.}\par
00355     Notification* thread_can_start_;\par
00356   \};\par
00357 \par
00358   {\cf17 static} DWORD WINAPI ThreadMain({\cf18 void}* ptr) \{\par
00359     {\cf20 // Transfers ownership.}\par
00360     scoped_ptr<ThreadMainParam> param({\cf17 static_cast<}ThreadMainParam*{\cf17 >}(ptr));\par
00361     {\cf19 if} (param->thread_can_start_ != NULL)\par
00362       param->thread_can_start_->WaitForNotification();\par
00363     param->runnable_->Run();\par
00364     {\cf19 return} 0;\par
00365   \}\par
00366 \par
00367   {\cf20 // Prohibit instantiation.}\par
00368   ThreadWithParamSupport();\par
00369 \par
00370   GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParamSupport);\par
00371 \};\par
00372 \par
00373 \}  {\cf20 // namespace}\par
00374 \par
00375 ThreadWithParamBase::ThreadWithParamBase(Runnable *runnable,\par
00376                                          Notification* thread_can_start)\par
00377       : thread_(ThreadWithParamSupport::CreateThread(runnable,\par
00378                                                      thread_can_start)) \{\par
00379 \}\par
00380 \par
00381 ThreadWithParamBase::~ThreadWithParamBase() \{\par
00382   Join();\par
00383 \}\par
00384 \par
00385 {\cf18 void} ThreadWithParamBase::Join() \{\par
00386   GTEST_CHECK_(::WaitForSingleObject(thread_.Get(), INFINITE) == WAIT_OBJECT_0)\par
00387       << {\cf22 "Failed to join the thread with error "} << ::GetLastError() << {\cf22 "."};\par
00388 \}\par
00389 \par
00390 {\cf20 // Maps a thread to a set of ThreadIdToThreadLocals that have values}\par
00391 {\cf20 // instantiated on that thread and notifies them when the thread exits.  A}\par
00392 {\cf20 // ThreadLocal instance is expected to persist until all threads it has}\par
00393 {\cf20 // values on have terminated.}\par
00394 {\cf17 class }ThreadLocalRegistryImpl \{\par
00395  {\cf17 public}:\par
00396   {\cf20 // Registers thread_local_instance as having value on the current thread.}\par
00397   {\cf20 // Returns a value that can be used to identify the thread from other threads.}\par
00398   {\cf17 static} ThreadLocalValueHolderBase* GetValueOnCurrentThread(\par
00399       {\cf17 const} ThreadLocalBase* thread_local_instance) \{\par
00400     DWORD current_thread = ::GetCurrentThreadId();\par
00401     MutexLock lock(&mutex_);\par
00402     ThreadIdToThreadLocals* {\cf17 const} thread_to_thread_locals =\par
00403         GetThreadLocalsMapLocked();\par
00404     ThreadIdToThreadLocals::iterator thread_local_pos =\par
00405         thread_to_thread_locals->find(current_thread);\par
00406     {\cf19 if} (thread_local_pos == thread_to_thread_locals->end()) \{\par
00407       thread_local_pos = thread_to_thread_locals->insert(\par
00408           std::make_pair(current_thread, ThreadLocalValues())).first;\par
00409       StartWatcherThreadFor(current_thread);\par
00410     \}\par
00411     ThreadLocalValues& thread_local_values = thread_local_pos->second;\par
00412     ThreadLocalValues::iterator value_pos =\par
00413         thread_local_values.find(thread_local_instance);\par
00414     {\cf19 if} (value_pos == thread_local_values.end()) \{\par
00415       value_pos =\par
00416           thread_local_values\par
00417               .insert(std::make_pair(\par
00418                   thread_local_instance,\par
00419                   linked_ptr<ThreadLocalValueHolderBase>(\par
00420                       thread_local_instance->NewValueForCurrentThread())))\par
00421               .first;\par
00422     \}\par
00423     {\cf19 return} value_pos->second.get();\par
00424   \}\par
00425 \par
00426   {\cf17 static} {\cf18 void} OnThreadLocalDestroyed(\par
00427       {\cf17 const} ThreadLocalBase* thread_local_instance) \{\par
00428     std::vector<linked_ptr<ThreadLocalValueHolderBase> > value_holders;\par
00429     {\cf20 // Clean up the ThreadLocalValues data structure while holding the lock, but}\par
00430     {\cf20 // defer the destruction of the ThreadLocalValueHolderBases.}\par
00431     \{\par
00432       MutexLock lock(&mutex_);\par
00433       ThreadIdToThreadLocals* {\cf17 const} thread_to_thread_locals =\par
00434           GetThreadLocalsMapLocked();\par
00435       {\cf19 for} (ThreadIdToThreadLocals::iterator it =\par
00436           thread_to_thread_locals->begin();\par
00437           it != thread_to_thread_locals->end();\par
00438           ++it) \{\par
00439         ThreadLocalValues& thread_local_values = it->second;\par
00440         ThreadLocalValues::iterator value_pos =\par
00441             thread_local_values.find(thread_local_instance);\par
00442         {\cf19 if} (value_pos != thread_local_values.end()) \{\par
00443           value_holders.push_back(value_pos->second);\par
00444           thread_local_values.erase(value_pos);\par
00445           {\cf20 // This 'if' can only be successful at most once, so theoretically we}\par
00446           {\cf20 // could break out of the loop here, but we don't bother doing so.}\par
00447         \}\par
00448       \}\par
00449     \}\par
00450     {\cf20 // Outside the lock, let the destructor for 'value_holders' deallocate the}\par
00451     {\cf20 // ThreadLocalValueHolderBases.}\par
00452   \}\par
00453 \par
00454   {\cf17 static} {\cf18 void} OnThreadExit(DWORD thread_id) \{\par
00455     GTEST_CHECK_(thread_id != 0) << ::GetLastError();\par
00456     std::vector<linked_ptr<ThreadLocalValueHolderBase> > value_holders;\par
00457     {\cf20 // Clean up the ThreadIdToThreadLocals data structure while holding the}\par
00458     {\cf20 // lock, but defer the destruction of the ThreadLocalValueHolderBases.}\par
00459     \{\par
00460       MutexLock lock(&mutex_);\par
00461       ThreadIdToThreadLocals* {\cf17 const} thread_to_thread_locals =\par
00462           GetThreadLocalsMapLocked();\par
00463       ThreadIdToThreadLocals::iterator thread_local_pos =\par
00464           thread_to_thread_locals->find(thread_id);\par
00465       {\cf19 if} (thread_local_pos != thread_to_thread_locals->end()) \{\par
00466         ThreadLocalValues& thread_local_values = thread_local_pos->second;\par
00467         {\cf19 for} (ThreadLocalValues::iterator value_pos =\par
00468             thread_local_values.begin();\par
00469             value_pos != thread_local_values.end();\par
00470             ++value_pos) \{\par
00471           value_holders.push_back(value_pos->second);\par
00472         \}\par
00473         thread_to_thread_locals->erase(thread_local_pos);\par
00474       \}\par
00475     \}\par
00476     {\cf20 // Outside the lock, let the destructor for 'value_holders' deallocate the}\par
00477     {\cf20 // ThreadLocalValueHolderBases.}\par
00478   \}\par
00479 \par
00480  {\cf17 private}:\par
00481   {\cf20 // In a particular thread, maps a ThreadLocal object to its value.}\par
00482   {\cf17 typedef} std::map<{\cf17 const} ThreadLocalBase*,\par
00483                    linked_ptr<ThreadLocalValueHolderBase> > ThreadLocalValues;\par
00484   {\cf20 // Stores all ThreadIdToThreadLocals having values in a thread, indexed by}\par
00485   {\cf20 // thread's ID.}\par
00486   {\cf17 typedef} std::map<DWORD, ThreadLocalValues> ThreadIdToThreadLocals;\par
00487 \par
00488   {\cf20 // Holds the thread id and thread handle that we pass from}\par
00489   {\cf20 // StartWatcherThreadFor to WatcherThreadFunc.}\par
00490   {\cf17 typedef} std::pair<DWORD, HANDLE> ThreadIdAndHandle;\par
00491 \par
00492   {\cf17 static} {\cf18 void} StartWatcherThreadFor(DWORD thread_id) \{\par
00493     {\cf20 // The returned handle will be kept in thread_map and closed by}\par
00494     {\cf20 // watcher_thread in WatcherThreadFunc.}\par
00495     HANDLE thread = ::OpenThread(SYNCHRONIZE | THREAD_QUERY_INFORMATION,\par
00496                                  FALSE,\par
00497                                  thread_id);\par
00498     GTEST_CHECK_(thread != NULL);\par
00499     {\cf20 // We need to to pass a valid thread ID pointer into CreateThread for it}\par
00500     {\cf20 // to work correctly under Win98.}\par
00501     DWORD watcher_thread_id;\par
00502     HANDLE watcher_thread = ::CreateThread(\par
00503         NULL,   {\cf20 // Default security.}\par
00504         0,      {\cf20 // Default stack size}\par
00505         &ThreadLocalRegistryImpl::WatcherThreadFunc,\par
00506         {\cf17 reinterpret_cast<}LPVOID{\cf17 >}({\cf17 new} ThreadIdAndHandle(thread_id, thread)),\par
00507         CREATE_SUSPENDED,\par
00508         &watcher_thread_id);\par
00509     GTEST_CHECK_(watcher_thread != NULL);\par
00510     {\cf20 // Give the watcher thread the same priority as ours to avoid being}\par
00511     {\cf20 // blocked by it.}\par
00512     ::SetThreadPriority(watcher_thread,\par
00513                         ::GetThreadPriority(::GetCurrentThread()));\par
00514     ::ResumeThread(watcher_thread);\par
00515     ::CloseHandle(watcher_thread);\par
00516   \}\par
00517 \par
00518   {\cf20 // Monitors exit from a given thread and notifies those}\par
00519   {\cf20 // ThreadIdToThreadLocals about thread termination.}\par
00520   {\cf17 static} DWORD WINAPI WatcherThreadFunc(LPVOID param) \{\par
00521     {\cf17 const} ThreadIdAndHandle* tah =\par
00522         {\cf17 reinterpret_cast<}{\cf17 const }ThreadIdAndHandle*{\cf17 >}(param);\par
00523     GTEST_CHECK_(\par
00524         ::WaitForSingleObject(tah->second, INFINITE) == WAIT_OBJECT_0);\par
00525     OnThreadExit(tah->first);\par
00526     ::CloseHandle(tah->second);\par
00527     {\cf17 delete} tah;\par
00528     {\cf19 return} 0;\par
00529   \}\par
00530 \par
00531   {\cf20 // Returns map of thread local instances.}\par
00532   {\cf17 static} ThreadIdToThreadLocals* GetThreadLocalsMapLocked() \{\par
00533     mutex_.AssertHeld();\par
00534     {\cf17 static} ThreadIdToThreadLocals* map = {\cf17 new} ThreadIdToThreadLocals;\par
00535     {\cf19 return} map;\par
00536   \}\par
00537 \par
00538   {\cf20 // Protects access to GetThreadLocalsMapLocked() and its return value.}\par
00539   {\cf17 static} Mutex mutex_;\par
00540   {\cf20 // Protects access to GetThreadMapLocked() and its return value.}\par
00541   {\cf17 static} Mutex thread_map_mutex_;\par
00542 \};\par
00543 \par
00544 Mutex ThreadLocalRegistryImpl::mutex_(Mutex::kStaticMutex);\par
00545 Mutex ThreadLocalRegistryImpl::thread_map_mutex_(Mutex::kStaticMutex);\par
00546 \par
00547 ThreadLocalValueHolderBase* ThreadLocalRegistry::GetValueOnCurrentThread(\par
00548       {\cf17 const} ThreadLocalBase* thread_local_instance) \{\par
00549   {\cf19 return} ThreadLocalRegistryImpl::GetValueOnCurrentThread(\par
00550       thread_local_instance);\par
00551 \}\par
00552 \par
00553 {\cf18 void} ThreadLocalRegistry::OnThreadLocalDestroyed(\par
00554       {\cf17 const} ThreadLocalBase* thread_local_instance) \{\par
00555   ThreadLocalRegistryImpl::OnThreadLocalDestroyed(thread_local_instance);\par
00556 \}\par
00557 \par
00558 {\cf21 #endif  }{\cf20 // GTEST_IS_THREADSAFE && GTEST_OS_WINDOWS}\par
00559 \par
00560 {\cf21 #if GTEST_USES_POSIX_RE}\par
00561 \par
00562 {\cf20 // Implements RE.  Currently only needed for death tests.}\par
00563 \par
00564 RE::~RE() \{\par
00565   {\cf19 if} (is_valid_) \{\par
00566     {\cf20 // regfree'ing an invalid regex might crash because the content}\par
00567     {\cf20 // of the regex is undefined. Since the regex's are essentially}\par
00568     {\cf20 // the same, one cannot be valid (or invalid) without the other}\par
00569     {\cf20 // being so too.}\par
00570     regfree(&partial_regex_);\par
00571     regfree(&full_regex_);\par
00572   \}\par
00573   free({\cf17 const_cast<}{\cf18 char}*{\cf17 >}(pattern_));\par
00574 \}\par
00575 \par
00576 {\cf20 // Returns true iff regular expression re matches the entire str.}\par
00577 {\cf18 bool} RE::FullMatch({\cf17 const} {\cf18 char}* str, {\cf17 const} RE& re) \{\par
00578   {\cf19 if} (!re.is_valid_) {\cf19 return} {\cf17 false};\par
00579 \par
00580   regmatch_t match;\par
00581   {\cf19 return} regexec(&re.full_regex_, str, 1, &match, 0) == 0;\par
00582 \}\par
00583 \par
00584 {\cf20 // Returns true iff regular expression re matches a substring of str}\par
00585 {\cf20 // (including str itself).}\par
00586 {\cf18 bool} RE::PartialMatch({\cf17 const} {\cf18 char}* str, {\cf17 const} RE& re) \{\par
00587   {\cf19 if} (!re.is_valid_) {\cf19 return} {\cf17 false};\par
00588 \par
00589   regmatch_t match;\par
00590   {\cf19 return} regexec(&re.partial_regex_, str, 1, &match, 0) == 0;\par
00591 \}\par
00592 \par
00593 {\cf20 // Initializes an RE from its string representation.}\par
00594 {\cf18 void} RE::Init({\cf17 const} {\cf18 char}* regex) \{\par
00595   pattern_ = posix::StrDup(regex);\par
00596 \par
00597   {\cf20 // Reserves enough bytes to hold the regular expression used for a}\par
00598   {\cf20 // full match.}\par
00599   {\cf17 const} {\cf18 size_t} full_regex_len = strlen(regex) + 10;\par
00600   {\cf18 char}* {\cf17 const} full_pattern = {\cf17 new} {\cf18 char}[full_regex_len];\par
00601 \par
00602   snprintf(full_pattern, full_regex_len, {\cf22 "^(%s)$"}, regex);\par
00603   is_valid_ = regcomp(&full_regex_, full_pattern, REG_EXTENDED) == 0;\par
00604   {\cf20 // We want to call regcomp(&partial_regex_, ...) even if the}\par
00605   {\cf20 // previous expression returns false.  Otherwise partial_regex_ may}\par
00606   {\cf20 // not be properly initialized can may cause trouble when it's}\par
00607   {\cf20 // freed.}\par
00608   {\cf20 //}\par
00609   {\cf20 // Some implementation of POSIX regex (e.g. on at least some}\par
00610   {\cf20 // versions of Cygwin) doesn't accept the empty string as a valid}\par
00611   {\cf20 // regex.  We change it to an equivalent form "()" to be safe.}\par
00612   {\cf19 if} (is_valid_) \{\par
00613     {\cf17 const} {\cf18 char}* {\cf17 const} partial_regex = (*regex == {\cf23 '\\0'}) ? {\cf22 "()"} : regex;\par
00614     is_valid_ = regcomp(&partial_regex_, partial_regex, REG_EXTENDED) == 0;\par
00615   \}\par
00616   EXPECT_TRUE(is_valid_)\par
00617       << {\cf22 "Regular expression \\""} << regex\par
00618       << {\cf22 "\\" is not a valid POSIX Extended regular expression."};\par
00619 \par
00620   {\cf17 delete}[] full_pattern;\par
00621 \}\par
00622 \par
00623 {\cf21 #elif GTEST_USES_SIMPLE_RE}\par
00624 \par
00625 {\cf20 // Returns true iff ch appears anywhere in str (excluding the}\par
00626 {\cf20 // terminating '\\0' character).}\par
00627 {\cf18 bool} IsInSet({\cf18 char} ch, {\cf17 const} {\cf18 char}* str) \{\par
00628   {\cf19 return} ch != {\cf23 '\\0'} && strchr(str, ch) != NULL;\par
00629 \}\par
00630 \par
00631 {\cf20 // Returns true iff ch belongs to the given classification.  Unlike}\par
00632 {\cf20 // similar functions in <ctype.h>, these aren't affected by the}\par
00633 {\cf20 // current locale.}\par
00634 {\cf18 bool} IsAsciiDigit({\cf18 char} ch) \{ {\cf19 return} {\cf23 '0'} <= ch && ch <= {\cf23 '9'}; \}\par
00635 {\cf18 bool} IsAsciiPunct({\cf18 char} ch) \{\par
00636   {\cf19 return} IsInSet(ch, {\cf22 "^-!\\"#$%&'()*+,./:;<=>?@[\\\\]_`\{|\}~"});\par
00637 \}\par
00638 {\cf18 bool} IsRepeat({\cf18 char} ch) \{ {\cf19 return} IsInSet(ch, {\cf22 "?*+"}); \}\par
00639 {\cf18 bool} IsAsciiWhiteSpace({\cf18 char} ch) \{ {\cf19 return} IsInSet(ch, {\cf22 " \\f\\n\\r\\t\\v"}); \}\par
00640 {\cf18 bool} IsAsciiWordChar({\cf18 char} ch) \{\par
00641   {\cf19 return} ({\cf23 'a'} <= ch && ch <= {\cf23 'z'}) || ({\cf23 'A'} <= ch && ch <= {\cf23 'Z'}) ||\par
00642       ({\cf23 '0'} <= ch && ch <= {\cf23 '9'}) || ch == {\cf23 '_'};\par
00643 \}\par
00644 \par
00645 {\cf20 // Returns true iff "\\\\c" is a supported escape sequence.}\par
00646 {\cf18 bool} IsValidEscape({\cf18 char} c) \{\par
00647   {\cf19 return} (IsAsciiPunct(c) || IsInSet(c, {\cf22 "dDfnrsStvwW"}));\par
00648 \}\par
00649 \par
00650 {\cf20 // Returns true iff the given atom (specified by escaped and pattern)}\par
00651 {\cf20 // matches ch.  The result is undefined if the atom is invalid.}\par
00652 {\cf18 bool} AtomMatchesChar({\cf18 bool} escaped, {\cf18 char} pattern_char, {\cf18 char} ch) \{\par
00653   {\cf19 if} (escaped) \{  {\cf20 // "\\\\p" where p is pattern_char.}\par
00654     {\cf19 switch} (pattern_char) \{\par
00655       {\cf19 case} {\cf23 'd'}: {\cf19 return} IsAsciiDigit(ch);\par
00656       {\cf19 case} {\cf23 'D'}: {\cf19 return} !IsAsciiDigit(ch);\par
00657       {\cf19 case} {\cf23 'f'}: {\cf19 return} ch == {\cf23 '\\f'};\par
00658       {\cf19 case} {\cf23 'n'}: {\cf19 return} ch == {\cf23 '\\n'};\par
00659       {\cf19 case} {\cf23 'r'}: {\cf19 return} ch == {\cf23 '\\r'};\par
00660       {\cf19 case} {\cf23 's'}: {\cf19 return} IsAsciiWhiteSpace(ch);\par
00661       {\cf19 case} {\cf23 'S'}: {\cf19 return} !IsAsciiWhiteSpace(ch);\par
00662       {\cf19 case} {\cf23 't'}: {\cf19 return} ch == {\cf23 '\\t'};\par
00663       {\cf19 case} {\cf23 'v'}: {\cf19 return} ch == {\cf23 '\\v'};\par
00664       {\cf19 case} {\cf23 'w'}: {\cf19 return} IsAsciiWordChar(ch);\par
00665       {\cf19 case} {\cf23 'W'}: {\cf19 return} !IsAsciiWordChar(ch);\par
00666     \}\par
00667     {\cf19 return} IsAsciiPunct(pattern_char) && pattern_char == ch;\par
00668   \}\par
00669 \par
00670   {\cf19 return} (pattern_char == {\cf23 '.'} && ch != {\cf23 '\\n'}) || pattern_char == ch;\par
00671 \}\par
00672 \par
00673 {\cf20 // Helper function used by ValidateRegex() to format error messages.}\par
00674 std::string FormatRegexSyntaxError({\cf17 const} {\cf18 char}* regex, {\cf18 int} index) \{\par
00675   {\cf19 return} (Message() << {\cf22 "Syntax error at index "} << index\par
00676           << {\cf22 " in simple regular expression \\""} << regex << {\cf22 "\\": "}).GetString();\par
00677 \}\par
00678 \par
00679 {\cf20 // Generates non-fatal failures and returns false if regex is invalid;}\par
00680 {\cf20 // otherwise returns true.}\par
00681 {\cf18 bool} ValidateRegex({\cf17 const} {\cf18 char}* regex) \{\par
00682   {\cf19 if} (regex == NULL) \{\par
00683     {\cf20 // TODO(wan@google.com): fix the source file location in the}\par
00684     {\cf20 // assertion failures to match where the regex is used in user}\par
00685     {\cf20 // code.}\par
00686     ADD_FAILURE() << {\cf22 "NULL is not a valid simple regular expression."};\par
00687     {\cf19 return} {\cf17 false};\par
00688   \}\par
00689 \par
00690   {\cf18 bool} is_valid = {\cf17 true};\par
00691 \par
00692   {\cf20 // True iff ?, *, or + can follow the previous atom.}\par
00693   {\cf18 bool} prev_repeatable = {\cf17 false};\par
00694   {\cf19 for} ({\cf18 int} i = 0; regex[i]; i++) \{\par
00695     {\cf19 if} (regex[i] == {\cf23 '\\\\'}) \{  {\cf20 // An escape sequence}\par
00696       i++;\par
00697       {\cf19 if} (regex[i] == {\cf23 '\\0'}) \{\par
00698         ADD_FAILURE() << FormatRegexSyntaxError(regex, i - 1)\par
00699                       << {\cf22 "'\\\\' cannot appear at the end."};\par
00700         {\cf19 return} {\cf17 false};\par
00701       \}\par
00702 \par
00703       {\cf19 if} (!IsValidEscape(regex[i])) \{\par
00704         ADD_FAILURE() << FormatRegexSyntaxError(regex, i - 1)\par
00705                       << {\cf22 "invalid escape sequence \\"\\\\"} << regex[i] << {\cf22 "\\"."};\par
00706         is_valid = {\cf17 false};\par
00707       \}\par
00708       prev_repeatable = {\cf17 true};\par
00709     \} {\cf19 else} \{  {\cf20 // Not an escape sequence.}\par
00710       {\cf17 const} {\cf18 char} ch = regex[i];\par
00711 \par
00712       {\cf19 if} (ch == {\cf23 '^'} && i > 0) \{\par
00713         ADD_FAILURE() << FormatRegexSyntaxError(regex, i)\par
00714                       << {\cf22 "'^' can only appear at the beginning."};\par
00715         is_valid = {\cf17 false};\par
00716       \} {\cf19 else} {\cf19 if} (ch == {\cf23 '$'} && regex[i + 1] != {\cf23 '\\0'}) \{\par
00717         ADD_FAILURE() << FormatRegexSyntaxError(regex, i)\par
00718                       << {\cf22 "'$' can only appear at the end."};\par
00719         is_valid = {\cf17 false};\par
00720       \} {\cf19 else} {\cf19 if} (IsInSet(ch, {\cf22 "()[]\{\}|"})) \{\par
00721         ADD_FAILURE() << FormatRegexSyntaxError(regex, i)\par
00722                       << {\cf22 "'"} << ch << {\cf22 "' is unsupported."};\par
00723         is_valid = {\cf17 false};\par
00724       \} {\cf19 else} {\cf19 if} (IsRepeat(ch) && !prev_repeatable) \{\par
00725         ADD_FAILURE() << FormatRegexSyntaxError(regex, i)\par
00726                       << {\cf22 "'"} << ch << {\cf22 "' can only follow a repeatable token."};\par
00727         is_valid = {\cf17 false};\par
00728       \}\par
00729 \par
00730       prev_repeatable = !IsInSet(ch, {\cf22 "^$?*+"});\par
00731     \}\par
00732   \}\par
00733 \par
00734   {\cf19 return} is_valid;\par
00735 \}\par
00736 \par
00737 {\cf20 // Matches a repeated regex atom followed by a valid simple regular}\par
00738 {\cf20 // expression.  The regex atom is defined as c if escaped is false,}\par
00739 {\cf20 // or \\c otherwise.  repeat is the repetition meta character (?, *,}\par
00740 {\cf20 // or +).  The behavior is undefined if str contains too many}\par
00741 {\cf20 // characters to be indexable by size_t, in which case the test will}\par
00742 {\cf20 // probably time out anyway.  We are fine with this limitation as}\par
00743 {\cf20 // std::string has it too.}\par
00744 {\cf18 bool} MatchRepetitionAndRegexAtHead(\par
00745     {\cf18 bool} escaped, {\cf18 char} c, {\cf18 char} repeat, {\cf17 const} {\cf18 char}* regex,\par
00746     {\cf17 const} {\cf18 char}* str) \{\par
00747   {\cf17 const} {\cf18 size_t} min_count = (repeat == {\cf23 '+'}) ? 1 : 0;\par
00748   {\cf17 const} {\cf18 size_t} max_count = (repeat == {\cf23 '?'}) ? 1 :\par
00749       {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(-1) - 1;\par
00750   {\cf20 // We cannot call numeric_limits::max() as it conflicts with the}\par
00751   {\cf20 // max() macro on Windows.}\par
00752 \par
00753   {\cf19 for} ({\cf18 size_t} i = 0; i <= max_count; ++i) \{\par
00754     {\cf20 // We know that the atom matches each of the first i characters in str.}\par
00755     {\cf19 if} (i >= min_count && MatchRegexAtHead(regex, str + i)) \{\par
00756       {\cf20 // We have enough matches at the head, and the tail matches too.}\par
00757       {\cf20 // Since we only care about *whether* the pattern matches str}\par
00758       {\cf20 // (as opposed to *how* it matches), there is no need to find a}\par
00759       {\cf20 // greedy match.}\par
00760       {\cf19 return} {\cf17 true};\par
00761     \}\par
00762     {\cf19 if} (str[i] == {\cf23 '\\0'} || !AtomMatchesChar(escaped, c, str[i]))\par
00763       {\cf19 return} {\cf17 false};\par
00764   \}\par
00765   {\cf19 return} {\cf17 false};\par
00766 \}\par
00767 \par
00768 {\cf20 // Returns true iff regex matches a prefix of str.  regex must be a}\par
00769 {\cf20 // valid simple regular expression and not start with "^", or the}\par
00770 {\cf20 // result is undefined.}\par
00771 {\cf18 bool} MatchRegexAtHead({\cf17 const} {\cf18 char}* regex, {\cf17 const} {\cf18 char}* str) \{\par
00772   {\cf19 if} (*regex == {\cf23 '\\0'})  {\cf20 // An empty regex matches a prefix of anything.}\par
00773     {\cf19 return} {\cf17 true};\par
00774 \par
00775   {\cf20 // "$" only matches the end of a string.  Note that regex being}\par
00776   {\cf20 // valid guarantees that there's nothing after "$" in it.}\par
00777   {\cf19 if} (*regex == {\cf23 '$'})\par
00778     {\cf19 return} *str == {\cf23 '\\0'};\par
00779 \par
00780   {\cf20 // Is the first thing in regex an escape sequence?}\par
00781   {\cf17 const} {\cf18 bool} escaped = *regex == {\cf23 '\\\\'};\par
00782   {\cf19 if} (escaped)\par
00783     ++regex;\par
00784   {\cf19 if} (IsRepeat(regex[1])) \{\par
00785     {\cf20 // MatchRepetitionAndRegexAtHead() calls MatchRegexAtHead(), so}\par
00786     {\cf20 // here's an indirect recursion.  It terminates as the regex gets}\par
00787     {\cf20 // shorter in each recursion.}\par
00788     {\cf19 return} MatchRepetitionAndRegexAtHead(\par
00789         escaped, regex[0], regex[1], regex + 2, str);\par
00790   \} {\cf19 else} \{\par
00791     {\cf20 // regex isn't empty, isn't "$", and doesn't start with a}\par
00792     {\cf20 // repetition.  We match the first atom of regex with the first}\par
00793     {\cf20 // character of str and recurse.}\par
00794     {\cf19 return} (*str != {\cf23 '\\0'}) && AtomMatchesChar(escaped, *regex, *str) &&\par
00795         MatchRegexAtHead(regex + 1, str + 1);\par
00796   \}\par
00797 \}\par
00798 \par
00799 {\cf20 // Returns true iff regex matches any substring of str.  regex must be}\par
00800 {\cf20 // a valid simple regular expression, or the result is undefined.}\par
00801 {\cf20 //}\par
00802 {\cf20 // The algorithm is recursive, but the recursion depth doesn't exceed}\par
00803 {\cf20 // the regex length, so we won't need to worry about running out of}\par
00804 {\cf20 // stack space normally.  In rare cases the time complexity can be}\par
00805 {\cf20 // exponential with respect to the regex length + the string length,}\par
00806 {\cf20 // but usually it's must faster (often close to linear).}\par
00807 {\cf18 bool} MatchRegexAnywhere({\cf17 const} {\cf18 char}* regex, {\cf17 const} {\cf18 char}* str) \{\par
00808   {\cf19 if} (regex == NULL || str == NULL)\par
00809     {\cf19 return} {\cf17 false};\par
00810 \par
00811   {\cf19 if} (*regex == {\cf23 '^'})\par
00812     {\cf19 return} MatchRegexAtHead(regex + 1, str);\par
00813 \par
00814   {\cf20 // A successful match can be anywhere in str.}\par
00815   {\cf19 do} \{\par
00816     {\cf19 if} (MatchRegexAtHead(regex, str))\par
00817       {\cf19 return} {\cf17 true};\par
00818   \} {\cf19 while} (*str++ != {\cf23 '\\0'});\par
00819   {\cf19 return} {\cf17 false};\par
00820 \}\par
00821 \par
00822 {\cf20 // Implements the RE class.}\par
00823 \par
00824 RE::~RE() \{\par
00825   free({\cf17 const_cast<}{\cf18 char}*{\cf17 >}(pattern_));\par
00826   free({\cf17 const_cast<}{\cf18 char}*{\cf17 >}(full_pattern_));\par
00827 \}\par
00828 \par
00829 {\cf20 // Returns true iff regular expression re matches the entire str.}\par
00830 {\cf18 bool} RE::FullMatch({\cf17 const} {\cf18 char}* str, {\cf17 const} RE& re) \{\par
00831   {\cf19 return} re.is_valid_ && MatchRegexAnywhere(re.full_pattern_, str);\par
00832 \}\par
00833 \par
00834 {\cf20 // Returns true iff regular expression re matches a substring of str}\par
00835 {\cf20 // (including str itself).}\par
00836 {\cf18 bool} RE::PartialMatch({\cf17 const} {\cf18 char}* str, {\cf17 const} RE& re) \{\par
00837   {\cf19 return} re.is_valid_ && MatchRegexAnywhere(re.pattern_, str);\par
00838 \}\par
00839 \par
00840 {\cf20 // Initializes an RE from its string representation.}\par
00841 {\cf18 void} RE::Init({\cf17 const} {\cf18 char}* regex) \{\par
00842   pattern_ = full_pattern_ = NULL;\par
00843   {\cf19 if} (regex != NULL) \{\par
00844     pattern_ = posix::StrDup(regex);\par
00845   \}\par
00846 \par
00847   is_valid_ = ValidateRegex(regex);\par
00848   {\cf19 if} (!is_valid_) \{\par
00849     {\cf20 // No need to calculate the full pattern when the regex is invalid.}\par
00850     {\cf19 return};\par
00851   \}\par
00852 \par
00853   {\cf17 const} {\cf18 size_t} len = strlen(regex);\par
00854   {\cf20 // Reserves enough bytes to hold the regular expression used for a}\par
00855   {\cf20 // full match: we need space to prepend a '^', append a '$', and}\par
00856   {\cf20 // terminate the string with '\\0'.}\par
00857   {\cf18 char}* buffer = {\cf17 static_cast<}{\cf18 char}*{\cf17 >}(malloc(len + 3));\par
00858   full_pattern_ = buffer;\par
00859 \par
00860   {\cf19 if} (*regex != {\cf23 '^'})\par
00861     *buffer++ = {\cf23 '^'};  {\cf20 // Makes sure full_pattern_ starts with '^'.}\par
00862 \par
00863   {\cf20 // We don't use snprintf or strncpy, as they trigger a warning when}\par
00864   {\cf20 // compiled with VC++ 8.0.}\par
00865   memcpy(buffer, regex, len);\par
00866   buffer += len;\par
00867 \par
00868   {\cf19 if} (len == 0 || regex[len - 1] != {\cf23 '$'})\par
00869     *buffer++ = {\cf23 '$'};  {\cf20 // Makes sure full_pattern_ ends with '$'.}\par
00870 \par
00871   *buffer = {\cf23 '\\0'};\par
00872 \}\par
00873 \par
00874 {\cf21 #endif  }{\cf20 // GTEST_USES_POSIX_RE}\par
00875 \par
00876 {\cf17 const} {\cf18 char} kUnknownFile[] = {\cf22 "unknown file"};\par
00877 \par
00878 {\cf20 // Formats a source file path and a line number as they would appear}\par
00879 {\cf20 // in an error message from the compiler used to compile this code.}\par
00880 GTEST_API_ ::std::string FormatFileLocation({\cf17 const} {\cf18 char}* file, {\cf18 int} line) \{\par
00881   {\cf17 const} std::string file_name(file == NULL ? kUnknownFile : file);\par
00882 \par
00883   {\cf19 if} (line < 0) \{\par
00884     {\cf19 return} file_name + {\cf22 ":"};\par
00885   \}\par
00886 {\cf21 #ifdef _MSC_VER}\par
00887   {\cf19 return} file_name + {\cf22 "("} + StreamableToString(line) + {\cf22 "):"};\par
00888 {\cf21 #else}\par
00889   {\cf19 return} file_name + {\cf22 ":"} + StreamableToString(line) + {\cf22 ":"};\par
00890 {\cf21 #endif  }{\cf20 // _MSC_VER}\par
00891 \}\par
00892 \par
00893 {\cf20 // Formats a file location for compiler-independent XML output.}\par
00894 {\cf20 // Although this function is not platform dependent, we put it next to}\par
00895 {\cf20 // FormatFileLocation in order to contrast the two functions.}\par
00896 {\cf20 // Note that FormatCompilerIndependentFileLocation() does NOT append colon}\par
00897 {\cf20 // to the file location it produces, unlike FormatFileLocation().}\par
00898 GTEST_API_ ::std::string FormatCompilerIndependentFileLocation(\par
00899     {\cf17 const} {\cf18 char}* file, {\cf18 int} line) \{\par
00900   {\cf17 const} std::string file_name(file == NULL ? kUnknownFile : file);\par
00901 \par
00902   {\cf19 if} (line < 0)\par
00903     {\cf19 return} file_name;\par
00904   {\cf19 else}\par
00905     {\cf19 return} file_name + {\cf22 ":"} + StreamableToString(line);\par
00906 \}\par
00907 \par
00908 GTestLog::GTestLog(GTestLogSeverity severity, {\cf17 const} {\cf18 char}* file, {\cf18 int} line)\par
00909     : severity_(severity) \{\par
00910   {\cf17 const} {\cf18 char}* {\cf17 const} marker =\par
00911       severity == GTEST_INFO ?    {\cf22 "[  INFO ]"} :\par
00912       severity == GTEST_WARNING ? {\cf22 "[WARNING]"} :\par
00913       severity == GTEST_ERROR ?   {\cf22 "[ ERROR ]"} : {\cf22 "[ FATAL ]"};\par
00914   GetStream() << ::std::endl << marker << {\cf22 " "}\par
00915               << FormatFileLocation(file, line).c_str() << {\cf22 ": "};\par
00916 \}\par
00917 \par
00918 {\cf20 // Flushes the buffers and, if severity is GTEST_FATAL, aborts the program.}\par
00919 GTestLog::~GTestLog() \{\par
00920   GetStream() << ::std::endl;\par
00921   {\cf19 if} (severity_ == GTEST_FATAL) \{\par
00922     fflush(stderr);\par
00923     posix::Abort();\par
00924   \}\par
00925 \}\par
00926 {\cf20 // Disable Microsoft deprecation warnings for POSIX functions called from}\par
00927 {\cf20 // this class (creat, dup, dup2, and close)}\par
00928 GTEST_DISABLE_MSC_WARNINGS_PUSH_(4996)\par
00929 \par
00930 {\cf21 #if GTEST_HAS_STREAM_REDIRECTION}\par
00931 \par
00932 {\cf20 // Object that captures an output stream (stdout/stderr).}\par
00933 {\cf17 class }CapturedStream \{\par
00934  {\cf17 public}:\par
00935   {\cf20 // The ctor redirects the stream to a temporary file.}\par
00936   {\cf17 explicit} CapturedStream({\cf18 int} fd) : fd_(fd), uncaptured_fd_(dup(fd)) \{\par
00937 {\cf21 # if GTEST_OS_WINDOWS}\par
00938     {\cf18 char} temp_dir_path[MAX_PATH + 1] = \{ {\cf23 '\\0'} \};  {\cf20 // NOLINT}\par
00939     {\cf18 char} temp_file_path[MAX_PATH + 1] = \{ {\cf23 '\\0'} \};  {\cf20 // NOLINT}\par
00940 \par
00941     ::GetTempPathA({\cf17 sizeof}(temp_dir_path), temp_dir_path);\par
00942     {\cf17 const} UINT success = ::GetTempFileNameA(temp_dir_path,\par
00943                                             {\cf22 "gtest_redir"},\par
00944                                             0,  {\cf20 // Generate unique file name.}\par
00945                                             temp_file_path);\par
00946     GTEST_CHECK_(success != 0)\par
00947         << {\cf22 "Unable to create a temporary file in "} << temp_dir_path;\par
00948     {\cf17 const} {\cf18 int} captured_fd = creat(temp_file_path, _S_IREAD | _S_IWRITE);\par
00949     GTEST_CHECK_(captured_fd != -1) << {\cf22 "Unable to open temporary file "}\par
00950                                     << temp_file_path;\par
00951     filename_ = temp_file_path;\par
00952 {\cf21 # else}\par
00953     {\cf20 // There's no guarantee that a test has write access to the current}\par
00954     {\cf20 // directory, so we create the temporary file in the /tmp directory}\par
00955     {\cf20 // instead. We use /tmp on most systems, and /sdcard on Android.}\par
00956     {\cf20 // That's because Android doesn't have /tmp.}\par
00957 {\cf21 #  if GTEST_OS_LINUX_ANDROID}\par
00958     {\cf20 // Note: Android applications are expected to call the framework's}\par
00959     {\cf20 // Context.getExternalStorageDirectory() method through JNI to get}\par
00960     {\cf20 // the location of the world-writable SD Card directory. However,}\par
00961     {\cf20 // this requires a Context handle, which cannot be retrieved}\par
00962     {\cf20 // globally from native code. Doing so also precludes running the}\par
00963     {\cf20 // code as part of a regular standalone executable, which doesn't}\par
00964     {\cf20 // run in a Dalvik process (e.g. when running it through 'adb shell').}\par
00965     {\cf20 //}\par
00966     {\cf20 // The location /sdcard is directly accessible from native code}\par
00967     {\cf20 // and is the only location (unofficially) supported by the Android}\par
00968     {\cf20 // team. It's generally a symlink to the real SD Card mount point}\par
00969     {\cf20 // which can be /mnt/sdcard, /mnt/sdcard0, /system/media/sdcard, or}\par
00970     {\cf20 // other OEM-customized locations. Never rely on these, and always}\par
00971     {\cf20 // use /sdcard.}\par
00972     {\cf18 char} name_template[] = {\cf22 "/sdcard/gtest_captured_stream.XXXXXX"};\par
00973 {\cf21 #  else}\par
00974     {\cf18 char} name_template[] = {\cf22 "/tmp/captured_stream.XXXXXX"};\par
00975 {\cf21 #  endif  }{\cf20 // GTEST_OS_LINUX_ANDROID}\par
00976     {\cf17 const} {\cf18 int} captured_fd = mkstemp(name_template);\par
00977     filename_ = name_template;\par
00978 {\cf21 # endif  }{\cf20 // GTEST_OS_WINDOWS}\par
00979     fflush(NULL);\par
00980     dup2(captured_fd, fd_);\par
00981     close(captured_fd);\par
00982   \}\par
00983 \par
00984   ~CapturedStream() \{\par
00985     remove(filename_.c_str());\par
00986   \}\par
00987 \par
00988   std::string GetCapturedString() \{\par
00989     {\cf19 if} (uncaptured_fd_ != -1) \{\par
00990       {\cf20 // Restores the original stream.}\par
00991       fflush(NULL);\par
00992       dup2(uncaptured_fd_, fd_);\par
00993       close(uncaptured_fd_);\par
00994       uncaptured_fd_ = -1;\par
00995     \}\par
00996 \par
00997     FILE* {\cf17 const} file = posix::FOpen(filename_.c_str(), {\cf22 "r"});\par
00998     {\cf17 const} std::string content = ReadEntireFile(file);\par
00999     posix::FClose(file);\par
01000     {\cf19 return} content;\par
01001   \}\par
01002 \par
01003  {\cf17 private}:\par
01004   {\cf17 const} {\cf18 int} fd_;  {\cf20 // A stream to capture.}\par
01005   {\cf18 int} uncaptured_fd_;\par
01006   {\cf20 // Name of the temporary file holding the stderr output.}\par
01007   ::std::string filename_;\par
01008 \par
01009   GTEST_DISALLOW_COPY_AND_ASSIGN_(CapturedStream);\par
01010 \};\par
01011 \par
01012 GTEST_DISABLE_MSC_WARNINGS_POP_()\par
01013 \par
01014 static CapturedStream* g_captured_stderr = NULL;\par
01015 static CapturedStream* g_captured_stdout = NULL;\par
01016 \par
01017 {\cf20 // Starts capturing an output stream (stdout/stderr).}\par
01018 {\cf18 void} CaptureStream({\cf18 int} fd, const {\cf18 char}* stream_name, CapturedStream** stream) \{\par
01019   {\cf19 if} (*stream != NULL) \{\par
01020     GTEST_LOG_(FATAL) << {\cf22 "Only one "} << stream_name\par
01021                       << {\cf22 " capturer can exist at a time."};\par
01022   \}\par
01023   *stream = {\cf17 new} CapturedStream(fd);\par
01024 \}\par
01025 \par
01026 {\cf20 // Stops capturing the output stream and returns the captured string.}\par
01027 std::string GetCapturedStream(CapturedStream** captured_stream) \{\par
01028   {\cf17 const} std::string content = (*captured_stream)->GetCapturedString();\par
01029 \par
01030   {\cf17 delete} *captured_stream;\par
01031   *captured_stream = NULL;\par
01032 \par
01033   {\cf19 return} content;\par
01034 \}\par
01035 \par
01036 {\cf20 // Starts capturing stdout.}\par
01037 {\cf18 void} CaptureStdout() \{\par
01038   CaptureStream(kStdOutFileno, {\cf22 "stdout"}, &g_captured_stdout);\par
01039 \}\par
01040 \par
01041 {\cf20 // Starts capturing stderr.}\par
01042 {\cf18 void} CaptureStderr() \{\par
01043   CaptureStream(kStdErrFileno, {\cf22 "stderr"}, &g_captured_stderr);\par
01044 \}\par
01045 \par
01046 {\cf20 // Stops capturing stdout and returns the captured string.}\par
01047 std::string GetCapturedStdout() \{\par
01048   {\cf19 return} GetCapturedStream(&g_captured_stdout);\par
01049 \}\par
01050 \par
01051 {\cf20 // Stops capturing stderr and returns the captured string.}\par
01052 std::string GetCapturedStderr() \{\par
01053   {\cf19 return} GetCapturedStream(&g_captured_stderr);\par
01054 \}\par
01055 \par
01056 {\cf21 #endif  }{\cf20 // GTEST_HAS_STREAM_REDIRECTION}\par
01057 \par
01058 {\cf18 size_t} GetFileSize(FILE* file) \{\par
01059   fseek(file, 0, SEEK_END);\par
01060   {\cf19 return} {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(ftell(file));\par
01061 \}\par
01062 \par
01063 std::string ReadEntireFile(FILE* file) \{\par
01064   {\cf17 const} {\cf18 size_t} file_size = GetFileSize(file);\par
01065   {\cf18 char}* {\cf17 const} buffer = {\cf17 new} {\cf18 char}[file_size];\par
01066 \par
01067   {\cf18 size_t} bytes_last_read = 0;  {\cf20 // # of bytes read in the last fread()}\par
01068   {\cf18 size_t} bytes_read = 0;       {\cf20 // # of bytes read so far}\par
01069 \par
01070   fseek(file, 0, SEEK_SET);\par
01071 \par
01072   {\cf20 // Keeps reading the file until we cannot read further or the}\par
01073   {\cf20 // pre-determined file size is reached.}\par
01074   {\cf19 do} \{\par
01075     bytes_last_read = fread(buffer+bytes_read, 1, file_size-bytes_read, file);\par
01076     bytes_read += bytes_last_read;\par
01077   \} {\cf19 while} (bytes_last_read > 0 && bytes_read < file_size);\par
01078 \par
01079   {\cf17 const} std::string content(buffer, bytes_read);\par
01080   {\cf17 delete}[] buffer;\par
01081 \par
01082   {\cf19 return} content;\par
01083 \}\par
01084 \par
01085 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
01086 \par
01087 {\cf17 static} const ::std::vector<testing::internal::string>* g_injected_test_argvs =\par
01088                                         NULL;  {\cf20 // Owned.}\par
01089 \par
01090 {\cf18 void} SetInjectableArgvs(const ::std::vector<testing::internal::string>* argvs) \{\par
01091   {\cf19 if} (g_injected_test_argvs != argvs)\par
01092     {\cf17 delete} g_injected_test_argvs;\par
01093   g_injected_test_argvs = argvs;\par
01094 \}\par
01095 \par
01096 const ::std::vector<testing::internal::string>& GetInjectableArgvs() \{\par
01097   {\cf19 if} (g_injected_test_argvs != NULL) \{\par
01098     {\cf19 return} *g_injected_test_argvs;\par
01099   \}\par
01100   {\cf19 return} GetArgvs();\par
01101 \}\par
01102 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
01103 \par
01104 {\cf21 #if GTEST_OS_WINDOWS_MOBILE}\par
01105 {\cf17 namespace }posix \{\par
01106 {\cf18 void} Abort() \{\par
01107   DebugBreak();\par
01108   TerminateProcess(GetCurrentProcess(), 1);\par
01109 \}\par
01110 \}  {\cf20 // namespace posix}\par
01111 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
01112 \par
01113 {\cf20 // Returns the name of the environment variable corresponding to the}\par
01114 {\cf20 // given flag.  For example, FlagToEnvVar("foo") will return}\par
01115 {\cf20 // "GTEST_FOO" in the open-source version.}\par
01116 {\cf17 static} std::string FlagToEnvVar({\cf17 const} {\cf18 char}* flag) \{\par
01117   {\cf17 const} std::string full_flag =\par
01118       (Message() << GTEST_FLAG_PREFIX_ << flag).GetString();\par
01119 \par
01120   Message env_var;\par
01121   {\cf19 for} ({\cf18 size_t} i = 0; i != full_flag.length(); i++) \{\par
01122     env_var << ToUpper(full_flag.c_str()[i]);\par
01123   \}\par
01124 \par
01125   {\cf19 return} env_var.GetString();\par
01126 \}\par
01127 \par
01128 {\cf20 // Parses 'str' for a 32-bit signed integer.  If successful, writes}\par
01129 {\cf20 // the result to *value and returns true; otherwise leaves *value}\par
01130 {\cf20 // unchanged and returns false.}\par
01131 {\cf18 bool} ParseInt32({\cf17 const} Message& src_text, {\cf17 const} {\cf18 char}* str, Int32* value) \{\par
01132   {\cf20 // Parses the environment variable as a decimal integer.}\par
01133   {\cf18 char}* end = NULL;\par
01134   {\cf17 const} {\cf18 long} long_value = strtol(str, &end, 10);  {\cf20 // NOLINT}\par
01135 \par
01136   {\cf20 // Has strtol() consumed all characters in the string?}\par
01137   {\cf19 if} (*end != {\cf23 '\\0'}) \{\par
01138     {\cf20 // No - an invalid character was encountered.}\par
01139     Message msg;\par
01140     msg << {\cf22 "WARNING: "} << src_text\par
01141         << {\cf22 " is expected to be a 32-bit integer, but actually"}\par
01142         << {\cf22 " has value \\""} << str << {\cf22 "\\".\\n"};\par
01143     printf({\cf22 "%s"}, msg.GetString().c_str());\par
01144     fflush(stdout);\par
01145     {\cf19 return} {\cf17 false};\par
01146   \}\par
01147 \par
01148   {\cf20 // Is the parsed value in the range of an Int32?}\par
01149   {\cf17 const} Int32 result = {\cf17 static_cast<}Int32{\cf17 >}(long_value);\par
01150   {\cf19 if} (long_value == LONG_MAX || long_value == LONG_MIN ||\par
01151       {\cf20 // The parsed value overflows as a long.  (strtol() returns}\par
01152       {\cf20 // LONG_MAX or LONG_MIN when the input overflows.)}\par
01153       result != long_value\par
01154       {\cf20 // The parsed value overflows as an Int32.}\par
01155       ) \{\par
01156     Message msg;\par
01157     msg << {\cf22 "WARNING: "} << src_text\par
01158         << {\cf22 " is expected to be a 32-bit integer, but actually"}\par
01159         << {\cf22 " has value "} << str << {\cf22 ", which overflows.\\n"};\par
01160     printf({\cf22 "%s"}, msg.GetString().c_str());\par
01161     fflush(stdout);\par
01162     {\cf19 return} {\cf17 false};\par
01163   \}\par
01164 \par
01165   *value = result;\par
01166   {\cf19 return} {\cf17 true};\par
01167 \}\par
01168 \par
01169 {\cf20 // Reads and returns the Boolean environment variable corresponding to}\par
01170 {\cf20 // the given flag; if it's not set, returns default_value.}\par
01171 {\cf20 //}\par
01172 {\cf20 // The value is considered true iff it's not "0".}\par
01173 {\cf18 bool} BoolFromGTestEnv({\cf17 const} {\cf18 char}* flag, {\cf18 bool} default_value) \{\par
01174 {\cf21 #if defined(GTEST_GET_BOOL_FROM_ENV_)}\par
01175   {\cf19 return} GTEST_GET_BOOL_FROM_ENV_(flag, default_value);\par
01176 {\cf21 #endif  }{\cf20 // defined(GTEST_GET_BOOL_FROM_ENV_)}\par
01177   {\cf17 const} std::string env_var = FlagToEnvVar(flag);\par
01178   {\cf17 const} {\cf18 char}* {\cf17 const} string_value = posix::GetEnv(env_var.c_str());\par
01179   {\cf19 return} string_value == NULL ?\par
01180       default_value : strcmp(string_value, {\cf22 "0"}) != 0;\par
01181 \}\par
01182 \par
01183 {\cf20 // Reads and returns a 32-bit integer stored in the environment}\par
01184 {\cf20 // variable corresponding to the given flag; if it isn't set or}\par
01185 {\cf20 // doesn't represent a valid 32-bit integer, returns default_value.}\par
01186 Int32 Int32FromGTestEnv({\cf17 const} {\cf18 char}* flag, Int32 default_value) \{\par
01187 {\cf21 #if defined(GTEST_GET_INT32_FROM_ENV_)}\par
01188   {\cf19 return} GTEST_GET_INT32_FROM_ENV_(flag, default_value);\par
01189 {\cf21 #endif  }{\cf20 // defined(GTEST_GET_INT32_FROM_ENV_)}\par
01190   {\cf17 const} std::string env_var = FlagToEnvVar(flag);\par
01191   {\cf17 const} {\cf18 char}* {\cf17 const} string_value = posix::GetEnv(env_var.c_str());\par
01192   {\cf19 if} (string_value == NULL) \{\par
01193     {\cf20 // The environment variable is not set.}\par
01194     {\cf19 return} default_value;\par
01195   \}\par
01196 \par
01197   Int32 result = default_value;\par
01198   {\cf19 if} (!ParseInt32(Message() << {\cf22 "Environment variable "} << env_var,\par
01199                   string_value, &result)) \{\par
01200     printf({\cf22 "The default value %s is used.\\n"},\par
01201            (Message() << default_value).GetString().c_str());\par
01202     fflush(stdout);\par
01203     {\cf19 return} default_value;\par
01204   \}\par
01205 \par
01206   {\cf19 return} result;\par
01207 \}\par
01208 \par
01209 {\cf20 // Reads and returns the string environment variable corresponding to}\par
01210 {\cf20 // the given flag; if it's not set, returns default_value.}\par
01211 std::string StringFromGTestEnv({\cf17 const} {\cf18 char}* flag, {\cf17 const} {\cf18 char}* default_value) \{\par
01212 {\cf21 #if defined(GTEST_GET_STRING_FROM_ENV_)}\par
01213   {\cf19 return} GTEST_GET_STRING_FROM_ENV_(flag, default_value);\par
01214 {\cf21 #endif  }{\cf20 // defined(GTEST_GET_STRING_FROM_ENV_)}\par
01215   {\cf17 const} std::string env_var = FlagToEnvVar(flag);\par
01216   {\cf17 const} {\cf18 char}* value = posix::GetEnv(env_var.c_str());\par
01217   {\cf19 if} (value != NULL) \{\par
01218     {\cf19 return} value;\par
01219   \}\par
01220 \par
01221   {\cf20 // As a special case for the 'output' flag, if GTEST_OUTPUT is not}\par
01222   {\cf20 // set, we look for XML_OUTPUT_FILE, which is set by the Bazel build}\par
01223   {\cf20 // system.  The value of XML_OUTPUT_FILE is a filename without the}\par
01224   {\cf20 // "xml:" prefix of GTEST_OUTPUT.}\par
01225   {\cf20 //}\par
01226   {\cf20 // The net priority order after flag processing is thus:}\par
01227   {\cf20 //   --gtest_output command line flag}\par
01228   {\cf20 //   GTEST_OUTPUT environment variable}\par
01229   {\cf20 //   XML_OUTPUT_FILE environment variable}\par
01230   {\cf20 //   'default_value'}\par
01231   {\cf19 if} (strcmp(flag, {\cf22 "output"}) == 0) \{\par
01232     value = posix::GetEnv({\cf22 "XML_OUTPUT_FILE"});\par
01233     {\cf19 if} (value != NULL) \{\par
01234       {\cf19 return} std::string({\cf22 "xml:"}) + value;\par
01235     \}\par
01236   \}\par
01237   {\cf19 return} default_value;\par
01238 \}\par
01239 \par
01240 \}  {\cf20 // namespace internal}\par
01241 \}  {\cf20 // namespace testing}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/src/gtest-printers.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-printers.cc}
{\xe \v gtest/src/gtest-printers.cc}
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/gtest-printers.h"}\par
{\f2 #include <ctype.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <cwchar>}\par
{\f2 #include <ostream>}\par
{\f2 #include <string>}\par
{\f2 #include "gtest/internal/gtest-port.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b testing::internal::CharFormat} \{ {\b testing::internal::kAsIs}
, {\b testing::internal::kHexEscape}
, {\b testing::internal::kSpecialEscape}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal2::PrintBytesInObjectTo} (const unsigned char *obj_bytes, size_t count, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::IsPrintableAscii} (wchar_t c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UnsignedChar , typename Char > void {\b testing::internal::PrintCharAndCodeTo} (Char c, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::PrintTo} (unsigned char c, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::PrintTo} (signed char c, ::std::ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::PrintTo} (wchar_t wc, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::UniversalPrintArray} (const char *begin, size_t len, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::UniversalPrintArray} (const wchar_t *begin, size_t len, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::PrintTo} (const char *s, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::PrintTo} (const wchar_t *s, ostream *os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::PrintStringTo} (const ::std::string &s, ostream *os)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-printers.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-printers.cc}
{\xe \v gtest/src/gtest-printers.cc}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2007, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: wan@google.com (Zhanyong Wan)}\par
00031 \par
00032 {\cf20 // Google Test - The Google C++ Testing Framework}\par
00033 {\cf20 //}\par
00034 {\cf20 // This file implements a universal value printer that can print a}\par
00035 {\cf20 // value of any type T:}\par
00036 {\cf20 //}\par
00037 {\cf20 //   void ::testing::internal::UniversalPrinter<T>::Print(value, ostream_ptr);}\par
00038 {\cf20 //}\par
00039 {\cf20 // It uses the << operator when possible, and prints the bytes in the}\par
00040 {\cf20 // object otherwise.  A user can override its behavior for a class}\par
00041 {\cf20 // type Foo by defining either operator<<(::std::ostream&, const Foo&)}\par
00042 {\cf20 // or void PrintTo(const Foo&, ::std::ostream*) in the namespace that}\par
00043 {\cf20 // defines Foo.}\par
00044 \par
00045 {\cf21 #include "gtest/gtest-printers.h"}\par
00046 {\cf21 #include <ctype.h>}\par
00047 {\cf21 #include <stdio.h>}\par
00048 {\cf21 #include <cwchar>}\par
00049 {\cf21 #include <ostream>}  {\cf20 // NOLINT}\par
00050 {\cf21 #include <string>}\par
00051 {\cf21 #include "gtest/internal/gtest-port.h"}\par
00052 \par
00053 {\cf17 namespace }testing \{\par
00054 \par
00055 {\cf17 namespace }\{\par
00056 \par
00057 using ::std::ostream;\par
00058 \par
00059 {\cf20 // Prints a segment of bytes in the given object.}\par
00060 GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\par
00061 GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\par
00062 GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\par
00063 {\cf18 void} PrintByteSegmentInObjectTo({\cf17 const} {\cf18 unsigned} {\cf18 char}* obj_bytes, {\cf18 size_t} start,\par
00064                                 {\cf18 size_t} count, ostream* os) \{\par
00065   {\cf18 char} text[5] = {\cf22 ""};\par
00066   {\cf19 for} ({\cf18 size_t} i = 0; i != count; i++) \{\par
00067     {\cf17 const} {\cf18 size_t} j = start + i;\par
00068     {\cf19 if} (i != 0) \{\par
00069       {\cf20 // Organizes the bytes into groups of 2 for easy parsing by}\par
00070       {\cf20 // human.}\par
00071       {\cf19 if} ((j % 2) == 0)\par
00072         *os << {\cf23 ' '};\par
00073       {\cf19 else}\par
00074         *os << {\cf23 '-'};\par
00075     \}\par
00076     GTEST_SNPRINTF_(text, {\cf17 sizeof}(text), {\cf22 "%02X"}, obj_bytes[j]);\par
00077     *os << text;\par
00078   \}\par
00079 \}\par
00080 \par
00081 {\cf20 // Prints the bytes in the given value to the given ostream.}\par
00082 {\cf18 void} PrintBytesInObjectToImpl({\cf17 const} {\cf18 unsigned} {\cf18 char}* obj_bytes, {\cf18 size_t} count,\par
00083                               ostream* os) \{\par
00084   {\cf20 // Tells the user how big the object is.}\par
00085   *os << count << {\cf22 "-byte object <"};\par
00086 \par
00087   {\cf17 const} {\cf18 size_t} kThreshold = 132;\par
00088   {\cf17 const} {\cf18 size_t} kChunkSize = 64;\par
00089   {\cf20 // If the object size is bigger than kThreshold, we'll have to omit}\par
00090   {\cf20 // some details by printing only the first and the last kChunkSize}\par
00091   {\cf20 // bytes.}\par
00092   {\cf20 // TODO(wan): let the user control the threshold using a flag.}\par
00093   {\cf19 if} (count < kThreshold) \{\par
00094     PrintByteSegmentInObjectTo(obj_bytes, 0, count, os);\par
00095   \} {\cf19 else} \{\par
00096     PrintByteSegmentInObjectTo(obj_bytes, 0, kChunkSize, os);\par
00097     *os << {\cf22 " ... "};\par
00098     {\cf20 // Rounds up to 2-byte boundary.}\par
00099     {\cf17 const} {\cf18 size_t} resume_pos = (count - kChunkSize + 1)/2*2;\par
00100     PrintByteSegmentInObjectTo(obj_bytes, resume_pos, count - resume_pos, os);\par
00101   \}\par
00102   *os << {\cf22 ">"};\par
00103 \}\par
00104 \par
00105 \}  {\cf20 // namespace}\par
00106 \par
00107 {\cf17 namespace }internal2 \{\par
00108 \par
00109 {\cf20 // Delegates to PrintBytesInObjectToImpl() to print the bytes in the}\par
00110 {\cf20 // given object.  The delegation simplifies the implementation, which}\par
00111 {\cf20 // uses the << operator and thus is easier done outside of the}\par
00112 {\cf20 // ::testing::internal namespace, which contains a << operator that}\par
00113 {\cf20 // sometimes conflicts with the one in STL.}\par
00114 {\cf18 void} PrintBytesInObjectTo({\cf17 const} {\cf18 unsigned} {\cf18 char}* obj_bytes, {\cf18 size_t} count,\par
00115                           ostream* os) \{\par
00116   PrintBytesInObjectToImpl(obj_bytes, count, os);\par
00117 \}\par
00118 \par
00119 \}  {\cf20 // namespace internal2}\par
00120 \par
00121 {\cf17 namespace }internal \{\par
00122 \par
00123 {\cf20 // Depending on the value of a char (or wchar_t), we print it in one}\par
00124 {\cf20 // of three formats:}\par
00125 {\cf20 //   - as is if it's a printable ASCII (e.g. 'a', '2', ' '),}\par
00126 {\cf20 //   - as a hexidecimal escape sequence (e.g. '\\x7F'), or}\par
00127 {\cf20 //   - as a special escape sequence (e.g. '\\r', '\\n').}\par
00128 {\cf17 enum} CharFormat \{\par
00129   kAsIs,\par
00130   kHexEscape,\par
00131   kSpecialEscape\par
00132 \};\par
00133 \par
00134 {\cf20 // Returns true if c is a printable ASCII character.  We test the}\par
00135 {\cf20 // value of c directly instead of calling isprint(), which is buggy on}\par
00136 {\cf20 // Windows Mobile.}\par
00137 {\cf17 inline} {\cf18 bool} IsPrintableAscii({\cf18 wchar_t} c) \{\par
00138   {\cf19 return} 0x20 <= c && c <= 0x7E;\par
00139 \}\par
00140 \par
00141 {\cf20 // Prints a wide or narrow char c as a character literal without the}\par
00142 {\cf20 // quotes, escaping it when necessary; returns how c was formatted.}\par
00143 {\cf20 // The template argument UnsignedChar is the unsigned version of Char,}\par
00144 {\cf20 // which is the type of c.}\par
00145 {\cf17 template} <{\cf17 typename} Un{\cf18 signed}Char, {\cf17 typename} Char>\par
00146 {\cf17 static} CharFormat PrintAsCharLiteralTo(Char c, ostream* os) \{\par
00147   {\cf19 switch} ({\cf17 static_cast<}{\cf18 wchar_t}{\cf17 >}(c)) \{\par
00148     {\cf19 case} L{\cf23 '\\0'}:\par
00149       *os << {\cf22 "\\\\0"};\par
00150       {\cf19 break};\par
00151     {\cf19 case} L{\cf23 '\\''}:\par
00152       *os << {\cf22 "\\\\'"};\par
00153       {\cf19 break};\par
00154     {\cf19 case} L{\cf23 '\\\\'}:\par
00155       *os << {\cf22 "\\\\\\\\"};\par
00156       {\cf19 break};\par
00157     {\cf19 case} L{\cf23 '\\a'}:\par
00158       *os << {\cf22 "\\\\a"};\par
00159       {\cf19 break};\par
00160     {\cf19 case} L{\cf23 '\\b'}:\par
00161       *os << {\cf22 "\\\\b"};\par
00162       {\cf19 break};\par
00163     {\cf19 case} L{\cf23 '\\f'}:\par
00164       *os << {\cf22 "\\\\f"};\par
00165       {\cf19 break};\par
00166     {\cf19 case} L{\cf23 '\\n'}:\par
00167       *os << {\cf22 "\\\\n"};\par
00168       {\cf19 break};\par
00169     {\cf19 case} L{\cf23 '\\r'}:\par
00170       *os << {\cf22 "\\\\r"};\par
00171       {\cf19 break};\par
00172     {\cf19 case} L{\cf23 '\\t'}:\par
00173       *os << {\cf22 "\\\\t"};\par
00174       {\cf19 break};\par
00175     {\cf19 case} L{\cf23 '\\v'}:\par
00176       *os << {\cf22 "\\\\v"};\par
00177       {\cf19 break};\par
00178     {\cf19 default}:\par
00179       {\cf19 if} (IsPrintableAscii(c)) \{\par
00180         *os << static_cast<char>(c);\par
00181         {\cf19 return} kAsIs;\par
00182       \} {\cf19 else} \{\par
00183         *os << {\cf22 "\\\\x"} + String::FormatHexInt({\cf17 static_cast<}UnsignedChar{\cf17 >}(c));\par
00184         {\cf19 return} kHexEscape;\par
00185       \}\par
00186   \}\par
00187   {\cf19 return} kSpecialEscape;\par
00188 \}\par
00189 \par
00190 {\cf20 // Prints a wchar_t c as if it's part of a string literal, escaping it when}\par
00191 {\cf20 // necessary; returns how c was formatted.}\par
00192 {\cf17 static} CharFormat PrintAsStringLiteralTo({\cf18 wchar_t} c, ostream* os) \{\par
00193   {\cf19 switch} (c) \{\par
00194     {\cf19 case} L{\cf23 '\\''}:\par
00195       *os << {\cf22 "'"};\par
00196       {\cf19 return} kAsIs;\par
00197     {\cf19 case} L{\cf23 '"'}:\par
00198       *os << {\cf22 "\\\\\\""};\par
00199       {\cf19 return} kSpecialEscape;\par
00200     {\cf19 default}:\par
00201       {\cf19 return} PrintAsCharLiteralTo<wchar_t>(c, os);\par
00202   \}\par
00203 \}\par
00204 \par
00205 {\cf20 // Prints a char c as if it's part of a string literal, escaping it when}\par
00206 {\cf20 // necessary; returns how c was formatted.}\par
00207 {\cf17 static} CharFormat PrintAsStringLiteralTo({\cf18 char} c, ostream* os) \{\par
00208   {\cf19 return} PrintAsStringLiteralTo(\par
00209       {\cf17 static_cast<}{\cf18 wchar_t}{\cf17 >}({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(c)), os);\par
00210 \}\par
00211 \par
00212 {\cf20 // Prints a wide or narrow character c and its code.  '\\0' is printed}\par
00213 {\cf20 // as "'\\\\0'", other unprintable characters are also properly escaped}\par
00214 {\cf20 // using the standard C++ escape sequence.  The template argument}\par
00215 {\cf20 // UnsignedChar is the unsigned version of Char, which is the type of c.}\par
00216 {\cf17 template} <{\cf17 typename} Un{\cf18 signed}Char, {\cf17 typename} Char>\par
00217 {\cf18 void} PrintCharAndCodeTo(Char c, ostream* os) \{\par
00218   {\cf20 // First, print c as a literal in the most readable form we can find.}\par
00219   *os << (({\cf17 sizeof}(c) > 1) ? {\cf22 "L'"} : {\cf22 "'"});\par
00220   {\cf17 const} CharFormat format = PrintAsCharLiteralTo<UnsignedChar>(c, os);\par
00221   *os << {\cf22 "'"};\par
00222 \par
00223   {\cf20 // To aid user debugging, we also print c's code in decimal, unless}\par
00224   {\cf20 // it's 0 (in which case c was printed as '\\\\0', making the code}\par
00225   {\cf20 // obvious).}\par
00226   {\cf19 if} (c == 0)\par
00227     {\cf19 return};\par
00228   *os << {\cf22 " ("} << {\cf17 static_cast<}{\cf18 int}{\cf17 >}(c);\par
00229 \par
00230   {\cf20 // For more convenience, we print c's code again in hexidecimal,}\par
00231   {\cf20 // unless c was already printed in the form '\\x##' or the code is in}\par
00232   {\cf20 // [1, 9].}\par
00233   {\cf19 if} (format == kHexEscape || (1 <= c && c <= 9)) \{\par
00234     {\cf20 // Do nothing.}\par
00235   \} {\cf19 else} \{\par
00236     *os << {\cf22 ", 0x"} << String::FormatHexInt({\cf17 static_cast<}UnsignedChar{\cf17 >}(c));\par
00237   \}\par
00238   *os << {\cf22 ")"};\par
00239 \}\par
00240 \par
00241 {\cf18 void} PrintTo({\cf18 unsigned} {\cf18 char} c, ::std::ostream* os) \{\par
00242   PrintCharAndCodeTo<unsigned char>(c, os);\par
00243 \}\par
00244 {\cf18 void} PrintTo({\cf18 signed} {\cf18 char} c, ::std::ostream* os) \{\par
00245   PrintCharAndCodeTo<unsigned char>(c, os);\par
00246 \}\par
00247 \par
00248 {\cf20 // Prints a wchar_t as a symbol if it is printable or as its internal}\par
00249 {\cf20 // code otherwise and also as its code.  L'\\0' is printed as "L'\\\\0'".}\par
00250 {\cf18 void} PrintTo({\cf18 wchar_t} wc, ostream* os) \{\par
00251   PrintCharAndCodeTo<wchar_t>(wc, os);\par
00252 \}\par
00253 \par
00254 {\cf20 // Prints the given array of characters to the ostream.  CharType must be either}\par
00255 {\cf20 // char or wchar_t.}\par
00256 {\cf20 // The array starts at begin, the length is len, it may include '\\0' characters}\par
00257 {\cf20 // and may not be NUL-terminated.}\par
00258 {\cf17 template} <{\cf17 typename} CharType>\par
00259 GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\par
00260 GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\par
00261 GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\par
00262 {\cf17 static} {\cf18 void} PrintCharsAsStringTo(\par
00263     {\cf17 const} CharType* begin, {\cf18 size_t} len, ostream* os) \{\par
00264   {\cf17 const} {\cf18 char}* {\cf17 const} kQuoteBegin = {\cf17 sizeof}(CharType) == 1 ? {\cf22 "\\""} : {\cf22 "L\\""};\par
00265   *os << kQuoteBegin;\par
00266   {\cf18 bool} is_previous_hex = {\cf17 false};\par
00267   {\cf19 for} ({\cf18 size_t} index = 0; index < len; ++index) \{\par
00268     {\cf17 const} CharType cur = begin[index];\par
00269     {\cf19 if} (is_previous_hex && IsXDigit(cur)) \{\par
00270       {\cf20 // Previous character is of '\\x..' form and this character can be}\par
00271       {\cf20 // interpreted as another hexadecimal digit in its number. Break string to}\par
00272       {\cf20 // disambiguate.}\par
00273       *os << {\cf22 "\\" "} << kQuoteBegin;\par
00274     \}\par
00275     is_previous_hex = PrintAsStringLiteralTo(cur, os) == kHexEscape;\par
00276   \}\par
00277   *os << {\cf22 "\\""};\par
00278 \}\par
00279 \par
00280 {\cf20 // Prints a (const) char/wchar_t array of 'len' elements, starting at address}\par
00281 {\cf20 // 'begin'.  CharType must be either char or wchar_t.}\par
00282 {\cf17 template} <{\cf17 typename} CharType>\par
00283 GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\par
00284 GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\par
00285 GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\par
00286 {\cf17 static} {\cf18 void} UniversalPrintCharArray(\par
00287     {\cf17 const} CharType* begin, {\cf18 size_t} len, ostream* os) \{\par
00288   {\cf20 // The code}\par
00289   {\cf20 //   const char kFoo[] = "foo";}\par
00290   {\cf20 // generates an array of 4, not 3, elements, with the last one being '\\0'.}\par
00291   {\cf20 //}\par
00292   {\cf20 // Therefore when printing a char array, we don't print the last element if}\par
00293   {\cf20 // it's '\\0', such that the output matches the string literal as it's}\par
00294   {\cf20 // written in the source code.}\par
00295   {\cf19 if} (len > 0 && begin[len - 1] == {\cf23 '\\0'}) \{\par
00296     PrintCharsAsStringTo(begin, len - 1, os);\par
00297     {\cf19 return};\par
00298   \}\par
00299 \par
00300   {\cf20 // If, however, the last element in the array is not '\\0', e.g.}\par
00301   {\cf20 //    const char kFoo[] = \{ 'f', 'o', 'o' \};}\par
00302   {\cf20 // we must print the entire array.  We also print a message to indicate}\par
00303   {\cf20 // that the array is not NUL-terminated.}\par
00304   PrintCharsAsStringTo(begin, len, os);\par
00305   *os << {\cf22 " (no terminating NUL)"};\par
00306 \}\par
00307 \par
00308 {\cf20 // Prints a (const) char array of 'len' elements, starting at address 'begin'.}\par
00309 {\cf18 void} UniversalPrintArray({\cf17 const} {\cf18 char}* begin, {\cf18 size_t} len, ostream* os) \{\par
00310   UniversalPrintCharArray(begin, len, os);\par
00311 \}\par
00312 \par
00313 {\cf20 // Prints a (const) wchar_t array of 'len' elements, starting at address}\par
00314 {\cf20 // 'begin'.}\par
00315 {\cf18 void} UniversalPrintArray({\cf17 const} {\cf18 wchar_t}* begin, {\cf18 size_t} len, ostream* os) \{\par
00316   UniversalPrintCharArray(begin, len, os);\par
00317 \}\par
00318 \par
00319 {\cf20 // Prints the given C string to the ostream.}\par
00320 {\cf18 void} PrintTo({\cf17 const} {\cf18 char}* s, ostream* os) \{\par
00321   {\cf19 if} (s == NULL) \{\par
00322     *os << {\cf22 "NULL"};\par
00323   \} {\cf19 else} \{\par
00324     *os << ImplicitCast_<const void*>(s) << {\cf22 " pointing to "};\par
00325     PrintCharsAsStringTo(s, strlen(s), os);\par
00326   \}\par
00327 \}\par
00328 \par
00329 {\cf20 // MSVC compiler can be configured to define whar_t as a typedef}\par
00330 {\cf20 // of unsigned short. Defining an overload for const wchar_t* in that case}\par
00331 {\cf20 // would cause pointers to unsigned shorts be printed as wide strings,}\par
00332 {\cf20 // possibly accessing more memory than intended and causing invalid}\par
00333 {\cf20 // memory accesses. MSVC defines _NATIVE_WCHAR_T_DEFINED symbol when}\par
00334 {\cf20 // wchar_t is implemented as a native type.}\par
00335 {\cf21 #if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)}\par
00336 {\cf20 // Prints the given wide C string to the ostream.}\par
00337 {\cf18 void} PrintTo({\cf17 const} {\cf18 wchar_t}* s, ostream* os) \{\par
00338   {\cf19 if} (s == NULL) \{\par
00339     *os << {\cf22 "NULL"};\par
00340   \} {\cf19 else} \{\par
00341     *os << ImplicitCast_<const void*>(s) << {\cf22 " pointing to "};\par
00342     PrintCharsAsStringTo(s, std::wcslen(s), os);\par
00343   \}\par
00344 \}\par
00345 {\cf21 #endif  }{\cf20 // wchar_t is native}\par
00346 \par
00347 {\cf20 // Prints a ::string object.}\par
00348 {\cf21 #if GTEST_HAS_GLOBAL_STRING}\par
00349 {\cf18 void} PrintStringTo(const ::string& s, ostream* os) \{\par
00350   PrintCharsAsStringTo(s.data(), s.size(), os);\par
00351 \}\par
00352 {\cf21 #endif  }{\cf20 // GTEST_HAS_GLOBAL_STRING}\par
00353 \par
00354 {\cf18 void} PrintStringTo(const ::std::string& s, ostream* os) \{\par
00355   PrintCharsAsStringTo(s.data(), s.size(), os);\par
00356 \}\par
00357 \par
00358 {\cf20 // Prints a ::wstring object.}\par
00359 {\cf21 #if GTEST_HAS_GLOBAL_WSTRING}\par
00360 {\cf18 void} PrintWideStringTo(const ::wstring& s, ostream* os) \{\par
00361   PrintCharsAsStringTo(s.data(), s.size(), os);\par
00362 \}\par
00363 {\cf21 #endif  }{\cf20 // GTEST_HAS_GLOBAL_WSTRING}\par
00364 \par
00365 {\cf21 #if GTEST_HAS_STD_WSTRING}\par
00366 {\cf18 void} PrintWideStringTo(const ::std::wstring& s, ostream* os) \{\par
00367   PrintCharsAsStringTo(s.data(), s.size(), os);\par
00368 \}\par
00369 {\cf21 #endif  }{\cf20 // GTEST_HAS_STD_WSTRING}\par
00370 \par
00371 \}  {\cf20 // namespace internal}\par
00372 \par
00373 \}  {\cf20 // namespace testing}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/src/gtest-test-part.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-test-part.cc}
{\xe \v gtest/src/gtest-test-part.cc}
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/gtest-test-part.h"}\par
{\f2 #include "src/gtest-internal-inl.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_IMPLEMENTATION_}\~ 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b testing::operator<<} (std::ostream &os, const TestPartResult &result)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v GTEST_IMPLEMENTATION_\:gtest-test-part.cc}
{\xe \v gtest-test-part.cc\:GTEST_IMPLEMENTATION_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_IMPLEMENTATION_\~ 1}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest-test-part.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 41}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-test-part.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-test-part.cc}
{\xe \v gtest/src/gtest-test-part.cc}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2008, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: mheule@google.com (Markus Heule)}\par
00031 {\cf20 //}\par
00032 {\cf20 // The Google C++ Testing Framework (Google Test)}\par
00033 \par
00034 {\cf21 #include "gtest/gtest-test-part.h"}\par
00035 \par
00036 {\cf20 // Indicates that this translation unit is part of Google Test's}\par
00037 {\cf20 // implementation.  It must come before gtest-internal-inl.h is}\par
00038 {\cf20 // included, or there will be a compiler error.  This trick exists to}\par
00039 {\cf20 // prevent the accidental inclusion of gtest-internal-inl.h in the}\par
00040 {\cf20 // user's code.}\par
00041 {\cf21 #define GTEST_IMPLEMENTATION_ 1}\par
00042 {\cf21 #include "src/gtest-internal-inl.h"}\par
00043 {\cf21 #undef GTEST_IMPLEMENTATION_}\par
00044 \par
00045 {\cf17 namespace }testing \{\par
00046 \par
00047 {\cf17 using} internal::GetUnitTestImpl;\par
00048 \par
00049 {\cf20 // Gets the summary of the failure message by omitting the stack trace}\par
00050 {\cf20 // in it.}\par
00051 std::string TestPartResult::ExtractSummary({\cf17 const} {\cf18 char}* message) \{\par
00052   {\cf17 const} {\cf18 char}* {\cf17 const} stack_trace = strstr(message, internal::kStackTraceMarker);\par
00053   {\cf19 return} stack_trace == NULL ? message :\par
00054       std::string(message, stack_trace);\par
00055 \}\par
00056 \par
00057 {\cf20 // Prints a TestPartResult object.}\par
00058 std::ostream& operator<<(std::ostream& os, {\cf17 const} TestPartResult& result) \{\par
00059   {\cf19 return} os\par
00060       << result.file_name() << {\cf22 ":"} << result.line_number() << {\cf22 ": "}\par
00061       << (result.type() == TestPartResult::kSuccess ? {\cf22 "Success"} :\par
00062           result.type() == TestPartResult::kFatalFailure ? {\cf22 "Fatal failure"} :\par
00063           {\cf22 "Non-fatal failure"}) << {\cf22 ":\\n"}\par
00064       << result.message() << std::endl;\par
00065 \}\par
00066 \par
00067 {\cf20 // Appends a TestPartResult to the array.}\par
00068 {\cf18 void} TestPartResultArray::Append({\cf17 const} TestPartResult& result) \{\par
00069   array_.push_back(result);\par
00070 \}\par
00071 \par
00072 {\cf20 // Returns the TestPartResult at the given index (0-based).}\par
00073 {\cf17 const} TestPartResult& TestPartResultArray::GetTestPartResult({\cf18 int} index){\cf17  const }\{\par
00074   {\cf19 if} (index < 0 || index >= size()) \{\par
00075     printf({\cf22 "\\nInvalid index (%d) into TestPartResultArray.\\n"}, index);\par
00076     internal::posix::Abort();\par
00077   \}\par
00078 \par
00079   {\cf19 return} array_[index];\par
00080 \}\par
00081 \par
00082 {\cf20 // Returns the number of TestPartResult objects in the array.}\par
00083 {\cf18 int} TestPartResultArray::size(){\cf17  const }\{\par
00084   {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(array_.size());\par
00085 \}\par
00086 \par
00087 {\cf17 namespace }internal \{\par
00088 \par
00089 HasNewFatalFailureHelper::HasNewFatalFailureHelper()\par
00090     : has_new_fatal_failure_(false),\par
00091       original_reporter_(GetUnitTestImpl()->\par
00092                          GetTestPartResultReporterForCurrentThread()) \{\par
00093   GetUnitTestImpl()->SetTestPartResultReporterForCurrentThread({\cf17 this});\par
00094 \}\par
00095 \par
00096 HasNewFatalFailureHelper::~HasNewFatalFailureHelper() \{\par
00097   GetUnitTestImpl()->SetTestPartResultReporterForCurrentThread(\par
00098       original_reporter_);\par
00099 \}\par
00100 \par
00101 {\cf18 void} HasNewFatalFailureHelper::ReportTestPartResult(\par
00102     {\cf17 const} TestPartResult& result) \{\par
00103   {\cf19 if} (result.fatally_failed())\par
00104     has_new_fatal_failure_ = {\cf17 true};\par
00105   original_reporter_->ReportTestPartResult(result);\par
00106 \}\par
00107 \par
00108 \}  {\cf20 // namespace internal}\par
00109 \par
00110 \}  {\cf20 // namespace testing}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/src/gtest-typed-test.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-typed-test.cc}
{\xe \v gtest/src/gtest-typed-test.cc}
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/gtest-typed-test.h"}\par
{\f2 #include "gtest/gtest.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest-typed-test.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest-typed-test.cc}
{\xe \v gtest/src/gtest-typed-test.cc}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2008 Google Inc.}\par
00002 {\cf20 // All Rights Reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: wan@google.com (Zhanyong Wan)}\par
00031 \par
00032 {\cf21 #include "gtest/gtest-typed-test.h"}\par
00033 {\cf21 #include "gtest/gtest.h"}\par
00034 \par
00035 {\cf17 namespace }testing \{\par
00036 {\cf17 namespace }internal \{\par
00037 \par
00038 {\cf21 #if GTEST_HAS_TYPED_TEST_P}\par
00039 \par
00040 {\cf20 // Skips to the first non-space char in str. Returns an empty string if str}\par
00041 {\cf20 // contains only whitespace characters.}\par
00042 {\cf17 static} {\cf17 const} {\cf18 char}* SkipSpaces({\cf17 const} {\cf18 char}* str) \{\par
00043   {\cf19 while} (IsSpace(*str))\par
00044     str++;\par
00045   {\cf19 return} str;\par
00046 \}\par
00047 \par
00048 {\cf17 static} std::vector<std::string> SplitIntoTestNames({\cf17 const} {\cf18 char}* src) \{\par
00049   std::vector<std::string> name_vec;\par
00050   src = SkipSpaces(src);\par
00051   {\cf19 for} (; src != NULL; src = SkipComma(src)) \{\par
00052     name_vec.push_back(StripTrailingSpaces(GetPrefixUntilComma(src)));\par
00053   \}\par
00054   {\cf19 return} name_vec;\par
00055 \}\par
00056 \par
00057 {\cf20 // Verifies that registered_tests match the test names in}\par
00058 {\cf20 // registered_tests_; returns registered_tests if successful, or}\par
00059 {\cf20 // aborts the program otherwise.}\par
00060 {\cf17 const} {\cf18 char}* TypedTestCasePState::VerifyRegisteredTestNames(\par
00061     {\cf17 const} {\cf18 char}* file, {\cf18 int} line, {\cf17 const} {\cf18 char}* registered_tests) \{\par
00062   {\cf17 typedef} RegisteredTestsMap::const_iterator RegisteredTestIter;\par
00063   registered_ = {\cf17 true};\par
00064 \par
00065   std::vector<std::string> name_vec = SplitIntoTestNames(registered_tests);\par
00066 \par
00067   Message errors;\par
00068 \par
00069   std::set<std::string> tests;\par
00070   {\cf19 for} (std::vector<std::string>::const_iterator name_it = name_vec.begin();\par
00071        name_it != name_vec.end(); ++name_it) \{\par
00072     {\cf17 const} std::string& name = *name_it;\par
00073     {\cf19 if} (tests.count(name) != 0) \{\par
00074       errors << {\cf22 "Test "} << name << {\cf22 " is listed more than once.\\n"};\par
00075       {\cf19 continue};\par
00076     \}\par
00077 \par
00078     {\cf18 bool} found = {\cf17 false};\par
00079     {\cf19 for} (RegisteredTestIter it = registered_tests_.begin();\par
00080          it != registered_tests_.end();\par
00081          ++it) \{\par
00082       {\cf19 if} (name == it->first) \{\par
00083         found = {\cf17 true};\par
00084         {\cf19 break};\par
00085       \}\par
00086     \}\par
00087 \par
00088     {\cf19 if} (found) \{\par
00089       tests.insert(name);\par
00090     \} {\cf19 else} \{\par
00091       errors << {\cf22 "No test named "} << name\par
00092              << {\cf22 " can be found in this test case.\\n"};\par
00093     \}\par
00094   \}\par
00095 \par
00096   {\cf19 for} (RegisteredTestIter it = registered_tests_.begin();\par
00097        it != registered_tests_.end();\par
00098        ++it) \{\par
00099     {\cf19 if} (tests.count(it->first) == 0) \{\par
00100       errors << {\cf22 "You forgot to list test "} << it->first << {\cf22 ".\\n"};\par
00101     \}\par
00102   \}\par
00103 \par
00104   {\cf17 const} std::string& errors_str = errors.GetString();\par
00105   {\cf19 if} (errors_str != {\cf22 ""}) \{\par
00106     fprintf(stderr, {\cf22 "%s %s"}, FormatFileLocation(file, line).c_str(),\par
00107             errors_str.c_str());\par
00108     fflush(stderr);\par
00109     posix::Abort();\par
00110   \}\par
00111 \par
00112   {\cf19 return} registered_tests;\par
00113 \}\par
00114 \par
00115 {\cf21 #endif  }{\cf20 // GTEST_HAS_TYPED_TEST_P}\par
00116 \par
00117 \}  {\cf20 // namespace internal}\par
00118 \}  {\cf20 // namespace testing}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/src/gtest.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest.cc}
{\xe \v gtest/src/gtest.cc}
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gtest/gtest.h"}\par
{\f2 #include "gtest/internal/custom/gtest.h"}\par
{\f2 #include "gtest/gtest-spi.h"}\par
{\f2 #include <ctype.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <wchar.h>}\par
{\f2 #include <wctype.h>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <iomanip>}\par
{\f2 #include <limits>}\par
{\f2 #include <list>}\par
{\f2 #include <map>}\par
{\f2 #include <ostream>}\par
{\f2 #include <sstream>}\par
{\f2 #include <vector>}\par
{\f2 #include <sys/time.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include "src/gtest-internal-inl.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D1\'F2\'F0\'F3\'EA\'F2\'F3\'F0\'FB \'E4\'E0\'ED\'ED\'FB\'F5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::PrettyUnitTestResultPrinter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::TestEventRepeater}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::XmlUnitTestResultPrinter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::ScopedPrematureExitFile}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b testing::internal::TestCaseNameIs}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'F0\'EE\'F1\'F2\'F0\'E0\'ED\'F1\'F2\'E2\'E0 \'E8\'EC\'E5\'ED\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b testing::internal::edit_distance}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_HAS_GETTIMEOFDAY_}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_IMPLEMENTATION_}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_IMPL_CMP_HELPER_}(op_name,  op)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_REPEATER_METHOD_}(Name,  Type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GTEST_REVERSE_REPEATER_METHOD_}(Name,  Type)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'F7\'E8\'F1\'EB\'E5\'ED\'E8\'FF\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b testing::internal::GTestColor} \{ {\b testing::internal::COLOR_DEFAULT}
, {\b testing::internal::COLOR_RED}
, {\b testing::internal::COLOR_GREEN}
, {\b testing::internal::COLOR_YELLOW}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_bool_} (also_run_disabled_tests, internal::BoolFromGTestEnv("also_run_disabled_tests", false), "Run disabled tests too, in addition to the tests normally being run.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_bool_} (break_on_failure, internal::BoolFromGTestEnv("break_on_failure", false), "True iff a failed assertion should be a debugger break-point.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_bool_} (catch_exceptions, internal::BoolFromGTestEnv("catch_exceptions", true), "True iff " GTEST_NAME_ " should catch exceptions and treat them as test failures.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_string_} (color, internal::StringFromGTestEnv("color", "auto"), "Whether to use colors in the output.  Valid values: yes, no, " "and auto.  'auto' means to use colors if the output is " "being sent to a terminal and the TERM environment variable " "is set to a terminal type that supports colors.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_string_} (filter, internal::StringFromGTestEnv("filter", GetDefaultFilter()), "A colon-separated list of glob (not regex) patterns " "for filtering the tests to run, optionally followed by a " "'-' and a : separated list of negative patterns (tests to " "exclude).  A test is run if it matches one of the positive " "patterns and does not match any of the negative patterns.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_bool_} (list_tests, false, "List all tests without running them.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_string_} (output, internal::StringFromGTestEnv("output", ""), "A format (currently must be \\"xml\\"), optionally followed " "by a colon and an output file name or directory. A directory " "is indicated by a trailing pathname separator. " "Examples: \\"xml:filename.xml\\", \\"xml::directoryname/\\". " "If a directory is specified, output files will be created " "within that directory, with file-names based on the test " "executable's name and, if necessary, made unique by adding " "digits.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_bool_} (print_time, internal::BoolFromGTestEnv("print_time", true), "True iff " GTEST_NAME_ " should display elapsed time in text output.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_int32_} (random_seed, internal::Int32FromGTestEnv("random_seed", 0), "Random number seed to use when shuffling test orders.  Must be in range " "[1, 99999], or 0 to use a seed based on the current time.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_int32_} (repeat, internal::Int32FromGTestEnv("repeat", 1), "How many times to repeat each test.  Specify a negative number " "for repeating forever.  Useful for shaking out flaky tests.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_bool_} (show_internal_stack_frames, false, "True iff " GTEST_NAME_ " should include internal stack frames when " "printing test failure stack traces.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_bool_} (shuffle, internal::BoolFromGTestEnv("shuffle", false), "True iff " GTEST_NAME_ " should randomize tests' order on every run.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_int32_} (stack_trace_depth, internal::Int32FromGTestEnv("stack_trace_depth", kMaxStackTraceDepth), "The maximum number of stack frames to print when an " "assertion fails.  The valid range is 0 through 100, inclusive.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_string_} (stream_result_to, internal::StringFromGTestEnv("stream_result_to", ""), "This flag specifies the host name and the port number on which to stream " "test results. Example: \\"localhost:555\\". The flag is effective only on " "Linux.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b testing::GTEST_DEFINE_bool_} (throw_on_failure, internal::BoolFromGTestEnv("throw_on_failure", false), "When this flag is specified, a failed assertion will throw an exception " "if exceptions are enabled or exit the program with a non-zero code " "otherwise.")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} {\b testing::internal::GTEST_DEFINE_STATIC_MUTEX_} (g_linked_ptr_mutex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} const ::std::vector< {\b testing::internal::string} > & {\b testing::internal::GetArgvs} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} FilePath {\b testing::internal::GetCurrentExecutableName} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} TypeId {\b testing::internal::GetTestTypeId} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AssertionResult {\b testing::internal::HasOneFailure} (const char *, const char *, const char *, const TestPartResultArray &results, TestPartResult::Type type, const std::string &substr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} TimeInMillis {\b testing::internal::GetTimeInMillis} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::SplitString} (const ::std::string &str, char delimiter, ::std::vector< ::std::string > *dest)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::AssertionSuccess} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::AssertionFailure} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::AssertionFailure} (const Message &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::vector< EditType > {\b testing::internal::edit_distance::CalculateOptimalEdits} (const std::vector< size_t > &left, const std::vector< size_t > &right)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::vector< EditType > {\b testing::internal::edit_distance::CalculateOptimalEdits} (const std::vector< std::string > &left, const std::vector< std::string > &right)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::edit_distance::CreateUnifiedDiff} (const std::vector< std::string > &left, const std::vector< std::string > &right, size_t context=2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::EqFailure} (const char *expected_expression, const char *actual_expression, const std::string &expected_value, const std::string &actual_value, bool ignoring_case)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::GetBoolAssertionFailureMessage} (const AssertionResult &assertion_result, const char *expression_text, const char *actual_predicate_value, const char *expected_predicate_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::DoubleNearPredFormat} (const char *expr1, const char *expr2, const char *abs_error_expr, double val1, double val2, double abs_error)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename RawType > AssertionResult {\b testing::internal::FloatingPointLE} (const char *expr1, const char *expr2, RawType val1, RawType val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::FloatLE} (const char *expr1, const char *expr2, float val1, float val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::DoubleLE} (const char *expr1, const char *expr2, double val1, double val2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::CmpHelperEQ} (const char *lhs_expression, const char *rhs_expression, BiggestInt lhs, BiggestInt rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::CmpHelperSTREQ} (const char *s1_expression, const char *s2_expression, const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::CmpHelperSTRCASEEQ} (const char *s1_expression, const char *s2_expression, const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::CmpHelperSTRNE} (const char *s1_expression, const char *s2_expression, const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::CmpHelperSTRCASENE} (const char *s1_expression, const char *s2_expression, const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::IsSubstring} (const char *needle_expr, const char *haystack_expr, const char *needle, const char *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::IsSubstring} (const char *needle_expr, const char *haystack_expr, const wchar_t *needle, const wchar_t *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::IsNotSubstring} (const char *needle_expr, const char *haystack_expr, const char *needle, const char *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::IsNotSubstring} (const char *needle_expr, const char *haystack_expr, const wchar_t *needle, const wchar_t *haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::IsSubstring} (const char *needle_expr, const char *haystack_expr, const ::std::string &needle, const ::std::string &haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::IsNotSubstring} (const char *needle_expr, const char *haystack_expr, const ::std::string &needle, const ::std::string &haystack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
UInt32 {\b testing::internal::ChopLowBits} (UInt32 *bits, int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::CodePointToUtf8} (UInt32 code_point)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::IsUtf16SurrogatePair} (wchar_t first, wchar_t second)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
UInt32 {\b testing::internal::CreateCodePointFromUtf16SurrogatePair} (wchar_t first, wchar_t second)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::WideStringToUtf8} (const wchar_t *str, int num_chars)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::CmpHelperSTREQ} (const char *s1_expression, const char *s2_expression, const wchar_t *s1, const wchar_t *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} AssertionResult {\b testing::internal::CmpHelperSTRNE} (const char *s1_expression, const char *s2_expression, const wchar_t *s1, const wchar_t *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::StringStreamToString} (::std::stringstream *stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::AppendUserMessage} (const std::string &gtest_msg, const Message &user_msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<int kSize> std::vector< std::string > {\b testing::ArrayAsVector} (const char *const (&array)[kSize])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::ValidateTestPropertyName} (const std::string &property_name, const std::vector< std::string > &reserved_names)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::ReportFailureInUnknownLocation} (TestPartResult::Type result_type, const std::string &message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T , typename Result > Result {\b testing::internal::HandleSehExceptionsInMethodIfSupported} (T *object, Result(T::*method)(), const char *location)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T , typename Result > Result {\b testing::internal::HandleExceptionsInMethodIfSupported} (T *object, Result(T::*method)(), const char *location)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} TestInfo * {\b testing::internal::MakeAndRegisterTestInfo} (const char *test_case_name, const char *name, const char *type_param, const char *value_param, CodeLocation code_location, TypeId fixture_class_id, SetUpTestCaseFunc set_up_tc, TearDownTestCaseFunc tear_down_tc, TestFactoryBase *factory)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b testing::internal::GetAnsiColorCode} (GTestColor color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::ShouldUseColor} (bool stdout_is_tty)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::ColoredPrintf} (GTestColor color, const char *fmt,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::PrintFullTestCommentIfPresent} (const TestInfo &test_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::FormatTimeInMillisAsSeconds} (TimeInMillis ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::FormatEpochTimeInMillisAsIso8601} (TimeInMillis ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testing::internal::WriteToShardStatusFileIfNeeded} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::ShouldShard} (const char *total_shards_str, const char *shard_index_str, bool in_subprocess_for_death_test)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} Int32 {\b testing::internal::Int32FromEnvOrDie} (const char *env_var, Int32 default_val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::ShouldRunTestOnShard} (int total_shards, int shard_index, int test_id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::internal::GetCurrentOsStackTraceExceptTop} (UnitTest *unit_test, int skip_count)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::IsTrue} (bool condition)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::AlwaysTrue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::SkipPrefix} (const char *prefix, const char **pstr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b testing::internal::ParseFlagValue} (const char *str, const char *flag, bool def_optional)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::ParseBoolFlag} (const char *str, const char *flag, bool *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} bool {\b testing::internal::ParseInt32Flag} (const char *str, const char *flag, Int32 *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::ParseStringFlag} (const char *str, const char *flag, std::string *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b testing::internal::ParseGoogleTestFlag} (const char *const arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CharType > void {\b testing::internal::ParseGoogleTestFlagsOnlyImpl} (int *argc, CharType **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::ParseGoogleTestFlagsOnly} (int *argc, char **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::internal::ParseGoogleTestFlagsOnly} (int *argc, wchar_t **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CharType > void {\b testing::internal::InitGoogleTestImpl} (int *argc, CharType **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::InitGoogleTest} (int *argc, char **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} void {\b testing::InitGoogleTest} (int *argc, wchar_t **argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} std::string {\b testing::TempDir} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CF\'E5\'F0\'E5\'EC\'E5\'ED\'ED\'FB\'E5\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
::std::vector< {\b testing::internal::string} > {\b testing::internal::g_argvs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const UInt32 {\b testing::internal::kMaxCodePoint1} = (static_cast<UInt32>(1) << 7) - 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const UInt32 {\b testing::internal::kMaxCodePoint2} = (static_cast<UInt32>(1) << (5 + 6)) - 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const UInt32 {\b testing::internal::kMaxCodePoint3} = (static_cast<UInt32>(1) << (4 + 2*6)) - 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const UInt32 {\b testing::internal::kMaxCodePoint4} = (static_cast<UInt32>(1) << (3 + 3*6)) - 1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'CC\'E0\'EA\'F0\'EE\'F1\'FB\par
\pard\plain 
{\xe \v GTEST_HAS_GETTIMEOFDAY_\:gtest.cc}
{\xe \v gtest.cc\:GTEST_HAS_GETTIMEOFDAY_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_HAS_GETTIMEOFDAY_\~ 1}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 116}}\par
}
{\xe \v GTEST_IMPL_CMP_HELPER_\:gtest.cc}
{\xe \v gtest.cc\:GTEST_IMPL_CMP_HELPER_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_IMPL_CMP_HELPER_( op_name,  op)}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid AssertionResult CmpHelper##op_name({\cf17 const} {\cf18 char}* expr1, {\cf17 const} {\cf18 char}* expr2, \\\par
                                   BiggestInt val1, BiggestInt val2) \{\\\par
  if (val1 op val2) \{\\\par
    return AssertionSuccess();\\\par
  \} {\cf19 else} \{\\\par
    return AssertionFailure() \\\par
        << {\cf22 "Expected: ("} << expr1 << {\cf22 ") "} #op {\cf22 " ("} << expr2\\\par
        << {\cf22 "), actual: "} << FormatForComparisonFailureMessage(val1, val2)\\\par
        << {\cf22 " vs "} << FormatForComparisonFailureMessage(val2, val1);\\\par
  \}\\\par
\}\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 1452}}\par
}
{\xe \v GTEST_IMPLEMENTATION_\:gtest.cc}
{\xe \v gtest.cc\:GTEST_IMPLEMENTATION_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_IMPLEMENTATION_\~ 1}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 141}}\par
}
{\xe \v GTEST_REPEATER_METHOD_\:gtest.cc}
{\xe \v gtest.cc\:GTEST_REPEATER_METHOD_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_REPEATER_METHOD_( Name,  Type)}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 void} TestEventRepeater::Name({\cf17 const} Type& parameter) \{ \\\par
  if (forwarding_enabled_) \{ \\\par
    for ({\cf18 size_t} i = 0; i < listeners_.size(); i++) \{ \\\par
      listeners_[i]->Name(parameter); \\\par
    \} \\\par
  \} \\\par
\}\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3292}}\par
}
{\xe \v GTEST_REVERSE_REPEATER_METHOD_\:gtest.cc}
{\xe \v gtest.cc\:GTEST_REVERSE_REPEATER_METHOD_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GTEST_REVERSE_REPEATER_METHOD_( Name,  Type)}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b \'CC\'E0\'EA\'F0\'EE\'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 void} TestEventRepeater::Name({\cf17 const} Type& parameter) \{ \\\par
  if (forwarding_enabled_) \{ \\\par
    for ({\cf18 int} i = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(listeners_.size()) - 1; i >= 0; i--) \{ \\\par
      listeners_[i]->Name(parameter); \\\par
    \} \\\par
  \} \\\par
\}\par
}
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 3302}}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest.cc}
{\xe \v gtest/src/gtest.cc}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2005, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 {\cf20 //}\par
00030 {\cf20 // Author: wan@google.com (Zhanyong Wan)}\par
00031 {\cf20 //}\par
00032 {\cf20 // The Google C++ Testing Framework (Google Test)}\par
00033 \par
00034 {\cf21 #include "gtest/gtest.h"}\par
00035 {\cf21 #include "gtest/internal/custom/gtest.h"}\par
00036 {\cf21 #include "gtest/gtest-spi.h"}\par
00037 \par
00038 {\cf21 #include <ctype.h>}\par
00039 {\cf21 #include <math.h>}\par
00040 {\cf21 #include <stdarg.h>}\par
00041 {\cf21 #include <stdio.h>}\par
00042 {\cf21 #include <stdlib.h>}\par
00043 {\cf21 #include <time.h>}\par
00044 {\cf21 #include <wchar.h>}\par
00045 {\cf21 #include <wctype.h>}\par
00046 \par
00047 {\cf21 #include <algorithm>}\par
00048 {\cf21 #include <iomanip>}\par
00049 {\cf21 #include <limits>}\par
00050 {\cf21 #include <list>}\par
00051 {\cf21 #include <map>}\par
00052 {\cf21 #include <ostream>}  {\cf20 // NOLINT}\par
00053 {\cf21 #include <sstream>}\par
00054 {\cf21 #include <vector>}\par
00055 \par
00056 {\cf21 #if GTEST_OS_LINUX}\par
00057 \par
00058 {\cf20 // TODO(kenton@google.com): Use autoconf to detect availability of}\par
00059 {\cf20 // gettimeofday().}\par
00060 {\cf21 # define GTEST_HAS_GETTIMEOFDAY_ 1}\par
00061 \par
00062 {\cf21 # include <fcntl.h>}  {\cf20 // NOLINT}\par
00063 {\cf21 # include <limits.h>}  {\cf20 // NOLINT}\par
00064 {\cf21 # include <sched.h>}  {\cf20 // NOLINT}\par
00065 {\cf20 // Declares vsnprintf().  This header is not available on Windows.}\par
00066 {\cf21 # include <strings.h>}  {\cf20 // NOLINT}\par
00067 {\cf21 # include <sys/mman.h>}  {\cf20 // NOLINT}\par
00068 {\cf21 # include <sys/time.h>}  {\cf20 // NOLINT}\par
00069 {\cf21 # include <unistd.h>}  {\cf20 // NOLINT}\par
00070 {\cf21 # include <string>}\par
00071 \par
00072 {\cf21 #elif GTEST_OS_SYMBIAN}\par
00073 {\cf21 # define GTEST_HAS_GETTIMEOFDAY_ 1}\par
00074 {\cf21 # include <sys/time.h>}  {\cf20 // NOLINT}\par
00075 \par
00076 {\cf21 #elif GTEST_OS_ZOS}\par
00077 {\cf21 # define GTEST_HAS_GETTIMEOFDAY_ 1}\par
00078 {\cf21 # include <sys/time.h>}  {\cf20 // NOLINT}\par
00079 \par
00080 {\cf20 // On z/OS we additionally need strings.h for strcasecmp.}\par
00081 {\cf21 # include <strings.h>}  {\cf20 // NOLINT}\par
00082 \par
00083 {\cf21 #elif GTEST_OS_WINDOWS_MOBILE  }{\cf20 // We are on Windows CE.}\par
00084 \par
00085 {\cf21 # include <windows.h>}  {\cf20 // NOLINT}\par
00086 {\cf21 # undef min}\par
00087 \par
00088 {\cf21 #elif GTEST_OS_WINDOWS  }{\cf20 // We are on Windows proper.}\par
00089 \par
00090 {\cf21 # include <io.h>}  {\cf20 // NOLINT}\par
00091 {\cf21 # include <sys/timeb.h>}  {\cf20 // NOLINT}\par
00092 {\cf21 # include <sys/types.h>}  {\cf20 // NOLINT}\par
00093 {\cf21 # include <sys/stat.h>}  {\cf20 // NOLINT}\par
00094 \par
00095 {\cf21 # if GTEST_OS_WINDOWS_MINGW}\par
00096 {\cf20 // MinGW has gettimeofday() but not _ftime64().}\par
00097 {\cf20 // TODO(kenton@google.com): Use autoconf to detect availability of}\par
00098 {\cf20 //   gettimeofday().}\par
00099 {\cf20 // TODO(kenton@google.com): There are other ways to get the time on}\par
00100 {\cf20 //   Windows, like GetTickCount() or GetSystemTimeAsFileTime().  MinGW}\par
00101 {\cf20 //   supports these.  consider using them instead.}\par
00102 {\cf21 #  define GTEST_HAS_GETTIMEOFDAY_ 1}\par
00103 {\cf21 #  include <sys/time.h>}  {\cf20 // NOLINT}\par
00104 {\cf21 # endif  }{\cf20 // GTEST_OS_WINDOWS_MINGW}\par
00105 \par
00106 {\cf20 // cpplint thinks that the header is already included, so we want to}\par
00107 {\cf20 // silence it.}\par
00108 {\cf21 # include <windows.h>}  {\cf20 // NOLINT}\par
00109 {\cf21 # undef min}\par
00110 \par
00111 {\cf21 #else}\par
00112 \par
00113 {\cf20 // Assume other platforms have gettimeofday().}\par
00114 {\cf20 // TODO(kenton@google.com): Use autoconf to detect availability of}\par
00115 {\cf20 //   gettimeofday().}\par
00116 {\cf21 # define GTEST_HAS_GETTIMEOFDAY_ 1}\par
00117 \par
00118 {\cf20 // cpplint thinks that the header is already included, so we want to}\par
00119 {\cf20 // silence it.}\par
00120 {\cf21 # include <sys/time.h>}  {\cf20 // NOLINT}\par
00121 {\cf21 # include <unistd.h>}  {\cf20 // NOLINT}\par
00122 \par
00123 {\cf21 #endif  }{\cf20 // GTEST_OS_LINUX}\par
00124 \par
00125 {\cf21 #if GTEST_HAS_EXCEPTIONS}\par
00126 {\cf21 # include <stdexcept>}\par
00127 {\cf21 #endif}\par
00128 \par
00129 {\cf21 #if GTEST_CAN_STREAM_RESULTS_}\par
00130 {\cf21 # include <arpa/inet.h>}  {\cf20 // NOLINT}\par
00131 {\cf21 # include <netdb.h>}  {\cf20 // NOLINT}\par
00132 {\cf21 # include <sys/socket.h>}  {\cf20 // NOLINT}\par
00133 {\cf21 # include <sys/types.h>}  {\cf20 // NOLINT}\par
00134 {\cf21 #endif}\par
00135 \par
00136 {\cf20 // Indicates that this translation unit is part of Google Test's}\par
00137 {\cf20 // implementation.  It must come before gtest-internal-inl.h is}\par
00138 {\cf20 // included, or there will be a compiler error.  This trick is to}\par
00139 {\cf20 // prevent a user from accidentally including gtest-internal-inl.h in}\par
00140 {\cf20 // his code.}\par
00141 {\cf21 #define GTEST_IMPLEMENTATION_ 1}\par
00142 {\cf21 #include "src/gtest-internal-inl.h"}\par
00143 {\cf21 #undef GTEST_IMPLEMENTATION_}\par
00144 \par
00145 {\cf21 #if GTEST_OS_WINDOWS}\par
00146 {\cf21 # define vsnprintf _vsnprintf}\par
00147 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
00148 \par
00149 {\cf17 namespace }testing \{\par
00150 \par
00151 {\cf17 using} internal::CountIf;\par
00152 {\cf17 using} internal::ForEach;\par
00153 {\cf17 using} internal::GetElementOr;\par
00154 {\cf17 using} internal::Shuffle;\par
00155 \par
00156 {\cf20 // Constants.}\par
00157 \par
00158 {\cf20 // A test whose test case name or test name matches this filter is}\par
00159 {\cf20 // disabled and not run.}\par
00160 {\cf17 static} {\cf17 const} {\cf18 char} kDisableTestFilter[] = {\cf22 "DISABLED_*:*/DISABLED_*"};\par
00161 \par
00162 {\cf20 // A test case whose name matches this filter is considered a death}\par
00163 {\cf20 // test case and will be run before test cases whose name doesn't}\par
00164 {\cf20 // match this filter.}\par
00165 {\cf17 static} {\cf17 const} {\cf18 char} kDeathTestCaseFilter[] = {\cf22 "*DeathTest:*DeathTest/*"};\par
00166 \par
00167 {\cf20 // A test filter that matches everything.}\par
00168 {\cf17 static} {\cf17 const} {\cf18 char} kUniversalFilter[] = {\cf22 "*"};\par
00169 \par
00170 {\cf20 // The default output file for XML output.}\par
00171 {\cf17 static} {\cf17 const} {\cf18 char} kDefaultOutputFile[] = {\cf22 "test_detail.xml"};\par
00172 \par
00173 {\cf20 // The environment variable name for the test shard index.}\par
00174 {\cf17 static} {\cf17 const} {\cf18 char} kTestShardIndex[] = {\cf22 "GTEST_SHARD_INDEX"};\par
00175 {\cf20 // The environment variable name for the total number of test shards.}\par
00176 {\cf17 static} {\cf17 const} {\cf18 char} kTestTotalShards[] = {\cf22 "GTEST_TOTAL_SHARDS"};\par
00177 {\cf20 // The environment variable name for the test shard status file.}\par
00178 {\cf17 static} {\cf17 const} {\cf18 char} kTestShardStatusFile[] = {\cf22 "GTEST_SHARD_STATUS_FILE"};\par
00179 \par
00180 {\cf17 namespace }internal \{\par
00181 \par
00182 {\cf20 // The text used in failure messages to indicate the start of the}\par
00183 {\cf20 // stack trace.}\par
00184 {\cf17 const} {\cf18 char} kStackTraceMarker[] = {\cf22 "\\nStack trace:\\n"};\par
00185 \par
00186 {\cf20 // g_help_flag is true iff the --help flag or an equivalent form is}\par
00187 {\cf20 // specified on the command line.}\par
00188 {\cf18 bool} g_help_flag = {\cf17 false};\par
00189 \par
00190 \}  {\cf20 // namespace internal}\par
00191 \par
00192 {\cf17 static} {\cf17 const} {\cf18 char}* GetDefaultFilter() \{\par
00193 {\cf21 #ifdef GTEST_TEST_FILTER_ENV_VAR_}\par
00194   {\cf17 const} {\cf18 char}* {\cf17 const} testbridge_test_only = getenv(GTEST_TEST_FILTER_ENV_VAR_);\par
00195   {\cf19 if} (testbridge_test_only != NULL) \{\par
00196     {\cf19 return} testbridge_test_only;\par
00197   \}\par
00198 {\cf21 #endif  }{\cf20 // GTEST_TEST_FILTER_ENV_VAR_}\par
00199   {\cf19 return} kUniversalFilter;\par
00200 \}\par
00201 \par
00202 GTEST_DEFINE_bool_(\par
00203     also_run_disabled_tests,\par
00204     internal::BoolFromGTestEnv({\cf22 "also_run_disabled_tests"}, {\cf17 false}),\par
00205     {\cf22 "Run disabled tests too, in addition to the tests normally being run."});\par
00206 \par
00207 GTEST_DEFINE_bool_(\par
00208     break_on_failure,\par
00209     internal::BoolFromGTestEnv({\cf22 "break_on_failure"}, {\cf17 false}),\par
00210     {\cf22 "True iff a failed assertion should be a debugger break-point."});\par
00211 \par
00212 GTEST_DEFINE_bool_(\par
00213     catch_exceptions,\par
00214     internal::BoolFromGTestEnv({\cf22 "catch_exceptions"}, {\cf17 true}),\par
00215     {\cf22 "True iff "} GTEST_NAME_\par
00216     {\cf22 " should catch exceptions and treat them as test failures."});\par
00217 \par
00218 GTEST_DEFINE_string_(\par
00219     color,\par
00220     internal::StringFromGTestEnv({\cf22 "color"}, {\cf22 "auto"}),\par
00221     {\cf22 "Whether to use colors in the output.  Valid values: yes, no, "}\par
00222     {\cf22 "and auto.  'auto' means to use colors if the output is "}\par
00223     {\cf22 "being sent to a terminal and the TERM environment variable "}\par
00224     {\cf22 "is set to a terminal type that supports colors."});\par
00225 \par
00226 GTEST_DEFINE_string_(\par
00227     filter,\par
00228     internal::StringFromGTestEnv({\cf22 "filter"}, GetDefaultFilter()),\par
00229     {\cf22 "A colon-separated list of glob (not regex) patterns "}\par
00230     {\cf22 "for filtering the tests to run, optionally followed by a "}\par
00231     {\cf22 "'-' and a : separated list of negative patterns (tests to "}\par
00232     {\cf22 "exclude).  A test is run if it matches one of the positive "}\par
00233     {\cf22 "patterns and does not match any of the negative patterns."});\par
00234 \par
00235 GTEST_DEFINE_bool_(list_tests, {\cf17 false},\par
00236                    {\cf22 "List all tests without running them."});\par
00237 \par
00238 GTEST_DEFINE_string_(\par
00239     output,\par
00240     internal::StringFromGTestEnv({\cf22 "output"}, {\cf22 ""}),\par
00241     {\cf22 "A format (currently must be \\"xml\\"), optionally followed "}\par
00242     {\cf22 "by a colon and an output file name or directory. A directory "}\par
00243     {\cf22 "is indicated by a trailing pathname separator. "}\par
00244     {\cf22 "Examples: \\"xml:filename.xml\\", \\"xml::directoryname/\\". "}\par
00245     {\cf22 "If a directory is specified, output files will be created "}\par
00246     {\cf22 "within that directory, with file-names based on the test "}\par
00247     {\cf22 "executable's name and, if necessary, made unique by adding "}\par
00248     {\cf22 "digits."});\par
00249 \par
00250 GTEST_DEFINE_bool_(\par
00251     print_time,\par
00252     internal::BoolFromGTestEnv({\cf22 "print_time"}, {\cf17 true}),\par
00253     {\cf22 "True iff "} GTEST_NAME_\par
00254     {\cf22 " should display elapsed time in text output."});\par
00255 \par
00256 GTEST_DEFINE_int32_(\par
00257     random_seed,\par
00258     internal::Int32FromGTestEnv({\cf22 "random_seed"}, 0),\par
00259     {\cf22 "Random number seed to use when shuffling test orders.  Must be in range "}\par
00260     {\cf22 "[1, 99999], or 0 to use a seed based on the current time."});\par
00261 \par
00262 GTEST_DEFINE_int32_(\par
00263     repeat,\par
00264     internal::Int32FromGTestEnv({\cf22 "repeat"}, 1),\par
00265     {\cf22 "How many times to repeat each test.  Specify a negative number "}\par
00266     {\cf22 "for repeating forever.  Useful for shaking out flaky tests."});\par
00267 \par
00268 GTEST_DEFINE_bool_(\par
00269     show_internal_stack_frames, {\cf17 false},\par
00270     {\cf22 "True iff "} GTEST_NAME_ {\cf22 " should include internal stack frames when "}\par
00271     {\cf22 "printing test failure stack traces."});\par
00272 \par
00273 GTEST_DEFINE_bool_(\par
00274     shuffle,\par
00275     internal::BoolFromGTestEnv({\cf22 "shuffle"}, {\cf17 false}),\par
00276     {\cf22 "True iff "} GTEST_NAME_\par
00277     {\cf22 " should randomize tests' order on every run."});\par
00278 \par
00279 GTEST_DEFINE_int32_(\par
00280     stack_trace_depth,\par
00281     internal::Int32FromGTestEnv({\cf22 "stack_trace_depth"}, kMaxStackTraceDepth),\par
00282     {\cf22 "The maximum number of stack frames to print when an "}\par
00283     {\cf22 "assertion fails.  The valid range is 0 through 100, inclusive."});\par
00284 \par
00285 GTEST_DEFINE_string_(\par
00286     stream_result_to,\par
00287     internal::StringFromGTestEnv({\cf22 "stream_result_to"}, {\cf22 ""}),\par
00288     {\cf22 "This flag specifies the host name and the port number on which to stream "}\par
00289     {\cf22 "test results. Example: \\"localhost:555\\". The flag is effective only on "}\par
00290     {\cf22 "Linux."});\par
00291 \par
00292 GTEST_DEFINE_bool_(\par
00293     throw_on_failure,\par
00294     internal::BoolFromGTestEnv({\cf22 "throw_on_failure"}, {\cf17 false}),\par
00295     {\cf22 "When this flag is specified, a failed assertion will throw an exception "}\par
00296     {\cf22 "if exceptions are enabled or exit the program with a non-zero code "}\par
00297     {\cf22 "otherwise."});\par
00298 \par
00299 {\cf21 #if GTEST_USE_OWN_FLAGFILE_FLAG_}\par
00300 GTEST_DEFINE_string_(\par
00301     flagfile,\par
00302     internal::StringFromGTestEnv({\cf22 "flagfile"}, {\cf22 ""}),\par
00303     {\cf22 "This flag specifies the flagfile to read command-line flags from."});\par
00304 {\cf21 #endif  }{\cf20 // GTEST_USE_OWN_FLAGFILE_FLAG_}\par
00305 \par
00306 {\cf17 namespace }internal \{\par
00307 \par
00308 {\cf20 // Generates a random number from [0, range), using a Linear}\par
00309 {\cf20 // Congruential Generator (LCG).  Crashes if 'range' is 0 or greater}\par
00310 {\cf20 // than kMaxRange.}\par
00311 UInt32 Random::Generate(UInt32 range) \{\par
00312   {\cf20 // These constants are the same as are used in glibc's rand(3).}\par
00313   state_ = (1103515245U*state_ + 12345U) % kMaxRange;\par
00314 \par
00315   GTEST_CHECK_(range > 0)\par
00316       << {\cf22 "Cannot generate a number in the range [0, 0)."};\par
00317   GTEST_CHECK_(range <= kMaxRange)\par
00318       << {\cf22 "Generation of a number in [0, "} << range << {\cf22 ") was requested, "}\par
00319       << {\cf22 "but this can only generate numbers in [0, "} << kMaxRange << {\cf22 ")."};\par
00320 \par
00321   {\cf20 // Converting via modulus introduces a bit of downward bias, but}\par
00322   {\cf20 // it's simple, and a linear congruential generator isn't too good}\par
00323   {\cf20 // to begin with.}\par
00324   {\cf19 return} state_ % range;\par
00325 \}\par
00326 \par
00327 {\cf20 // GTestIsInitialized() returns true iff the user has initialized}\par
00328 {\cf20 // Google Test.  Useful for catching the user mistake of not initializing}\par
00329 {\cf20 // Google Test before calling RUN_ALL_TESTS().}\par
00330 {\cf17 static} {\cf18 bool} GTestIsInitialized() \{ {\cf19 return} GetArgvs().size() > 0; \}\par
00331 \par
00332 {\cf20 // Iterates over a vector of TestCases, keeping a running sum of the}\par
00333 {\cf20 // results of calling a given int-returning method on each.}\par
00334 {\cf20 // Returns the sum.}\par
00335 {\cf17 static} {\cf18 int} SumOverTestCaseList({\cf17 const} std::vector<TestCase*>& case_list,\par
00336                                {\cf18 int} (TestCase::*method)() {\cf17 const}) \{\par
00337   {\cf18 int} sum = 0;\par
00338   {\cf19 for} ({\cf18 size_t} i = 0; i < case_list.size(); i++) \{\par
00339     sum += (case_list[i]->*method)();\par
00340   \}\par
00341   {\cf19 return} sum;\par
00342 \}\par
00343 \par
00344 {\cf20 // Returns true iff the test case passed.}\par
00345 {\cf17 static} {\cf18 bool} TestCasePassed({\cf17 const} TestCase* test_case) \{\par
00346   {\cf19 return} test_case->should_run() && test_case->Passed();\par
00347 \}\par
00348 \par
00349 {\cf20 // Returns true iff the test case failed.}\par
00350 {\cf17 static} {\cf18 bool} TestCaseFailed({\cf17 const} TestCase* test_case) \{\par
00351   {\cf19 return} test_case->should_run() && test_case->Failed();\par
00352 \}\par
00353 \par
00354 {\cf20 // Returns true iff test_case contains at least one test that should}\par
00355 {\cf20 // run.}\par
00356 {\cf17 static} {\cf18 bool} ShouldRunTestCase({\cf17 const} TestCase* test_case) \{\par
00357   {\cf19 return} test_case->should_run();\par
00358 \}\par
00359 \par
00360 {\cf20 // AssertHelper constructor.}\par
00361 AssertHelper::AssertHelper(TestPartResult::Type type,\par
00362                            {\cf17 const} {\cf18 char}* file,\par
00363                            {\cf18 int} line,\par
00364                            {\cf17 const} {\cf18 char}* message)\par
00365     : data_(new AssertHelperData(type, file, line, message)) \{\par
00366 \}\par
00367 \par
00368 AssertHelper::~AssertHelper() \{\par
00369   {\cf17 delete} data_;\par
00370 \}\par
00371 \par
00372 {\cf20 // Message assignment, for assertion streaming support.}\par
00373 {\cf18 void} AssertHelper::operator=({\cf17 const} Message& message){\cf17  const }\{\par
00374   UnitTest::GetInstance()->\par
00375     AddTestPartResult(data_->type, data_->file, data_->line,\par
00376                       AppendUserMessage(data_->message, message),\par
00377                       UnitTest::GetInstance()->impl()\par
00378                       ->CurrentOsStackTraceExceptTop(1)\par
00379                       {\cf20 // Skips the stack frame for this function itself.}\par
00380                       );  {\cf20 // NOLINT}\par
00381 \}\par
00382 \par
00383 {\cf20 // Mutex for linked pointers.}\par
00384 GTEST_API_ GTEST_DEFINE_STATIC_MUTEX_(g_linked_ptr_mutex);\par
00385 \par
00386 {\cf20 // A copy of all command line arguments.  Set by InitGoogleTest().}\par
00387 ::std::vector<testing::internal::string> g_argvs;\par
00388 \par
00389 const ::std::vector<testing::internal::string>& GetArgvs() \{\par
00390 {\cf21 #if defined(GTEST_CUSTOM_GET_ARGVS_)}\par
00391   {\cf19 return} GTEST_CUSTOM_GET_ARGVS_();\par
00392 {\cf21 #else  }{\cf20 // defined(GTEST_CUSTOM_GET_ARGVS_)}\par
00393   {\cf19 return} g_argvs;\par
00394 {\cf21 #endif  }{\cf20 // defined(GTEST_CUSTOM_GET_ARGVS_)}\par
00395 \}\par
00396 \par
00397 {\cf20 // Returns the current application's name, removing directory path if that}\par
00398 {\cf20 // is present.}\par
00399 FilePath GetCurrentExecutableName() \{\par
00400   FilePath result;\par
00401 \par
00402 {\cf21 #if GTEST_OS_WINDOWS}\par
00403   result.Set(FilePath(GetArgvs()[0]).RemoveExtension({\cf22 "exe"}));\par
00404 {\cf21 #else}\par
00405   result.Set(FilePath(GetArgvs()[0]));\par
00406 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
00407 \par
00408   {\cf19 return} result.RemoveDirectoryName();\par
00409 \}\par
00410 \par
00411 {\cf20 // Functions for processing the gtest_output flag.}\par
00412 \par
00413 {\cf20 // Returns the output format, or "" for normal printed output.}\par
00414 std::string UnitTestOptions::GetOutputFormat() \{\par
00415   {\cf17 const} {\cf18 char}* {\cf17 const} gtest_output_flag = GTEST_FLAG(output).c_str();\par
00416   {\cf19 if} (gtest_output_flag == NULL) {\cf19 return} std::string({\cf22 ""});\par
00417 \par
00418   {\cf17 const} {\cf18 char}* {\cf17 const} colon = strchr(gtest_output_flag, {\cf23 ':'});\par
00419   {\cf19 return} (colon == NULL) ?\par
00420       std::string(gtest_output_flag) :\par
00421       std::string(gtest_output_flag, colon - gtest_output_flag);\par
00422 \}\par
00423 \par
00424 {\cf20 // Returns the name of the requested output file, or the default if none}\par
00425 {\cf20 // was explicitly specified.}\par
00426 std::string UnitTestOptions::GetAbsolutePathToOutputFile() \{\par
00427   {\cf17 const} {\cf18 char}* {\cf17 const} gtest_output_flag = GTEST_FLAG(output).c_str();\par
00428   {\cf19 if} (gtest_output_flag == NULL)\par
00429     {\cf19 return} {\cf22 ""};\par
00430 \par
00431   {\cf17 const} {\cf18 char}* {\cf17 const} colon = strchr(gtest_output_flag, {\cf23 ':'});\par
00432   {\cf19 if} (colon == NULL)\par
00433     {\cf19 return} internal::FilePath::ConcatPaths(\par
00434         internal::FilePath(\par
00435             UnitTest::GetInstance()->original_working_dir()),\par
00436         internal::FilePath(kDefaultOutputFile)).string();\par
00437 \par
00438   internal::FilePath output_name(colon + 1);\par
00439   {\cf19 if} (!output_name.IsAbsolutePath())\par
00440     {\cf20 // TODO(wan@google.com): on Windows \\some\\path is not an absolute}\par
00441     {\cf20 // path (as its meaning depends on the current drive), yet the}\par
00442     {\cf20 // following logic for turning it into an absolute path is wrong.}\par
00443     {\cf20 // Fix it.}\par
00444     output_name = internal::FilePath::ConcatPaths(\par
00445         internal::FilePath(UnitTest::GetInstance()->original_working_dir()),\par
00446         internal::FilePath(colon + 1));\par
00447 \par
00448   {\cf19 if} (!output_name.IsDirectory())\par
00449     {\cf19 return} output_name.string();\par
00450 \par
00451   internal::FilePath result(internal::FilePath::GenerateUniqueFileName(\par
00452       output_name, internal::GetCurrentExecutableName(),\par
00453       GetOutputFormat().c_str()));\par
00454   {\cf19 return} result.string();\par
00455 \}\par
00456 \par
00457 {\cf20 // Returns true iff the wildcard pattern matches the string.  The}\par
00458 {\cf20 // first ':' or '\\0' character in pattern marks the end of it.}\par
00459 {\cf20 //}\par
00460 {\cf20 // This recursive algorithm isn't very efficient, but is clear and}\par
00461 {\cf20 // works well enough for matching test names, which are short.}\par
00462 {\cf18 bool} UnitTestOptions::PatternMatchesString({\cf17 const} {\cf18 char} *pattern,\par
00463                                            {\cf17 const} {\cf18 char} *str) \{\par
00464   {\cf19 switch} (*pattern) \{\par
00465     {\cf19 case} {\cf23 '\\0'}:\par
00466     {\cf19 case} {\cf23 ':'}:  {\cf20 // Either ':' or '\\0' marks the end of the pattern.}\par
00467       {\cf19 return} *str == {\cf23 '\\0'};\par
00468     {\cf19 case} {\cf23 '?'}:  {\cf20 // Matches any single character.}\par
00469       {\cf19 return} *str != {\cf23 '\\0'} && PatternMatchesString(pattern + 1, str + 1);\par
00470     {\cf19 case} {\cf23 '*'}:  {\cf20 // Matches any string (possibly empty) of characters.}\par
00471       {\cf19 return} (*str != {\cf23 '\\0'} && PatternMatchesString(pattern, str + 1)) ||\par
00472           PatternMatchesString(pattern + 1, str);\par
00473     {\cf19 default}:  {\cf20 // Non-special character.  Matches itself.}\par
00474       {\cf19 return} *pattern == *str &&\par
00475           PatternMatchesString(pattern + 1, str + 1);\par
00476   \}\par
00477 \}\par
00478 \par
00479 {\cf18 bool} UnitTestOptions::MatchesFilter(\par
00480     {\cf17 const} std::string& name, {\cf17 const} {\cf18 char}* filter) \{\par
00481   {\cf17 const} {\cf18 char} *cur_pattern = filter;\par
00482   {\cf19 for} (;;) \{\par
00483     {\cf19 if} (PatternMatchesString(cur_pattern, name.c_str())) \{\par
00484       {\cf19 return} {\cf17 true};\par
00485     \}\par
00486 \par
00487     {\cf20 // Finds the next pattern in the filter.}\par
00488     cur_pattern = strchr(cur_pattern, {\cf23 ':'});\par
00489 \par
00490     {\cf20 // Returns if no more pattern can be found.}\par
00491     {\cf19 if} (cur_pattern == NULL) \{\par
00492       {\cf19 return} {\cf17 false};\par
00493     \}\par
00494 \par
00495     {\cf20 // Skips the pattern separater (the ':' character).}\par
00496     cur_pattern++;\par
00497   \}\par
00498 \}\par
00499 \par
00500 {\cf20 // Returns true iff the user-specified filter matches the test case}\par
00501 {\cf20 // name and the test name.}\par
00502 {\cf18 bool} UnitTestOptions::FilterMatchesTest({\cf17 const} std::string &test_case_name,\par
00503                                         {\cf17 const} std::string &test_name) \{\par
00504   {\cf17 const} std::string& full_name = test_case_name + {\cf22 "."} + test_name.c_str();\par
00505 \par
00506   {\cf20 // Split --gtest_filter at '-', if there is one, to separate into}\par
00507   {\cf20 // positive filter and negative filter portions}\par
00508   {\cf17 const} {\cf18 char}* {\cf17 const} p = GTEST_FLAG(filter).c_str();\par
00509   {\cf17 const} {\cf18 char}* {\cf17 const} dash = strchr(p, {\cf23 '-'});\par
00510   std::string positive;\par
00511   std::string negative;\par
00512   {\cf19 if} (dash == NULL) \{\par
00513     positive = GTEST_FLAG(filter).c_str();  {\cf20 // Whole string is a positive filter}\par
00514     negative = {\cf22 ""};\par
00515   \} {\cf19 else} \{\par
00516     positive = std::string(p, dash);   {\cf20 // Everything up to the dash}\par
00517     negative = std::string(dash + 1);  {\cf20 // Everything after the dash}\par
00518     {\cf19 if} (positive.empty()) \{\par
00519       {\cf20 // Treat '-test1' as the same as '*-test1'}\par
00520       positive = kUniversalFilter;\par
00521     \}\par
00522   \}\par
00523 \par
00524   {\cf20 // A filter is a colon-separated list of patterns.  It matches a}\par
00525   {\cf20 // test if any pattern in it matches the test.}\par
00526   {\cf19 return} (MatchesFilter(full_name, positive.c_str()) &&\par
00527           !MatchesFilter(full_name, negative.c_str()));\par
00528 \}\par
00529 \par
00530 {\cf21 #if GTEST_HAS_SEH}\par
00531 {\cf20 // Returns EXCEPTION_EXECUTE_HANDLER if Google Test should handle the}\par
00532 {\cf20 // given SEH exception, or EXCEPTION_CONTINUE_SEARCH otherwise.}\par
00533 {\cf20 // This function is useful as an __except condition.}\par
00534 {\cf18 int} UnitTestOptions::GTestShouldProcessSEH(DWORD exception_code) \{\par
00535   {\cf20 // Google Test should handle a SEH exception if:}\par
00536   {\cf20 //   1. the user wants it to, AND}\par
00537   {\cf20 //   2. this is not a breakpoint exception, AND}\par
00538   {\cf20 //   3. this is not a C++ exception (VC++ implements them via SEH,}\par
00539   {\cf20 //      apparently).}\par
00540   {\cf20 //}\par
00541   {\cf20 // SEH exception code for C++ exceptions.}\par
00542   {\cf20 // (see http://support.microsoft.com/kb/185294 for more information).}\par
00543   {\cf17 const} DWORD kCxxExceptionCode = 0xe06d7363;\par
00544 \par
00545   {\cf18 bool} should_handle = {\cf17 true};\par
00546 \par
00547   {\cf19 if} (!GTEST_FLAG(catch_exceptions))\par
00548     should_handle = {\cf17 false};\par
00549   {\cf19 else} {\cf19 if} (exception_code == EXCEPTION_BREAKPOINT)\par
00550     should_handle = {\cf17 false};\par
00551   {\cf19 else} {\cf19 if} (exception_code == kCxxExceptionCode)\par
00552     should_handle = {\cf17 false};\par
00553 \par
00554   {\cf19 return} should_handle ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH;\par
00555 \}\par
00556 {\cf21 #endif  }{\cf20 // GTEST_HAS_SEH}\par
00557 \par
00558 \}  {\cf20 // namespace internal}\par
00559 \par
00560 {\cf20 // The c'tor sets this object as the test part result reporter used by}\par
00561 {\cf20 // Google Test.  The 'result' parameter specifies where to report the}\par
00562 {\cf20 // results. Intercepts only failures from the current thread.}\par
00563 ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(\par
00564     TestPartResultArray* result)\par
00565     : intercept_mode_(INTERCEPT_ONLY_CURRENT_THREAD),\par
00566       result_(result) \{\par
00567   Init();\par
00568 \}\par
00569 \par
00570 {\cf20 // The c'tor sets this object as the test part result reporter used by}\par
00571 {\cf20 // Google Test.  The 'result' parameter specifies where to report the}\par
00572 {\cf20 // results.}\par
00573 ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(\par
00574     InterceptMode intercept_mode, TestPartResultArray* result)\par
00575     : intercept_mode_(intercept_mode),\par
00576       result_(result) \{\par
00577   Init();\par
00578 \}\par
00579 \par
00580 {\cf18 void} ScopedFakeTestPartResultReporter::Init() \{\par
00581   internal::UnitTestImpl* {\cf17 const} impl = internal::GetUnitTestImpl();\par
00582   {\cf19 if} (intercept_mode_ == INTERCEPT_ALL_THREADS) \{\par
00583     old_reporter_ = impl->GetGlobalTestPartResultReporter();\par
00584     impl->SetGlobalTestPartResultReporter({\cf17 this});\par
00585   \} {\cf19 else} \{\par
00586     old_reporter_ = impl->GetTestPartResultReporterForCurrentThread();\par
00587     impl->SetTestPartResultReporterForCurrentThread({\cf17 this});\par
00588   \}\par
00589 \}\par
00590 \par
00591 {\cf20 // The d'tor restores the test part result reporter used by Google Test}\par
00592 {\cf20 // before.}\par
00593 ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter() \{\par
00594   internal::UnitTestImpl* {\cf17 const} impl = internal::GetUnitTestImpl();\par
00595   {\cf19 if} (intercept_mode_ == INTERCEPT_ALL_THREADS) \{\par
00596     impl->SetGlobalTestPartResultReporter(old_reporter_);\par
00597   \} {\cf19 else} \{\par
00598     impl->SetTestPartResultReporterForCurrentThread(old_reporter_);\par
00599   \}\par
00600 \}\par
00601 \par
00602 {\cf20 // Increments the test part result count and remembers the result.}\par
00603 {\cf20 // This method is from the TestPartResultReporterInterface interface.}\par
00604 {\cf18 void} ScopedFakeTestPartResultReporter::ReportTestPartResult(\par
00605     {\cf17 const} TestPartResult& result) \{\par
00606   result_->Append(result);\par
00607 \}\par
00608 \par
00609 {\cf17 namespace }internal \{\par
00610 \par
00611 {\cf20 // Returns the type ID of ::testing::Test.  We should always call this}\par
00612 {\cf20 // instead of GetTypeId< ::testing::Test>() to get the type ID of}\par
00613 {\cf20 // testing::Test.  This is to work around a suspected linker bug when}\par
00614 {\cf20 // using Google Test as a framework on Mac OS X.  The bug causes}\par
00615 {\cf20 // GetTypeId< ::testing::Test>() to return different values depending}\par
00616 {\cf20 // on whether the call is from the Google Test framework itself or}\par
00617 {\cf20 // from user test code.  GetTestTypeId() is guaranteed to always}\par
00618 {\cf20 // return the same value, as it always calls GetTypeId<>() from the}\par
00619 {\cf20 // gtest.cc, which is within the Google Test framework.}\par
00620 TypeId GetTestTypeId() \{\par
00621   {\cf19 return} GetTypeId<Test>();\par
00622 \}\par
00623 \par
00624 {\cf20 // The value of GetTestTypeId() as seen from within the Google Test}\par
00625 {\cf20 // library.  This is solely for testing GetTestTypeId().}\par
00626 {\cf17 extern} {\cf17 const} TypeId kTestTypeIdInGoogleTest = GetTestTypeId();\par
00627 \par
00628 {\cf20 // This predicate-formatter checks that 'results' contains a test part}\par
00629 {\cf20 // failure of the given type and that the failure message contains the}\par
00630 {\cf20 // given substring.}\par
00631 AssertionResult HasOneFailure({\cf17 const} {\cf18 char}* {\cf20 /* results_expr */},\par
00632                               {\cf17 const} {\cf18 char}* {\cf20 /* type_expr */},\par
00633                               {\cf17 const} {\cf18 char}* {\cf20 /* substr_expr */},\par
00634                               {\cf17 const} TestPartResultArray& results,\par
00635                               TestPartResult::Type type,\par
00636                               {\cf17 const} std::string& substr) \{\par
00637   {\cf17 const} std::string expected(type == TestPartResult::kFatalFailure ?\par
00638                         {\cf22 "1 fatal failure"} :\par
00639                         {\cf22 "1 non-fatal failure"});\par
00640   Message msg;\par
00641   {\cf19 if} (results.size() != 1) \{\par
00642     msg << {\cf22 "Expected: "} << expected << {\cf22 "\\n"}\par
00643         << {\cf22 "  Actual: "} << results.size() << {\cf22 " failures"};\par
00644     {\cf19 for} ({\cf18 int} i = 0; i < results.size(); i++) \{\par
00645       msg << {\cf22 "\\n"} << results.GetTestPartResult(i);\par
00646     \}\par
00647     {\cf19 return} AssertionFailure() << msg;\par
00648   \}\par
00649 \par
00650   {\cf17 const} TestPartResult& r = results.GetTestPartResult(0);\par
00651   {\cf19 if} (r.type() != type) \{\par
00652     {\cf19 return} AssertionFailure() << {\cf22 "Expected: "} << expected << {\cf22 "\\n"}\par
00653                               << {\cf22 "  Actual:\\n"}\par
00654                               << r;\par
00655   \}\par
00656 \par
00657   {\cf19 if} (strstr(r.message(), substr.c_str()) == NULL) \{\par
00658     {\cf19 return} AssertionFailure() << {\cf22 "Expected: "} << expected << {\cf22 " containing \\""}\par
00659                               << substr << {\cf22 "\\"\\n"}\par
00660                               << {\cf22 "  Actual:\\n"}\par
00661                               << r;\par
00662   \}\par
00663 \par
00664   {\cf19 return} AssertionSuccess();\par
00665 \}\par
00666 \par
00667 {\cf20 // The constructor of SingleFailureChecker remembers where to look up}\par
00668 {\cf20 // test part results, what type of failure we expect, and what}\par
00669 {\cf20 // substring the failure message should contain.}\par
00670 SingleFailureChecker::SingleFailureChecker({\cf17 const} TestPartResultArray* results,\par
00671                                            TestPartResult::Type type,\par
00672                                            {\cf17 const} std::string& substr)\par
00673     : results_(results), type_(type), substr_(substr) \{\}\par
00674 \par
00675 {\cf20 // The destructor of SingleFailureChecker verifies that the given}\par
00676 {\cf20 // TestPartResultArray contains exactly one failure that has the given}\par
00677 {\cf20 // type and contains the given substring.  If that's not the case, a}\par
00678 {\cf20 // non-fatal failure will be generated.}\par
00679 SingleFailureChecker::~SingleFailureChecker() \{\par
00680   EXPECT_PRED_FORMAT3(HasOneFailure, *results_, type_, substr_);\par
00681 \}\par
00682 \par
00683 DefaultGlobalTestPartResultReporter::DefaultGlobalTestPartResultReporter(\par
00684     UnitTestImpl* unit_test) : unit_test_(unit_test) \{\}\par
00685 \par
00686 {\cf18 void} DefaultGlobalTestPartResultReporter::ReportTestPartResult(\par
00687     {\cf17 const} TestPartResult& result) \{\par
00688   unit_test_->current_test_result()->AddTestPartResult(result);\par
00689   unit_test_->listeners()->repeater()->OnTestPartResult(result);\par
00690 \}\par
00691 \par
00692 DefaultPerThreadTestPartResultReporter::DefaultPerThreadTestPartResultReporter(\par
00693     UnitTestImpl* unit_test) : unit_test_(unit_test) \{\}\par
00694 \par
00695 {\cf18 void} DefaultPerThreadTestPartResultReporter::ReportTestPartResult(\par
00696     {\cf17 const} TestPartResult& result) \{\par
00697   unit_test_->GetGlobalTestPartResultReporter()->ReportTestPartResult(result);\par
00698 \}\par
00699 \par
00700 {\cf20 // Returns the global test part result reporter.}\par
00701 TestPartResultReporterInterface*\par
00702 UnitTestImpl::GetGlobalTestPartResultReporter() \{\par
00703   internal::MutexLock lock(&global_test_part_result_reporter_mutex_);\par
00704   {\cf19 return} global_test_part_result_repoter_;\par
00705 \}\par
00706 \par
00707 {\cf20 // Sets the global test part result reporter.}\par
00708 {\cf18 void} UnitTestImpl::SetGlobalTestPartResultReporter(\par
00709     TestPartResultReporterInterface* reporter) \{\par
00710   internal::MutexLock lock(&global_test_part_result_reporter_mutex_);\par
00711   global_test_part_result_repoter_ = reporter;\par
00712 \}\par
00713 \par
00714 {\cf20 // Returns the test part result reporter for the current thread.}\par
00715 TestPartResultReporterInterface*\par
00716 UnitTestImpl::GetTestPartResultReporterForCurrentThread() \{\par
00717   {\cf19 return} per_thread_test_part_result_reporter_.get();\par
00718 \}\par
00719 \par
00720 {\cf20 // Sets the test part result reporter for the current thread.}\par
00721 {\cf18 void} UnitTestImpl::SetTestPartResultReporterForCurrentThread(\par
00722     TestPartResultReporterInterface* reporter) \{\par
00723   per_thread_test_part_result_reporter_.set(reporter);\par
00724 \}\par
00725 \par
00726 {\cf20 // Gets the number of successful test cases.}\par
00727 {\cf18 int} UnitTestImpl::successful_test_case_count(){\cf17  const }\{\par
00728   {\cf19 return} CountIf(test_cases_, TestCasePassed);\par
00729 \}\par
00730 \par
00731 {\cf20 // Gets the number of failed test cases.}\par
00732 {\cf18 int} UnitTestImpl::failed_test_case_count(){\cf17  const }\{\par
00733   {\cf19 return} CountIf(test_cases_, TestCaseFailed);\par
00734 \}\par
00735 \par
00736 {\cf20 // Gets the number of all test cases.}\par
00737 {\cf18 int} UnitTestImpl::total_test_case_count(){\cf17  const }\{\par
00738   {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(test_cases_.size());\par
00739 \}\par
00740 \par
00741 {\cf20 // Gets the number of all test cases that contain at least one test}\par
00742 {\cf20 // that should run.}\par
00743 {\cf18 int} UnitTestImpl::test_case_to_run_count(){\cf17  const }\{\par
00744   {\cf19 return} CountIf(test_cases_, ShouldRunTestCase);\par
00745 \}\par
00746 \par
00747 {\cf20 // Gets the number of successful tests.}\par
00748 {\cf18 int} UnitTestImpl::successful_test_count(){\cf17  const }\{\par
00749   {\cf19 return} SumOverTestCaseList(test_cases_, &TestCase::successful_test_count);\par
00750 \}\par
00751 \par
00752 {\cf20 // Gets the number of failed tests.}\par
00753 {\cf18 int} UnitTestImpl::failed_test_count(){\cf17  const }\{\par
00754   {\cf19 return} SumOverTestCaseList(test_cases_, &TestCase::failed_test_count);\par
00755 \}\par
00756 \par
00757 {\cf20 // Gets the number of disabled tests that will be reported in the XML report.}\par
00758 {\cf18 int} UnitTestImpl::reportable_disabled_test_count(){\cf17  const }\{\par
00759   {\cf19 return} SumOverTestCaseList(test_cases_,\par
00760                              &TestCase::reportable_disabled_test_count);\par
00761 \}\par
00762 \par
00763 {\cf20 // Gets the number of disabled tests.}\par
00764 {\cf18 int} UnitTestImpl::disabled_test_count(){\cf17  const }\{\par
00765   {\cf19 return} SumOverTestCaseList(test_cases_, &TestCase::disabled_test_count);\par
00766 \}\par
00767 \par
00768 {\cf20 // Gets the number of tests to be printed in the XML report.}\par
00769 {\cf18 int} UnitTestImpl::reportable_test_count(){\cf17  const }\{\par
00770   {\cf19 return} SumOverTestCaseList(test_cases_, &TestCase::reportable_test_count);\par
00771 \}\par
00772 \par
00773 {\cf20 // Gets the number of all tests.}\par
00774 {\cf18 int} UnitTestImpl::total_test_count(){\cf17  const }\{\par
00775   {\cf19 return} SumOverTestCaseList(test_cases_, &TestCase::total_test_count);\par
00776 \}\par
00777 \par
00778 {\cf20 // Gets the number of tests that should run.}\par
00779 {\cf18 int} UnitTestImpl::test_to_run_count(){\cf17  const }\{\par
00780   {\cf19 return} SumOverTestCaseList(test_cases_, &TestCase::test_to_run_count);\par
00781 \}\par
00782 \par
00783 {\cf20 // Returns the current OS stack trace as an std::string.}\par
00784 {\cf20 //}\par
00785 {\cf20 // The maximum number of stack frames to be included is specified by}\par
00786 {\cf20 // the gtest_stack_trace_depth flag.  The skip_count parameter}\par
00787 {\cf20 // specifies the number of top frames to be skipped, which doesn't}\par
00788 {\cf20 // count against the number of frames to be included.}\par
00789 {\cf20 //}\par
00790 {\cf20 // For example, if Foo() calls Bar(), which in turn calls}\par
00791 {\cf20 // CurrentOsStackTraceExceptTop(1), Foo() will be included in the}\par
00792 {\cf20 // trace but Bar() and CurrentOsStackTraceExceptTop() won't.}\par
00793 std::string UnitTestImpl::CurrentOsStackTraceExceptTop({\cf18 int} skip_count) \{\par
00794   {\cf19 return} os_stack_trace_getter()->CurrentStackTrace(\par
00795       {\cf17 static_cast<}{\cf18 int}{\cf17 >}(GTEST_FLAG(stack_trace_depth)),\par
00796       skip_count + 1\par
00797       {\cf20 // Skips the user-specified number of frames plus this function}\par
00798       {\cf20 // itself.}\par
00799       );  {\cf20 // NOLINT}\par
00800 \}\par
00801 \par
00802 {\cf20 // Returns the current time in milliseconds.}\par
00803 TimeInMillis GetTimeInMillis() \{\par
00804 {\cf21 #if GTEST_OS_WINDOWS_MOBILE || defined(__BORLANDC__)}\par
00805   {\cf20 // Difference between 1970-01-01 and 1601-01-01 in milliseconds.}\par
00806   {\cf20 // http://analogous.blogspot.com/2005/04/epoch.html}\par
00807   {\cf17 const} TimeInMillis kJavaEpochToWinFileTimeDelta =\par
00808     {\cf17 static_cast<}TimeInMillis{\cf17 >}(116444736UL) * 100000UL;\par
00809   {\cf17 const} DWORD kTenthMicrosInMilliSecond = 10000;\par
00810 \par
00811   SYSTEMTIME now_systime;\par
00812   FILETIME now_filetime;\par
00813   ULARGE_INTEGER now_int64;\par
00814   {\cf20 // TODO(kenton@google.com): Shouldn't this just use}\par
00815   {\cf20 //   GetSystemTimeAsFileTime()?}\par
00816   GetSystemTime(&now_systime);\par
00817   {\cf19 if} (SystemTimeToFileTime(&now_systime, &now_filetime)) \{\par
00818     now_int64.LowPart = now_filetime.dwLowDateTime;\par
00819     now_int64.HighPart = now_filetime.dwHighDateTime;\par
00820     now_int64.QuadPart = (now_int64.QuadPart / kTenthMicrosInMilliSecond) -\par
00821       kJavaEpochToWinFileTimeDelta;\par
00822     {\cf19 return} now_int64.QuadPart;\par
00823   \}\par
00824   {\cf19 return} 0;\par
00825 {\cf21 #elif GTEST_OS_WINDOWS && !GTEST_HAS_GETTIMEOFDAY_}\par
00826   __timeb64 now;\par
00827 \par
00828   {\cf20 // MSVC 8 deprecates _ftime64(), so we want to suppress warning 4996}\par
00829   {\cf20 // (deprecated function) there.}\par
00830   {\cf20 // TODO(kenton@google.com): Use GetTickCount()?  Or use}\par
00831   {\cf20 //   SystemTimeToFileTime()}\par
00832   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4996)\par
00833   _ftime64(&now);\par
00834   GTEST_DISABLE_MSC_WARNINGS_POP_()\par
00835 \par
00836   {\cf19 return} {\cf17 static_cast<}TimeInMillis{\cf17 >}(now.time) * 1000 + now.millitm;\par
00837 #elif GTEST_HAS_GETTIMEOFDAY_\par
00838   {\cf17 struct} timeval now;\par
00839   gettimeofday(&now, NULL);\par
00840   {\cf19 return} {\cf17 static_cast<}TimeInMillis{\cf17 >}(now.tv_sec) * 1000 + now.tv_usec / 1000;\par
00841 #{\cf19 else}\par
00842 # error {\cf22 "Don't know how to get the current time on your system."}\par
00843 #endif\par
00844 \}\par
00845 \par
00846 {\cf20 // Utilities}\par
00847 \par
00848 {\cf20 // class String.}\par
00849 \par
00850 {\cf21 #if GTEST_OS_WINDOWS_MOBILE}\par
00851 {\cf20 // Creates a UTF-16 wide string from the given ANSI string, allocating}\par
00852 {\cf20 // memory using new. The caller is responsible for deleting the return}\par
00853 {\cf20 // value using delete[]. Returns the wide string, or NULL if the}\par
00854 {\cf20 // input is NULL.}\par
00855 LPCWSTR String::AnsiToUtf16({\cf17 const} {\cf18 char}* ansi) \{\par
00856   {\cf19 if} (!ansi) {\cf19 return} NULL;\par
00857   {\cf17 const} {\cf18 int} length = strlen(ansi);\par
00858   {\cf17 const} {\cf18 int} unicode_length =\par
00859       MultiByteToWideChar(CP_ACP, 0, ansi, length,\par
00860                           NULL, 0);\par
00861   WCHAR* unicode = {\cf17 new} WCHAR[unicode_length + 1];\par
00862   MultiByteToWideChar(CP_ACP, 0, ansi, length,\par
00863                       unicode, unicode_length);\par
00864   unicode[unicode_length] = 0;\par
00865   {\cf19 return} unicode;\par
00866 \}\par
00867 \par
00868 {\cf20 // Creates an ANSI string from the given wide string, allocating}\par
00869 {\cf20 // memory using new. The caller is responsible for deleting the return}\par
00870 {\cf20 // value using delete[]. Returns the ANSI string, or NULL if the}\par
00871 {\cf20 // input is NULL.}\par
00872 {\cf17 const} {\cf18 char}* String::Utf16ToAnsi(LPCWSTR utf16_str)  \{\par
00873   {\cf19 if} (!utf16_str) {\cf19 return} NULL;\par
00874   {\cf17 const} {\cf18 int} ansi_length =\par
00875       WideCharToMultiByte(CP_ACP, 0, utf16_str, -1,\par
00876                           NULL, 0, NULL, NULL);\par
00877   {\cf18 char}* ansi = {\cf17 new} {\cf18 char}[ansi_length + 1];\par
00878   WideCharToMultiByte(CP_ACP, 0, utf16_str, -1,\par
00879                       ansi, ansi_length, NULL, NULL);\par
00880   ansi[ansi_length] = 0;\par
00881   {\cf19 return} ansi;\par
00882 \}\par
00883 \par
00884 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
00885 \par
00886 {\cf20 // Compares two C strings.  Returns true iff they have the same content.}\par
00887 {\cf20 //}\par
00888 {\cf20 // Unlike strcmp(), this function can handle NULL argument(s).  A NULL}\par
00889 {\cf20 // C string is considered different to any non-NULL C string,}\par
00890 {\cf20 // including the empty string.}\par
00891 {\cf18 bool} String::CStringEquals({\cf17 const} {\cf18 char} * lhs, {\cf17 const} {\cf18 char} * rhs) \{\par
00892   {\cf19 if} ( lhs == NULL ) {\cf19 return} rhs == NULL;\par
00893 \par
00894   {\cf19 if} ( rhs == NULL ) {\cf19 return} {\cf17 false};\par
00895 \par
00896   {\cf19 return} strcmp(lhs, rhs) == 0;\par
00897 \}\par
00898 \par
00899 {\cf21 #if GTEST_HAS_STD_WSTRING || GTEST_HAS_GLOBAL_WSTRING}\par
00900 \par
00901 {\cf20 // Converts an array of wide chars to a narrow string using the UTF-8}\par
00902 {\cf20 // encoding, and streams the result to the given Message object.}\par
00903 {\cf17 static} {\cf18 void} StreamWideCharsToMessage({\cf17 const} {\cf18 wchar_t}* wstr, {\cf18 size_t} length,\par
00904                                      Message* msg) \{\par
00905   {\cf19 for} ({\cf18 size_t} i = 0; i != length; ) \{  {\cf20 // NOLINT}\par
00906     {\cf19 if} (wstr[i] != L{\cf23 '\\0'}) \{\par
00907       *msg << WideStringToUtf8(wstr + i, static_cast<int>(length - i));\par
00908       {\cf19 while} (i != length && wstr[i] != L{\cf23 '\\0'})\par
00909         i++;\par
00910     \} {\cf19 else} \{\par
00911       *msg << {\cf23 '\\0'};\par
00912       i++;\par
00913     \}\par
00914   \}\par
00915 \}\par
00916 \par
00917 {\cf21 #endif  }{\cf20 // GTEST_HAS_STD_WSTRING || GTEST_HAS_GLOBAL_WSTRING}\par
00918 \par
00919 {\cf18 void} SplitString(const ::std::string& str, {\cf18 char} delimiter,\par
00920                  ::std::vector< ::std::string>* dest) \{\par
00921   ::std::vector< ::std::string> parsed;\par
00922   ::std::string::size_type pos = 0;\par
00923   {\cf19 while} (::testing::internal::AlwaysTrue()) \{\par
00924     const ::std::string::size_type colon = str.find(delimiter, pos);\par
00925     {\cf19 if} (colon == ::std::string::npos) \{\par
00926       parsed.push_back(str.substr(pos));\par
00927       {\cf19 break};\par
00928     \} {\cf19 else} \{\par
00929       parsed.push_back(str.substr(pos, colon - pos));\par
00930       pos = colon + 1;\par
00931     \}\par
00932   \}\par
00933   dest->swap(parsed);\par
00934 \}\par
00935 \par
00936 \}  {\cf20 // namespace internal}\par
00937 \par
00938 {\cf20 // Constructs an empty Message.}\par
00939 {\cf20 // We allocate the stringstream separately because otherwise each use of}\par
00940 {\cf20 // ASSERT/EXPECT in a procedure adds over 200 bytes to the procedure's}\par
00941 {\cf20 // stack frame leading to huge stack frames in some cases; gcc does not reuse}\par
00942 {\cf20 // the stack space.}\par
00943 Message::Message() : ss_(new ::std::stringstream) \{\par
00944   {\cf20 // By default, we want there to be enough precision when printing}\par
00945   {\cf20 // a double to a Message.}\par
00946   *ss_ << std::setprecision(std::numeric_limits<double>::digits10 + 2);\par
00947 \}\par
00948 \par
00949 {\cf20 // These two overloads allow streaming a wide C string to a Message}\par
00950 {\cf20 // using the UTF-8 encoding.}\par
00951 Message& Message::operator <<({\cf17 const} {\cf18 wchar_t}* wide_c_str) \{\par
00952   {\cf19 return} *{\cf17 this} << internal::String::ShowWideCString(wide_c_str);\par
00953 \}\par
00954 Message& Message::operator <<({\cf18 wchar_t}* wide_c_str) \{\par
00955   {\cf19 return} *{\cf17 this} << internal::String::ShowWideCString(wide_c_str);\par
00956 \}\par
00957 \par
00958 {\cf21 #if GTEST_HAS_STD_WSTRING}\par
00959 {\cf20 // Converts the given wide string to a narrow string using the UTF-8}\par
00960 {\cf20 // encoding, and streams the result to this Message object.}\par
00961 Message& Message::operator <<(const ::std::wstring& wstr) \{\par
00962   internal::StreamWideCharsToMessage(wstr.c_str(), wstr.length(), {\cf17 this});\par
00963   {\cf19 return} *{\cf17 this};\par
00964 \}\par
00965 {\cf21 #endif  }{\cf20 // GTEST_HAS_STD_WSTRING}\par
00966 \par
00967 {\cf21 #if GTEST_HAS_GLOBAL_WSTRING}\par
00968 {\cf20 // Converts the given wide string to a narrow string using the UTF-8}\par
00969 {\cf20 // encoding, and streams the result to this Message object.}\par
00970 Message& Message::operator <<(const ::wstring& wstr) \{\par
00971   internal::StreamWideCharsToMessage(wstr.c_str(), wstr.length(), {\cf17 this});\par
00972   {\cf19 return} *{\cf17 this};\par
00973 \}\par
00974 {\cf21 #endif  }{\cf20 // GTEST_HAS_GLOBAL_WSTRING}\par
00975 \par
00976 {\cf20 // Gets the text streamed to this object so far as an std::string.}\par
00977 {\cf20 // Each '\\0' character in the buffer is replaced with "\\\\0".}\par
00978 std::string Message::GetString(){\cf17  const }\{\par
00979   {\cf19 return} internal::StringStreamToString(ss_.get());\par
00980 \}\par
00981 \par
00982 {\cf20 // AssertionResult constructors.}\par
00983 {\cf20 // Used in EXPECT_TRUE/FALSE(assertion_result).}\par
00984 AssertionResult::AssertionResult({\cf17 const} AssertionResult& other)\par
00985     : success_(other.success_),\par
00986       message_(other.message_.get() != NULL ?\par
00987                new ::std::string(*other.message_) :\par
00988                static_cast< ::std::string*>(NULL)) \{\par
00989 \}\par
00990 \par
00991 {\cf20 // Swaps two AssertionResults.}\par
00992 {\cf18 void} AssertionResult::swap(AssertionResult& other) \{\par
00993   {\cf17 using} std::swap;\par
00994   swap(success_, other.success_);\par
00995   swap(message_, other.message_);\par
00996 \}\par
00997 \par
00998 {\cf20 // Returns the assertion's negation. Used with EXPECT/ASSERT_FALSE.}\par
00999 AssertionResult AssertionResult::operator!(){\cf17  const }\{\par
01000   AssertionResult negation(!success_);\par
01001   {\cf19 if} (message_.get() != NULL)\par
01002     negation << *message_;\par
01003   {\cf19 return} negation;\par
01004 \}\par
01005 \par
01006 {\cf20 // Makes a successful assertion result.}\par
01007 AssertionResult AssertionSuccess() \{\par
01008   {\cf19 return} AssertionResult({\cf17 true});\par
01009 \}\par
01010 \par
01011 {\cf20 // Makes a failed assertion result.}\par
01012 AssertionResult AssertionFailure() \{\par
01013   {\cf19 return} AssertionResult({\cf17 false});\par
01014 \}\par
01015 \par
01016 {\cf20 // Makes a failed assertion result with the given failure message.}\par
01017 {\cf20 // Deprecated; use AssertionFailure() << message.}\par
01018 AssertionResult AssertionFailure({\cf17 const} Message& message) \{\par
01019   {\cf19 return} AssertionFailure() << message;\par
01020 \}\par
01021 \par
01022 {\cf17 namespace }internal \{\par
01023 \par
01024 {\cf17 namespace }edit_distance \{\par
01025 std::vector<EditType> CalculateOptimalEdits({\cf17 const} std::vector<size_t>& left,\par
01026                                             {\cf17 const} std::vector<size_t>& right) \{\par
01027   std::vector<std::vector<double> > costs(\par
01028       left.size() + 1, std::vector<double>(right.size() + 1));\par
01029   std::vector<std::vector<EditType> > best_move(\par
01030       left.size() + 1, std::vector<EditType>(right.size() + 1));\par
01031 \par
01032   {\cf20 // Populate for empty right.}\par
01033   {\cf19 for} ({\cf18 size_t} l_i = 0; l_i < costs.size(); ++l_i) \{\par
01034     costs[l_i][0] = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(l_i);\par
01035     best_move[l_i][0] = kRemove;\par
01036   \}\par
01037   {\cf20 // Populate for empty left.}\par
01038   {\cf19 for} ({\cf18 size_t} r_i = 1; r_i < costs[0].size(); ++r_i) \{\par
01039     costs[0][r_i] = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(r_i);\par
01040     best_move[0][r_i] = kAdd;\par
01041   \}\par
01042 \par
01043   {\cf19 for} ({\cf18 size_t} l_i = 0; l_i < left.size(); ++l_i) \{\par
01044     {\cf19 for} ({\cf18 size_t} r_i = 0; r_i < right.size(); ++r_i) \{\par
01045       {\cf19 if} (left[l_i] == right[r_i]) \{\par
01046         {\cf20 // Found a match. Consume it.}\par
01047         costs[l_i + 1][r_i + 1] = costs[l_i][r_i];\par
01048         best_move[l_i + 1][r_i + 1] = kMatch;\par
01049         {\cf19 continue};\par
01050       \}\par
01051 \par
01052       {\cf17 const} {\cf18 double} add = costs[l_i + 1][r_i];\par
01053       {\cf17 const} {\cf18 double} remove = costs[l_i][r_i + 1];\par
01054       {\cf17 const} {\cf18 double} replace = costs[l_i][r_i];\par
01055       {\cf19 if} (add < remove && add < replace) \{\par
01056         costs[l_i + 1][r_i + 1] = add + 1;\par
01057         best_move[l_i + 1][r_i + 1] = kAdd;\par
01058       \} {\cf19 else} {\cf19 if} (remove < add && remove < replace) \{\par
01059         costs[l_i + 1][r_i + 1] = remove + 1;\par
01060         best_move[l_i + 1][r_i + 1] = kRemove;\par
01061       \} {\cf19 else} \{\par
01062         {\cf20 // We make replace a little more expensive than add/remove to lower}\par
01063         {\cf20 // their priority.}\par
01064         costs[l_i + 1][r_i + 1] = replace + 1.00001;\par
01065         best_move[l_i + 1][r_i + 1] = kReplace;\par
01066       \}\par
01067     \}\par
01068   \}\par
01069 \par
01070   {\cf20 // Reconstruct the best path. We do it in reverse order.}\par
01071   std::vector<EditType> best_path;\par
01072   {\cf19 for} ({\cf18 size_t} l_i = left.size(), r_i = right.size(); l_i > 0 || r_i > 0;) \{\par
01073     EditType move = best_move[l_i][r_i];\par
01074     best_path.push_back(move);\par
01075     l_i -= move != kAdd;\par
01076     r_i -= move != kRemove;\par
01077   \}\par
01078   std::reverse(best_path.begin(), best_path.end());\par
01079   {\cf19 return} best_path;\par
01080 \}\par
01081 \par
01082 {\cf17 namespace }\{\par
01083 \par
01084 {\cf20 // Helper class to convert string into ids with deduplication.}\par
01085 {\cf17 class }InternalStrings \{\par
01086  {\cf17 public}:\par
01087   {\cf18 size_t} GetId({\cf17 const} std::string& str) \{\par
01088     IdMap::iterator it = ids_.find(str);\par
01089     {\cf19 if} (it != ids_.end()) {\cf19 return} it->second;\par
01090     {\cf18 size_t} {\cf18 id} = ids_.size();\par
01091     {\cf19 return} ids_[str] = id;\par
01092   \}\par
01093 \par
01094  {\cf17 private}:\par
01095   {\cf17 typedef} std::map<std::string, size_t> IdMap;\par
01096   IdMap ids_;\par
01097 \};\par
01098 \par
01099 \}  {\cf20 // namespace}\par
01100 \par
01101 std::vector<EditType> CalculateOptimalEdits(\par
01102     {\cf17 const} std::vector<std::string>& left,\par
01103     {\cf17 const} std::vector<std::string>& right) \{\par
01104   std::vector<size_t> left_ids, right_ids;\par
01105   \{\par
01106     InternalStrings intern_table;\par
01107     {\cf19 for} ({\cf18 size_t} i = 0; i < left.size(); ++i) \{\par
01108       left_ids.push_back(intern_table.GetId(left[i]));\par
01109     \}\par
01110     {\cf19 for} ({\cf18 size_t} i = 0; i < right.size(); ++i) \{\par
01111       right_ids.push_back(intern_table.GetId(right[i]));\par
01112     \}\par
01113   \}\par
01114   {\cf19 return} CalculateOptimalEdits(left_ids, right_ids);\par
01115 \}\par
01116 \par
01117 {\cf17 namespace }\{\par
01118 \par
01119 {\cf20 // Helper class that holds the state for one hunk and prints it out to the}\par
01120 {\cf20 // stream.}\par
01121 {\cf20 // It reorders adds/removes when possible to group all removes before all}\par
01122 {\cf20 // adds. It also adds the hunk header before printint into the stream.}\par
01123 {\cf17 class }Hunk \{\par
01124  {\cf17 public}:\par
01125   Hunk({\cf18 size_t} left_start, {\cf18 size_t} right_start)\par
01126       : left_start_(left_start),\par
01127         right_start_(right_start),\par
01128         adds_(),\par
01129         removes_(),\par
01130         common_() \{\}\par
01131 \par
01132   {\cf18 void} PushLine({\cf18 char} edit, {\cf17 const} {\cf18 char}* line) \{\par
01133     {\cf19 switch} (edit) \{\par
01134       {\cf19 case} {\cf23 ' '}:\par
01135         ++common_;\par
01136         FlushEdits();\par
01137         hunk_.push_back(std::make_pair({\cf23 ' '}, line));\par
01138         {\cf19 break};\par
01139       {\cf19 case} {\cf23 '-'}:\par
01140         ++removes_;\par
01141         hunk_removes_.push_back(std::make_pair({\cf23 '-'}, line));\par
01142         {\cf19 break};\par
01143       {\cf19 case} {\cf23 '+'}:\par
01144         ++adds_;\par
01145         hunk_adds_.push_back(std::make_pair({\cf23 '+'}, line));\par
01146         {\cf19 break};\par
01147     \}\par
01148   \}\par
01149 \par
01150   {\cf18 void} PrintTo(std::ostream* os) \{\par
01151     PrintHeader(os);\par
01152     FlushEdits();\par
01153     {\cf19 for} (std::list<std::pair<char, const char*> >::const_iterator it =\par
01154              hunk_.begin();\par
01155          it != hunk_.end(); ++it) \{\par
01156       *os << it->first << it->second << {\cf22 "\\n"};\par
01157     \}\par
01158   \}\par
01159 \par
01160   {\cf18 bool} has_edits(){\cf17  const }\{ {\cf19 return} adds_ || removes_; \}\par
01161 \par
01162  {\cf17 private}:\par
01163   {\cf18 void} FlushEdits() \{\par
01164     hunk_.splice(hunk_.end(), hunk_removes_);\par
01165     hunk_.splice(hunk_.end(), hunk_adds_);\par
01166   \}\par
01167 \par
01168   {\cf20 // Print a unified diff header for one hunk.}\par
01169   {\cf20 // The format is}\par
01170   {\cf20 //   "@@ -<left_start>,<left_length> +<right_start>,<right_length> @@"}\par
01171   {\cf20 // where the left/right parts are ommitted if unnecessary.}\par
01172   {\cf18 void} PrintHeader(std::ostream* ss){\cf17  const }\{\par
01173     *ss << {\cf22 "@@ "};\par
01174     {\cf19 if} (removes_) \{\par
01175       *ss << {\cf22 "-"} << left_start_ << {\cf22 ","} << (removes_ + common_);\par
01176     \}\par
01177     {\cf19 if} (removes_ && adds_) \{\par
01178       *ss << {\cf22 " "};\par
01179     \}\par
01180     {\cf19 if} (adds_) \{\par
01181       *ss << {\cf22 "+"} << right_start_ << {\cf22 ","} << (adds_ + common_);\par
01182     \}\par
01183     *ss << {\cf22 " @@\\n"};\par
01184   \}\par
01185 \par
01186   {\cf18 size_t} left_start_, right_start_;\par
01187   {\cf18 size_t} adds_, removes_, common_;\par
01188   std::list<std::pair<char, const char*> > hunk_, hunk_adds_, hunk_removes_;\par
01189 \};\par
01190 \par
01191 \}  {\cf20 // namespace}\par
01192 \par
01193 {\cf20 // Create a list of diff hunks in Unified diff format.}\par
01194 {\cf20 // Each hunk has a header generated by PrintHeader above plus a body with}\par
01195 {\cf20 // lines prefixed with ' ' for no change, '-' for deletion and '+' for}\par
01196 {\cf20 // addition.}\par
01197 {\cf20 // 'context' represents the desired unchanged prefix/suffix around the diff.}\par
01198 {\cf20 // If two hunks are close enough that their contexts overlap, then they are}\par
01199 {\cf20 // joined into one hunk.}\par
01200 std::string CreateUnifiedDiff({\cf17 const} std::vector<std::string>& left,\par
01201                               {\cf17 const} std::vector<std::string>& right,\par
01202                               {\cf18 size_t} context) \{\par
01203   {\cf17 const} std::vector<EditType> edits = CalculateOptimalEdits(left, right);\par
01204 \par
01205   {\cf18 size_t} l_i = 0, r_i = 0, edit_i = 0;\par
01206   std::stringstream ss;\par
01207   {\cf19 while} (edit_i < edits.size()) \{\par
01208     {\cf20 // Find first edit.}\par
01209     {\cf19 while} (edit_i < edits.size() && edits[edit_i] == kMatch) \{\par
01210       ++l_i;\par
01211       ++r_i;\par
01212       ++edit_i;\par
01213     \}\par
01214 \par
01215     {\cf20 // Find the first line to include in the hunk.}\par
01216     {\cf17 const} {\cf18 size_t} prefix_context = std::min(l_i, context);\par
01217     Hunk hunk(l_i - prefix_context + 1, r_i - prefix_context + 1);\par
01218     {\cf19 for} ({\cf18 size_t} i = prefix_context; i > 0; --i) \{\par
01219       hunk.PushLine({\cf23 ' '}, left[l_i - i].c_str());\par
01220     \}\par
01221 \par
01222     {\cf20 // Iterate the edits until we found enough suffix for the hunk or the input}\par
01223     {\cf20 // is over.}\par
01224     {\cf18 size_t} n_suffix = 0;\par
01225     {\cf19 for} (; edit_i < edits.size(); ++edit_i) \{\par
01226       {\cf19 if} (n_suffix >= context) \{\par
01227         {\cf20 // Continue only if the next hunk is very close.}\par
01228         std::vector<EditType>::const_iterator it = edits.begin() + edit_i;\par
01229         {\cf19 while} (it != edits.end() && *it == kMatch) ++it;\par
01230         {\cf19 if} (it == edits.end() || (it - edits.begin()) - edit_i >= context) \{\par
01231           {\cf20 // There is no next edit or it is too far away.}\par
01232           {\cf19 break};\par
01233         \}\par
01234       \}\par
01235 \par
01236       EditType edit = edits[edit_i];\par
01237       {\cf20 // Reset count when a non match is found.}\par
01238       n_suffix = edit == kMatch ? n_suffix + 1 : 0;\par
01239 \par
01240       {\cf19 if} (edit == kMatch || edit == kRemove || edit == kReplace) \{\par
01241         hunk.PushLine(edit == kMatch ? {\cf23 ' '} : {\cf23 '-'}, left[l_i].c_str());\par
01242       \}\par
01243       {\cf19 if} (edit == kAdd || edit == kReplace) \{\par
01244         hunk.PushLine({\cf23 '+'}, right[r_i].c_str());\par
01245       \}\par
01246 \par
01247       {\cf20 // Advance indices, depending on edit type.}\par
01248       l_i += edit != kAdd;\par
01249       r_i += edit != kRemove;\par
01250     \}\par
01251 \par
01252     {\cf19 if} (!hunk.has_edits()) \{\par
01253       {\cf20 // We are done. We don't want this hunk.}\par
01254       {\cf19 break};\par
01255     \}\par
01256 \par
01257     hunk.PrintTo(&ss);\par
01258   \}\par
01259   {\cf19 return} ss.str();\par
01260 \}\par
01261 \par
01262 \}  {\cf20 // namespace edit_distance}\par
01263 \par
01264 {\cf17 namespace }\{\par
01265 \par
01266 {\cf20 // The string representation of the values received in EqFailure() are already}\par
01267 {\cf20 // escaped. Split them on escaped '\\n' boundaries. Leave all other escaped}\par
01268 {\cf20 // characters the same.}\par
01269 std::vector<std::string> SplitEscapedString({\cf17 const} std::string& str) \{\par
01270   std::vector<std::string> lines;\par
01271   {\cf18 size_t} start = 0, end = str.size();\par
01272   {\cf19 if} (end > 2 && str[0] == {\cf23 '"'} && str[end - 1] == {\cf23 '"'}) \{\par
01273     ++start;\par
01274     --end;\par
01275   \}\par
01276   {\cf18 bool} escaped = {\cf17 false};\par
01277   {\cf19 for} ({\cf18 size_t} i = start; i + 1 < end; ++i) \{\par
01278     {\cf19 if} (escaped) \{\par
01279       escaped = {\cf17 false};\par
01280       {\cf19 if} (str[i] == {\cf23 'n'}) \{\par
01281         lines.push_back(str.substr(start, i - start - 1));\par
01282         start = i + 1;\par
01283       \}\par
01284     \} {\cf19 else} \{\par
01285       escaped = str[i] == {\cf23 '\\\\'};\par
01286     \}\par
01287   \}\par
01288   lines.push_back(str.substr(start, end - start));\par
01289   {\cf19 return} lines;\par
01290 \}\par
01291 \par
01292 \}  {\cf20 // namespace}\par
01293 \par
01294 {\cf20 // Constructs and returns the message for an equality assertion}\par
01295 {\cf20 // (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.}\par
01296 {\cf20 //}\par
01297 {\cf20 // The first four parameters are the expressions used in the assertion}\par
01298 {\cf20 // and their values, as strings.  For example, for ASSERT_EQ(foo, bar)}\par
01299 {\cf20 // where foo is 5 and bar is 6, we have:}\par
01300 {\cf20 //}\par
01301 {\cf20 //   lhs_expression: "foo"}\par
01302 {\cf20 //   rhs_expression: "bar"}\par
01303 {\cf20 //   lhs_value:      "5"}\par
01304 {\cf20 //   rhs_value:      "6"}\par
01305 {\cf20 //}\par
01306 {\cf20 // The ignoring_case parameter is true iff the assertion is a}\par
01307 {\cf20 // *_STRCASEEQ*.  When it's true, the string "Ignoring case" will}\par
01308 {\cf20 // be inserted into the message.}\par
01309 AssertionResult EqFailure({\cf17 const} {\cf18 char}* lhs_expression,\par
01310                           {\cf17 const} {\cf18 char}* rhs_expression,\par
01311                           {\cf17 const} std::string& lhs_value,\par
01312                           {\cf17 const} std::string& rhs_value,\par
01313                           {\cf18 bool} ignoring_case) \{\par
01314   Message msg;\par
01315   msg << {\cf22 "      Expected: "} << lhs_expression;\par
01316   {\cf19 if} (lhs_value != lhs_expression) \{\par
01317     msg << {\cf22 "\\n      Which is: "} << lhs_value;\par
01318   \}\par
01319   msg << {\cf22 "\\nTo be equal to: "} << rhs_expression;\par
01320   {\cf19 if} (rhs_value != rhs_expression) \{\par
01321     msg << {\cf22 "\\n      Which is: "} << rhs_value;\par
01322   \}\par
01323 \par
01324   {\cf19 if} (ignoring_case) \{\par
01325     msg << {\cf22 "\\nIgnoring case"};\par
01326   \}\par
01327 \par
01328   {\cf19 if} (!lhs_value.empty() && !rhs_value.empty()) \{\par
01329     {\cf17 const} std::vector<std::string> lhs_lines =\par
01330         SplitEscapedString(lhs_value);\par
01331     {\cf17 const} std::vector<std::string> rhs_lines =\par
01332         SplitEscapedString(rhs_value);\par
01333     {\cf19 if} (lhs_lines.size() > 1 || rhs_lines.size() > 1) \{\par
01334       msg << {\cf22 "\\nWith diff:\\n"}\par
01335           << edit_distance::CreateUnifiedDiff(lhs_lines, rhs_lines);\par
01336     \}\par
01337   \}\par
01338 \par
01339   {\cf19 return} AssertionFailure() << msg;\par
01340 \}\par
01341 \par
01342 {\cf20 // Constructs a failure message for Boolean assertions such as EXPECT_TRUE.}\par
01343 std::string GetBoolAssertionFailureMessage(\par
01344     {\cf17 const} AssertionResult& assertion_result,\par
01345     {\cf17 const} {\cf18 char}* expression_text,\par
01346     {\cf17 const} {\cf18 char}* actual_predicate_value,\par
01347     {\cf17 const} {\cf18 char}* expected_predicate_value) \{\par
01348   {\cf17 const} {\cf18 char}* actual_message = assertion_result.message();\par
01349   Message msg;\par
01350   msg << {\cf22 "Value of: "} << expression_text\par
01351       << {\cf22 "\\n  Actual: "} << actual_predicate_value;\par
01352   {\cf19 if} (actual_message[0] != {\cf23 '\\0'})\par
01353     msg << {\cf22 " ("} << actual_message << {\cf22 ")"};\par
01354   msg << {\cf22 "\\nExpected: "} << expected_predicate_value;\par
01355   {\cf19 return} msg.GetString();\par
01356 \}\par
01357 \par
01358 {\cf20 // Helper function for implementing ASSERT_NEAR.}\par
01359 AssertionResult DoubleNearPredFormat({\cf17 const} {\cf18 char}* expr1,\par
01360                                      {\cf17 const} {\cf18 char}* expr2,\par
01361                                      {\cf17 const} {\cf18 char}* abs_error_expr,\par
01362                                      {\cf18 double} val1,\par
01363                                      {\cf18 double} val2,\par
01364                                      {\cf18 double} abs_error) \{\par
01365   {\cf17 const} {\cf18 double} diff = fabs(val1 - val2);\par
01366   {\cf19 if} (diff <= abs_error) {\cf19 return} AssertionSuccess();\par
01367 \par
01368   {\cf20 // TODO(wan): do not print the value of an expression if it's}\par
01369   {\cf20 // already a literal.}\par
01370   {\cf19 return} AssertionFailure()\par
01371       << {\cf22 "The difference between "} << expr1 << {\cf22 " and "} << expr2\par
01372       << {\cf22 " is "} << diff << {\cf22 ", which exceeds "} << abs_error_expr << {\cf22 ", where\\n"}\par
01373       << expr1 << {\cf22 " evaluates to "} << val1 << {\cf22 ",\\n"}\par
01374       << expr2 << {\cf22 " evaluates to "} << val2 << {\cf22 ", and\\n"}\par
01375       << abs_error_expr << {\cf22 " evaluates to "} << abs_error << {\cf22 "."};\par
01376 \}\par
01377 \par
01378 \par
01379 {\cf20 // Helper template for implementing FloatLE() and DoubleLE().}\par
01380 {\cf17 template} <{\cf17 typename} RawType>\par
01381 AssertionResult FloatingPointLE({\cf17 const} {\cf18 char}* expr1,\par
01382                                 {\cf17 const} {\cf18 char}* expr2,\par
01383                                 RawType val1,\par
01384                                 RawType val2) \{\par
01385   {\cf20 // Returns success if val1 is less than val2,}\par
01386   {\cf19 if} (val1 < val2) \{\par
01387     {\cf19 return} AssertionSuccess();\par
01388   \}\par
01389 \par
01390   {\cf20 // or if val1 is almost equal to val2.}\par
01391   {\cf17 const} FloatingPoint<RawType> lhs(val1), rhs(val2);\par
01392   {\cf19 if} (lhs.AlmostEquals(rhs)) \{\par
01393     {\cf19 return} AssertionSuccess();\par
01394   \}\par
01395 \par
01396   {\cf20 // Note that the above two checks will both fail if either val1 or}\par
01397   {\cf20 // val2 is NaN, as the IEEE floating-point standard requires that}\par
01398   {\cf20 // any predicate involving a NaN must return false.}\par
01399 \par
01400   ::std::stringstream val1_ss;\par
01401   val1_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\par
01402           << val1;\par
01403 \par
01404   ::std::stringstream val2_ss;\par
01405   val2_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\par
01406           << val2;\par
01407 \par
01408   {\cf19 return} AssertionFailure()\par
01409       << {\cf22 "Expected: ("} << expr1 << {\cf22 ") <= ("} << expr2 << {\cf22 ")\\n"}\par
01410       << {\cf22 "  Actual: "} << StringStreamToString(&val1_ss) << {\cf22 " vs "}\par
01411       << StringStreamToString(&val2_ss);\par
01412 \}\par
01413 \par
01414 \}  {\cf20 // namespace internal}\par
01415 \par
01416 {\cf20 // Asserts that val1 is less than, or almost equal to, val2.  Fails}\par
01417 {\cf20 // otherwise.  In particular, it fails if either val1 or val2 is NaN.}\par
01418 AssertionResult FloatLE({\cf17 const} {\cf18 char}* expr1, {\cf17 const} {\cf18 char}* expr2,\par
01419                         {\cf18 float} val1, {\cf18 float} val2) \{\par
01420   {\cf19 return} internal::FloatingPointLE<float>(expr1, expr2, val1, val2);\par
01421 \}\par
01422 \par
01423 {\cf20 // Asserts that val1 is less than, or almost equal to, val2.  Fails}\par
01424 {\cf20 // otherwise.  In particular, it fails if either val1 or val2 is NaN.}\par
01425 AssertionResult DoubleLE({\cf17 const} {\cf18 char}* expr1, {\cf17 const} {\cf18 char}* expr2,\par
01426                          {\cf18 double} val1, {\cf18 double} val2) \{\par
01427   {\cf19 return} internal::FloatingPointLE<double>(expr1, expr2, val1, val2);\par
01428 \}\par
01429 \par
01430 {\cf17 namespace }internal \{\par
01431 \par
01432 {\cf20 // The helper function for \{ASSERT|EXPECT\}_EQ with int or enum}\par
01433 {\cf20 // arguments.}\par
01434 AssertionResult CmpHelperEQ({\cf17 const} {\cf18 char}* lhs_expression,\par
01435                             {\cf17 const} {\cf18 char}* rhs_expression,\par
01436                             BiggestInt lhs,\par
01437                             BiggestInt rhs) \{\par
01438   {\cf19 if} (lhs == rhs) \{\par
01439     {\cf19 return} AssertionSuccess();\par
01440   \}\par
01441 \par
01442   {\cf19 return} EqFailure(lhs_expression,\par
01443                    rhs_expression,\par
01444                    FormatForComparisonFailureMessage(lhs, rhs),\par
01445                    FormatForComparisonFailureMessage(rhs, lhs),\par
01446                    {\cf17 false});\par
01447 \}\par
01448 \par
01449 {\cf20 // A macro for implementing the helper functions needed to implement}\par
01450 {\cf20 // ASSERT_?? and EXPECT_?? with integer or enum arguments.  It is here}\par
01451 {\cf20 // just to avoid copy-and-paste of similar code.}\par
01452 {\cf21 #define GTEST_IMPL_CMP_HELPER_(op_name, op)\\}\par
01453 {\cf21 AssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \\}\par
01454 {\cf21                                    BiggestInt val1, BiggestInt val2) \{\\}\par
01455 {\cf21   if (val1 op val2) \{\\}\par
01456 {\cf21     return AssertionSuccess();\\}\par
01457 {\cf21   \} else \{\\}\par
01458 {\cf21     return AssertionFailure() \\}\par
01459 {\cf21         << "Expected: ("} << expr1 << ") " #op " (" << expr2\\\par
01460         << "), actual: " << FormatForComparisonFailureMessage(val1, val2)\\\par
01461         << " vs " << FormatForComparisonFailureMessage(val2, val1);\\\par
01462   \}\\\par
01463 \}\par
01464 \par
01465 {\cf20 // Implements the helper function for \{ASSERT|EXPECT\}_NE with int or}\par
01466 {\cf20 // enum arguments.}\par
01467 GTEST_IMPL_CMP_HELPER_(NE, !=)\par
01468 {\cf20 // Implements the helper function for \{ASSERT|EXPECT\}_LE with int or}\par
01469 {\cf20 // enum arguments.}\par
01470 GTEST_IMPL_CMP_HELPER_(LE, <=)\par
01471 {\cf20 // Implements the helper function for \{ASSERT|EXPECT\}_LT with int or}\par
01472 {\cf20 // enum arguments.}\par
01473 GTEST_IMPL_CMP_HELPER_(LT, < )\par
01474 {\cf20 // Implements the helper function for \{ASSERT|EXPECT\}_GE with int or}\par
01475 {\cf20 // enum arguments.}\par
01476 GTEST_IMPL_CMP_HELPER_(GE, >=)\par
01477 {\cf20 // Implements the helper function for \{ASSERT|EXPECT\}_GT with int or}\par
01478 {\cf20 // enum arguments.}\par
01479 GTEST_IMPL_CMP_HELPER_(GT, > )\par
01480 \par
01481 {\cf21 #undef GTEST_IMPL_CMP_HELPER_}\par
01482 \par
01483 {\cf20 // The helper function for \{ASSERT|EXPECT\}_STREQ.}\par
01484 AssertionResult CmpHelperSTREQ({\cf17 const} {\cf18 char}* lhs_expression,\par
01485                                {\cf17 const} {\cf18 char}* rhs_expression,\par
01486                                {\cf17 const} {\cf18 char}* lhs,\par
01487                                {\cf17 const} {\cf18 char}* rhs) \{\par
01488   {\cf19 if} (String::CStringEquals(lhs, rhs)) \{\par
01489     {\cf19 return} AssertionSuccess();\par
01490   \}\par
01491 \par
01492   {\cf19 return} EqFailure(lhs_expression,\par
01493                    rhs_expression,\par
01494                    PrintToString(lhs),\par
01495                    PrintToString(rhs),\par
01496                    {\cf17 false});\par
01497 \}\par
01498 \par
01499 {\cf20 // The helper function for \{ASSERT|EXPECT\}_STRCASEEQ.}\par
01500 AssertionResult CmpHelperSTRCASEEQ({\cf17 const} {\cf18 char}* lhs_expression,\par
01501                                    {\cf17 const} {\cf18 char}* rhs_expression,\par
01502                                    {\cf17 const} {\cf18 char}* lhs,\par
01503                                    {\cf17 const} {\cf18 char}* rhs) \{\par
01504   {\cf19 if} (String::CaseInsensitiveCStringEquals(lhs, rhs)) \{\par
01505     {\cf19 return} AssertionSuccess();\par
01506   \}\par
01507 \par
01508   {\cf19 return} EqFailure(lhs_expression,\par
01509                    rhs_expression,\par
01510                    PrintToString(lhs),\par
01511                    PrintToString(rhs),\par
01512                    {\cf17 true});\par
01513 \}\par
01514 \par
01515 {\cf20 // The helper function for \{ASSERT|EXPECT\}_STRNE.}\par
01516 AssertionResult CmpHelperSTRNE({\cf17 const} {\cf18 char}* s1_expression,\par
01517                                {\cf17 const} {\cf18 char}* s2_expression,\par
01518                                {\cf17 const} {\cf18 char}* s1,\par
01519                                {\cf17 const} {\cf18 char}* s2) \{\par
01520   {\cf19 if} (!String::CStringEquals(s1, s2)) \{\par
01521     {\cf19 return} AssertionSuccess();\par
01522   \} {\cf19 else} \{\par
01523     {\cf19 return} AssertionFailure() << {\cf22 "Expected: ("} << s1_expression << {\cf22 ") != ("}\par
01524                               << s2_expression << {\cf22 "), actual: \\""}\par
01525                               << s1 << {\cf22 "\\" vs \\""} << s2 << {\cf22 "\\""};\par
01526   \}\par
01527 \}\par
01528 \par
01529 {\cf20 // The helper function for \{ASSERT|EXPECT\}_STRCASENE.}\par
01530 AssertionResult CmpHelperSTRCASENE({\cf17 const} {\cf18 char}* s1_expression,\par
01531                                    {\cf17 const} {\cf18 char}* s2_expression,\par
01532                                    {\cf17 const} {\cf18 char}* s1,\par
01533                                    {\cf17 const} {\cf18 char}* s2) \{\par
01534   {\cf19 if} (!String::CaseInsensitiveCStringEquals(s1, s2)) \{\par
01535     {\cf19 return} AssertionSuccess();\par
01536   \} {\cf19 else} \{\par
01537     {\cf19 return} AssertionFailure()\par
01538         << {\cf22 "Expected: ("} << s1_expression << {\cf22 ") != ("}\par
01539         << s2_expression << {\cf22 ") (ignoring case), actual: \\""}\par
01540         << s1 << {\cf22 "\\" vs \\""} << s2 << {\cf22 "\\""};\par
01541   \}\par
01542 \}\par
01543 \par
01544 \}  {\cf20 // namespace internal}\par
01545 \par
01546 {\cf17 namespace }\{\par
01547 \par
01548 {\cf20 // Helper functions for implementing IsSubString() and IsNotSubstring().}\par
01549 \par
01550 {\cf20 // This group of overloaded functions return true iff needle is a}\par
01551 {\cf20 // substring of haystack.  NULL is considered a substring of itself}\par
01552 {\cf20 // only.}\par
01553 \par
01554 {\cf18 bool} IsSubstringPred({\cf17 const} {\cf18 char}* needle, {\cf17 const} {\cf18 char}* haystack) \{\par
01555   {\cf19 if} (needle == NULL || haystack == NULL)\par
01556     {\cf19 return} needle == haystack;\par
01557 \par
01558   {\cf19 return} strstr(haystack, needle) != NULL;\par
01559 \}\par
01560 \par
01561 {\cf18 bool} IsSubstringPred({\cf17 const} {\cf18 wchar_t}* needle, {\cf17 const} {\cf18 wchar_t}* haystack) \{\par
01562   {\cf19 if} (needle == NULL || haystack == NULL)\par
01563     {\cf19 return} needle == haystack;\par
01564 \par
01565   {\cf19 return} wcsstr(haystack, needle) != NULL;\par
01566 \}\par
01567 \par
01568 {\cf20 // StringType here can be either ::std::string or ::std::wstring.}\par
01569 {\cf17 template} <{\cf17 typename} StringType>\par
01570 {\cf18 bool} IsSubstringPred({\cf17 const} StringType& needle,\par
01571                      {\cf17 const} StringType& haystack) \{\par
01572   {\cf19 return} haystack.find(needle) != StringType::npos;\par
01573 \}\par
01574 \par
01575 {\cf20 // This function implements either IsSubstring() or IsNotSubstring(),}\par
01576 {\cf20 // depending on the value of the expected_to_be_substring parameter.}\par
01577 {\cf20 // StringType here can be const char*, const wchar_t*, ::std::string,}\par
01578 {\cf20 // or ::std::wstring.}\par
01579 {\cf17 template} <{\cf17 typename} StringType>\par
01580 AssertionResult IsSubstringImpl(\par
01581     {\cf18 bool} expected_to_be_substring,\par
01582     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01583     {\cf17 const} StringType& needle, {\cf17 const} StringType& haystack) \{\par
01584   {\cf19 if} (IsSubstringPred(needle, haystack) == expected_to_be_substring)\par
01585     {\cf19 return} AssertionSuccess();\par
01586 \par
01587   {\cf17 const} {\cf18 bool} is_wide_string = {\cf17 sizeof}(needle[0]) > 1;\par
01588   {\cf17 const} {\cf18 char}* {\cf17 const} begin_string_quote = is_wide_string ? {\cf22 "L\\""} : {\cf22 "\\""};\par
01589   {\cf19 return} AssertionFailure()\par
01590       << {\cf22 "Value of: "} << needle_expr << {\cf22 "\\n"}\par
01591       << {\cf22 "  Actual: "} << begin_string_quote << needle << {\cf22 "\\"\\n"}\par
01592       << {\cf22 "Expected: "} << (expected_to_be_substring ? {\cf22 ""} : {\cf22 "not "})\par
01593       << {\cf22 "a substring of "} << haystack_expr << {\cf22 "\\n"}\par
01594       << {\cf22 "Which is: "} << begin_string_quote << haystack << {\cf22 "\\""};\par
01595 \}\par
01596 \par
01597 \}  {\cf20 // namespace}\par
01598 \par
01599 {\cf20 // IsSubstring() and IsNotSubstring() check whether needle is a}\par
01600 {\cf20 // substring of haystack (NULL is considered a substring of itself}\par
01601 {\cf20 // only), and return an appropriate error message when they fail.}\par
01602 \par
01603 AssertionResult IsSubstring(\par
01604     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01605     {\cf17 const} {\cf18 char}* needle, {\cf17 const} {\cf18 char}* haystack) \{\par
01606   {\cf19 return} IsSubstringImpl({\cf17 true}, needle_expr, haystack_expr, needle, haystack);\par
01607 \}\par
01608 \par
01609 AssertionResult IsSubstring(\par
01610     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01611     {\cf17 const} {\cf18 wchar_t}* needle, {\cf17 const} {\cf18 wchar_t}* haystack) \{\par
01612   {\cf19 return} IsSubstringImpl({\cf17 true}, needle_expr, haystack_expr, needle, haystack);\par
01613 \}\par
01614 \par
01615 AssertionResult IsNotSubstring(\par
01616     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01617     {\cf17 const} {\cf18 char}* needle, {\cf17 const} {\cf18 char}* haystack) \{\par
01618   {\cf19 return} IsSubstringImpl({\cf17 false}, needle_expr, haystack_expr, needle, haystack);\par
01619 \}\par
01620 \par
01621 AssertionResult IsNotSubstring(\par
01622     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01623     {\cf17 const} {\cf18 wchar_t}* needle, {\cf17 const} {\cf18 wchar_t}* haystack) \{\par
01624   {\cf19 return} IsSubstringImpl({\cf17 false}, needle_expr, haystack_expr, needle, haystack);\par
01625 \}\par
01626 \par
01627 AssertionResult IsSubstring(\par
01628     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01629     const ::std::string& needle, const ::std::string& haystack) \{\par
01630   {\cf19 return} IsSubstringImpl({\cf17 true}, needle_expr, haystack_expr, needle, haystack);\par
01631 \}\par
01632 \par
01633 AssertionResult IsNotSubstring(\par
01634     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01635     const ::std::string& needle, const ::std::string& haystack) \{\par
01636   {\cf19 return} IsSubstringImpl({\cf17 false}, needle_expr, haystack_expr, needle, haystack);\par
01637 \}\par
01638 \par
01639 {\cf21 #if GTEST_HAS_STD_WSTRING}\par
01640 AssertionResult IsSubstring(\par
01641     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01642     const ::std::wstring& needle, const ::std::wstring& haystack) \{\par
01643   {\cf19 return} IsSubstringImpl({\cf17 true}, needle_expr, haystack_expr, needle, haystack);\par
01644 \}\par
01645 \par
01646 AssertionResult IsNotSubstring(\par
01647     {\cf17 const} {\cf18 char}* needle_expr, {\cf17 const} {\cf18 char}* haystack_expr,\par
01648     const ::std::wstring& needle, const ::std::wstring& haystack) \{\par
01649   {\cf19 return} IsSubstringImpl({\cf17 false}, needle_expr, haystack_expr, needle, haystack);\par
01650 \}\par
01651 {\cf21 #endif  }{\cf20 // GTEST_HAS_STD_WSTRING}\par
01652 \par
01653 {\cf17 namespace }internal \{\par
01654 \par
01655 {\cf21 #if GTEST_OS_WINDOWS}\par
01656 \par
01657 {\cf17 namespace }\{\par
01658 \par
01659 {\cf20 // Helper function for IsHRESULT\{SuccessFailure\} predicates}\par
01660 AssertionResult HRESULTFailureHelper({\cf17 const} {\cf18 char}* expr,\par
01661                                      {\cf17 const} {\cf18 char}* expected,\par
01662                                      {\cf18 long} hr) \{  {\cf20 // NOLINT}\par
01663 {\cf21 # if GTEST_OS_WINDOWS_MOBILE}\par
01664 \par
01665   {\cf20 // Windows CE doesn't support FormatMessage.}\par
01666   {\cf17 const} {\cf18 char} error_text[] = {\cf22 ""};\par
01667 \par
01668 {\cf21 # else}\par
01669 \par
01670   {\cf20 // Looks up the human-readable system message for the HRESULT code}\par
01671   {\cf20 // and since we're not passing any params to FormatMessage, we don't}\par
01672   {\cf20 // want inserts expanded.}\par
01673   {\cf17 const} DWORD kFlags = FORMAT_MESSAGE_FROM_SYSTEM |\par
01674                        FORMAT_MESSAGE_IGNORE_INSERTS;\par
01675   {\cf17 const} DWORD kBufSize = 4096;\par
01676   {\cf20 // Gets the system's human readable message string for this HRESULT.}\par
01677   {\cf18 char} error_text[kBufSize] = \{ {\cf23 '\\0'} \};\par
01678   DWORD message_length = ::FormatMessageA(kFlags,\par
01679                                           0,  {\cf20 // no source, we're asking system}\par
01680                                           hr,  {\cf20 // the error}\par
01681                                           0,  {\cf20 // no line width restrictions}\par
01682                                           error_text,  {\cf20 // output buffer}\par
01683                                           kBufSize,  {\cf20 // buf size}\par
01684                                           NULL);  {\cf20 // no arguments for inserts}\par
01685   {\cf20 // Trims tailing white space (FormatMessage leaves a trailing CR-LF)}\par
01686   {\cf19 for} (; message_length && IsSpace(error_text[message_length - 1]);\par
01687           --message_length) \{\par
01688     error_text[message_length - 1] = {\cf23 '\\0'};\par
01689   \}\par
01690 \par
01691 {\cf21 # endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
01692 \par
01693   {\cf17 const} std::string error_hex({\cf22 "0x"} + String::FormatHexInt(hr));\par
01694   return ::testing::AssertionFailure()\par
01695       << {\cf22 "Expected: "} << expr << {\cf22 " "} << expected << {\cf22 ".\\n"}\par
01696       << {\cf22 "  Actual: "} << error_hex << {\cf22 " "} << error_text << {\cf22 "\\n"};\par
01697 \}\par
01698 \par
01699 \}  {\cf20 // namespace}\par
01700 \par
01701 AssertionResult IsHRESULTSuccess({\cf17 const} {\cf18 char}* expr, {\cf18 long} hr) \{  {\cf20 // NOLINT}\par
01702   {\cf19 if} (SUCCEEDED(hr)) \{\par
01703     {\cf19 return} AssertionSuccess();\par
01704   \}\par
01705   {\cf19 return} HRESULTFailureHelper(expr, {\cf22 "succeeds"}, hr);\par
01706 \}\par
01707 \par
01708 AssertionResult IsHRESULTFailure({\cf17 const} {\cf18 char}* expr, {\cf18 long} hr) \{  {\cf20 // NOLINT}\par
01709   {\cf19 if} (FAILED(hr)) \{\par
01710     {\cf19 return} AssertionSuccess();\par
01711   \}\par
01712   {\cf19 return} HRESULTFailureHelper(expr, {\cf22 "fails"}, hr);\par
01713 \}\par
01714 \par
01715 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
01716 \par
01717 {\cf20 // Utility functions for encoding Unicode text (wide strings) in}\par
01718 {\cf20 // UTF-8.}\par
01719 \par
01720 {\cf20 // A Unicode code-point can have upto 21 bits, and is encoded in UTF-8}\par
01721 {\cf20 // like this:}\par
01722 {\cf20 //}\par
01723 {\cf20 // Code-point length   Encoding}\par
01724 {\cf20 //   0 -  7 bits       0xxxxxxx}\par
01725 {\cf20 //   8 - 11 bits       110xxxxx 10xxxxxx}\par
01726 {\cf20 //  12 - 16 bits       1110xxxx 10xxxxxx 10xxxxxx}\par
01727 {\cf20 //  17 - 21 bits       11110xxx 10xxxxxx 10xxxxxx 10xxxxxx}\par
01728 \par
01729 {\cf20 // The maximum code-point a one-byte UTF-8 sequence can represent.}\par
01730 {\cf17 const} UInt32 kMaxCodePoint1 = ({\cf17 static_cast<}UInt32{\cf17 >}(1) <<  7) - 1;\par
01731 \par
01732 {\cf20 // The maximum code-point a two-byte UTF-8 sequence can represent.}\par
01733 {\cf17 const} UInt32 kMaxCodePoint2 = ({\cf17 static_cast<}UInt32{\cf17 >}(1) << (5 + 6)) - 1;\par
01734 \par
01735 {\cf20 // The maximum code-point a three-byte UTF-8 sequence can represent.}\par
01736 {\cf17 const} UInt32 kMaxCodePoint3 = ({\cf17 static_cast<}UInt32{\cf17 >}(1) << (4 + 2*6)) - 1;\par
01737 \par
01738 {\cf20 // The maximum code-point a four-byte UTF-8 sequence can represent.}\par
01739 {\cf17 const} UInt32 kMaxCodePoint4 = ({\cf17 static_cast<}UInt32{\cf17 >}(1) << (3 + 3*6)) - 1;\par
01740 \par
01741 {\cf20 // Chops off the n lowest bits from a bit pattern.  Returns the n}\par
01742 {\cf20 // lowest bits.  As a side effect, the original bit pattern will be}\par
01743 {\cf20 // shifted to the right by n bits.}\par
01744 {\cf17 inline} UInt32 ChopLowBits(UInt32* bits, {\cf18 int} n) \{\par
01745   {\cf17 const} UInt32 low_bits = *bits & (({\cf17 static_cast<}UInt32{\cf17 >}(1) << n) - 1);\par
01746   *bits >>= n;\par
01747   {\cf19 return} low_bits;\par
01748 \}\par
01749 \par
01750 {\cf20 // Converts a Unicode code point to a narrow string in UTF-8 encoding.}\par
01751 {\cf20 // code_point parameter is of type UInt32 because wchar_t may not be}\par
01752 {\cf20 // wide enough to contain a code point.}\par
01753 {\cf20 // If the code_point is not a valid Unicode code point}\par
01754 {\cf20 // (i.e. outside of Unicode range U+0 to U+10FFFF) it will be converted}\par
01755 {\cf20 // to "(Invalid Unicode 0xXXXXXXXX)".}\par
01756 std::string CodePointToUtf8(UInt32 code_point) \{\par
01757   {\cf19 if} (code_point > kMaxCodePoint4) \{\par
01758     {\cf19 return} {\cf22 "(Invalid Unicode 0x"} + String::FormatHexInt(code_point) + {\cf22 ")"};\par
01759   \}\par
01760 \par
01761   {\cf18 char} str[5];  {\cf20 // Big enough for the largest valid code point.}\par
01762   {\cf19 if} (code_point <= kMaxCodePoint1) \{\par
01763     str[1] = {\cf23 '\\0'};\par
01764     str[0] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(code_point);                          {\cf20 // 0xxxxxxx}\par
01765   \} {\cf19 else} {\cf19 if} (code_point <= kMaxCodePoint2) \{\par
01766     str[2] = {\cf23 '\\0'};\par
01767     str[1] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
01768     str[0] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xC0 | code_point);                   {\cf20 // 110xxxxx}\par
01769   \} {\cf19 else} {\cf19 if} (code_point <= kMaxCodePoint3) \{\par
01770     str[3] = {\cf23 '\\0'};\par
01771     str[2] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
01772     str[1] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
01773     str[0] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xE0 | code_point);                   {\cf20 // 1110xxxx}\par
01774   \} {\cf19 else} \{  {\cf20 // code_point <= kMaxCodePoint4}\par
01775     str[4] = {\cf23 '\\0'};\par
01776     str[3] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
01777     str[2] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
01778     str[1] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80 | ChopLowBits(&code_point, 6));  {\cf20 // 10xxxxxx}\par
01779     str[0] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xF0 | code_point);                   {\cf20 // 11110xxx}\par
01780   \}\par
01781   {\cf19 return} str;\par
01782 \}\par
01783 \par
01784 {\cf20 // The following two functions only make sense if the the system}\par
01785 {\cf20 // uses UTF-16 for wide string encoding. All supported systems}\par
01786 {\cf20 // with 16 bit wchar_t (Windows, Cygwin, Symbian OS) do use UTF-16.}\par
01787 \par
01788 {\cf20 // Determines if the arguments constitute UTF-16 surrogate pair}\par
01789 {\cf20 // and thus should be combined into a single Unicode code point}\par
01790 {\cf20 // using CreateCodePointFromUtf16SurrogatePair.}\par
01791 {\cf17 inline} {\cf18 bool} IsUtf16SurrogatePair({\cf18 wchar_t} first, {\cf18 wchar_t} second) \{\par
01792   {\cf19 return} {\cf17 sizeof}(wchar_t) == 2 &&\par
01793       (first & 0xFC00) == 0xD800 && (second & 0xFC00) == 0xDC00;\par
01794 \}\par
01795 \par
01796 {\cf20 // Creates a Unicode code point from UTF16 surrogate pair.}\par
01797 {\cf17 inline} UInt32 CreateCodePointFromUtf16SurrogatePair({\cf18 wchar_t} first,\par
01798                                                     {\cf18 wchar_t} second) \{\par
01799   {\cf17 const} UInt32 mask = (1 << 10) - 1;\par
01800   {\cf19 return} ({\cf17 sizeof}({\cf18 wchar_t}) == 2) ?\par
01801       (((first & mask) << 10) | (second & mask)) + 0x10000 :\par
01802       {\cf20 // This function should not be called when the condition is}\par
01803       {\cf20 // false, but we provide a sensible default in case it is.}\par
01804       {\cf17 static_cast<}UInt32{\cf17 >}(first);\par
01805 \}\par
01806 \par
01807 {\cf20 // Converts a wide string to a narrow string in UTF-8 encoding.}\par
01808 {\cf20 // The wide string is assumed to have the following encoding:}\par
01809 {\cf20 //   UTF-16 if sizeof(wchar_t) == 2 (on Windows, Cygwin, Symbian OS)}\par
01810 {\cf20 //   UTF-32 if sizeof(wchar_t) == 4 (on Linux)}\par
01811 {\cf20 // Parameter str points to a null-terminated wide string.}\par
01812 {\cf20 // Parameter num_chars may additionally limit the number}\par
01813 {\cf20 // of wchar_t characters processed. -1 is used when the entire string}\par
01814 {\cf20 // should be processed.}\par
01815 {\cf20 // If the string contains code points that are not valid Unicode code points}\par
01816 {\cf20 // (i.e. outside of Unicode range U+0 to U+10FFFF) they will be output}\par
01817 {\cf20 // as '(Invalid Unicode 0xXXXXXXXX)'. If the string is in UTF16 encoding}\par
01818 {\cf20 // and contains invalid UTF-16 surrogate pairs, values in those pairs}\par
01819 {\cf20 // will be encoded as individual Unicode characters from Basic Normal Plane.}\par
01820 std::string WideStringToUtf8({\cf17 const} {\cf18 wchar_t}* str, {\cf18 int} num_chars) \{\par
01821   {\cf19 if} (num_chars == -1)\par
01822     num_chars = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(wcslen(str));\par
01823 \par
01824   ::std::stringstream stream;\par
01825   {\cf19 for} ({\cf18 int} i = 0; i < num_chars; ++i) \{\par
01826     UInt32 unicode_code_point;\par
01827 \par
01828     {\cf19 if} (str[i] == L{\cf23 '\\0'}) \{\par
01829       {\cf19 break};\par
01830     \} {\cf19 else} {\cf19 if} (i + 1 < num_chars && IsUtf16SurrogatePair(str[i], str[i + 1])) \{\par
01831       unicode_code_point = CreateCodePointFromUtf16SurrogatePair(str[i],\par
01832                                                                  str[i + 1]);\par
01833       i++;\par
01834     \} {\cf19 else} \{\par
01835       unicode_code_point = {\cf17 static_cast<}UInt32{\cf17 >}(str[i]);\par
01836     \}\par
01837 \par
01838     stream << CodePointToUtf8(unicode_code_point);\par
01839   \}\par
01840   {\cf19 return} StringStreamToString(&stream);\par
01841 \}\par
01842 \par
01843 {\cf20 // Converts a wide C string to an std::string using the UTF-8 encoding.}\par
01844 {\cf20 // NULL will be converted to "(null)".}\par
01845 std::string String::ShowWideCString({\cf17 const} {\cf18 wchar_t} * wide_c_str) \{\par
01846   {\cf19 if} (wide_c_str == NULL)  {\cf19 return} {\cf22 "(null)"};\par
01847 \par
01848   {\cf19 return} internal::WideStringToUtf8(wide_c_str, -1);\par
01849 \}\par
01850 \par
01851 {\cf20 // Compares two wide C strings.  Returns true iff they have the same}\par
01852 {\cf20 // content.}\par
01853 {\cf20 //}\par
01854 {\cf20 // Unlike wcscmp(), this function can handle NULL argument(s).  A NULL}\par
01855 {\cf20 // C string is considered different to any non-NULL C string,}\par
01856 {\cf20 // including the empty string.}\par
01857 {\cf18 bool} String::WideCStringEquals({\cf17 const} {\cf18 wchar_t} * lhs, {\cf17 const} {\cf18 wchar_t} * rhs) \{\par
01858   {\cf19 if} (lhs == NULL) {\cf19 return} rhs == NULL;\par
01859 \par
01860   {\cf19 if} (rhs == NULL) {\cf19 return} {\cf17 false};\par
01861 \par
01862   {\cf19 return} wcscmp(lhs, rhs) == 0;\par
01863 \}\par
01864 \par
01865 {\cf20 // Helper function for *_STREQ on wide strings.}\par
01866 AssertionResult CmpHelperSTREQ({\cf17 const} {\cf18 char}* lhs_expression,\par
01867                                {\cf17 const} {\cf18 char}* rhs_expression,\par
01868                                {\cf17 const} {\cf18 wchar_t}* lhs,\par
01869                                {\cf17 const} {\cf18 wchar_t}* rhs) \{\par
01870   {\cf19 if} (String::WideCStringEquals(lhs, rhs)) \{\par
01871     {\cf19 return} AssertionSuccess();\par
01872   \}\par
01873 \par
01874   {\cf19 return} EqFailure(lhs_expression,\par
01875                    rhs_expression,\par
01876                    PrintToString(lhs),\par
01877                    PrintToString(rhs),\par
01878                    {\cf17 false});\par
01879 \}\par
01880 \par
01881 {\cf20 // Helper function for *_STRNE on wide strings.}\par
01882 AssertionResult CmpHelperSTRNE({\cf17 const} {\cf18 char}* s1_expression,\par
01883                                {\cf17 const} {\cf18 char}* s2_expression,\par
01884                                {\cf17 const} {\cf18 wchar_t}* s1,\par
01885                                {\cf17 const} {\cf18 wchar_t}* s2) \{\par
01886   {\cf19 if} (!String::WideCStringEquals(s1, s2)) \{\par
01887     {\cf19 return} AssertionSuccess();\par
01888   \}\par
01889 \par
01890   {\cf19 return} AssertionFailure() << {\cf22 "Expected: ("} << s1_expression << {\cf22 ") != ("}\par
01891                             << s2_expression << {\cf22 "), actual: "}\par
01892                             << PrintToString(s1)\par
01893                             << {\cf22 " vs "} << PrintToString(s2);\par
01894 \}\par
01895 \par
01896 {\cf20 // Compares two C strings, ignoring case.  Returns true iff they have}\par
01897 {\cf20 // the same content.}\par
01898 {\cf20 //}\par
01899 {\cf20 // Unlike strcasecmp(), this function can handle NULL argument(s).  A}\par
01900 {\cf20 // NULL C string is considered different to any non-NULL C string,}\par
01901 {\cf20 // including the empty string.}\par
01902 {\cf18 bool} String::CaseInsensitiveCStringEquals({\cf17 const} {\cf18 char} * lhs, {\cf17 const} {\cf18 char} * rhs) \{\par
01903   {\cf19 if} (lhs == NULL)\par
01904     {\cf19 return} rhs == NULL;\par
01905   {\cf19 if} (rhs == NULL)\par
01906     {\cf19 return} {\cf17 false};\par
01907   {\cf19 return} posix::StrCaseCmp(lhs, rhs) == 0;\par
01908 \}\par
01909 \par
01910   {\cf20 // Compares two wide C strings, ignoring case.  Returns true iff they}\par
01911   {\cf20 // have the same content.}\par
01912   {\cf20 //}\par
01913   {\cf20 // Unlike wcscasecmp(), this function can handle NULL argument(s).}\par
01914   {\cf20 // A NULL C string is considered different to any non-NULL wide C string,}\par
01915   {\cf20 // including the empty string.}\par
01916   {\cf20 // NB: The implementations on different platforms slightly differ.}\par
01917   {\cf20 // On windows, this method uses _wcsicmp which compares according to LC_CTYPE}\par
01918   {\cf20 // environment variable. On GNU platform this method uses wcscasecmp}\par
01919   {\cf20 // which compares according to LC_CTYPE category of the current locale.}\par
01920   {\cf20 // On MacOS X, it uses towlower, which also uses LC_CTYPE category of the}\par
01921   {\cf20 // current locale.}\par
01922 {\cf18 bool} String::CaseInsensitiveWideCStringEquals({\cf17 const} {\cf18 wchar_t}* lhs,\par
01923                                               {\cf17 const} {\cf18 wchar_t}* rhs) \{\par
01924   {\cf19 if} (lhs == NULL) {\cf19 return} rhs == NULL;\par
01925 \par
01926   {\cf19 if} (rhs == NULL) {\cf19 return} {\cf17 false};\par
01927 \par
01928 {\cf21 #if GTEST_OS_WINDOWS}\par
01929   {\cf19 return} _wcsicmp(lhs, rhs) == 0;\par
01930 {\cf21 #elif GTEST_OS_LINUX && !GTEST_OS_LINUX_ANDROID}\par
01931   {\cf19 return} wcscasecmp(lhs, rhs) == 0;\par
01932 {\cf21 #else}\par
01933   {\cf20 // Android, Mac OS X and Cygwin don't define wcscasecmp.}\par
01934   {\cf20 // Other unknown OSes may not define it either.}\par
01935   wint_t left, right;\par
01936   {\cf19 do} \{\par
01937     left = towlower(*lhs++);\par
01938     right = towlower(*rhs++);\par
01939   \} {\cf19 while} (left && left == right);\par
01940   {\cf19 return} left == right;\par
01941 {\cf21 #endif  }{\cf20 // OS selector}\par
01942 \}\par
01943 \par
01944 {\cf20 // Returns true iff str ends with the given suffix, ignoring case.}\par
01945 {\cf20 // Any string is considered to end with an empty suffix.}\par
01946 {\cf18 bool} String::EndsWithCaseInsensitive(\par
01947     {\cf17 const} std::string& str, {\cf17 const} std::string& suffix) \{\par
01948   {\cf17 const} {\cf18 size_t} str_len = str.length();\par
01949   {\cf17 const} {\cf18 size_t} suffix_len = suffix.length();\par
01950   {\cf19 return} (str_len >= suffix_len) &&\par
01951          CaseInsensitiveCStringEquals(str.c_str() + str_len - suffix_len,\par
01952                                       suffix.c_str());\par
01953 \}\par
01954 \par
01955 {\cf20 // Formats an int value as "%02d".}\par
01956 std::string String::FormatIntWidth2({\cf18 int} value) \{\par
01957   std::stringstream ss;\par
01958   ss << std::setfill({\cf23 '0'}) << std::setw(2) << value;\par
01959   {\cf19 return} ss.str();\par
01960 \}\par
01961 \par
01962 {\cf20 // Formats an int value as "%X".}\par
01963 std::string String::FormatHexInt({\cf18 int} value) \{\par
01964   std::stringstream ss;\par
01965   ss << std::hex << std::uppercase << value;\par
01966   {\cf19 return} ss.str();\par
01967 \}\par
01968 \par
01969 {\cf20 // Formats a byte as "%02X".}\par
01970 std::string String::FormatByte({\cf18 unsigned} {\cf18 char} value) \{\par
01971   std::stringstream ss;\par
01972   ss << std::setfill({\cf23 '0'}) << std::setw(2) << std::hex << std::uppercase\par
01973      << {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(value);\par
01974   {\cf19 return} ss.str();\par
01975 \}\par
01976 \par
01977 {\cf20 // Converts the buffer in a stringstream to an std::string, converting NUL}\par
01978 {\cf20 // bytes to "\\\\0" along the way.}\par
01979 std::string StringStreamToString(::std::stringstream* ss) \{\par
01980   const ::std::string& str = ss->str();\par
01981   {\cf17 const} {\cf18 char}* {\cf17 const} start = str.c_str();\par
01982   {\cf17 const} {\cf18 char}* {\cf17 const} end = start + str.length();\par
01983 \par
01984   std::string result;\par
01985   result.reserve(2 * (end - start));\par
01986   {\cf19 for} ({\cf17 const} {\cf18 char}* ch = start; ch != end; ++ch) \{\par
01987     {\cf19 if} (*ch == {\cf23 '\\0'}) \{\par
01988       result += {\cf22 "\\\\0"};  {\cf20 // Replaces NUL with "\\\\0";}\par
01989     \} {\cf19 else} \{\par
01990       result += *ch;\par
01991     \}\par
01992   \}\par
01993 \par
01994   {\cf19 return} result;\par
01995 \}\par
01996 \par
01997 {\cf20 // Appends the user-supplied message to the Google-Test-generated message.}\par
01998 std::string AppendUserMessage({\cf17 const} std::string& gtest_msg,\par
01999                               {\cf17 const} Message& user_msg) \{\par
02000   {\cf20 // Appends the user message if it's non-empty.}\par
02001   {\cf17 const} std::string user_msg_string = user_msg.GetString();\par
02002   {\cf19 if} (user_msg_string.empty()) \{\par
02003     {\cf19 return} gtest_msg;\par
02004   \}\par
02005 \par
02006   {\cf19 return} gtest_msg + {\cf22 "\\n"} + user_msg_string;\par
02007 \}\par
02008 \par
02009 \}  {\cf20 // namespace internal}\par
02010 \par
02011 {\cf20 // class TestResult}\par
02012 \par
02013 {\cf20 // Creates an empty TestResult.}\par
02014 TestResult::TestResult()\par
02015     : death_test_count_(0),\par
02016       elapsed_time_(0) \{\par
02017 \}\par
02018 \par
02019 {\cf20 // D'tor.}\par
02020 TestResult::~TestResult() \{\par
02021 \}\par
02022 \par
02023 {\cf20 // Returns the i-th test part result among all the results. i can}\par
02024 {\cf20 // range from 0 to total_part_count() - 1. If i is not in that range,}\par
02025 {\cf20 // aborts the program.}\par
02026 {\cf17 const} TestPartResult& TestResult::GetTestPartResult({\cf18 int} i){\cf17  const }\{\par
02027   {\cf19 if} (i < 0 || i >= total_part_count())\par
02028     internal::posix::Abort();\par
02029   {\cf19 return} test_part_results_.at(i);\par
02030 \}\par
02031 \par
02032 {\cf20 // Returns the i-th test property. i can range from 0 to}\par
02033 {\cf20 // test_property_count() - 1. If i is not in that range, aborts the}\par
02034 {\cf20 // program.}\par
02035 {\cf17 const} TestProperty& TestResult::GetTestProperty({\cf18 int} i){\cf17  const }\{\par
02036   {\cf19 if} (i < 0 || i >= test_property_count())\par
02037     internal::posix::Abort();\par
02038   {\cf19 return} test_properties_.at(i);\par
02039 \}\par
02040 \par
02041 {\cf20 // Clears the test part results.}\par
02042 {\cf18 void} TestResult::ClearTestPartResults() \{\par
02043   test_part_results_.clear();\par
02044 \}\par
02045 \par
02046 {\cf20 // Adds a test part result to the list.}\par
02047 {\cf18 void} TestResult::AddTestPartResult({\cf17 const} TestPartResult& test_part_result) \{\par
02048   test_part_results_.push_back(test_part_result);\par
02049 \}\par
02050 \par
02051 {\cf20 // Adds a test property to the list. If a property with the same key as the}\par
02052 {\cf20 // supplied property is already represented, the value of this test_property}\par
02053 {\cf20 // replaces the old value for that key.}\par
02054 {\cf18 void} TestResult::RecordProperty({\cf17 const} std::string& xml_element,\par
02055                                 {\cf17 const} TestProperty& test_property) \{\par
02056   {\cf19 if} (!ValidateTestProperty(xml_element, test_property)) \{\par
02057     {\cf19 return};\par
02058   \}\par
02059   internal::MutexLock lock(&test_properites_mutex_);\par
02060   {\cf17 const} std::vector<TestProperty>::iterator property_with_matching_key =\par
02061       std::find_if(test_properties_.begin(), test_properties_.end(),\par
02062                    internal::TestPropertyKeyIs(test_property.key()));\par
02063   {\cf19 if} (property_with_matching_key == test_properties_.end()) \{\par
02064     test_properties_.push_back(test_property);\par
02065     {\cf19 return};\par
02066   \}\par
02067   property_with_matching_key->SetValue(test_property.value());\par
02068 \}\par
02069 \par
02070 {\cf20 // The list of reserved attributes used in the <testsuites> element of XML}\par
02071 {\cf20 // output.}\par
02072 {\cf17 static} {\cf17 const} {\cf18 char}* {\cf17 const} kReservedTestSuitesAttributes[] = \{\par
02073   {\cf22 "disabled"},\par
02074   {\cf22 "errors"},\par
02075   {\cf22 "failures"},\par
02076   {\cf22 "name"},\par
02077   {\cf22 "random_seed"},\par
02078   {\cf22 "tests"},\par
02079   {\cf22 "time"},\par
02080   {\cf22 "timestamp"}\par
02081 \};\par
02082 \par
02083 {\cf20 // The list of reserved attributes used in the <testsuite> element of XML}\par
02084 {\cf20 // output.}\par
02085 {\cf17 static} {\cf17 const} {\cf18 char}* {\cf17 const} kReservedTestSuiteAttributes[] = \{\par
02086   {\cf22 "disabled"},\par
02087   {\cf22 "errors"},\par
02088   {\cf22 "failures"},\par
02089   {\cf22 "name"},\par
02090   {\cf22 "tests"},\par
02091   {\cf22 "time"}\par
02092 \};\par
02093 \par
02094 {\cf20 // The list of reserved attributes used in the <testcase> element of XML output.}\par
02095 {\cf17 static} {\cf17 const} {\cf18 char}* {\cf17 const} kReservedTestCaseAttributes[] = \{\par
02096   {\cf22 "classname"},\par
02097   {\cf22 "name"},\par
02098   {\cf22 "status"},\par
02099   {\cf22 "time"},\par
02100   {\cf22 "type_param"},\par
02101   {\cf22 "value_param"}\par
02102 \};\par
02103 \par
02104 {\cf17 template} <{\cf18 int} kSize>\par
02105 std::vector<std::string> ArrayAsVector({\cf17 const} {\cf18 char}* {\cf17 const} (&array)[kSize]) \{\par
02106   {\cf19 return} std::vector<std::string>(array, array + kSize);\par
02107 \}\par
02108 \par
02109 {\cf17 static} std::vector<std::string> GetReservedAttributesForElement(\par
02110     {\cf17 const} std::string& xml_element) \{\par
02111   {\cf19 if} (xml_element == {\cf22 "testsuites"}) \{\par
02112     {\cf19 return} ArrayAsVector(kReservedTestSuitesAttributes);\par
02113   \} {\cf19 else} {\cf19 if} (xml_element == {\cf22 "testsuite"}) \{\par
02114     {\cf19 return} ArrayAsVector(kReservedTestSuiteAttributes);\par
02115   \} {\cf19 else} {\cf19 if} (xml_element == {\cf22 "testcase"}) \{\par
02116     {\cf19 return} ArrayAsVector(kReservedTestCaseAttributes);\par
02117   \} {\cf19 else} \{\par
02118     GTEST_CHECK_({\cf17 false}) << {\cf22 "Unrecognized xml_element provided: "} << xml_element;\par
02119   \}\par
02120   {\cf20 // This code is unreachable but some compilers may not realizes that.}\par
02121   {\cf19 return} std::vector<std::string>();\par
02122 \}\par
02123 \par
02124 {\cf17 static} std::string FormatWordList({\cf17 const} std::vector<std::string>& words) \{\par
02125   Message word_list;\par
02126   {\cf19 for} ({\cf18 size_t} i = 0; i < words.size(); ++i) \{\par
02127     {\cf19 if} (i > 0 && words.size() > 2) \{\par
02128       word_list << {\cf22 ", "};\par
02129     \}\par
02130     {\cf19 if} (i == words.size() - 1) \{\par
02131       word_list << {\cf22 "and "};\par
02132     \}\par
02133     word_list << {\cf22 "'"} << words[i] << {\cf22 "'"};\par
02134   \}\par
02135   {\cf19 return} word_list.GetString();\par
02136 \}\par
02137 \par
02138 {\cf18 bool} ValidateTestPropertyName({\cf17 const} std::string& property_name,\par
02139                               {\cf17 const} std::vector<std::string>& reserved_names) \{\par
02140   {\cf19 if} (std::find(reserved_names.begin(), reserved_names.end(), property_name) !=\par
02141           reserved_names.end()) \{\par
02142     ADD_FAILURE() << {\cf22 "Reserved key used in RecordProperty(): "} << property_name\par
02143                   << {\cf22 " ("} << FormatWordList(reserved_names)\par
02144                   << {\cf22 " are reserved by "} << GTEST_NAME_ << {\cf22 ")"};\par
02145     {\cf19 return} {\cf17 false};\par
02146   \}\par
02147   {\cf19 return} {\cf17 true};\par
02148 \}\par
02149 \par
02150 {\cf20 // Adds a failure if the key is a reserved attribute of the element named}\par
02151 {\cf20 // xml_element.  Returns true if the property is valid.}\par
02152 {\cf18 bool} TestResult::ValidateTestProperty({\cf17 const} std::string& xml_element,\par
02153                                       {\cf17 const} TestProperty& test_property) \{\par
02154   {\cf19 return} ValidateTestPropertyName(test_property.key(),\par
02155                                   GetReservedAttributesForElement(xml_element));\par
02156 \}\par
02157 \par
02158 {\cf20 // Clears the object.}\par
02159 {\cf18 void} TestResult::Clear() \{\par
02160   test_part_results_.clear();\par
02161   test_properties_.clear();\par
02162   death_test_count_ = 0;\par
02163   elapsed_time_ = 0;\par
02164 \}\par
02165 \par
02166 {\cf20 // Returns true iff the test failed.}\par
02167 {\cf18 bool} TestResult::Failed(){\cf17  const }\{\par
02168   {\cf19 for} ({\cf18 int} i = 0; i < total_part_count(); ++i) \{\par
02169     {\cf19 if} (GetTestPartResult(i).failed())\par
02170       {\cf19 return} {\cf17 true};\par
02171   \}\par
02172   {\cf19 return} {\cf17 false};\par
02173 \}\par
02174 \par
02175 {\cf20 // Returns true iff the test part fatally failed.}\par
02176 {\cf17 static} {\cf18 bool} TestPartFatallyFailed({\cf17 const} TestPartResult& result) \{\par
02177   {\cf19 return} result.fatally_failed();\par
02178 \}\par
02179 \par
02180 {\cf20 // Returns true iff the test fatally failed.}\par
02181 {\cf18 bool} TestResult::HasFatalFailure(){\cf17  const }\{\par
02182   {\cf19 return} CountIf(test_part_results_, TestPartFatallyFailed) > 0;\par
02183 \}\par
02184 \par
02185 {\cf20 // Returns true iff the test part non-fatally failed.}\par
02186 {\cf17 static} {\cf18 bool} TestPartNonfatallyFailed({\cf17 const} TestPartResult& result) \{\par
02187   {\cf19 return} result.nonfatally_failed();\par
02188 \}\par
02189 \par
02190 {\cf20 // Returns true iff the test has a non-fatal failure.}\par
02191 {\cf18 bool} TestResult::HasNonfatalFailure(){\cf17  const }\{\par
02192   {\cf19 return} CountIf(test_part_results_, TestPartNonfatallyFailed) > 0;\par
02193 \}\par
02194 \par
02195 {\cf20 // Gets the number of all test parts.  This is the sum of the number}\par
02196 {\cf20 // of successful test parts and the number of failed test parts.}\par
02197 {\cf18 int} TestResult::total_part_count(){\cf17  const }\{\par
02198   {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(test_part_results_.size());\par
02199 \}\par
02200 \par
02201 {\cf20 // Returns the number of the test properties.}\par
02202 {\cf18 int} TestResult::test_property_count(){\cf17  const }\{\par
02203   {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(test_properties_.size());\par
02204 \}\par
02205 \par
02206 {\cf20 // class Test}\par
02207 \par
02208 {\cf20 // Creates a Test object.}\par
02209 \par
02210 {\cf20 // The c'tor saves the states of all flags.}\par
02211 Test::Test()\par
02212     : gtest_flag_saver_(new GTEST_FLAG_SAVER_) \{\par
02213 \}\par
02214 \par
02215 {\cf20 // The d'tor restores the states of all flags.  The actual work is}\par
02216 {\cf20 // done by the d'tor of the gtest_flag_saver_ field, and thus not}\par
02217 {\cf20 // visible here.}\par
02218 Test::~Test() \{\par
02219 \}\par
02220 \par
02221 {\cf20 // Sets up the test fixture.}\par
02222 {\cf20 //}\par
02223 {\cf20 // A sub-class may override this.}\par
02224 {\cf18 void} Test::SetUp() \{\par
02225 \}\par
02226 \par
02227 {\cf20 // Tears down the test fixture.}\par
02228 {\cf20 //}\par
02229 {\cf20 // A sub-class may override this.}\par
02230 {\cf18 void} Test::TearDown() \{\par
02231 \}\par
02232 \par
02233 {\cf20 // Allows user supplied key value pairs to be recorded for later output.}\par
02234 {\cf18 void} Test::RecordProperty({\cf17 const} std::string& key, {\cf17 const} std::string& value) \{\par
02235   UnitTest::GetInstance()->RecordProperty(key, value);\par
02236 \}\par
02237 \par
02238 {\cf20 // Allows user supplied key value pairs to be recorded for later output.}\par
02239 {\cf18 void} Test::RecordProperty({\cf17 const} std::string& key, {\cf18 int} value) \{\par
02240   Message value_message;\par
02241   value_message << value;\par
02242   RecordProperty(key, value_message.GetString().c_str());\par
02243 \}\par
02244 \par
02245 {\cf17 namespace }internal \{\par
02246 \par
02247 {\cf18 void} ReportFailureInUnknownLocation(TestPartResult::Type result_type,\par
02248                                     {\cf17 const} std::string& message) \{\par
02249   {\cf20 // This function is a friend of UnitTest and as such has access to}\par
02250   {\cf20 // AddTestPartResult.}\par
02251   UnitTest::GetInstance()->AddTestPartResult(\par
02252       result_type,\par
02253       NULL,  {\cf20 // No info about the source file where the exception occurred.}\par
02254       -1,    {\cf20 // We have no info on which line caused the exception.}\par
02255       message,\par
02256       {\cf22 ""});   {\cf20 // No stack trace, either.}\par
02257 \}\par
02258 \par
02259 \}  {\cf20 // namespace internal}\par
02260 \par
02261 {\cf20 // Google Test requires all tests in the same test case to use the same test}\par
02262 {\cf20 // fixture class.  This function checks if the current test has the}\par
02263 {\cf20 // same fixture class as the first test in the current test case.  If}\par
02264 {\cf20 // yes, it returns true; otherwise it generates a Google Test failure and}\par
02265 {\cf20 // returns false.}\par
02266 {\cf18 bool} Test::HasSameFixtureClass() \{\par
02267   internal::UnitTestImpl* {\cf17 const} impl = internal::GetUnitTestImpl();\par
02268   {\cf17 const} TestCase* {\cf17 const} test_case = impl->current_test_case();\par
02269 \par
02270   {\cf20 // Info about the first test in the current test case.}\par
02271   {\cf17 const} TestInfo* {\cf17 const} first_test_info = test_case->test_info_list()[0];\par
02272   {\cf17 const} internal::TypeId first_fixture_id = first_test_info->fixture_class_id_;\par
02273   {\cf17 const} {\cf18 char}* {\cf17 const} first_test_name = first_test_info->name();\par
02274 \par
02275   {\cf20 // Info about the current test.}\par
02276   {\cf17 const} TestInfo* {\cf17 const} this_test_info = impl->current_test_info();\par
02277   {\cf17 const} internal::TypeId this_fixture_id = this_test_info->fixture_class_id_;\par
02278   {\cf17 const} {\cf18 char}* {\cf17 const} this_test_name = this_test_info->name();\par
02279 \par
02280   {\cf19 if} (this_fixture_id != first_fixture_id) \{\par
02281     {\cf20 // Is the first test defined using TEST?}\par
02282     {\cf17 const} {\cf18 bool} first_is_TEST = first_fixture_id == internal::GetTestTypeId();\par
02283     {\cf20 // Is this test defined using TEST?}\par
02284     {\cf17 const} {\cf18 bool} this_is_TEST = this_fixture_id == internal::GetTestTypeId();\par
02285 \par
02286     {\cf19 if} (first_is_TEST || this_is_TEST) \{\par
02287       {\cf20 // Both TEST and TEST_F appear in same test case, which is incorrect.}\par
02288       {\cf20 // Tell the user how to fix this.}\par
02289 \par
02290       {\cf20 // Gets the name of the TEST and the name of the TEST_F.  Note}\par
02291       {\cf20 // that first_is_TEST and this_is_TEST cannot both be true, as}\par
02292       {\cf20 // the fixture IDs are different for the two tests.}\par
02293       {\cf17 const} {\cf18 char}* {\cf17 const} TEST_name =\par
02294           first_is_TEST ? first_test_name : this_test_name;\par
02295       {\cf17 const} {\cf18 char}* {\cf17 const} TEST_F_name =\par
02296           first_is_TEST ? this_test_name : first_test_name;\par
02297 \par
02298       ADD_FAILURE()\par
02299           << {\cf22 "All tests in the same test case must use the same test fixture\\n"}\par
02300           << {\cf22 "class, so mixing TEST_F and TEST in the same test case is\\n"}\par
02301           << {\cf22 "illegal.  In test case "} << this_test_info->test_case_name()\par
02302           << {\cf22 ",\\n"}\par
02303           << {\cf22 "test "} << TEST_F_name << {\cf22 " is defined using TEST_F but\\n"}\par
02304           << {\cf22 "test "} << TEST_name << {\cf22 " is defined using TEST.  You probably\\n"}\par
02305           << {\cf22 "want to change the TEST to TEST_F or move it to another test\\n"}\par
02306           << {\cf22 "case."};\par
02307     \} {\cf19 else} \{\par
02308       {\cf20 // Two fixture classes with the same name appear in two different}\par
02309       {\cf20 // namespaces, which is not allowed. Tell the user how to fix this.}\par
02310       ADD_FAILURE()\par
02311           << {\cf22 "All tests in the same test case must use the same test fixture\\n"}\par
02312           << {\cf22 "class.  However, in test case "}\par
02313           << this_test_info->test_case_name() << {\cf22 ",\\n"}\par
02314           << {\cf22 "you defined test "} << first_test_name\par
02315           << {\cf22 " and test "} << this_test_name << {\cf22 "\\n"}\par
02316           << {\cf22 "using two different test fixture classes.  This can happen if\\n"}\par
02317           << {\cf22 "the two classes are from different namespaces or translation\\n"}\par
02318           << {\cf22 "units and have the same name.  You should probably rename one\\n"}\par
02319           << {\cf22 "of the classes to put the tests into different test cases."};\par
02320     \}\par
02321     {\cf19 return} {\cf17 false};\par
02322   \}\par
02323 \par
02324   {\cf19 return} {\cf17 true};\par
02325 \}\par
02326 \par
02327 {\cf21 #if GTEST_HAS_SEH}\par
02328 \par
02329 {\cf20 // Adds an "exception thrown" fatal failure to the current test.  This}\par
02330 {\cf20 // function returns its result via an output parameter pointer because VC++}\par
02331 {\cf20 // prohibits creation of objects with destructors on stack in functions}\par
02332 {\cf20 // using __try (see error C2712).}\par
02333 {\cf17 static} std::string* FormatSehExceptionMessage(DWORD exception_code,\par
02334                                               {\cf17 const} {\cf18 char}* location) \{\par
02335   Message message;\par
02336   message << {\cf22 "SEH exception with code 0x"} << std::setbase(16) <<\par
02337     exception_code << std::setbase(10) << {\cf22 " thrown in "} << location << {\cf22 "."};\par
02338 \par
02339   {\cf19 return} {\cf17 new} std::string(message.GetString());\par
02340 \}\par
02341 \par
02342 {\cf21 #endif  }{\cf20 // GTEST_HAS_SEH}\par
02343 \par
02344 {\cf17 namespace }internal \{\par
02345 \par
02346 {\cf21 #if GTEST_HAS_EXCEPTIONS}\par
02347 \par
02348 {\cf20 // Adds an "exception thrown" fatal failure to the current test.}\par
02349 {\cf17 static} std::string FormatCxxExceptionMessage({\cf17 const} {\cf18 char}* description,\par
02350                                              {\cf17 const} {\cf18 char}* location) \{\par
02351   Message message;\par
02352   {\cf19 if} (description != NULL) \{\par
02353     message << {\cf22 "C++ exception with description \\""} << description << {\cf22 "\\""};\par
02354   \} {\cf19 else} \{\par
02355     message << {\cf22 "Unknown C++ exception"};\par
02356   \}\par
02357   message << {\cf22 " thrown in "} << location << {\cf22 "."};\par
02358 \par
02359   {\cf19 return} message.GetString();\par
02360 \}\par
02361 \par
02362 {\cf17 static} std::string PrintTestPartResultToString(\par
02363     {\cf17 const} TestPartResult& test_part_result);\par
02364 \par
02365 GoogleTestFailureException::GoogleTestFailureException(\par
02366     {\cf17 const} TestPartResult& failure)\par
02367     : ::std::runtime_error(PrintTestPartResultToString(failure).c_str()) \{\}\par
02368 \par
02369 {\cf21 #endif  }{\cf20 // GTEST_HAS_EXCEPTIONS}\par
02370 \par
02371 {\cf20 // We put these helper functions in the internal namespace as IBM's xlC}\par
02372 {\cf20 // compiler rejects the code if they were declared static.}\par
02373 \par
02374 {\cf20 // Runs the given method and handles SEH exceptions it throws, when}\par
02375 {\cf20 // SEH is supported; returns the 0-value for type Result in case of an}\par
02376 {\cf20 // SEH exception.  (Microsoft compilers cannot handle SEH and C++}\par
02377 {\cf20 // exceptions in the same function.  Therefore, we provide a separate}\par
02378 {\cf20 // wrapper function for handling SEH exceptions.)}\par
02379 {\cf17 template} <{\cf17 class} T, {\cf17 typename} Result>\par
02380 Result HandleSehExceptionsInMethodIfSupported(\par
02381     T* {\cf18 object}, Result (T::*method)(), {\cf17 const} {\cf18 char}* location) \{\par
02382 {\cf21 #if GTEST_HAS_SEH}\par
02383   __try \{\par
02384     {\cf19 return} (object->*method)();\par
02385   \} __except (internal::UnitTestOptions::GTestShouldProcessSEH(  {\cf20 // NOLINT}\par
02386       GetExceptionCode())) \{\par
02387     {\cf20 // We create the exception message on the heap because VC++ prohibits}\par
02388     {\cf20 // creation of objects with destructors on stack in functions using __try}\par
02389     {\cf20 // (see error C2712).}\par
02390     std::string* exception_message = FormatSehExceptionMessage(\par
02391         GetExceptionCode(), location);\par
02392     internal::ReportFailureInUnknownLocation(TestPartResult::kFatalFailure,\par
02393                                              *exception_message);\par
02394     {\cf17 delete} exception_message;\par
02395     {\cf19 return} {\cf17 static_cast<}Result{\cf17 >}(0);\par
02396   \}\par
02397 {\cf21 #else}\par
02398   (void)location;\par
02399   {\cf19 return} (object->*method)();\par
02400 {\cf21 #endif  }{\cf20 // GTEST_HAS_SEH}\par
02401 \}\par
02402 \par
02403 {\cf20 // Runs the given method and catches and reports C++ and/or SEH-style}\par
02404 {\cf20 // exceptions, if they are supported; returns the 0-value for type}\par
02405 {\cf20 // Result in case of an SEH exception.}\par
02406 {\cf17 template} <{\cf17 class} T, {\cf17 typename} Result>\par
02407 Result HandleExceptionsInMethodIfSupported(\par
02408     T* {\cf18 object}, Result (T::*method)(), {\cf17 const} {\cf18 char}* location) \{\par
02409   {\cf20 // NOTE: The user code can affect the way in which Google Test handles}\par
02410   {\cf20 // exceptions by setting GTEST_FLAG(catch_exceptions), but only before}\par
02411   {\cf20 // RUN_ALL_TESTS() starts. It is technically possible to check the flag}\par
02412   {\cf20 // after the exception is caught and either report or re-throw the}\par
02413   {\cf20 // exception based on the flag's value:}\par
02414   {\cf20 //}\par
02415   {\cf20 // try \{}\par
02416   {\cf20 //   // Perform the test method.}\par
02417   {\cf20 // \} catch (...) \{}\par
02418   {\cf20 //   if (GTEST_FLAG(catch_exceptions))}\par
02419   {\cf20 //     // Report the exception as failure.}\par
02420   {\cf20 //   else}\par
02421   {\cf20 //     throw;  // Re-throws the original exception.}\par
02422   {\cf20 // \}}\par
02423   {\cf20 //}\par
02424   {\cf20 // However, the purpose of this flag is to allow the program to drop into}\par
02425   {\cf20 // the debugger when the exception is thrown. On most platforms, once the}\par
02426   {\cf20 // control enters the catch block, the exception origin information is}\par
02427   {\cf20 // lost and the debugger will stop the program at the point of the}\par
02428   {\cf20 // re-throw in this function -- instead of at the point of the original}\par
02429   {\cf20 // throw statement in the code under test.  For this reason, we perform}\par
02430   {\cf20 // the check early, sacrificing the ability to affect Google Test's}\par
02431   {\cf20 // exception handling in the method where the exception is thrown.}\par
02432   {\cf19 if} (internal::GetUnitTestImpl()->catch_exceptions()) \{\par
02433 {\cf21 #if GTEST_HAS_EXCEPTIONS}\par
02434     {\cf19 try} \{\par
02435       {\cf19 return} HandleSehExceptionsInMethodIfSupported({\cf18 object}, method, location);\par
02436     \} {\cf19 catch} ({\cf17 const} internal::GoogleTestFailureException&) \{  {\cf20 // NOLINT}\par
02437       {\cf20 // This exception type can only be thrown by a failed Google}\par
02438       {\cf20 // Test assertion with the intention of letting another testing}\par
02439       {\cf20 // framework catch it.  Therefore we just re-throw it.}\par
02440       {\cf19 throw};\par
02441     \} {\cf19 catch} ({\cf17 const} std::exception& e) \{  {\cf20 // NOLINT}\par
02442       internal::ReportFailureInUnknownLocation(\par
02443           TestPartResult::kFatalFailure,\par
02444           FormatCxxExceptionMessage(e.what(), location));\par
02445     \} {\cf19 catch} (...) \{  {\cf20 // NOLINT}\par
02446       internal::ReportFailureInUnknownLocation(\par
02447           TestPartResult::kFatalFailure,\par
02448           FormatCxxExceptionMessage(NULL, location));\par
02449     \}\par
02450     {\cf19 return} {\cf17 static_cast<}Result{\cf17 >}(0);\par
02451 {\cf21 #else}\par
02452     {\cf19 return} HandleSehExceptionsInMethodIfSupported({\cf18 object}, method, location);\par
02453 {\cf21 #endif  }{\cf20 // GTEST_HAS_EXCEPTIONS}\par
02454   \} {\cf19 else} \{\par
02455     {\cf19 return} (object->*method)();\par
02456   \}\par
02457 \}\par
02458 \par
02459 \}  {\cf20 // namespace internal}\par
02460 \par
02461 {\cf20 // Runs the test and updates the test result.}\par
02462 {\cf18 void} Test::Run() \{\par
02463   {\cf19 if} (!HasSameFixtureClass()) {\cf19 return};\par
02464 \par
02465   internal::UnitTestImpl* {\cf17 const} impl = internal::GetUnitTestImpl();\par
02466   impl->os_stack_trace_getter()->UponLeavingGTest();\par
02467   internal::HandleExceptionsInMethodIfSupported({\cf17 this}, &Test::SetUp, {\cf22 "SetUp()"});\par
02468   {\cf20 // We will run the test only if SetUp() was successful.}\par
02469   {\cf19 if} (!HasFatalFailure()) \{\par
02470     impl->os_stack_trace_getter()->UponLeavingGTest();\par
02471     internal::HandleExceptionsInMethodIfSupported(\par
02472         {\cf17 this}, &Test::TestBody, {\cf22 "the test body"});\par
02473   \}\par
02474 \par
02475   {\cf20 // However, we want to clean up as much as possible.  Hence we will}\par
02476   {\cf20 // always call TearDown(), even if SetUp() or the test body has}\par
02477   {\cf20 // failed.}\par
02478   impl->os_stack_trace_getter()->UponLeavingGTest();\par
02479   internal::HandleExceptionsInMethodIfSupported(\par
02480       {\cf17 this}, &Test::TearDown, {\cf22 "TearDown()"});\par
02481 \}\par
02482 \par
02483 {\cf20 // Returns true iff the current test has a fatal failure.}\par
02484 {\cf18 bool} Test::HasFatalFailure() \{\par
02485   {\cf19 return} internal::GetUnitTestImpl()->current_test_result()->HasFatalFailure();\par
02486 \}\par
02487 \par
02488 {\cf20 // Returns true iff the current test has a non-fatal failure.}\par
02489 {\cf18 bool} Test::HasNonfatalFailure() \{\par
02490   {\cf19 return} internal::GetUnitTestImpl()->current_test_result()->\par
02491       HasNonfatalFailure();\par
02492 \}\par
02493 \par
02494 {\cf20 // class TestInfo}\par
02495 \par
02496 {\cf20 // Constructs a TestInfo object. It assumes ownership of the test factory}\par
02497 {\cf20 // object.}\par
02498 TestInfo::TestInfo({\cf17 const} std::string& a_test_case_name,\par
02499                    {\cf17 const} std::string& a_name,\par
02500                    {\cf17 const} {\cf18 char}* a_type_param,\par
02501                    {\cf17 const} {\cf18 char}* a_value_param,\par
02502                    internal::CodeLocation a_code_location,\par
02503                    internal::TypeId fixture_class_id,\par
02504                    internal::TestFactoryBase* factory)\par
02505     : test_case_name_(a_test_case_name),\par
02506       name_(a_name),\par
02507       type_param_(a_type_param ? new std::string(a_type_param) : NULL),\par
02508       value_param_(a_value_param ? new std::string(a_value_param) : NULL),\par
02509       location_(a_code_location),\par
02510       fixture_class_id_(fixture_class_id),\par
02511       should_run_(false),\par
02512       is_disabled_(false),\par
02513       matches_filter_(false),\par
02514       factory_(factory),\par
02515       result_() \{\}\par
02516 \par
02517 {\cf20 // Destructs a TestInfo object.}\par
02518 TestInfo::~TestInfo() \{ {\cf17 delete} factory_; \}\par
02519 \par
02520 {\cf17 namespace }internal \{\par
02521 \par
02522 {\cf20 // Creates a new TestInfo object and registers it with Google Test;}\par
02523 {\cf20 // returns the created object.}\par
02524 {\cf20 //}\par
02525 {\cf20 // Arguments:}\par
02526 {\cf20 //}\par
02527 {\cf20 //   test_case_name:   name of the test case}\par
02528 {\cf20 //   name:             name of the test}\par
02529 {\cf20 //   type_param:       the name of the test's type parameter, or NULL if}\par
02530 {\cf20 //                     this is not a typed or a type-parameterized test.}\par
02531 {\cf20 //   value_param:      text representation of the test's value parameter,}\par
02532 {\cf20 //                     or NULL if this is not a value-parameterized test.}\par
02533 {\cf20 //   code_location:    code location where the test is defined}\par
02534 {\cf20 //   fixture_class_id: ID of the test fixture class}\par
02535 {\cf20 //   set_up_tc:        pointer to the function that sets up the test case}\par
02536 {\cf20 //   tear_down_tc:     pointer to the function that tears down the test case}\par
02537 {\cf20 //   factory:          pointer to the factory that creates a test object.}\par
02538 {\cf20 //                     The newly created TestInfo instance will assume}\par
02539 {\cf20 //                     ownership of the factory object.}\par
02540 TestInfo* MakeAndRegisterTestInfo(\par
02541     {\cf17 const} {\cf18 char}* test_case_name,\par
02542     {\cf17 const} {\cf18 char}* name,\par
02543     {\cf17 const} {\cf18 char}* type_param,\par
02544     {\cf17 const} {\cf18 char}* value_param,\par
02545     CodeLocation code_location,\par
02546     TypeId fixture_class_id,\par
02547     SetUpTestCaseFunc set_up_tc,\par
02548     TearDownTestCaseFunc tear_down_tc,\par
02549     TestFactoryBase* factory) \{\par
02550   TestInfo* {\cf17 const} test_info =\par
02551       {\cf17 new} TestInfo(test_case_name, name, type_param, value_param,\par
02552                    code_location, fixture_class_id, factory);\par
02553   GetUnitTestImpl()->AddTestInfo(set_up_tc, tear_down_tc, test_info);\par
02554   {\cf19 return} test_info;\par
02555 \}\par
02556 \par
02557 {\cf21 #if GTEST_HAS_PARAM_TEST}\par
02558 {\cf18 void} ReportInvalidTestCaseType({\cf17 const} {\cf18 char}* test_case_name,\par
02559                                CodeLocation code_location) \{\par
02560   Message errors;\par
02561   errors\par
02562       << {\cf22 "Attempted redefinition of test case "} << test_case_name << {\cf22 ".\\n"}\par
02563       << {\cf22 "All tests in the same test case must use the same test fixture\\n"}\par
02564       << {\cf22 "class.  However, in test case "} << test_case_name << {\cf22 ", you tried\\n"}\par
02565       << {\cf22 "to define a test using a fixture class different from the one\\n"}\par
02566       << {\cf22 "used earlier. This can happen if the two fixture classes are\\n"}\par
02567       << {\cf22 "from different namespaces and have the same name. You should\\n"}\par
02568       << {\cf22 "probably rename one of the classes to put the tests into different\\n"}\par
02569       << {\cf22 "test cases."};\par
02570 \par
02571   fprintf(stderr, {\cf22 "%s %s"},\par
02572           FormatFileLocation(code_location.file.c_str(),\par
02573                              code_location.line).c_str(),\par
02574           errors.GetString().c_str());\par
02575 \}\par
02576 {\cf21 #endif  }{\cf20 // GTEST_HAS_PARAM_TEST}\par
02577 \par
02578 \}  {\cf20 // namespace internal}\par
02579 \par
02580 {\cf17 namespace }\{\par
02581 \par
02582 {\cf20 // A predicate that checks the test name of a TestInfo against a known}\par
02583 {\cf20 // value.}\par
02584 {\cf20 //}\par
02585 {\cf20 // This is used for implementation of the TestCase class only.  We put}\par
02586 {\cf20 // it in the anonymous namespace to prevent polluting the outer}\par
02587 {\cf20 // namespace.}\par
02588 {\cf20 //}\par
02589 {\cf20 // TestNameIs is copyable.}\par
02590 {\cf17 class }TestNameIs \{\par
02591  {\cf17 public}:\par
02592   {\cf20 // Constructor.}\par
02593   {\cf20 //}\par
02594   {\cf20 // TestNameIs has NO default constructor.}\par
02595   {\cf17 explicit} TestNameIs({\cf17 const} {\cf18 char}* name)\par
02596       : name_(name) \{\}\par
02597 \par
02598   {\cf20 // Returns true iff the test name of test_info matches name_.}\par
02599   {\cf18 bool} operator()({\cf17 const} TestInfo * test_info){\cf17  const }\{\par
02600     {\cf19 return} test_info && test_info->name() == name_;\par
02601   \}\par
02602 \par
02603  {\cf17 private}:\par
02604   std::string name_;\par
02605 \};\par
02606 \par
02607 \}  {\cf20 // namespace}\par
02608 \par
02609 {\cf17 namespace }internal \{\par
02610 \par
02611 {\cf20 // This method expands all parameterized tests registered with macros TEST_P}\par
02612 {\cf20 // and INSTANTIATE_TEST_CASE_P into regular tests and registers those.}\par
02613 {\cf20 // This will be done just once during the program runtime.}\par
02614 {\cf18 void} UnitTestImpl::RegisterParameterizedTests() \{\par
02615 {\cf21 #if GTEST_HAS_PARAM_TEST}\par
02616   {\cf19 if} (!parameterized_tests_registered_) \{\par
02617     parameterized_test_registry_.RegisterTests();\par
02618     parameterized_tests_registered_ = {\cf17 true};\par
02619   \}\par
02620 {\cf21 #endif}\par
02621 \}\par
02622 \par
02623 \}  {\cf20 // namespace internal}\par
02624 \par
02625 {\cf20 // Creates the test object, runs it, records its result, and then}\par
02626 {\cf20 // deletes it.}\par
02627 {\cf18 void} TestInfo::Run() \{\par
02628   {\cf19 if} (!should_run_) {\cf19 return};\par
02629 \par
02630   {\cf20 // Tells UnitTest where to store test result.}\par
02631   internal::UnitTestImpl* {\cf17 const} impl = internal::GetUnitTestImpl();\par
02632   impl->set_current_test_info({\cf17 this});\par
02633 \par
02634   TestEventListener* repeater = UnitTest::GetInstance()->listeners().repeater();\par
02635 \par
02636   {\cf20 // Notifies the unit test event listeners that a test is about to start.}\par
02637   repeater->OnTestStart(*{\cf17 this});\par
02638 \par
02639   {\cf17 const} TimeInMillis start = internal::GetTimeInMillis();\par
02640 \par
02641   impl->os_stack_trace_getter()->UponLeavingGTest();\par
02642 \par
02643   {\cf20 // Creates the test object.}\par
02644   Test* {\cf17 const} test = internal::HandleExceptionsInMethodIfSupported(\par
02645       factory_, &internal::TestFactoryBase::CreateTest,\par
02646       {\cf22 "the test fixture's constructor"});\par
02647 \par
02648   {\cf20 // Runs the test only if the test object was created and its}\par
02649   {\cf20 // constructor didn't generate a fatal failure.}\par
02650   {\cf19 if} ((test != NULL) && !Test::HasFatalFailure()) \{\par
02651     {\cf20 // This doesn't throw as all user code that can throw are wrapped into}\par
02652     {\cf20 // exception handling code.}\par
02653     test->Run();\par
02654   \}\par
02655 \par
02656   {\cf20 // Deletes the test object.}\par
02657   impl->os_stack_trace_getter()->UponLeavingGTest();\par
02658   internal::HandleExceptionsInMethodIfSupported(\par
02659       test, &Test::DeleteSelf_, {\cf22 "the test fixture's destructor"});\par
02660 \par
02661   result_.set_elapsed_time(internal::GetTimeInMillis() - start);\par
02662 \par
02663   {\cf20 // Notifies the unit test event listener that a test has just finished.}\par
02664   repeater->OnTestEnd(*{\cf17 this});\par
02665 \par
02666   {\cf20 // Tells UnitTest to stop associating assertion results to this}\par
02667   {\cf20 // test.}\par
02668   impl->set_current_test_info(NULL);\par
02669 \}\par
02670 \par
02671 {\cf20 // class TestCase}\par
02672 \par
02673 {\cf20 // Gets the number of successful tests in this test case.}\par
02674 {\cf18 int} TestCase::successful_test_count(){\cf17  const }\{\par
02675   {\cf19 return} CountIf(test_info_list_, TestPassed);\par
02676 \}\par
02677 \par
02678 {\cf20 // Gets the number of failed tests in this test case.}\par
02679 {\cf18 int} TestCase::failed_test_count(){\cf17  const }\{\par
02680   {\cf19 return} CountIf(test_info_list_, TestFailed);\par
02681 \}\par
02682 \par
02683 {\cf20 // Gets the number of disabled tests that will be reported in the XML report.}\par
02684 {\cf18 int} TestCase::reportable_disabled_test_count(){\cf17  const }\{\par
02685   {\cf19 return} CountIf(test_info_list_, TestReportableDisabled);\par
02686 \}\par
02687 \par
02688 {\cf20 // Gets the number of disabled tests in this test case.}\par
02689 {\cf18 int} TestCase::disabled_test_count(){\cf17  const }\{\par
02690   {\cf19 return} CountIf(test_info_list_, TestDisabled);\par
02691 \}\par
02692 \par
02693 {\cf20 // Gets the number of tests to be printed in the XML report.}\par
02694 {\cf18 int} TestCase::reportable_test_count(){\cf17  const }\{\par
02695   {\cf19 return} CountIf(test_info_list_, TestReportable);\par
02696 \}\par
02697 \par
02698 {\cf20 // Get the number of tests in this test case that should run.}\par
02699 {\cf18 int} TestCase::test_to_run_count(){\cf17  const }\{\par
02700   {\cf19 return} CountIf(test_info_list_, ShouldRunTest);\par
02701 \}\par
02702 \par
02703 {\cf20 // Gets the number of all tests.}\par
02704 {\cf18 int} TestCase::total_test_count(){\cf17  const }\{\par
02705   {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(test_info_list_.size());\par
02706 \}\par
02707 \par
02708 {\cf20 // Creates a TestCase with the given name.}\par
02709 {\cf20 //}\par
02710 {\cf20 // Arguments:}\par
02711 {\cf20 //}\par
02712 {\cf20 //   name:         name of the test case}\par
02713 {\cf20 //   a_type_param: the name of the test case's type parameter, or NULL if}\par
02714 {\cf20 //                 this is not a typed or a type-parameterized test case.}\par
02715 {\cf20 //   set_up_tc:    pointer to the function that sets up the test case}\par
02716 {\cf20 //   tear_down_tc: pointer to the function that tears down the test case}\par
02717 TestCase::TestCase({\cf17 const} {\cf18 char}* a_name, {\cf17 const} {\cf18 char}* a_type_param,\par
02718                    Test::SetUpTestCaseFunc set_up_tc,\par
02719                    Test::TearDownTestCaseFunc tear_down_tc)\par
02720     : name_(a_name),\par
02721       type_param_(a_type_param ? new std::string(a_type_param) : NULL),\par
02722       set_up_tc_(set_up_tc),\par
02723       tear_down_tc_(tear_down_tc),\par
02724       should_run_(false),\par
02725       elapsed_time_(0) \{\par
02726 \}\par
02727 \par
02728 {\cf20 // Destructor of TestCase.}\par
02729 TestCase::~TestCase() \{\par
02730   {\cf20 // Deletes every Test in the collection.}\par
02731   ForEach(test_info_list_, internal::Delete<TestInfo>);\par
02732 \}\par
02733 \par
02734 {\cf20 // Returns the i-th test among all the tests. i can range from 0 to}\par
02735 {\cf20 // total_test_count() - 1. If i is not in that range, returns NULL.}\par
02736 {\cf17 const} TestInfo* TestCase::GetTestInfo({\cf18 int} i){\cf17  const }\{\par
02737   {\cf17 const} {\cf18 int} index = GetElementOr(test_indices_, i, -1);\par
02738   {\cf19 return} index < 0 ? NULL : test_info_list_[index];\par
02739 \}\par
02740 \par
02741 {\cf20 // Returns the i-th test among all the tests. i can range from 0 to}\par
02742 {\cf20 // total_test_count() - 1. If i is not in that range, returns NULL.}\par
02743 TestInfo* TestCase::GetMutableTestInfo({\cf18 int} i) \{\par
02744   {\cf17 const} {\cf18 int} index = GetElementOr(test_indices_, i, -1);\par
02745   {\cf19 return} index < 0 ? NULL : test_info_list_[index];\par
02746 \}\par
02747 \par
02748 {\cf20 // Adds a test to this test case.  Will delete the test upon}\par
02749 {\cf20 // destruction of the TestCase object.}\par
02750 {\cf18 void} TestCase::AddTestInfo(TestInfo * test_info) \{\par
02751   test_info_list_.push_back(test_info);\par
02752   test_indices_.push_back({\cf17 static_cast<}{\cf18 int}{\cf17 >}(test_indices_.size()));\par
02753 \}\par
02754 \par
02755 {\cf20 // Runs every test in this TestCase.}\par
02756 {\cf18 void} TestCase::Run() \{\par
02757   {\cf19 if} (!should_run_) {\cf19 return};\par
02758 \par
02759   internal::UnitTestImpl* {\cf17 const} impl = internal::GetUnitTestImpl();\par
02760   impl->set_current_test_case({\cf17 this});\par
02761 \par
02762   TestEventListener* repeater = UnitTest::GetInstance()->listeners().repeater();\par
02763 \par
02764   repeater->OnTestCaseStart(*{\cf17 this});\par
02765   impl->os_stack_trace_getter()->UponLeavingGTest();\par
02766   internal::HandleExceptionsInMethodIfSupported(\par
02767       {\cf17 this}, &TestCase::RunSetUpTestCase, {\cf22 "SetUpTestCase()"});\par
02768 \par
02769   {\cf17 const} internal::TimeInMillis start = internal::GetTimeInMillis();\par
02770   {\cf19 for} ({\cf18 int} i = 0; i < total_test_count(); i++) \{\par
02771     GetMutableTestInfo(i)->Run();\par
02772   \}\par
02773   elapsed_time_ = internal::GetTimeInMillis() - start;\par
02774 \par
02775   impl->os_stack_trace_getter()->UponLeavingGTest();\par
02776   internal::HandleExceptionsInMethodIfSupported(\par
02777       {\cf17 this}, &TestCase::RunTearDownTestCase, {\cf22 "TearDownTestCase()"});\par
02778 \par
02779   repeater->OnTestCaseEnd(*{\cf17 this});\par
02780   impl->set_current_test_case(NULL);\par
02781 \}\par
02782 \par
02783 {\cf20 // Clears the results of all tests in this test case.}\par
02784 {\cf18 void} TestCase::ClearResult() \{\par
02785   ad_hoc_test_result_.Clear();\par
02786   ForEach(test_info_list_, TestInfo::ClearTestResult);\par
02787 \}\par
02788 \par
02789 {\cf20 // Shuffles the tests in this test case.}\par
02790 {\cf18 void} TestCase::ShuffleTests(internal::Random* random) \{\par
02791   Shuffle(random, &test_indices_);\par
02792 \}\par
02793 \par
02794 {\cf20 // Restores the test order to before the first shuffle.}\par
02795 {\cf18 void} TestCase::UnshuffleTests() \{\par
02796   {\cf19 for} ({\cf18 size_t} i = 0; i < test_indices_.size(); i++) \{\par
02797     test_indices_[i] = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(i);\par
02798   \}\par
02799 \}\par
02800 \par
02801 {\cf20 // Formats a countable noun.  Depending on its quantity, either the}\par
02802 {\cf20 // singular form or the plural form is used. e.g.}\par
02803 {\cf20 //}\par
02804 {\cf20 // FormatCountableNoun(1, "formula", "formuli") returns "1 formula".}\par
02805 {\cf20 // FormatCountableNoun(5, "book", "books") returns "5 books".}\par
02806 {\cf17 static} std::string FormatCountableNoun({\cf18 int} count,\par
02807                                        {\cf17 const} {\cf18 char} * singular_form,\par
02808                                        {\cf17 const} {\cf18 char} * plural_form) \{\par
02809   {\cf19 return} internal::StreamableToString(count) + {\cf22 " "} +\par
02810       (count == 1 ? singular_form : plural_form);\par
02811 \}\par
02812 \par
02813 {\cf20 // Formats the count of tests.}\par
02814 {\cf17 static} std::string FormatTestCount({\cf18 int} test_count) \{\par
02815   {\cf19 return} FormatCountableNoun(test_count, {\cf22 "test"}, {\cf22 "tests"});\par
02816 \}\par
02817 \par
02818 {\cf20 // Formats the count of test cases.}\par
02819 {\cf17 static} std::string FormatTestCaseCount({\cf18 int} test_case_count) \{\par
02820   {\cf19 return} FormatCountableNoun(test_case_count, {\cf22 "test case"}, {\cf22 "test cases"});\par
02821 \}\par
02822 \par
02823 {\cf20 // Converts a TestPartResult::Type enum to human-friendly string}\par
02824 {\cf20 // representation.  Both kNonFatalFailure and kFatalFailure are translated}\par
02825 {\cf20 // to "Failure", as the user usually doesn't care about the difference}\par
02826 {\cf20 // between the two when viewing the test result.}\par
02827 {\cf17 static} {\cf17 const} {\cf18 char} * TestPartResultTypeToString(TestPartResult::Type type) \{\par
02828   {\cf19 switch} (type) \{\par
02829     {\cf19 case} TestPartResult::kSuccess:\par
02830       {\cf19 return} {\cf22 "Success"};\par
02831 \par
02832     {\cf19 case} TestPartResult::kNonFatalFailure:\par
02833     {\cf19 case} TestPartResult::kFatalFailure:\par
02834 {\cf21 #ifdef _MSC_VER}\par
02835       {\cf19 return} {\cf22 "error: "};\par
02836 {\cf21 #else}\par
02837       {\cf19 return} {\cf22 "Failure\\n"};\par
02838 {\cf21 #endif}\par
02839     {\cf19 default}:\par
02840       {\cf19 return} {\cf22 "Unknown result type"};\par
02841   \}\par
02842 \}\par
02843 \par
02844 {\cf17 namespace }internal \{\par
02845 \par
02846 {\cf20 // Prints a TestPartResult to an std::string.}\par
02847 {\cf17 static} std::string PrintTestPartResultToString(\par
02848     {\cf17 const} TestPartResult& test_part_result) \{\par
02849   {\cf19 return} (Message()\par
02850           << internal::FormatFileLocation(test_part_result.file_name(),\par
02851                                           test_part_result.line_number())\par
02852           << {\cf22 " "} << TestPartResultTypeToString(test_part_result.type())\par
02853           << test_part_result.message()).GetString();\par
02854 \}\par
02855 \par
02856 {\cf20 // Prints a TestPartResult.}\par
02857 {\cf17 static} {\cf18 void} PrintTestPartResult({\cf17 const} TestPartResult& test_part_result) \{\par
02858   {\cf17 const} std::string& result =\par
02859       PrintTestPartResultToString(test_part_result);\par
02860   printf({\cf22 "%s\\n"}, result.c_str());\par
02861   fflush(stdout);\par
02862   {\cf20 // If the test program runs in Visual Studio or a debugger, the}\par
02863   {\cf20 // following statements add the test part result message to the Output}\par
02864   {\cf20 // window such that the user can double-click on it to jump to the}\par
02865   {\cf20 // corresponding source code location; otherwise they do nothing.}\par
02866 {\cf21 #if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE}\par
02867   {\cf20 // We don't call OutputDebugString*() on Windows Mobile, as printing}\par
02868   {\cf20 // to stdout is done by OutputDebugString() there already - we don't}\par
02869   {\cf20 // want the same message printed twice.}\par
02870   ::OutputDebugStringA(result.c_str());\par
02871   ::OutputDebugStringA({\cf22 "\\n"});\par
02872 {\cf21 #endif}\par
02873 \}\par
02874 \par
02875 {\cf20 // class PrettyUnitTestResultPrinter}\par
02876 \par
02877 {\cf17 enum} GTestColor \{\par
02878   COLOR_DEFAULT,\par
02879   COLOR_RED,\par
02880   COLOR_GREEN,\par
02881   COLOR_YELLOW\par
02882 \};\par
02883 \par
02884 {\cf21 #if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE && \\}\par
02885 {\cf21     !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT}\par
02886 \par
02887 {\cf20 // Returns the character attribute for the given color.}\par
02888 WORD GetColorAttribute(GTestColor color) \{\par
02889   {\cf19 switch} (color) \{\par
02890     {\cf19 case} COLOR_RED:    {\cf19 return} FOREGROUND_RED;\par
02891     {\cf19 case} COLOR_GREEN:  {\cf19 return} FOREGROUND_GREEN;\par
02892     {\cf19 case} COLOR_YELLOW: {\cf19 return} FOREGROUND_RED | FOREGROUND_GREEN;\par
02893     {\cf19 default}:           {\cf19 return} 0;\par
02894   \}\par
02895 \}\par
02896 \par
02897 {\cf21 #else}\par
02898 \par
02899 {\cf20 // Returns the ANSI color code for the given color.  COLOR_DEFAULT is}\par
02900 {\cf20 // an invalid input.}\par
02901 {\cf17 const} {\cf18 char}* GetAnsiColorCode(GTestColor color) \{\par
02902   {\cf19 switch} (color) \{\par
02903     {\cf19 case} COLOR_RED:     {\cf19 return} {\cf22 "1"};\par
02904     {\cf19 case} COLOR_GREEN:   {\cf19 return} {\cf22 "2"};\par
02905     {\cf19 case} COLOR_YELLOW:  {\cf19 return} {\cf22 "3"};\par
02906     {\cf19 default}:            {\cf19 return} NULL;\par
02907   \};\par
02908 \}\par
02909 \par
02910 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE}\par
02911 \par
02912 {\cf20 // Returns true iff Google Test should use colors in the output.}\par
02913 {\cf18 bool} ShouldUseColor({\cf18 bool} stdout_is_tty) \{\par
02914   {\cf17 const} {\cf18 char}* {\cf17 const} gtest_color = GTEST_FLAG(color).c_str();\par
02915 \par
02916   {\cf19 if} (String::CaseInsensitiveCStringEquals(gtest_color, {\cf22 "auto"})) \{\par
02917 {\cf21 #if GTEST_OS_WINDOWS}\par
02918     {\cf20 // On Windows the TERM variable is usually not set, but the}\par
02919     {\cf20 // console there does support colors.}\par
02920     {\cf19 return} stdout_is_tty;\par
02921 {\cf21 #else}\par
02922     {\cf20 // On non-Windows platforms, we rely on the TERM variable.}\par
02923     {\cf17 const} {\cf18 char}* {\cf17 const} term = posix::GetEnv({\cf22 "TERM"});\par
02924     {\cf17 const} {\cf18 bool} term_supports_color =\par
02925         String::CStringEquals(term, {\cf22 "xterm"}) ||\par
02926         String::CStringEquals(term, {\cf22 "xterm-color"}) ||\par
02927         String::CStringEquals(term, {\cf22 "xterm-256color"}) ||\par
02928         String::CStringEquals(term, {\cf22 "screen"}) ||\par
02929         String::CStringEquals(term, {\cf22 "screen-256color"}) ||\par
02930         String::CStringEquals(term, {\cf22 "tmux"}) ||\par
02931         String::CStringEquals(term, {\cf22 "tmux-256color"}) ||\par
02932         String::CStringEquals(term, {\cf22 "rxvt-unicode"}) ||\par
02933         String::CStringEquals(term, {\cf22 "rxvt-unicode-256color"}) ||\par
02934         String::CStringEquals(term, {\cf22 "linux"}) ||\par
02935         String::CStringEquals(term, {\cf22 "cygwin"});\par
02936     {\cf19 return} stdout_is_tty && term_supports_color;\par
02937 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
02938   \}\par
02939 \par
02940   {\cf19 return} String::CaseInsensitiveCStringEquals(gtest_color, {\cf22 "yes"}) ||\par
02941       String::CaseInsensitiveCStringEquals(gtest_color, {\cf22 "true"}) ||\par
02942       String::CaseInsensitiveCStringEquals(gtest_color, {\cf22 "t"}) ||\par
02943       String::CStringEquals(gtest_color, {\cf22 "1"});\par
02944   {\cf20 // We take "yes", "true", "t", and "1" as meaning "yes".  If the}\par
02945   {\cf20 // value is neither one of these nor "auto", we treat it as "no" to}\par
02946   {\cf20 // be conservative.}\par
02947 \}\par
02948 \par
02949 {\cf20 // Helpers for printing colored strings to stdout. Note that on Windows, we}\par
02950 {\cf20 // cannot simply emit special characters and have the terminal change colors.}\par
02951 {\cf20 // This routine must actually emit the characters rather than return a string}\par
02952 {\cf20 // that would be colored when printed, as can be done on Linux.}\par
02953 GTEST_ATTRIBUTE_PRINTF_(2, 3)\par
02954 void ColoredPrintf(GTestColor color, const {\cf18 char}* fmt, ...) \{\par
02955   va_list args;\par
02956   va_start(args, fmt);\par
02957 \par
02958 {\cf21 #if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || GTEST_OS_ZOS || \\}\par
02959 {\cf21     GTEST_OS_IOS || GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT}\par
02960   {\cf17 const} {\cf18 bool} use_color = AlwaysFalse();\par
02961 {\cf21 #else}\par
02962   {\cf17 static} {\cf17 const} {\cf18 bool} in_color_mode =\par
02963       ShouldUseColor(posix::IsATTY(posix::FileNo(stdout)) != 0);\par
02964   {\cf17 const} {\cf18 bool} use_color = in_color_mode && (color != COLOR_DEFAULT);\par
02965 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || GTEST_OS_ZOS}\par
02966   {\cf20 // The '!= 0' comparison is necessary to satisfy MSVC 7.1.}\par
02967 \par
02968   {\cf19 if} (!use_color) \{\par
02969     vprintf(fmt, args);\par
02970     va_end(args);\par
02971     {\cf19 return};\par
02972   \}\par
02973 \par
02974 {\cf21 #if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE && \\}\par
02975 {\cf21     !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT}\par
02976   {\cf17 const} HANDLE stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE);\par
02977 \par
02978   {\cf20 // Gets the current text color.}\par
02979   CONSOLE_SCREEN_BUFFER_INFO buffer_info;\par
02980   GetConsoleScreenBufferInfo(stdout_handle, &buffer_info);\par
02981   {\cf17 const} WORD old_color_attrs = buffer_info.wAttributes;\par
02982 \par
02983   {\cf20 // We need to flush the stream buffers into the console before each}\par
02984   {\cf20 // SetConsoleTextAttribute call lest it affect the text that is already}\par
02985   {\cf20 // printed but has not yet reached the console.}\par
02986   fflush(stdout);\par
02987   SetConsoleTextAttribute(stdout_handle,\par
02988                           GetColorAttribute(color) | FOREGROUND_INTENSITY);\par
02989   vprintf(fmt, args);\par
02990 \par
02991   fflush(stdout);\par
02992   {\cf20 // Restores the text color.}\par
02993   SetConsoleTextAttribute(stdout_handle, old_color_attrs);\par
02994 {\cf21 #else}\par
02995   printf({\cf22 "\\033[0;3%sm"}, GetAnsiColorCode(color));\par
02996   vprintf(fmt, args);\par
02997   printf({\cf22 "\\033[m"});  {\cf20 // Resets the terminal to default.}\par
02998 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MOBILE}\par
02999   va_end(args);\par
03000 \}\par
03001 \par
03002 {\cf20 // Text printed in Google Test's text output and --gunit_list_tests}\par
03003 {\cf20 // output to label the type parameter and value parameter for a test.}\par
03004 {\cf17 static} {\cf17 const} {\cf18 char} kTypeParamLabel[] = {\cf22 "TypeParam"};\par
03005 {\cf17 static} {\cf17 const} {\cf18 char} kValueParamLabel[] = {\cf22 "GetParam()"};\par
03006 \par
03007 {\cf18 void} PrintFullTestCommentIfPresent({\cf17 const} TestInfo& test_info) \{\par
03008   {\cf17 const} {\cf18 char}* {\cf17 const} type_param = test_info.type_param();\par
03009   {\cf17 const} {\cf18 char}* {\cf17 const} value_param = test_info.value_param();\par
03010 \par
03011   {\cf19 if} (type_param != NULL || value_param != NULL) \{\par
03012     printf({\cf22 ", where "});\par
03013     {\cf19 if} (type_param != NULL) \{\par
03014       printf({\cf22 "%s = %s"}, kTypeParamLabel, type_param);\par
03015       {\cf19 if} (value_param != NULL)\par
03016         printf({\cf22 " and "});\par
03017     \}\par
03018     {\cf19 if} (value_param != NULL) \{\par
03019       printf({\cf22 "%s = %s"}, kValueParamLabel, value_param);\par
03020     \}\par
03021   \}\par
03022 \}\par
03023 \par
03024 {\cf20 // This class implements the TestEventListener interface.}\par
03025 {\cf20 //}\par
03026 {\cf20 // Class PrettyUnitTestResultPrinter is copyable.}\par
03027 {\cf17 class }PrettyUnitTestResultPrinter : {\cf17 public} TestEventListener \{\par
03028  {\cf17 public}:\par
03029   PrettyUnitTestResultPrinter() \{\}\par
03030   {\cf17 static} {\cf18 void} PrintTestName({\cf17 const} {\cf18 char} * test_case, {\cf17 const} {\cf18 char} * test) \{\par
03031     printf({\cf22 "%s.%s"}, test_case, test);\par
03032   \}\par
03033 \par
03034   {\cf20 // The following methods override what's in the TestEventListener class.}\par
03035   {\cf17 virtual} {\cf18 void} OnTestProgramStart({\cf17 const} UnitTest& {\cf20 /*unit_test*/}) \{\}\par
03036   {\cf17 virtual} {\cf18 void} OnTestIterationStart({\cf17 const} UnitTest& unit_test, {\cf18 int} iteration);\par
03037   {\cf17 virtual} {\cf18 void} OnEnvironmentsSetUpStart({\cf17 const} UnitTest& unit_test);\par
03038   {\cf17 virtual} {\cf18 void} OnEnvironmentsSetUpEnd({\cf17 const} UnitTest& {\cf20 /*unit_test*/}) \{\}\par
03039   {\cf17 virtual} {\cf18 void} OnTestCaseStart({\cf17 const} TestCase& test_case);\par
03040   {\cf17 virtual} {\cf18 void} OnTestStart({\cf17 const} TestInfo& test_info);\par
03041   {\cf17 virtual} {\cf18 void} OnTestPartResult({\cf17 const} TestPartResult& result);\par
03042   {\cf17 virtual} {\cf18 void} OnTestEnd({\cf17 const} TestInfo& test_info);\par
03043   {\cf17 virtual} {\cf18 void} OnTestCaseEnd({\cf17 const} TestCase& test_case);\par
03044   {\cf17 virtual} {\cf18 void} OnEnvironmentsTearDownStart({\cf17 const} UnitTest& unit_test);\par
03045   {\cf17 virtual} {\cf18 void} OnEnvironmentsTearDownEnd({\cf17 const} UnitTest& {\cf20 /*unit_test*/}) \{\}\par
03046   {\cf17 virtual} {\cf18 void} OnTestIterationEnd({\cf17 const} UnitTest& unit_test, {\cf18 int} iteration);\par
03047   {\cf17 virtual} {\cf18 void} OnTestProgramEnd({\cf17 const} UnitTest& {\cf20 /*unit_test*/}) \{\}\par
03048 \par
03049  {\cf17 private}:\par
03050   {\cf17 static} {\cf18 void} PrintFailedTests({\cf17 const} UnitTest& unit_test);\par
03051 \};\par
03052 \par
03053   {\cf20 // Fired before each iteration of tests starts.}\par
03054 {\cf18 void} PrettyUnitTestResultPrinter::OnTestIterationStart(\par
03055     {\cf17 const} UnitTest& unit_test, {\cf18 int} iteration) \{\par
03056   {\cf19 if} (GTEST_FLAG(repeat) != 1)\par
03057     printf({\cf22 "\\nRepeating all tests (iteration %d) . . .\\n\\n"}, iteration + 1);\par
03058 \par
03059   {\cf17 const} {\cf18 char}* {\cf17 const} filter = GTEST_FLAG(filter).c_str();\par
03060 \par
03061   {\cf20 // Prints the filter if it's not *.  This reminds the user that some}\par
03062   {\cf20 // tests may be skipped.}\par
03063   {\cf19 if} (!String::CStringEquals(filter, kUniversalFilter)) \{\par
03064     ColoredPrintf(COLOR_YELLOW,\par
03065                   {\cf22 "Note: %s filter = %s\\n"}, GTEST_NAME_, filter);\par
03066   \}\par
03067 \par
03068   {\cf19 if} (internal::ShouldShard(kTestTotalShards, kTestShardIndex, {\cf17 false})) \{\par
03069     {\cf17 const} Int32 shard_index = Int32FromEnvOrDie(kTestShardIndex, -1);\par
03070     ColoredPrintf(COLOR_YELLOW,\par
03071                   {\cf22 "Note: This is test shard %d of %s.\\n"},\par
03072                   {\cf17 static_cast<}{\cf18 int}{\cf17 >}(shard_index) + 1,\par
03073                   internal::posix::GetEnv(kTestTotalShards));\par
03074   \}\par
03075 \par
03076   {\cf19 if} (GTEST_FLAG(shuffle)) \{\par
03077     ColoredPrintf(COLOR_YELLOW,\par
03078                   {\cf22 "Note: Randomizing tests' orders with a seed of %d .\\n"},\par
03079                   unit_test.random_seed());\par
03080   \}\par
03081 \par
03082   ColoredPrintf(COLOR_GREEN,  {\cf22 "[==========] "});\par
03083   printf({\cf22 "Running %s from %s.\\n"},\par
03084          FormatTestCount(unit_test.test_to_run_count()).c_str(),\par
03085          FormatTestCaseCount(unit_test.test_case_to_run_count()).c_str());\par
03086   fflush(stdout);\par
03087 \}\par
03088 \par
03089 {\cf18 void} PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart(\par
03090     {\cf17 const} UnitTest& {\cf20 /*unit_test*/}) \{\par
03091   ColoredPrintf(COLOR_GREEN,  {\cf22 "[----------] "});\par
03092   printf({\cf22 "Global test environment set-up.\\n"});\par
03093   fflush(stdout);\par
03094 \}\par
03095 \par
03096 {\cf18 void} PrettyUnitTestResultPrinter::OnTestCaseStart({\cf17 const} TestCase& test_case) \{\par
03097   {\cf17 const} std::string counts =\par
03098       FormatCountableNoun(test_case.test_to_run_count(), {\cf22 "test"}, {\cf22 "tests"});\par
03099   ColoredPrintf(COLOR_GREEN, {\cf22 "[----------] "});\par
03100   printf({\cf22 "%s from %s"}, counts.c_str(), test_case.name());\par
03101   {\cf19 if} (test_case.type_param() == NULL) \{\par
03102     printf({\cf22 "\\n"});\par
03103   \} {\cf19 else} \{\par
03104     printf({\cf22 ", where %s = %s\\n"}, kTypeParamLabel, test_case.type_param());\par
03105   \}\par
03106   fflush(stdout);\par
03107 \}\par
03108 \par
03109 {\cf18 void} PrettyUnitTestResultPrinter::OnTestStart({\cf17 const} TestInfo& test_info) \{\par
03110   ColoredPrintf(COLOR_GREEN,  {\cf22 "[ RUN      ] "});\par
03111   PrintTestName(test_info.test_case_name(), test_info.name());\par
03112   printf({\cf22 "\\n"});\par
03113   fflush(stdout);\par
03114 \}\par
03115 \par
03116 {\cf20 // Called after an assertion failure.}\par
03117 {\cf18 void} PrettyUnitTestResultPrinter::OnTestPartResult(\par
03118     {\cf17 const} TestPartResult& result) \{\par
03119   {\cf20 // If the test part succeeded, we don't need to do anything.}\par
03120   {\cf19 if} (result.type() == TestPartResult::kSuccess)\par
03121     {\cf19 return};\par
03122 \par
03123   {\cf20 // Print failure message from the assertion (e.g. expected this and got that).}\par
03124   PrintTestPartResult(result);\par
03125   fflush(stdout);\par
03126 \}\par
03127 \par
03128 {\cf18 void} PrettyUnitTestResultPrinter::OnTestEnd({\cf17 const} TestInfo& test_info) \{\par
03129   {\cf19 if} (test_info.result()->Passed()) \{\par
03130     ColoredPrintf(COLOR_GREEN, {\cf22 "[       OK ] "});\par
03131   \} {\cf19 else} \{\par
03132     ColoredPrintf(COLOR_RED, {\cf22 "[  FAILED  ] "});\par
03133   \}\par
03134   PrintTestName(test_info.test_case_name(), test_info.name());\par
03135   {\cf19 if} (test_info.result()->Failed())\par
03136     PrintFullTestCommentIfPresent(test_info);\par
03137 \par
03138   {\cf19 if} (GTEST_FLAG(print_time)) \{\par
03139     printf({\cf22 " (%s ms)\\n"}, internal::StreamableToString(\par
03140            test_info.result()->elapsed_time()).c_str());\par
03141   \} {\cf19 else} \{\par
03142     printf({\cf22 "\\n"});\par
03143   \}\par
03144   fflush(stdout);\par
03145 \}\par
03146 \par
03147 {\cf18 void} PrettyUnitTestResultPrinter::OnTestCaseEnd({\cf17 const} TestCase& test_case) \{\par
03148   {\cf19 if} (!GTEST_FLAG(print_time)) {\cf19 return};\par
03149 \par
03150   {\cf17 const} std::string counts =\par
03151       FormatCountableNoun(test_case.test_to_run_count(), {\cf22 "test"}, {\cf22 "tests"});\par
03152   ColoredPrintf(COLOR_GREEN, {\cf22 "[----------] "});\par
03153   printf({\cf22 "%s from %s (%s ms total)\\n\\n"},\par
03154          counts.c_str(), test_case.name(),\par
03155          internal::StreamableToString(test_case.elapsed_time()).c_str());\par
03156   fflush(stdout);\par
03157 \}\par
03158 \par
03159 {\cf18 void} PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart(\par
03160     {\cf17 const} UnitTest& {\cf20 /*unit_test*/}) \{\par
03161   ColoredPrintf(COLOR_GREEN,  {\cf22 "[----------] "});\par
03162   printf({\cf22 "Global test environment tear-down\\n"});\par
03163   fflush(stdout);\par
03164 \}\par
03165 \par
03166 {\cf20 // Internal helper for printing the list of failed tests.}\par
03167 {\cf18 void} PrettyUnitTestResultPrinter::PrintFailedTests({\cf17 const} UnitTest& unit_test) \{\par
03168   {\cf17 const} {\cf18 int} failed_test_count = unit_test.failed_test_count();\par
03169   {\cf19 if} (failed_test_count == 0) \{\par
03170     {\cf19 return};\par
03171   \}\par
03172 \par
03173   {\cf19 for} ({\cf18 int} i = 0; i < unit_test.total_test_case_count(); ++i) \{\par
03174     {\cf17 const} TestCase& test_case = *unit_test.GetTestCase(i);\par
03175     {\cf19 if} (!test_case.should_run() || (test_case.failed_test_count() == 0)) \{\par
03176       {\cf19 continue};\par
03177     \}\par
03178     {\cf19 for} ({\cf18 int} j = 0; j < test_case.total_test_count(); ++j) \{\par
03179       {\cf17 const} TestInfo& test_info = *test_case.GetTestInfo(j);\par
03180       {\cf19 if} (!test_info.should_run() || test_info.result()->Passed()) \{\par
03181         {\cf19 continue};\par
03182       \}\par
03183       ColoredPrintf(COLOR_RED, {\cf22 "[  FAILED  ] "});\par
03184       printf({\cf22 "%s.%s"}, test_case.name(), test_info.name());\par
03185       PrintFullTestCommentIfPresent(test_info);\par
03186       printf({\cf22 "\\n"});\par
03187     \}\par
03188   \}\par
03189 \}\par
03190 \par
03191 {\cf18 void} PrettyUnitTestResultPrinter::OnTestIterationEnd({\cf17 const} UnitTest& unit_test,\par
03192                                                      {\cf18 int} {\cf20 /*iteration*/}) \{\par
03193   ColoredPrintf(COLOR_GREEN,  {\cf22 "[==========] "});\par
03194   printf({\cf22 "%s from %s ran."},\par
03195          FormatTestCount(unit_test.test_to_run_count()).c_str(),\par
03196          FormatTestCaseCount(unit_test.test_case_to_run_count()).c_str());\par
03197   {\cf19 if} (GTEST_FLAG(print_time)) \{\par
03198     printf({\cf22 " (%s ms total)"},\par
03199            internal::StreamableToString(unit_test.elapsed_time()).c_str());\par
03200   \}\par
03201   printf({\cf22 "\\n"});\par
03202   ColoredPrintf(COLOR_GREEN,  {\cf22 "[  PASSED  ] "});\par
03203   printf({\cf22 "%s.\\n"}, FormatTestCount(unit_test.successful_test_count()).c_str());\par
03204 \par
03205   {\cf18 int} num_failures = unit_test.failed_test_count();\par
03206   {\cf19 if} (!unit_test.Passed()) \{\par
03207     {\cf17 const} {\cf18 int} failed_test_count = unit_test.failed_test_count();\par
03208     ColoredPrintf(COLOR_RED,  {\cf22 "[  FAILED  ] "});\par
03209     printf({\cf22 "%s, listed below:\\n"}, FormatTestCount(failed_test_count).c_str());\par
03210     PrintFailedTests(unit_test);\par
03211     printf({\cf22 "\\n%2d FAILED %s\\n"}, num_failures,\par
03212                         num_failures == 1 ? {\cf22 "TEST"} : {\cf22 "TESTS"});\par
03213   \}\par
03214 \par
03215   {\cf18 int} num_disabled = unit_test.reportable_disabled_test_count();\par
03216   {\cf19 if} (num_disabled && !GTEST_FLAG(also_run_disabled_tests)) \{\par
03217     {\cf19 if} (!num_failures) \{\par
03218       printf({\cf22 "\\n"});  {\cf20 // Add a spacer if no FAILURE banner is displayed.}\par
03219     \}\par
03220     ColoredPrintf(COLOR_YELLOW,\par
03221                   {\cf22 "  YOU HAVE %d DISABLED %s\\n\\n"},\par
03222                   num_disabled,\par
03223                   num_disabled == 1 ? {\cf22 "TEST"} : {\cf22 "TESTS"});\par
03224   \}\par
03225   {\cf20 // Ensure that Google Test output is printed before, e.g., heapchecker output.}\par
03226   fflush(stdout);\par
03227 \}\par
03228 \par
03229 {\cf20 // End PrettyUnitTestResultPrinter}\par
03230 \par
03231 {\cf20 // class TestEventRepeater}\par
03232 {\cf20 //}\par
03233 {\cf20 // This class forwards events to other event listeners.}\par
03234 {\cf17 class }TestEventRepeater : {\cf17 public} TestEventListener \{\par
03235  {\cf17 public}:\par
03236   TestEventRepeater() : forwarding_enabled_(true) \{\}\par
03237   {\cf17 virtual} ~TestEventRepeater();\par
03238   {\cf18 void} Append(TestEventListener *listener);\par
03239   TestEventListener* Release(TestEventListener* listener);\par
03240 \par
03241   {\cf20 // Controls whether events will be forwarded to listeners_. Set to false}\par
03242   {\cf20 // in death test child processes.}\par
03243   {\cf18 bool} forwarding_enabled(){\cf17  const }\{ {\cf19 return} forwarding_enabled_; \}\par
03244   {\cf18 void} set_forwarding_enabled({\cf18 bool} enable) \{ forwarding_enabled_ = enable; \}\par
03245 \par
03246   {\cf17 virtual} {\cf18 void} OnTestProgramStart({\cf17 const} UnitTest& unit_test);\par
03247   {\cf17 virtual} {\cf18 void} OnTestIterationStart({\cf17 const} UnitTest& unit_test, {\cf18 int} iteration);\par
03248   {\cf17 virtual} {\cf18 void} OnEnvironmentsSetUpStart({\cf17 const} UnitTest& unit_test);\par
03249   {\cf17 virtual} {\cf18 void} OnEnvironmentsSetUpEnd({\cf17 const} UnitTest& unit_test);\par
03250   {\cf17 virtual} {\cf18 void} OnTestCaseStart({\cf17 const} TestCase& test_case);\par
03251   {\cf17 virtual} {\cf18 void} OnTestStart({\cf17 const} TestInfo& test_info);\par
03252   {\cf17 virtual} {\cf18 void} OnTestPartResult({\cf17 const} TestPartResult& result);\par
03253   {\cf17 virtual} {\cf18 void} OnTestEnd({\cf17 const} TestInfo& test_info);\par
03254   {\cf17 virtual} {\cf18 void} OnTestCaseEnd({\cf17 const} TestCase& test_case);\par
03255   {\cf17 virtual} {\cf18 void} OnEnvironmentsTearDownStart({\cf17 const} UnitTest& unit_test);\par
03256   {\cf17 virtual} {\cf18 void} OnEnvironmentsTearDownEnd({\cf17 const} UnitTest& unit_test);\par
03257   {\cf17 virtual} {\cf18 void} OnTestIterationEnd({\cf17 const} UnitTest& unit_test, {\cf18 int} iteration);\par
03258   {\cf17 virtual} {\cf18 void} OnTestProgramEnd({\cf17 const} UnitTest& unit_test);\par
03259 \par
03260  {\cf17 private}:\par
03261   {\cf20 // Controls whether events will be forwarded to listeners_. Set to false}\par
03262   {\cf20 // in death test child processes.}\par
03263   {\cf18 bool} forwarding_enabled_;\par
03264   {\cf20 // The list of listeners that receive events.}\par
03265   std::vector<TestEventListener*> listeners_;\par
03266 \par
03267   GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventRepeater);\par
03268 \};\par
03269 \par
03270 TestEventRepeater::~TestEventRepeater() \{\par
03271   ForEach(listeners_, Delete<TestEventListener>);\par
03272 \}\par
03273 \par
03274 {\cf18 void} TestEventRepeater::Append(TestEventListener *listener) \{\par
03275   listeners_.push_back(listener);\par
03276 \}\par
03277 \par
03278 {\cf20 // TODO(vladl@google.com): Factor the search functionality into Vector::Find.}\par
03279 TestEventListener* TestEventRepeater::Release(TestEventListener *listener) \{\par
03280   {\cf19 for} ({\cf18 size_t} i = 0; i < listeners_.size(); ++i) \{\par
03281     {\cf19 if} (listeners_[i] == listener) \{\par
03282       listeners_.erase(listeners_.begin() + i);\par
03283       {\cf19 return} listener;\par
03284     \}\par
03285   \}\par
03286 \par
03287   {\cf19 return} NULL;\par
03288 \}\par
03289 \par
03290 {\cf20 // Since most methods are very similar, use macros to reduce boilerplate.}\par
03291 {\cf20 // This defines a member that forwards the call to all listeners.}\par
03292 {\cf21 #define GTEST_REPEATER_METHOD_(Name, Type) \\}\par
03293 {\cf21 void TestEventRepeater::Name(const Type& parameter) \{ \\}\par
03294 {\cf21   if (forwarding_enabled_) \{ \\}\par
03295 {\cf21     for (size_t i = 0; i < listeners_.size(); i++) \{ \\}\par
03296 {\cf21       listeners_[i]->Name(parameter); \\}\par
03297 {\cf21     \} \\}\par
03298 {\cf21   \} \\}\par
03299 {\cf21 \}}\par
03300 {\cf20 // This defines a member that forwards the call to all listeners in reverse}\par
03301 {\cf20 // order.}\par
03302 {\cf21 #define GTEST_REVERSE_REPEATER_METHOD_(Name, Type) \\}\par
03303 {\cf21 void TestEventRepeater::Name(const Type& parameter) \{ \\}\par
03304 {\cf21   if (forwarding_enabled_) \{ \\}\par
03305 {\cf21     for (int i = static_cast<int>(listeners_.size()) - 1; i >= 0; i--) \{ \\}\par
03306 {\cf21       listeners_[i]->Name(parameter); \\}\par
03307 {\cf21     \} \\}\par
03308 {\cf21   \} \\}\par
03309 {\cf21 \}}\par
03310 \par
03311 GTEST_REPEATER_METHOD_(OnTestProgramStart, UnitTest)\par
03312 GTEST_REPEATER_METHOD_(OnEnvironmentsSetUpStart, UnitTest)\par
03313 GTEST_REPEATER_METHOD_(OnTestCaseStart, TestCase)\par
03314 GTEST_REPEATER_METHOD_(OnTestStart, TestInfo)\par
03315 GTEST_REPEATER_METHOD_(OnTestPartResult, TestPartResult)\par
03316 GTEST_REPEATER_METHOD_(OnEnvironmentsTearDownStart, UnitTest)\par
03317 GTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsSetUpEnd, UnitTest)\par
03318 GTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsTearDownEnd, UnitTest)\par
03319 GTEST_REVERSE_REPEATER_METHOD_(OnTestEnd, TestInfo)\par
03320 GTEST_REVERSE_REPEATER_METHOD_(OnTestCaseEnd, TestCase)\par
03321 GTEST_REVERSE_REPEATER_METHOD_(OnTestProgramEnd, UnitTest)\par
03322 \par
03323 {\cf21 #undef GTEST_REPEATER_METHOD_}\par
03324 {\cf21 #undef GTEST_REVERSE_REPEATER_METHOD_}\par
03325 \par
03326 {\cf18 void} TestEventRepeater::OnTestIterationStart({\cf17 const} UnitTest& unit_test,\par
03327                                              {\cf18 int} iteration) \{\par
03328   {\cf19 if} (forwarding_enabled_) \{\par
03329     {\cf19 for} ({\cf18 size_t} i = 0; i < listeners_.size(); i++) \{\par
03330       listeners_[i]->OnTestIterationStart(unit_test, iteration);\par
03331     \}\par
03332   \}\par
03333 \}\par
03334 \par
03335 {\cf18 void} TestEventRepeater::OnTestIterationEnd({\cf17 const} UnitTest& unit_test,\par
03336                                            {\cf18 int} iteration) \{\par
03337   {\cf19 if} (forwarding_enabled_) \{\par
03338     {\cf19 for} ({\cf18 int} i = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(listeners_.size()) - 1; i >= 0; i--) \{\par
03339       listeners_[i]->OnTestIterationEnd(unit_test, iteration);\par
03340     \}\par
03341   \}\par
03342 \}\par
03343 \par
03344 {\cf20 // End TestEventRepeater}\par
03345 \par
03346 {\cf20 // This class generates an XML output file.}\par
03347 {\cf17 class }XmlUnitTestResultPrinter : {\cf17 public} EmptyTestEventListener \{\par
03348  {\cf17 public}:\par
03349   {\cf17 explicit} XmlUnitTestResultPrinter({\cf17 const} {\cf18 char}* output_file);\par
03350 \par
03351   {\cf17 virtual} {\cf18 void} OnTestIterationEnd({\cf17 const} UnitTest& unit_test, {\cf18 int} iteration);\par
03352 \par
03353  {\cf17 private}:\par
03354   {\cf20 // Is c a whitespace character that is normalized to a space character}\par
03355   {\cf20 // when it appears in an XML attribute value?}\par
03356   {\cf17 static} {\cf18 bool} IsNormalizableWhitespace({\cf18 char} c) \{\par
03357     {\cf19 return} c == 0x9 || c == 0xA || c == 0xD;\par
03358   \}\par
03359 \par
03360   {\cf20 // May c appear in a well-formed XML document?}\par
03361   {\cf17 static} {\cf18 bool} IsValidXmlCharacter({\cf18 char} c) \{\par
03362     {\cf19 return} IsNormalizableWhitespace(c) || c >= 0x20;\par
03363   \}\par
03364 \par
03365   {\cf20 // Returns an XML-escaped copy of the input string str.  If}\par
03366   {\cf20 // is_attribute is true, the text is meant to appear as an attribute}\par
03367   {\cf20 // value, and normalizable whitespace is preserved by replacing it}\par
03368   {\cf20 // with character references.}\par
03369   {\cf17 static} std::string EscapeXml({\cf17 const} std::string& str, {\cf18 bool} is_attribute);\par
03370 \par
03371   {\cf20 // Returns the given string with all characters invalid in XML removed.}\par
03372   {\cf17 static} std::string RemoveInvalidXmlCharacters({\cf17 const} std::string& str);\par
03373 \par
03374   {\cf20 // Convenience wrapper around EscapeXml when str is an attribute value.}\par
03375   {\cf17 static} std::string EscapeXmlAttribute({\cf17 const} std::string& str) \{\par
03376     {\cf19 return} EscapeXml(str, {\cf17 true});\par
03377   \}\par
03378 \par
03379   {\cf20 // Convenience wrapper around EscapeXml when str is not an attribute value.}\par
03380   {\cf17 static} std::string EscapeXmlText({\cf17 const} {\cf18 char}* str) \{\par
03381     {\cf19 return} EscapeXml(str, {\cf17 false});\par
03382   \}\par
03383 \par
03384   {\cf20 // Verifies that the given attribute belongs to the given element and}\par
03385   {\cf20 // streams the attribute as XML.}\par
03386   {\cf17 static} {\cf18 void} OutputXmlAttribute(std::ostream* stream,\par
03387                                  {\cf17 const} std::string& element_name,\par
03388                                  {\cf17 const} std::string& name,\par
03389                                  {\cf17 const} std::string& value);\par
03390 \par
03391   {\cf20 // Streams an XML CDATA section, escaping invalid CDATA sequences as needed.}\par
03392   {\cf17 static} {\cf18 void} OutputXmlCDataSection(::std::ostream* stream, {\cf17 const} {\cf18 char}* data);\par
03393 \par
03394   {\cf20 // Streams an XML representation of a TestInfo object.}\par
03395   {\cf17 static} {\cf18 void} OutputXmlTestInfo(::std::ostream* stream,\par
03396                                 {\cf17 const} {\cf18 char}* test_case_name,\par
03397                                 {\cf17 const} TestInfo& test_info);\par
03398 \par
03399   {\cf20 // Prints an XML representation of a TestCase object}\par
03400   {\cf17 static} {\cf18 void} PrintXmlTestCase(::std::ostream* stream,\par
03401                                {\cf17 const} TestCase& test_case);\par
03402 \par
03403   {\cf20 // Prints an XML summary of unit_test to output stream out.}\par
03404   {\cf17 static} {\cf18 void} PrintXmlUnitTest(::std::ostream* stream,\par
03405                                {\cf17 const} UnitTest& unit_test);\par
03406 \par
03407   {\cf20 // Produces a string representing the test properties in a result as space}\par
03408   {\cf20 // delimited XML attributes based on the property key="value" pairs.}\par
03409   {\cf20 // When the std::string is not empty, it includes a space at the beginning,}\par
03410   {\cf20 // to delimit this attribute from prior attributes.}\par
03411   {\cf17 static} std::string TestPropertiesAsXmlAttributes({\cf17 const} TestResult& result);\par
03412 \par
03413   {\cf20 // The output file.}\par
03414   {\cf17 const} std::string output_file_;\par
03415 \par
03416   GTEST_DISALLOW_COPY_AND_ASSIGN_(XmlUnitTestResultPrinter);\par
03417 \};\par
03418 \par
03419 {\cf20 // Creates a new XmlUnitTestResultPrinter.}\par
03420 XmlUnitTestResultPrinter::XmlUnitTestResultPrinter({\cf17 const} {\cf18 char}* output_file)\par
03421     : output_file_(output_file) \{\par
03422   {\cf19 if} (output_file_.c_str() == NULL || output_file_.empty()) \{\par
03423     fprintf(stderr, {\cf22 "XML output file may not be null\\n"});\par
03424     fflush(stderr);\par
03425     exit(EXIT_FAILURE);\par
03426   \}\par
03427 \}\par
03428 \par
03429 {\cf20 // Called after the unit test ends.}\par
03430 {\cf18 void} XmlUnitTestResultPrinter::OnTestIterationEnd({\cf17 const} UnitTest& unit_test,\par
03431                                                   {\cf18 int} {\cf20 /*iteration*/}) \{\par
03432   FILE* xmlout = NULL;\par
03433   FilePath output_file(output_file_);\par
03434   FilePath output_dir(output_file.RemoveFileName());\par
03435 \par
03436   {\cf19 if} (output_dir.CreateDirectoriesRecursively()) \{\par
03437     xmlout = posix::FOpen(output_file_.c_str(), {\cf22 "w"});\par
03438   \}\par
03439   {\cf19 if} (xmlout == NULL) \{\par
03440     {\cf20 // TODO(wan): report the reason of the failure.}\par
03441     {\cf20 //}\par
03442     {\cf20 // We don't do it for now as:}\par
03443     {\cf20 //}\par
03444     {\cf20 //   1. There is no urgent need for it.}\par
03445     {\cf20 //   2. It's a bit involved to make the errno variable thread-safe on}\par
03446     {\cf20 //      all three operating systems (Linux, Windows, and Mac OS).}\par
03447     {\cf20 //   3. To interpret the meaning of errno in a thread-safe way,}\par
03448     {\cf20 //      we need the strerror_r() function, which is not available on}\par
03449     {\cf20 //      Windows.}\par
03450     fprintf(stderr,\par
03451             {\cf22 "Unable to open file \\"%s\\"\\n"},\par
03452             output_file_.c_str());\par
03453     fflush(stderr);\par
03454     exit(EXIT_FAILURE);\par
03455   \}\par
03456   std::stringstream stream;\par
03457   PrintXmlUnitTest(&stream, unit_test);\par
03458   fprintf(xmlout, {\cf22 "%s"}, StringStreamToString(&stream).c_str());\par
03459   fclose(xmlout);\par
03460 \}\par
03461 \par
03462 {\cf20 // Returns an XML-escaped copy of the input string str.  If is_attribute}\par
03463 {\cf20 // is true, the text is meant to appear as an attribute value, and}\par
03464 {\cf20 // normalizable whitespace is preserved by replacing it with character}\par
03465 {\cf20 // references.}\par
03466 {\cf20 //}\par
03467 {\cf20 // Invalid XML characters in str, if any, are stripped from the output.}\par
03468 {\cf20 // It is expected that most, if not all, of the text processed by this}\par
03469 {\cf20 // module will consist of ordinary English text.}\par
03470 {\cf20 // If this module is ever modified to produce version 1.1 XML output,}\par
03471 {\cf20 // most invalid characters can be retained using character references.}\par
03472 {\cf20 // TODO(wan): It might be nice to have a minimally invasive, human-readable}\par
03473 {\cf20 // escaping scheme for invalid characters, rather than dropping them.}\par
03474 std::string XmlUnitTestResultPrinter::EscapeXml(\par
03475     {\cf17 const} std::string& str, {\cf18 bool} is_attribute) \{\par
03476   Message m;\par
03477 \par
03478   {\cf19 for} ({\cf18 size_t} i = 0; i < str.size(); ++i) \{\par
03479     {\cf17 const} {\cf18 char} ch = str[i];\par
03480     {\cf19 switch} (ch) \{\par
03481       {\cf19 case} {\cf23 '<'}:\par
03482         m << {\cf22 "&lt;"};\par
03483         {\cf19 break};\par
03484       {\cf19 case} {\cf23 '>'}:\par
03485         m << {\cf22 "&gt;"};\par
03486         {\cf19 break};\par
03487       {\cf19 case} {\cf23 '&'}:\par
03488         m << {\cf22 "&amp;"};\par
03489         {\cf19 break};\par
03490       {\cf19 case} {\cf23 '\\''}:\par
03491         {\cf19 if} (is_attribute)\par
03492           m << {\cf22 "&apos;"};\par
03493         {\cf19 else}\par
03494           m << {\cf23 '\\''};\par
03495         {\cf19 break};\par
03496       {\cf19 case} {\cf23 '"'}:\par
03497         {\cf19 if} (is_attribute)\par
03498           m << {\cf22 "&quot;"};\par
03499         {\cf19 else}\par
03500           m << {\cf23 '"'};\par
03501         {\cf19 break};\par
03502       {\cf19 default}:\par
03503         {\cf19 if} (IsValidXmlCharacter(ch)) \{\par
03504           {\cf19 if} (is_attribute && IsNormalizableWhitespace(ch))\par
03505             m << {\cf22 "&#x"} << String::FormatByte({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch))\par
03506               << {\cf22 ";"};\par
03507           {\cf19 else}\par
03508             m << ch;\par
03509         \}\par
03510         {\cf19 break};\par
03511     \}\par
03512   \}\par
03513 \par
03514   {\cf19 return} m.GetString();\par
03515 \}\par
03516 \par
03517 {\cf20 // Returns the given string with all characters invalid in XML removed.}\par
03518 {\cf20 // Currently invalid characters are dropped from the string. An}\par
03519 {\cf20 // alternative is to replace them with certain characters such as . or ?.}\par
03520 std::string XmlUnitTestResultPrinter::RemoveInvalidXmlCharacters(\par
03521     {\cf17 const} std::string& str) \{\par
03522   std::string output;\par
03523   output.reserve(str.size());\par
03524   {\cf19 for} (std::string::const_iterator it = str.begin(); it != str.end(); ++it)\par
03525     {\cf19 if} (IsValidXmlCharacter(*it))\par
03526       output.push_back(*it);\par
03527 \par
03528   {\cf19 return} output;\par
03529 \}\par
03530 \par
03531 {\cf20 // The following routines generate an XML representation of a UnitTest}\par
03532 {\cf20 // object.}\par
03533 {\cf20 //}\par
03534 {\cf20 // This is how Google Test concepts map to the DTD:}\par
03535 {\cf20 //}\par
03536 {\cf20 // <testsuites name="AllTests">        <-- corresponds to a UnitTest object}\par
03537 {\cf20 //   <testsuite name="testcase-name">  <-- corresponds to a TestCase object}\par
03538 {\cf20 //     <testcase name="test-name">     <-- corresponds to a TestInfo object}\par
03539 {\cf20 //       <failure message="...">...</failure>}\par
03540 {\cf20 //       <failure message="...">...</failure>}\par
03541 {\cf20 //       <failure message="...">...</failure>}\par
03542 {\cf20 //                                     <-- individual assertion failures}\par
03543 {\cf20 //     </testcase>}\par
03544 {\cf20 //   </testsuite>}\par
03545 {\cf20 // </testsuites>}\par
03546 \par
03547 {\cf20 // Formats the given time in milliseconds as seconds.}\par
03548 std::string FormatTimeInMillisAsSeconds(TimeInMillis ms) \{\par
03549   ::std::stringstream ss;\par
03550   ss << (static_cast<double>(ms) * 1e-3);\par
03551   {\cf19 return} ss.str();\par
03552 \}\par
03553 \par
03554 {\cf17 static} {\cf18 bool} PortableLocaltime(time_t seconds, {\cf17 struct} tm* out) \{\par
03555 {\cf21 #if defined(_MSC_VER)}\par
03556   {\cf19 return} localtime_s(out, &seconds) == 0;\par
03557 {\cf21 #elif defined(__MINGW32__) || defined(__MINGW64__)}\par
03558   {\cf20 // MINGW <time.h> provides neither localtime_r nor localtime_s, but uses}\par
03559   {\cf20 // Windows' localtime(), which has a thread-local tm buffer.}\par
03560   {\cf17 struct }tm* tm_ptr = localtime(&seconds);  {\cf20 // NOLINT}\par
03561   {\cf19 if} (tm_ptr == NULL)\par
03562     {\cf19 return} {\cf17 false};\par
03563   *out = *tm_ptr;\par
03564   {\cf19 return} {\cf17 true};\par
03565 {\cf21 #else}\par
03566   {\cf19 return} localtime_r(&seconds, out) != NULL;\par
03567 {\cf21 #endif}\par
03568 \}\par
03569 \par
03570 {\cf20 // Converts the given epoch time in milliseconds to a date string in the ISO}\par
03571 {\cf20 // 8601 format, without the timezone information.}\par
03572 std::string FormatEpochTimeInMillisAsIso8601(TimeInMillis ms) \{\par
03573   {\cf17 struct }tm time_struct;\par
03574   {\cf19 if} (!PortableLocaltime({\cf17 static_cast<}time_t{\cf17 >}(ms / 1000), &time_struct))\par
03575     {\cf19 return} {\cf22 ""};\par
03576   {\cf20 // YYYY-MM-DDThh:mm:ss}\par
03577   {\cf19 return} StreamableToString(time_struct.tm_year + 1900) + {\cf22 "-"} +\par
03578       String::FormatIntWidth2(time_struct.tm_mon + 1) + {\cf22 "-"} +\par
03579       String::FormatIntWidth2(time_struct.tm_mday) + {\cf22 "T"} +\par
03580       String::FormatIntWidth2(time_struct.tm_hour) + {\cf22 ":"} +\par
03581       String::FormatIntWidth2(time_struct.tm_min) + {\cf22 ":"} +\par
03582       String::FormatIntWidth2(time_struct.tm_sec);\par
03583 \}\par
03584 \par
03585 {\cf20 // Streams an XML CDATA section, escaping invalid CDATA sequences as needed.}\par
03586 {\cf18 void} XmlUnitTestResultPrinter::OutputXmlCDataSection(::std::ostream* stream,\par
03587                                                      {\cf17 const} {\cf18 char}* data) \{\par
03588   {\cf17 const} {\cf18 char}* segment = data;\par
03589   *stream << {\cf22 "<![CDATA["};\par
03590   {\cf19 for} (;;) \{\par
03591     {\cf17 const} {\cf18 char}* {\cf17 const} next_segment = strstr(segment, {\cf22 "]]>"});\par
03592     {\cf19 if} (next_segment != NULL) \{\par
03593       stream->write(\par
03594           segment, {\cf17 static_cast<}std::streamsize{\cf17 >}(next_segment - segment));\par
03595       *stream << {\cf22 "]]>]]&gt;<![CDATA["};\par
03596       segment = next_segment + strlen({\cf22 "]]>"});\par
03597     \} {\cf19 else} \{\par
03598       *stream << segment;\par
03599       {\cf19 break};\par
03600     \}\par
03601   \}\par
03602   *stream << {\cf22 "]]>"};\par
03603 \}\par
03604 \par
03605 {\cf18 void} XmlUnitTestResultPrinter::OutputXmlAttribute(\par
03606     std::ostream* stream,\par
03607     {\cf17 const} std::string& element_name,\par
03608     {\cf17 const} std::string& name,\par
03609     {\cf17 const} std::string& value) \{\par
03610   {\cf17 const} std::vector<std::string>& allowed_names =\par
03611       GetReservedAttributesForElement(element_name);\par
03612 \par
03613   GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=\par
03614                    allowed_names.end())\par
03615       << {\cf22 "Attribute "} << name << {\cf22 " is not allowed for element <"} << element_name\par
03616       << {\cf22 ">."};\par
03617 \par
03618   *stream << {\cf22 " "} << name << {\cf22 "=\\""} << EscapeXmlAttribute(value) << {\cf22 "\\""};\par
03619 \}\par
03620 \par
03621 {\cf20 // Prints an XML representation of a TestInfo object.}\par
03622 {\cf20 // TODO(wan): There is also value in printing properties with the plain printer.}\par
03623 {\cf18 void} XmlUnitTestResultPrinter::OutputXmlTestInfo(::std::ostream* stream,\par
03624                                                  {\cf17 const} {\cf18 char}* test_case_name,\par
03625                                                  {\cf17 const} TestInfo& test_info) \{\par
03626   {\cf17 const} TestResult& result = *test_info.result();\par
03627   {\cf17 const} std::string kTestcase = {\cf22 "testcase"};\par
03628 \par
03629   *stream << {\cf22 "    <testcase"};\par
03630   OutputXmlAttribute(stream, kTestcase, {\cf22 "name"}, test_info.name());\par
03631 \par
03632   {\cf19 if} (test_info.value_param() != NULL) \{\par
03633     OutputXmlAttribute(stream, kTestcase, {\cf22 "value_param"},\par
03634                        test_info.value_param());\par
03635   \}\par
03636   {\cf19 if} (test_info.type_param() != NULL) \{\par
03637     OutputXmlAttribute(stream, kTestcase, {\cf22 "type_param"}, test_info.type_param());\par
03638   \}\par
03639 \par
03640   OutputXmlAttribute(stream, kTestcase, {\cf22 "status"},\par
03641                      test_info.should_run() ? {\cf22 "run"} : {\cf22 "notrun"});\par
03642   OutputXmlAttribute(stream, kTestcase, {\cf22 "time"},\par
03643                      FormatTimeInMillisAsSeconds(result.elapsed_time()));\par
03644   OutputXmlAttribute(stream, kTestcase, {\cf22 "classname"}, test_case_name);\par
03645   *stream << TestPropertiesAsXmlAttributes(result);\par
03646 \par
03647   {\cf18 int} failures = 0;\par
03648   {\cf19 for} ({\cf18 int} i = 0; i < result.total_part_count(); ++i) \{\par
03649     {\cf17 const} TestPartResult& part = result.GetTestPartResult(i);\par
03650     {\cf19 if} (part.failed()) \{\par
03651       {\cf19 if} (++failures == 1) \{\par
03652         *stream << {\cf22 ">\\n"};\par
03653       \}\par
03654       {\cf17 const} std::string location =\par
03655           internal::FormatCompilerIndependentFileLocation(part.file_name(),\par
03656                                                           part.line_number());\par
03657       {\cf17 const} std::string summary = location + {\cf22 "\\n"} + part.summary();\par
03658       *stream << {\cf22 "      <failure message=\\""}\par
03659               << EscapeXmlAttribute(summary.c_str())\par
03660               << {\cf22 "\\" type=\\"\\">"};\par
03661       {\cf17 const} std::string detail = location + {\cf22 "\\n"} + part.message();\par
03662       OutputXmlCDataSection(stream, RemoveInvalidXmlCharacters(detail).c_str());\par
03663       *stream << {\cf22 "</failure>\\n"};\par
03664     \}\par
03665   \}\par
03666 \par
03667   {\cf19 if} (failures == 0)\par
03668     *stream << {\cf22 " />\\n"};\par
03669   {\cf19 else}\par
03670     *stream << {\cf22 "    </testcase>\\n"};\par
03671 \}\par
03672 \par
03673 {\cf20 // Prints an XML representation of a TestCase object}\par
03674 {\cf18 void} XmlUnitTestResultPrinter::PrintXmlTestCase(std::ostream* stream,\par
03675                                                 {\cf17 const} TestCase& test_case) \{\par
03676   {\cf17 const} std::string kTestsuite = {\cf22 "testsuite"};\par
03677   *stream << {\cf22 "  <"} << kTestsuite;\par
03678   OutputXmlAttribute(stream, kTestsuite, {\cf22 "name"}, test_case.name());\par
03679   OutputXmlAttribute(stream, kTestsuite, {\cf22 "tests"},\par
03680                      StreamableToString(test_case.reportable_test_count()));\par
03681   OutputXmlAttribute(stream, kTestsuite, {\cf22 "failures"},\par
03682                      StreamableToString(test_case.failed_test_count()));\par
03683   OutputXmlAttribute(\par
03684       stream, kTestsuite, {\cf22 "disabled"},\par
03685       StreamableToString(test_case.reportable_disabled_test_count()));\par
03686   OutputXmlAttribute(stream, kTestsuite, {\cf22 "errors"}, {\cf22 "0"});\par
03687   OutputXmlAttribute(stream, kTestsuite, {\cf22 "time"},\par
03688                      FormatTimeInMillisAsSeconds(test_case.elapsed_time()));\par
03689   *stream << TestPropertiesAsXmlAttributes(test_case.ad_hoc_test_result())\par
03690           << {\cf22 ">\\n"};\par
03691 \par
03692   {\cf19 for} ({\cf18 int} i = 0; i < test_case.total_test_count(); ++i) \{\par
03693     {\cf19 if} (test_case.GetTestInfo(i)->is_reportable())\par
03694       OutputXmlTestInfo(stream, test_case.name(), *test_case.GetTestInfo(i));\par
03695   \}\par
03696   *stream << {\cf22 "  </"} << kTestsuite << {\cf22 ">\\n"};\par
03697 \}\par
03698 \par
03699 {\cf20 // Prints an XML summary of unit_test to output stream out.}\par
03700 {\cf18 void} XmlUnitTestResultPrinter::PrintXmlUnitTest(std::ostream* stream,\par
03701                                                 {\cf17 const} UnitTest& unit_test) \{\par
03702   {\cf17 const} std::string kTestsuites = {\cf22 "testsuites"};\par
03703 \par
03704   *stream << {\cf22 "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>\\n"};\par
03705   *stream << {\cf22 "<"} << kTestsuites;\par
03706 \par
03707   OutputXmlAttribute(stream, kTestsuites, {\cf22 "tests"},\par
03708                      StreamableToString(unit_test.reportable_test_count()));\par
03709   OutputXmlAttribute(stream, kTestsuites, {\cf22 "failures"},\par
03710                      StreamableToString(unit_test.failed_test_count()));\par
03711   OutputXmlAttribute(\par
03712       stream, kTestsuites, {\cf22 "disabled"},\par
03713       StreamableToString(unit_test.reportable_disabled_test_count()));\par
03714   OutputXmlAttribute(stream, kTestsuites, {\cf22 "errors"}, {\cf22 "0"});\par
03715   OutputXmlAttribute(\par
03716       stream, kTestsuites, {\cf22 "timestamp"},\par
03717       FormatEpochTimeInMillisAsIso8601(unit_test.start_timestamp()));\par
03718   OutputXmlAttribute(stream, kTestsuites, {\cf22 "time"},\par
03719                      FormatTimeInMillisAsSeconds(unit_test.elapsed_time()));\par
03720 \par
03721   {\cf19 if} (GTEST_FLAG(shuffle)) \{\par
03722     OutputXmlAttribute(stream, kTestsuites, {\cf22 "random_seed"},\par
03723                        StreamableToString(unit_test.random_seed()));\par
03724   \}\par
03725 \par
03726   *stream << TestPropertiesAsXmlAttributes(unit_test.ad_hoc_test_result());\par
03727 \par
03728   OutputXmlAttribute(stream, kTestsuites, {\cf22 "name"}, {\cf22 "AllTests"});\par
03729   *stream << {\cf22 ">\\n"};\par
03730 \par
03731   {\cf19 for} ({\cf18 int} i = 0; i < unit_test.total_test_case_count(); ++i) \{\par
03732     {\cf19 if} (unit_test.GetTestCase(i)->reportable_test_count() > 0)\par
03733       PrintXmlTestCase(stream, *unit_test.GetTestCase(i));\par
03734   \}\par
03735   *stream << {\cf22 "</"} << kTestsuites << {\cf22 ">\\n"};\par
03736 \}\par
03737 \par
03738 {\cf20 // Produces a string representing the test properties in a result as space}\par
03739 {\cf20 // delimited XML attributes based on the property key="value" pairs.}\par
03740 std::string XmlUnitTestResultPrinter::TestPropertiesAsXmlAttributes(\par
03741     {\cf17 const} TestResult& result) \{\par
03742   Message attributes;\par
03743   {\cf19 for} ({\cf18 int} i = 0; i < result.test_property_count(); ++i) \{\par
03744     {\cf17 const} TestProperty& {\cf17 property} = result.GetTestProperty(i);\par
03745     attributes << {\cf22 " "} << {\cf17 property}.key() << {\cf22 "="}\par
03746         << {\cf22 "\\""} << EscapeXmlAttribute(property.value()) << {\cf22 "\\""};\par
03747   \}\par
03748   {\cf19 return} attributes.GetString();\par
03749 \}\par
03750 \par
03751 {\cf20 // End XmlUnitTestResultPrinter}\par
03752 \par
03753 {\cf21 #if GTEST_CAN_STREAM_RESULTS_}\par
03754 \par
03755 {\cf20 // Checks if str contains '=', '&', '%' or '\\n' characters. If yes,}\par
03756 {\cf20 // replaces them by "%xx" where xx is their hexadecimal value. For}\par
03757 {\cf20 // example, replaces "=" with "%3D".  This algorithm is O(strlen(str))}\par
03758 {\cf20 // in both time and space -- important as the input str may contain an}\par
03759 {\cf20 // arbitrarily long test failure message and stack trace.}\par
03760 std::string StreamingListener::UrlEncode({\cf17 const} {\cf18 char}* str) \{\par
03761   std::string result;\par
03762   result.reserve(strlen(str) + 1);\par
03763   {\cf19 for} ({\cf18 char} ch = *str; ch != {\cf23 '\\0'}; ch = *++str) \{\par
03764     {\cf19 switch} (ch) \{\par
03765       {\cf19 case} {\cf23 '%'}:\par
03766       {\cf19 case} {\cf23 '='}:\par
03767       {\cf19 case} {\cf23 '&'}:\par
03768       {\cf19 case} {\cf23 '\\n'}:\par
03769         result.append({\cf22 "%"} + String::FormatByte({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(ch)));\par
03770         {\cf19 break};\par
03771       {\cf19 default}:\par
03772         result.push_back(ch);\par
03773         {\cf19 break};\par
03774     \}\par
03775   \}\par
03776   {\cf19 return} result;\par
03777 \}\par
03778 \par
03779 {\cf18 void} StreamingListener::SocketWriter::MakeConnection() \{\par
03780   GTEST_CHECK_(sockfd_ == -1)\par
03781       << {\cf22 "MakeConnection() can't be called when there is already a connection."};\par
03782 \par
03783   addrinfo hints;\par
03784   memset(&hints, 0, {\cf17 sizeof}(hints));\par
03785   hints.ai_family = AF_UNSPEC;    {\cf20 // To allow both IPv4 and IPv6 addresses.}\par
03786   hints.ai_socktype = SOCK_STREAM;\par
03787   addrinfo* servinfo = NULL;\par
03788 \par
03789   {\cf20 // Use the getaddrinfo() to get a linked list of IP addresses for}\par
03790   {\cf20 // the given host name.}\par
03791   {\cf17 const} {\cf18 int} error_num = getaddrinfo(\par
03792       host_name_.c_str(), port_num_.c_str(), &hints, &servinfo);\par
03793   {\cf19 if} (error_num != 0) \{\par
03794     GTEST_LOG_(WARNING) << {\cf22 "stream_result_to: getaddrinfo() failed: "}\par
03795                         << gai_strerror(error_num);\par
03796   \}\par
03797 \par
03798   {\cf20 // Loop through all the results and connect to the first we can.}\par
03799   {\cf19 for} (addrinfo* cur_addr = servinfo; sockfd_ == -1 && cur_addr != NULL;\par
03800        cur_addr = cur_addr->ai_next) \{\par
03801     sockfd_ = socket(\par
03802         cur_addr->ai_family, cur_addr->ai_socktype, cur_addr->ai_protocol);\par
03803     {\cf19 if} (sockfd_ != -1) \{\par
03804       {\cf20 // Connect the client socket to the server socket.}\par
03805       {\cf19 if} (connect(sockfd_, cur_addr->ai_addr, cur_addr->ai_addrlen) == -1) \{\par
03806         close(sockfd_);\par
03807         sockfd_ = -1;\par
03808       \}\par
03809     \}\par
03810   \}\par
03811 \par
03812   freeaddrinfo(servinfo);  {\cf20 // all done with this structure}\par
03813 \par
03814   {\cf19 if} (sockfd_ == -1) \{\par
03815     GTEST_LOG_(WARNING) << {\cf22 "stream_result_to: failed to connect to "}\par
03816                         << host_name_ << {\cf22 ":"} << port_num_;\par
03817   \}\par
03818 \}\par
03819 \par
03820 {\cf20 // End of class Streaming Listener}\par
03821 {\cf21 #endif  }{\cf20 // GTEST_CAN_STREAM_RESULTS__}\par
03822 \par
03823 {\cf20 // Class ScopedTrace}\par
03824 \par
03825 {\cf20 // Pushes the given source file location and message onto a per-thread}\par
03826 {\cf20 // trace stack maintained by Google Test.}\par
03827 ScopedTrace::ScopedTrace({\cf17 const} {\cf18 char}* file, {\cf18 int} line, {\cf17 const} Message& message)\par
03828     GTEST_LOCK_EXCLUDED_(&UnitTest::mutex_) \{\par
03829   TraceInfo trace;\par
03830   trace.file = file;\par
03831   trace.line = line;\par
03832   trace.message = message.GetString();\par
03833 \par
03834   UnitTest::GetInstance()->PushGTestTrace(trace);\par
03835 \}\par
03836 \par
03837 {\cf20 // Pops the info pushed by the c'tor.}\par
03838 ScopedTrace::~ScopedTrace()\par
03839     GTEST_LOCK_EXCLUDED_(&UnitTest::mutex_) \{\par
03840   UnitTest::GetInstance()->PopGTestTrace();\par
03841 \}\par
03842 \par
03843 \par
03844 {\cf20 // class OsStackTraceGetter}\par
03845 \par
03846 {\cf17 const} {\cf18 char}* {\cf17 const} OsStackTraceGetterInterface::kElidedFramesMarker =\par
03847     {\cf22 "... "} GTEST_NAME_ {\cf22 " internal frames ..."};\par
03848 \par
03849 std::string OsStackTraceGetter::CurrentStackTrace({\cf18 int} {\cf20 /*max_depth*/},\par
03850                                                   {\cf18 int} {\cf20 /*skip_count*/}) \{\par
03851   {\cf19 return} {\cf22 ""};\par
03852 \}\par
03853 \par
03854 {\cf18 void} OsStackTraceGetter::UponLeavingGTest() \{\}\par
03855 \par
03856 {\cf20 // A helper class that creates the premature-exit file in its}\par
03857 {\cf20 // constructor and deletes the file in its destructor.}\par
03858 {\cf17 class }ScopedPrematureExitFile \{\par
03859  {\cf17 public}:\par
03860   {\cf17 explicit} ScopedPrematureExitFile({\cf17 const} {\cf18 char}* premature_exit_filepath)\par
03861       : premature_exit_filepath_(premature_exit_filepath) \{\par
03862     {\cf20 // If a path to the premature-exit file is specified...}\par
03863     {\cf19 if} (premature_exit_filepath != NULL && *premature_exit_filepath != {\cf23 '\\0'}) \{\par
03864       {\cf20 // create the file with a single "0" character in it.  I/O}\par
03865       {\cf20 // errors are ignored as there's nothing better we can do and we}\par
03866       {\cf20 // don't want to fail the test because of this.}\par
03867       FILE* pfile = posix::FOpen(premature_exit_filepath, {\cf22 "w"});\par
03868       fwrite({\cf22 "0"}, 1, 1, pfile);\par
03869       fclose(pfile);\par
03870     \}\par
03871   \}\par
03872 \par
03873   ~ScopedPrematureExitFile() \{\par
03874     {\cf19 if} (premature_exit_filepath_ != NULL && *premature_exit_filepath_ != {\cf23 '\\0'}) \{\par
03875       remove(premature_exit_filepath_);\par
03876     \}\par
03877   \}\par
03878 \par
03879  {\cf17 private}:\par
03880   {\cf17 const} {\cf18 char}* {\cf17 const} premature_exit_filepath_;\par
03881 \par
03882   GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedPrematureExitFile);\par
03883 \};\par
03884 \par
03885 \}  {\cf20 // namespace internal}\par
03886 \par
03887 {\cf20 // class TestEventListeners}\par
03888 \par
03889 TestEventListeners::TestEventListeners()\par
03890     : repeater_(new internal::TestEventRepeater()),\par
03891       default_result_printer_(NULL),\par
03892       default_xml_generator_(NULL) \{\par
03893 \}\par
03894 \par
03895 TestEventListeners::~TestEventListeners() \{ {\cf17 delete} repeater_; \}\par
03896 \par
03897 {\cf20 // Returns the standard listener responsible for the default console}\par
03898 {\cf20 // output.  Can be removed from the listeners list to shut down default}\par
03899 {\cf20 // console output.  Note that removing this object from the listener list}\par
03900 {\cf20 // with Release transfers its ownership to the user.}\par
03901 {\cf18 void} TestEventListeners::Append(TestEventListener* listener) \{\par
03902   repeater_->Append(listener);\par
03903 \}\par
03904 \par
03905 {\cf20 // Removes the given event listener from the list and returns it.  It then}\par
03906 {\cf20 // becomes the caller's responsibility to delete the listener. Returns}\par
03907 {\cf20 // NULL if the listener is not found in the list.}\par
03908 TestEventListener* TestEventListeners::Release(TestEventListener* listener) \{\par
03909   {\cf19 if} (listener == default_result_printer_)\par
03910     default_result_printer_ = NULL;\par
03911   {\cf19 else} {\cf19 if} (listener == default_xml_generator_)\par
03912     default_xml_generator_ = NULL;\par
03913   {\cf19 return} repeater_->Release(listener);\par
03914 \}\par
03915 \par
03916 {\cf20 // Returns repeater that broadcasts the TestEventListener events to all}\par
03917 {\cf20 // subscribers.}\par
03918 TestEventListener* TestEventListeners::repeater() \{ {\cf19 return} repeater_; \}\par
03919 \par
03920 {\cf20 // Sets the default_result_printer attribute to the provided listener.}\par
03921 {\cf20 // The listener is also added to the listener list and previous}\par
03922 {\cf20 // default_result_printer is removed from it and deleted. The listener can}\par
03923 {\cf20 // also be NULL in which case it will not be added to the list. Does}\par
03924 {\cf20 // nothing if the previous and the current listener objects are the same.}\par
03925 {\cf18 void} TestEventListeners::SetDefaultResultPrinter(TestEventListener* listener) \{\par
03926   {\cf19 if} (default_result_printer_ != listener) \{\par
03927     {\cf20 // It is an error to pass this method a listener that is already in the}\par
03928     {\cf20 // list.}\par
03929     {\cf17 delete} Release(default_result_printer_);\par
03930     default_result_printer_ = listener;\par
03931     {\cf19 if} (listener != NULL)\par
03932       Append(listener);\par
03933   \}\par
03934 \}\par
03935 \par
03936 {\cf20 // Sets the default_xml_generator attribute to the provided listener.  The}\par
03937 {\cf20 // listener is also added to the listener list and previous}\par
03938 {\cf20 // default_xml_generator is removed from it and deleted. The listener can}\par
03939 {\cf20 // also be NULL in which case it will not be added to the list. Does}\par
03940 {\cf20 // nothing if the previous and the current listener objects are the same.}\par
03941 {\cf18 void} TestEventListeners::SetDefaultXmlGenerator(TestEventListener* listener) \{\par
03942   {\cf19 if} (default_xml_generator_ != listener) \{\par
03943     {\cf20 // It is an error to pass this method a listener that is already in the}\par
03944     {\cf20 // list.}\par
03945     {\cf17 delete} Release(default_xml_generator_);\par
03946     default_xml_generator_ = listener;\par
03947     {\cf19 if} (listener != NULL)\par
03948       Append(listener);\par
03949   \}\par
03950 \}\par
03951 \par
03952 {\cf20 // Controls whether events will be forwarded by the repeater to the}\par
03953 {\cf20 // listeners in the list.}\par
03954 {\cf18 bool} TestEventListeners::EventForwardingEnabled(){\cf17  const }\{\par
03955   {\cf19 return} repeater_->forwarding_enabled();\par
03956 \}\par
03957 \par
03958 {\cf18 void} TestEventListeners::SuppressEventForwarding() \{\par
03959   repeater_->set_forwarding_enabled({\cf17 false});\par
03960 \}\par
03961 \par
03962 {\cf20 // class UnitTest}\par
03963 \par
03964 {\cf20 // Gets the singleton UnitTest object.  The first time this method is}\par
03965 {\cf20 // called, a UnitTest object is constructed and returned.  Consecutive}\par
03966 {\cf20 // calls will return the same object.}\par
03967 {\cf20 //}\par
03968 {\cf20 // We don't protect this under mutex_ as a user is not supposed to}\par
03969 {\cf20 // call this before main() starts, from which point on the return}\par
03970 {\cf20 // value will never change.}\par
03971 UnitTest* UnitTest::GetInstance() \{\par
03972   {\cf20 // When compiled with MSVC 7.1 in optimized mode, destroying the}\par
03973   {\cf20 // UnitTest object upon exiting the program messes up the exit code,}\par
03974   {\cf20 // causing successful tests to appear failed.  We have to use a}\par
03975   {\cf20 // different implementation in this case to bypass the compiler bug.}\par
03976   {\cf20 // This implementation makes the compiler happy, at the cost of}\par
03977   {\cf20 // leaking the UnitTest object.}\par
03978 \par
03979   {\cf20 // CodeGear C++Builder insists on a public destructor for the}\par
03980   {\cf20 // default implementation.  Use this implementation to keep good OO}\par
03981   {\cf20 // design with private destructor.}\par
03982 \par
03983 {\cf21 #if (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)}\par
03984   {\cf17 static} UnitTest* {\cf17 const} instance = {\cf17 new} UnitTest;\par
03985   {\cf19 return} instance;\par
03986 {\cf21 #else}\par
03987   {\cf17 static} UnitTest instance;\par
03988   {\cf19 return} &instance;\par
03989 {\cf21 #endif  }{\cf20 // (_MSC_VER == 1310 && !defined(_DEBUG)) || defined(__BORLANDC__)}\par
03990 \}\par
03991 \par
03992 {\cf20 // Gets the number of successful test cases.}\par
03993 {\cf18 int} UnitTest::successful_test_case_count(){\cf17  const }\{\par
03994   {\cf19 return} impl()->successful_test_case_count();\par
03995 \}\par
03996 \par
03997 {\cf20 // Gets the number of failed test cases.}\par
03998 {\cf18 int} UnitTest::failed_test_case_count(){\cf17  const }\{\par
03999   {\cf19 return} impl()->failed_test_case_count();\par
04000 \}\par
04001 \par
04002 {\cf20 // Gets the number of all test cases.}\par
04003 {\cf18 int} UnitTest::total_test_case_count(){\cf17  const }\{\par
04004   {\cf19 return} impl()->total_test_case_count();\par
04005 \}\par
04006 \par
04007 {\cf20 // Gets the number of all test cases that contain at least one test}\par
04008 {\cf20 // that should run.}\par
04009 {\cf18 int} UnitTest::test_case_to_run_count(){\cf17  const }\{\par
04010   {\cf19 return} impl()->test_case_to_run_count();\par
04011 \}\par
04012 \par
04013 {\cf20 // Gets the number of successful tests.}\par
04014 {\cf18 int} UnitTest::successful_test_count(){\cf17  const }\{\par
04015   {\cf19 return} impl()->successful_test_count();\par
04016 \}\par
04017 \par
04018 {\cf20 // Gets the number of failed tests.}\par
04019 {\cf18 int} UnitTest::failed_test_count(){\cf17  const }\{ {\cf19 return} impl()->failed_test_count(); \}\par
04020 \par
04021 {\cf20 // Gets the number of disabled tests that will be reported in the XML report.}\par
04022 {\cf18 int} UnitTest::reportable_disabled_test_count(){\cf17  const }\{\par
04023   {\cf19 return} impl()->reportable_disabled_test_count();\par
04024 \}\par
04025 \par
04026 {\cf20 // Gets the number of disabled tests.}\par
04027 {\cf18 int} UnitTest::disabled_test_count(){\cf17  const }\{\par
04028   {\cf19 return} impl()->disabled_test_count();\par
04029 \}\par
04030 \par
04031 {\cf20 // Gets the number of tests to be printed in the XML report.}\par
04032 {\cf18 int} UnitTest::reportable_test_count(){\cf17  const }\{\par
04033   {\cf19 return} impl()->reportable_test_count();\par
04034 \}\par
04035 \par
04036 {\cf20 // Gets the number of all tests.}\par
04037 {\cf18 int} UnitTest::total_test_count(){\cf17  const }\{ {\cf19 return} impl()->total_test_count(); \}\par
04038 \par
04039 {\cf20 // Gets the number of tests that should run.}\par
04040 {\cf18 int} UnitTest::test_to_run_count(){\cf17  const }\{ {\cf19 return} impl()->test_to_run_count(); \}\par
04041 \par
04042 {\cf20 // Gets the time of the test program start, in ms from the start of the}\par
04043 {\cf20 // UNIX epoch.}\par
04044 internal::TimeInMillis UnitTest::start_timestamp(){\cf17  const }\{\par
04045     {\cf19 return} impl()->start_timestamp();\par
04046 \}\par
04047 \par
04048 {\cf20 // Gets the elapsed time, in milliseconds.}\par
04049 internal::TimeInMillis UnitTest::elapsed_time(){\cf17  const }\{\par
04050   {\cf19 return} impl()->elapsed_time();\par
04051 \}\par
04052 \par
04053 {\cf20 // Returns true iff the unit test passed (i.e. all test cases passed).}\par
04054 {\cf18 bool} UnitTest::Passed(){\cf17  const }\{ {\cf19 return} impl()->Passed(); \}\par
04055 \par
04056 {\cf20 // Returns true iff the unit test failed (i.e. some test case failed}\par
04057 {\cf20 // or something outside of all tests failed).}\par
04058 {\cf18 bool} UnitTest::Failed(){\cf17  const }\{ {\cf19 return} impl()->Failed(); \}\par
04059 \par
04060 {\cf20 // Gets the i-th test case among all the test cases. i can range from 0 to}\par
04061 {\cf20 // total_test_case_count() - 1. If i is not in that range, returns NULL.}\par
04062 {\cf17 const} TestCase* UnitTest::GetTestCase({\cf18 int} i){\cf17  const }\{\par
04063   {\cf19 return} impl()->GetTestCase(i);\par
04064 \}\par
04065 \par
04066 {\cf20 // Returns the TestResult containing information on test failures and}\par
04067 {\cf20 // properties logged outside of individual test cases.}\par
04068 {\cf17 const} TestResult& UnitTest::ad_hoc_test_result(){\cf17  const }\{\par
04069   {\cf19 return} *impl()->ad_hoc_test_result();\par
04070 \}\par
04071 \par
04072 {\cf20 // Gets the i-th test case among all the test cases. i can range from 0 to}\par
04073 {\cf20 // total_test_case_count() - 1. If i is not in that range, returns NULL.}\par
04074 TestCase* UnitTest::GetMutableTestCase({\cf18 int} i) \{\par
04075   {\cf19 return} impl()->GetMutableTestCase(i);\par
04076 \}\par
04077 \par
04078 {\cf20 // Returns the list of event listeners that can be used to track events}\par
04079 {\cf20 // inside Google Test.}\par
04080 TestEventListeners& UnitTest::listeners() \{\par
04081   {\cf19 return} *impl()->listeners();\par
04082 \}\par
04083 \par
04084 {\cf20 // Registers and returns a global test environment.  When a test}\par
04085 {\cf20 // program is run, all global test environments will be set-up in the}\par
04086 {\cf20 // order they were registered.  After all tests in the program have}\par
04087 {\cf20 // finished, all global test environments will be torn-down in the}\par
04088 {\cf20 // *reverse* order they were registered.}\par
04089 {\cf20 //}\par
04090 {\cf20 // The UnitTest object takes ownership of the given environment.}\par
04091 {\cf20 //}\par
04092 {\cf20 // We don't protect this under mutex_, as we only support calling it}\par
04093 {\cf20 // from the main thread.}\par
04094 Environment* UnitTest::AddEnvironment(Environment* env) \{\par
04095   {\cf19 if} (env == NULL) \{\par
04096     {\cf19 return} NULL;\par
04097   \}\par
04098 \par
04099   impl_->environments().push_back(env);\par
04100   {\cf19 return} env;\par
04101 \}\par
04102 \par
04103 {\cf20 // Adds a TestPartResult to the current TestResult object.  All Google Test}\par
04104 {\cf20 // assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc) eventually call}\par
04105 {\cf20 // this to report their results.  The user code should use the}\par
04106 {\cf20 // assertion macros instead of calling this directly.}\par
04107 {\cf18 void} UnitTest::AddTestPartResult(\par
04108     TestPartResult::Type result_type,\par
04109     {\cf17 const} {\cf18 char}* file_name,\par
04110     {\cf18 int} line_number,\par
04111     {\cf17 const} std::string& message,\par
04112     {\cf17 const} std::string& os_stack_trace) GTEST_LOCK_EXCLUDED_(mutex_) \{\par
04113   Message msg;\par
04114   msg << message;\par
04115 \par
04116   internal::MutexLock lock(&mutex_);\par
04117   {\cf19 if} (impl_->gtest_trace_stack().size() > 0) \{\par
04118     msg << {\cf22 "\\n"} << GTEST_NAME_ << {\cf22 " trace:"};\par
04119 \par
04120     {\cf19 for} ({\cf18 int} i = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(impl_->gtest_trace_stack().size());\par
04121          i > 0; --i) \{\par
04122       {\cf17 const} internal::TraceInfo& trace = impl_->gtest_trace_stack()[i - 1];\par
04123       msg << {\cf22 "\\n"} << internal::FormatFileLocation(trace.file, trace.line)\par
04124           << {\cf22 " "} << trace.message;\par
04125     \}\par
04126   \}\par
04127 \par
04128   {\cf19 if} (os_stack_trace.c_str() != NULL && !os_stack_trace.empty()) \{\par
04129     msg << internal::kStackTraceMarker << os_stack_trace;\par
04130   \}\par
04131 \par
04132   {\cf17 const} TestPartResult result =\par
04133     TestPartResult(result_type, file_name, line_number,\par
04134                    msg.GetString().c_str());\par
04135   impl_->GetTestPartResultReporterForCurrentThread()->\par
04136       ReportTestPartResult(result);\par
04137 \par
04138   {\cf19 if} (result_type != TestPartResult::kSuccess) \{\par
04139     {\cf20 // gtest_break_on_failure takes precedence over}\par
04140     {\cf20 // gtest_throw_on_failure.  This allows a user to set the latter}\par
04141     {\cf20 // in the code (perhaps in order to use Google Test assertions}\par
04142     {\cf20 // with another testing framework) and specify the former on the}\par
04143     {\cf20 // command line for debugging.}\par
04144     {\cf19 if} (GTEST_FLAG(break_on_failure)) \{\par
04145 {\cf21 #if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT}\par
04146       {\cf20 // Using DebugBreak on Windows allows gtest to still break into a debugger}\par
04147       {\cf20 // when a failure happens and both the --gtest_break_on_failure and}\par
04148       {\cf20 // the --gtest_catch_exceptions flags are specified.}\par
04149       DebugBreak();\par
04150 {\cf21 #else}\par
04151       {\cf20 // Dereference NULL through a volatile pointer to prevent the compiler}\par
04152       {\cf20 // from removing. We use this rather than abort() or __builtin_trap() for}\par
04153       {\cf20 // portability: Symbian doesn't implement abort() well, and some debuggers}\par
04154       {\cf20 // don't correctly trap abort().}\par
04155       *{\cf17 static_cast<}{\cf17 volatile }{\cf18 int}*{\cf17 >}(NULL) = 1;\par
04156 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS}\par
04157     \} {\cf19 else} {\cf19 if} (GTEST_FLAG(throw_on_failure)) \{\par
04158 {\cf21 #if GTEST_HAS_EXCEPTIONS}\par
04159       {\cf19 throw} internal::GoogleTestFailureException(result);\par
04160 {\cf21 #else}\par
04161       {\cf20 // We cannot call abort() as it generates a pop-up in debug mode}\par
04162       {\cf20 // that cannot be suppressed in VC 7.1 or below.}\par
04163       exit(1);\par
04164 {\cf21 #endif}\par
04165     \}\par
04166   \}\par
04167 \}\par
04168 \par
04169 {\cf20 // Adds a TestProperty to the current TestResult object when invoked from}\par
04170 {\cf20 // inside a test, to current TestCase's ad_hoc_test_result_ when invoked}\par
04171 {\cf20 // from SetUpTestCase or TearDownTestCase, or to the global property set}\par
04172 {\cf20 // when invoked elsewhere.  If the result already contains a property with}\par
04173 {\cf20 // the same key, the value will be updated.}\par
04174 {\cf18 void} UnitTest::RecordProperty({\cf17 const} std::string& key,\par
04175                               {\cf17 const} std::string& value) \{\par
04176   impl_->RecordProperty(TestProperty(key, value));\par
04177 \}\par
04178 \par
04179 {\cf20 // Runs all tests in this UnitTest object and prints the result.}\par
04180 {\cf20 // Returns 0 if successful, or 1 otherwise.}\par
04181 {\cf20 //}\par
04182 {\cf20 // We don't protect this under mutex_, as we only support calling it}\par
04183 {\cf20 // from the main thread.}\par
04184 {\cf18 int} UnitTest::Run() \{\par
04185   {\cf17 const} {\cf18 bool} in_death_test_child_process =\par
04186       internal::GTEST_FLAG(internal_run_death_test).length() > 0;\par
04187 \par
04188   {\cf20 // Google Test implements this protocol for catching that a test}\par
04189   {\cf20 // program exits before returning control to Google Test:}\par
04190   {\cf20 //}\par
04191   {\cf20 //   1. Upon start, Google Test creates a file whose absolute path}\par
04192   {\cf20 //      is specified by the environment variable}\par
04193   {\cf20 //      TEST_PREMATURE_EXIT_FILE.}\par
04194   {\cf20 //   2. When Google Test has finished its work, it deletes the file.}\par
04195   {\cf20 //}\par
04196   {\cf20 // This allows a test runner to set TEST_PREMATURE_EXIT_FILE before}\par
04197   {\cf20 // running a Google-Test-based test program and check the existence}\par
04198   {\cf20 // of the file at the end of the test execution to see if it has}\par
04199   {\cf20 // exited prematurely.}\par
04200 \par
04201   {\cf20 // If we are in the child process of a death test, don't}\par
04202   {\cf20 // create/delete the premature exit file, as doing so is unnecessary}\par
04203   {\cf20 // and will confuse the parent process.  Otherwise, create/delete}\par
04204   {\cf20 // the file upon entering/leaving this function.  If the program}\par
04205   {\cf20 // somehow exits before this function has a chance to return, the}\par
04206   {\cf20 // premature-exit file will be left undeleted, causing a test runner}\par
04207   {\cf20 // that understands the premature-exit-file protocol to report the}\par
04208   {\cf20 // test as having failed.}\par
04209   {\cf17 const} internal::ScopedPrematureExitFile premature_exit_file(\par
04210       in_death_test_child_process ?\par
04211       NULL : internal::posix::GetEnv({\cf22 "TEST_PREMATURE_EXIT_FILE"}));\par
04212 \par
04213   {\cf20 // Captures the value of GTEST_FLAG(catch_exceptions).  This value will be}\par
04214   {\cf20 // used for the duration of the program.}\par
04215   impl()->set_catch_exceptions(GTEST_FLAG(catch_exceptions));\par
04216 \par
04217 {\cf21 #if GTEST_HAS_SEH}\par
04218   {\cf20 // Either the user wants Google Test to catch exceptions thrown by the}\par
04219   {\cf20 // tests or this is executing in the context of death test child}\par
04220   {\cf20 // process. In either case the user does not want to see pop-up dialogs}\par
04221   {\cf20 // about crashes - they are expected.}\par
04222   {\cf19 if} (impl()->catch_exceptions() || in_death_test_child_process) \{\par
04223 {\cf21 # if !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT}\par
04224     {\cf20 // SetErrorMode doesn't exist on CE.}\par
04225     SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOALIGNMENTFAULTEXCEPT |\par
04226                  SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);\par
04227 {\cf21 # endif  }{\cf20 // !GTEST_OS_WINDOWS_MOBILE}\par
04228 \par
04229 {\cf21 # if (defined(_MSC_VER) || GTEST_OS_WINDOWS_MINGW) && !GTEST_OS_WINDOWS_MOBILE}\par
04230     {\cf20 // Death test children can be terminated with _abort().  On Windows,}\par
04231     {\cf20 // _abort() can show a dialog with a warning message.  This forces the}\par
04232     {\cf20 // abort message to go to stderr instead.}\par
04233     _set_error_mode(_OUT_TO_STDERR);\par
04234 {\cf21 # endif}\par
04235 \par
04236 {\cf21 # if _MSC_VER >= 1400 && !GTEST_OS_WINDOWS_MOBILE}\par
04237     {\cf20 // In the debug version, Visual Studio pops up a separate dialog}\par
04238     {\cf20 // offering a choice to debug the aborted program. We need to suppress}\par
04239     {\cf20 // this dialog or it will pop up for every EXPECT/ASSERT_DEATH statement}\par
04240     {\cf20 // executed. Google Test will notify the user of any unexpected}\par
04241     {\cf20 // failure via stderr.}\par
04242     {\cf20 //}\par
04243     {\cf20 // VC++ doesn't define _set_abort_behavior() prior to the version 8.0.}\par
04244     {\cf20 // Users of prior VC versions shall suffer the agony and pain of}\par
04245     {\cf20 // clicking through the countless debug dialogs.}\par
04246     {\cf20 // TODO(vladl@google.com): find a way to suppress the abort dialog() in the}\par
04247     {\cf20 // debug mode when compiled with VC 7.1 or lower.}\par
04248     {\cf19 if} (!GTEST_FLAG(break_on_failure))\par
04249       _set_abort_behavior(\par
04250           0x0,                                    {\cf20 // Clear the following flags:}\par
04251           _WRITE_ABORT_MSG | _CALL_REPORTFAULT);  {\cf20 // pop-up window, core dump.}\par
04252 {\cf21 # endif}\par
04253   \}\par
04254 {\cf21 #endif  }{\cf20 // GTEST_HAS_SEH}\par
04255 \par
04256   {\cf19 return} internal::HandleExceptionsInMethodIfSupported(\par
04257       impl(),\par
04258       &internal::UnitTestImpl::RunAllTests,\par
04259       {\cf22 "auxiliary test code (environments or event listeners)"}) ? 0 : 1;\par
04260 \}\par
04261 \par
04262 {\cf20 // Returns the working directory when the first TEST() or TEST_F() was}\par
04263 {\cf20 // executed.}\par
04264 {\cf17 const} {\cf18 char}* UnitTest::original_working_dir(){\cf17  const }\{\par
04265   {\cf19 return} impl_->original_working_dir_.c_str();\par
04266 \}\par
04267 \par
04268 {\cf20 // Returns the TestCase object for the test that's currently running,}\par
04269 {\cf20 // or NULL if no test is running.}\par
04270 {\cf17 const} TestCase* UnitTest::current_test_case() const\par
04271     GTEST_LOCK_EXCLUDED_(mutex_) \{\par
04272   internal::MutexLock lock(&mutex_);\par
04273   {\cf19 return} impl_->current_test_case();\par
04274 \}\par
04275 \par
04276 {\cf20 // Returns the TestInfo object for the test that's currently running,}\par
04277 {\cf20 // or NULL if no test is running.}\par
04278 {\cf17 const} TestInfo* UnitTest::current_test_info() const\par
04279     GTEST_LOCK_EXCLUDED_(mutex_) \{\par
04280   internal::MutexLock lock(&mutex_);\par
04281   {\cf19 return} impl_->current_test_info();\par
04282 \}\par
04283 \par
04284 {\cf20 // Returns the random seed used at the start of the current test run.}\par
04285 {\cf18 int} UnitTest::random_seed(){\cf17  const }\{ {\cf19 return} impl_->random_seed(); \}\par
04286 \par
04287 {\cf21 #if GTEST_HAS_PARAM_TEST}\par
04288 {\cf20 // Returns ParameterizedTestCaseRegistry object used to keep track of}\par
04289 {\cf20 // value-parameterized tests and instantiate and register them.}\par
04290 internal::ParameterizedTestCaseRegistry&\par
04291     UnitTest::parameterized_test_registry()\par
04292         GTEST_LOCK_EXCLUDED_(mutex_) \{\par
04293   {\cf19 return} impl_->parameterized_test_registry();\par
04294 \}\par
04295 {\cf21 #endif  }{\cf20 // GTEST_HAS_PARAM_TEST}\par
04296 \par
04297 {\cf20 // Creates an empty UnitTest.}\par
04298 UnitTest::UnitTest() \{\par
04299   impl_ = {\cf17 new} internal::UnitTestImpl({\cf17 this});\par
04300 \}\par
04301 \par
04302 {\cf20 // Destructor of UnitTest.}\par
04303 UnitTest::~UnitTest() \{\par
04304   {\cf17 delete} impl_;\par
04305 \}\par
04306 \par
04307 {\cf20 // Pushes a trace defined by SCOPED_TRACE() on to the per-thread}\par
04308 {\cf20 // Google Test trace stack.}\par
04309 {\cf18 void} UnitTest::PushGTestTrace({\cf17 const} internal::TraceInfo& trace)\par
04310     GTEST_LOCK_EXCLUDED_(mutex_) \{\par
04311   internal::MutexLock lock(&mutex_);\par
04312   impl_->gtest_trace_stack().push_back(trace);\par
04313 \}\par
04314 \par
04315 {\cf20 // Pops a trace from the per-thread Google Test trace stack.}\par
04316 {\cf18 void} UnitTest::PopGTestTrace()\par
04317     GTEST_LOCK_EXCLUDED_(mutex_) \{\par
04318   internal::MutexLock lock(&mutex_);\par
04319   impl_->gtest_trace_stack().pop_back();\par
04320 \}\par
04321 \par
04322 {\cf17 namespace }internal \{\par
04323 \par
04324 UnitTestImpl::UnitTestImpl(UnitTest* parent)\par
04325     : parent_(parent),\par
04326       GTEST_DISABLE_MSC_WARNINGS_PUSH_(4355 {\cf20 /* using this in initializer */})\par
04327       default_global_test_part_result_reporter_(this),\par
04328       default_per_thread_test_part_result_reporter_(this),\par
04329       GTEST_DISABLE_MSC_WARNINGS_POP_()\par
04330       global_test_part_result_repoter_(\par
04331           &default_global_test_part_result_reporter_),\par
04332       per_thread_test_part_result_reporter_(\par
04333           &default_per_thread_test_part_result_reporter_),\par
04334 #if GTEST_HAS_PARAM_TEST\par
04335       parameterized_test_registry_(),\par
04336       parameterized_tests_registered_(false),\par
04337 #endif  {\cf20 // GTEST_HAS_PARAM_TEST}\par
04338       last_death_test_case_(-1),\par
04339       current_test_case_(NULL),\par
04340       current_test_info_(NULL),\par
04341       ad_hoc_test_result_(),\par
04342       os_stack_trace_getter_(NULL),\par
04343       post_flag_parse_init_performed_(false),\par
04344       random_seed_(0),  {\cf20 // Will be overridden by the flag before first use.}\par
04345       random_(0),  {\cf20 // Will be reseeded before first use.}\par
04346       start_timestamp_(0),\par
04347       elapsed_time_(0),\par
04348 #if GTEST_HAS_DEATH_TEST\par
04349       death_test_factory_(new DefaultDeathTestFactory),\par
04350 #endif\par
04351       {\cf20 // Will be overridden by the flag before first use.}\par
04352       catch_exceptions_(false) \{\par
04353   listeners()->SetDefaultResultPrinter({\cf17 new} PrettyUnitTestResultPrinter);\par
04354 \}\par
04355 \par
04356 UnitTestImpl::~UnitTestImpl() \{\par
04357   {\cf20 // Deletes every TestCase.}\par
04358   ForEach(test_cases_, internal::Delete<TestCase>);\par
04359 \par
04360   {\cf20 // Deletes every Environment.}\par
04361   ForEach(environments_, internal::Delete<Environment>);\par
04362 \par
04363   {\cf17 delete} os_stack_trace_getter_;\par
04364 \}\par
04365 \par
04366 {\cf20 // Adds a TestProperty to the current TestResult object when invoked in a}\par
04367 {\cf20 // context of a test, to current test case's ad_hoc_test_result when invoke}\par
04368 {\cf20 // from SetUpTestCase/TearDownTestCase, or to the global property set}\par
04369 {\cf20 // otherwise.  If the result already contains a property with the same key,}\par
04370 {\cf20 // the value will be updated.}\par
04371 {\cf18 void} UnitTestImpl::RecordProperty({\cf17 const} TestProperty& test_property) \{\par
04372   std::string xml_element;\par
04373   TestResult* test_result;  {\cf20 // TestResult appropriate for property recording.}\par
04374 \par
04375   {\cf19 if} (current_test_info_ != NULL) \{\par
04376     xml_element = {\cf22 "testcase"};\par
04377     test_result = &(current_test_info_->result_);\par
04378   \} {\cf19 else} {\cf19 if} (current_test_case_ != NULL) \{\par
04379     xml_element = {\cf22 "testsuite"};\par
04380     test_result = &(current_test_case_->ad_hoc_test_result_);\par
04381   \} {\cf19 else} \{\par
04382     xml_element = {\cf22 "testsuites"};\par
04383     test_result = &ad_hoc_test_result_;\par
04384   \}\par
04385   test_result->RecordProperty(xml_element, test_property);\par
04386 \}\par
04387 \par
04388 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
04389 {\cf20 // Disables event forwarding if the control is currently in a death test}\par
04390 {\cf20 // subprocess. Must not be called before InitGoogleTest.}\par
04391 {\cf18 void} UnitTestImpl::SuppressTestEventsIfInSubprocess() \{\par
04392   {\cf19 if} (internal_run_death_test_flag_.get() != NULL)\par
04393     listeners()->SuppressEventForwarding();\par
04394 \}\par
04395 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
04396 \par
04397 {\cf20 // Initializes event listeners performing XML output as specified by}\par
04398 {\cf20 // UnitTestOptions. Must not be called before InitGoogleTest.}\par
04399 {\cf18 void} UnitTestImpl::ConfigureXmlOutput() \{\par
04400   {\cf17 const} std::string& output_format = UnitTestOptions::GetOutputFormat();\par
04401   {\cf19 if} (output_format == {\cf22 "xml"}) \{\par
04402     listeners()->SetDefaultXmlGenerator({\cf17 new} XmlUnitTestResultPrinter(\par
04403         UnitTestOptions::GetAbsolutePathToOutputFile().c_str()));\par
04404   \} {\cf19 else} {\cf19 if} (output_format != {\cf22 ""}) \{\par
04405     printf({\cf22 "WARNING: unrecognized output format \\"%s\\" ignored.\\n"},\par
04406            output_format.c_str());\par
04407     fflush(stdout);\par
04408   \}\par
04409 \}\par
04410 \par
04411 {\cf21 #if GTEST_CAN_STREAM_RESULTS_}\par
04412 {\cf20 // Initializes event listeners for streaming test results in string form.}\par
04413 {\cf20 // Must not be called before InitGoogleTest.}\par
04414 {\cf18 void} UnitTestImpl::ConfigureStreamingOutput() \{\par
04415   {\cf17 const} std::string& target = GTEST_FLAG(stream_result_to);\par
04416   {\cf19 if} (!target.empty()) \{\par
04417     {\cf17 const} {\cf18 size_t} pos = target.find({\cf23 ':'});\par
04418     {\cf19 if} (pos != std::string::npos) \{\par
04419       listeners()->Append({\cf17 new} StreamingListener(target.substr(0, pos),\par
04420                                                 target.substr(pos+1)));\par
04421     \} {\cf19 else} \{\par
04422       printf({\cf22 "WARNING: unrecognized streaming target \\"%s\\" ignored.\\n"},\par
04423              target.c_str());\par
04424       fflush(stdout);\par
04425     \}\par
04426   \}\par
04427 \}\par
04428 {\cf21 #endif  }{\cf20 // GTEST_CAN_STREAM_RESULTS_}\par
04429 \par
04430 {\cf20 // Performs initialization dependent upon flag values obtained in}\par
04431 {\cf20 // ParseGoogleTestFlagsOnly.  Is called from InitGoogleTest after the call to}\par
04432 {\cf20 // ParseGoogleTestFlagsOnly.  In case a user neglects to call InitGoogleTest}\par
04433 {\cf20 // this function is also called from RunAllTests.  Since this function can be}\par
04434 {\cf20 // called more than once, it has to be idempotent.}\par
04435 {\cf18 void} UnitTestImpl::PostFlagParsingInit() \{\par
04436   {\cf20 // Ensures that this function does not execute more than once.}\par
04437   {\cf19 if} (!post_flag_parse_init_performed_) \{\par
04438     post_flag_parse_init_performed_ = {\cf17 true};\par
04439 \par
04440 {\cf21 #if defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)}\par
04441     {\cf20 // Register to send notifications about key process state changes.}\par
04442     listeners()->Append({\cf17 new} GTEST_CUSTOM_TEST_EVENT_LISTENER_());\par
04443 {\cf21 #endif  }{\cf20 // defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)}\par
04444 \par
04445 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
04446     InitDeathTestSubprocessControlInfo();\par
04447     SuppressTestEventsIfInSubprocess();\par
04448 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
04449 \par
04450     {\cf20 // Registers parameterized tests. This makes parameterized tests}\par
04451     {\cf20 // available to the UnitTest reflection API without running}\par
04452     {\cf20 // RUN_ALL_TESTS.}\par
04453     RegisterParameterizedTests();\par
04454 \par
04455     {\cf20 // Configures listeners for XML output. This makes it possible for users}\par
04456     {\cf20 // to shut down the default XML output before invoking RUN_ALL_TESTS.}\par
04457     ConfigureXmlOutput();\par
04458 \par
04459 {\cf21 #if GTEST_CAN_STREAM_RESULTS_}\par
04460     {\cf20 // Configures listeners for streaming test results to the specified server.}\par
04461     ConfigureStreamingOutput();\par
04462 {\cf21 #endif  }{\cf20 // GTEST_CAN_STREAM_RESULTS_}\par
04463   \}\par
04464 \}\par
04465 \par
04466 {\cf20 // A predicate that checks the name of a TestCase against a known}\par
04467 {\cf20 // value.}\par
04468 {\cf20 //}\par
04469 {\cf20 // This is used for implementation of the UnitTest class only.  We put}\par
04470 {\cf20 // it in the anonymous namespace to prevent polluting the outer}\par
04471 {\cf20 // namespace.}\par
04472 {\cf20 //}\par
04473 {\cf20 // TestCaseNameIs is copyable.}\par
04474 {\cf17 class }TestCaseNameIs \{\par
04475  {\cf17 public}:\par
04476   {\cf20 // Constructor.}\par
04477   {\cf17 explicit} TestCaseNameIs({\cf17 const} std::string& name)\par
04478       : name_(name) \{\}\par
04479 \par
04480   {\cf20 // Returns true iff the name of test_case matches name_.}\par
04481   {\cf18 bool} operator()({\cf17 const} TestCase* test_case){\cf17  const }\{\par
04482     {\cf19 return} test_case != NULL && strcmp(test_case->name(), name_.c_str()) == 0;\par
04483   \}\par
04484 \par
04485  {\cf17 private}:\par
04486   std::string name_;\par
04487 \};\par
04488 \par
04489 {\cf20 // Finds and returns a TestCase with the given name.  If one doesn't}\par
04490 {\cf20 // exist, creates one and returns it.  It's the CALLER'S}\par
04491 {\cf20 // RESPONSIBILITY to ensure that this function is only called WHEN THE}\par
04492 {\cf20 // TESTS ARE NOT SHUFFLED.}\par
04493 {\cf20 //}\par
04494 {\cf20 // Arguments:}\par
04495 {\cf20 //}\par
04496 {\cf20 //   test_case_name: name of the test case}\par
04497 {\cf20 //   type_param:     the name of the test case's type parameter, or NULL if}\par
04498 {\cf20 //                   this is not a typed or a type-parameterized test case.}\par
04499 {\cf20 //   set_up_tc:      pointer to the function that sets up the test case}\par
04500 {\cf20 //   tear_down_tc:   pointer to the function that tears down the test case}\par
04501 TestCase* UnitTestImpl::GetTestCase({\cf17 const} {\cf18 char}* test_case_name,\par
04502                                     {\cf17 const} {\cf18 char}* type_param,\par
04503                                     Test::SetUpTestCaseFunc set_up_tc,\par
04504                                     Test::TearDownTestCaseFunc tear_down_tc) \{\par
04505   {\cf20 // Can we find a TestCase with the given name?}\par
04506   {\cf17 const} std::vector<TestCase*>::const_iterator test_case =\par
04507       std::find_if(test_cases_.begin(), test_cases_.end(),\par
04508                    TestCaseNameIs(test_case_name));\par
04509 \par
04510   {\cf19 if} (test_case != test_cases_.end())\par
04511     {\cf19 return} *test_case;\par
04512 \par
04513   {\cf20 // No.  Let's create one.}\par
04514   TestCase* {\cf17 const} new_test_case =\par
04515       {\cf17 new} TestCase(test_case_name, type_param, set_up_tc, tear_down_tc);\par
04516 \par
04517   {\cf20 // Is this a death test case?}\par
04518   {\cf19 if} (internal::UnitTestOptions::MatchesFilter(test_case_name,\par
04519                                                kDeathTestCaseFilter)) \{\par
04520     {\cf20 // Yes.  Inserts the test case after the last death test case}\par
04521     {\cf20 // defined so far.  This only works when the test cases haven't}\par
04522     {\cf20 // been shuffled.  Otherwise we may end up running a death test}\par
04523     {\cf20 // after a non-death test.}\par
04524     ++last_death_test_case_;\par
04525     test_cases_.insert(test_cases_.begin() + last_death_test_case_,\par
04526                        new_test_case);\par
04527   \} {\cf19 else} \{\par
04528     {\cf20 // No.  Appends to the end of the list.}\par
04529     test_cases_.push_back(new_test_case);\par
04530   \}\par
04531 \par
04532   test_case_indices_.push_back({\cf17 static_cast<}{\cf18 int}{\cf17 >}(test_case_indices_.size()));\par
04533   {\cf19 return} new_test_case;\par
04534 \}\par
04535 \par
04536 {\cf20 // Helpers for setting up / tearing down the given environment.  They}\par
04537 {\cf20 // are for use in the ForEach() function.}\par
04538 {\cf17 static} {\cf18 void} SetUpEnvironment(Environment* env) \{ env->SetUp(); \}\par
04539 {\cf17 static} {\cf18 void} TearDownEnvironment(Environment* env) \{ env->TearDown(); \}\par
04540 \par
04541 {\cf20 // Runs all tests in this UnitTest object, prints the result, and}\par
04542 {\cf20 // returns true if all tests are successful.  If any exception is}\par
04543 {\cf20 // thrown during a test, the test is considered to be failed, but the}\par
04544 {\cf20 // rest of the tests will still be run.}\par
04545 {\cf20 //}\par
04546 {\cf20 // When parameterized tests are enabled, it expands and registers}\par
04547 {\cf20 // parameterized tests first in RegisterParameterizedTests().}\par
04548 {\cf20 // All other functions called from RunAllTests() may safely assume that}\par
04549 {\cf20 // parameterized tests are ready to be counted and run.}\par
04550 {\cf18 bool} UnitTestImpl::RunAllTests() \{\par
04551   {\cf20 // Makes sure InitGoogleTest() was called.}\par
04552   {\cf19 if} (!GTestIsInitialized()) \{\par
04553     printf({\cf22 "%s"},\par
04554            {\cf22 "\\nThis test program did NOT call ::testing::InitGoogleTest "}\par
04555            {\cf22 "before calling RUN_ALL_TESTS().  Please fix it.\\n"});\par
04556     {\cf19 return} {\cf17 false};\par
04557   \}\par
04558 \par
04559   {\cf20 // Do not run any test if the --help flag was specified.}\par
04560   {\cf19 if} (g_help_flag)\par
04561     {\cf19 return} {\cf17 true};\par
04562 \par
04563   {\cf20 // Repeats the call to the post-flag parsing initialization in case the}\par
04564   {\cf20 // user didn't call InitGoogleTest.}\par
04565   PostFlagParsingInit();\par
04566 \par
04567   {\cf20 // Even if sharding is not on, test runners may want to use the}\par
04568   {\cf20 // GTEST_SHARD_STATUS_FILE to query whether the test supports the sharding}\par
04569   {\cf20 // protocol.}\par
04570   internal::WriteToShardStatusFileIfNeeded();\par
04571 \par
04572   {\cf20 // True iff we are in a subprocess for running a thread-safe-style}\par
04573   {\cf20 // death test.}\par
04574   {\cf18 bool} in_subprocess_for_death_test = {\cf17 false};\par
04575 \par
04576 {\cf21 #if GTEST_HAS_DEATH_TEST}\par
04577   in_subprocess_for_death_test = (internal_run_death_test_flag_.get() != NULL);\par
04578 {\cf21 # if defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)}\par
04579   {\cf19 if} (in_subprocess_for_death_test) \{\par
04580     GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_();\par
04581   \}\par
04582 {\cf21 # endif  }{\cf20 // defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)}\par
04583 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST}\par
04584 \par
04585   {\cf17 const} {\cf18 bool} should_shard = ShouldShard(kTestTotalShards, kTestShardIndex,\par
04586                                         in_subprocess_for_death_test);\par
04587 \par
04588   {\cf20 // Compares the full test names with the filter to decide which}\par
04589   {\cf20 // tests to run.}\par
04590   {\cf17 const} {\cf18 bool} has_tests_to_run = FilterTests(should_shard\par
04591                                               ? HONOR_SHARDING_PROTOCOL\par
04592                                               : IGNORE_SHARDING_PROTOCOL) > 0;\par
04593 \par
04594   {\cf20 // Lists the tests and exits if the --gtest_list_tests flag was specified.}\par
04595   {\cf19 if} (GTEST_FLAG(list_tests)) \{\par
04596     {\cf20 // This must be called *after* FilterTests() has been called.}\par
04597     ListTestsMatchingFilter();\par
04598     {\cf19 return} {\cf17 true};\par
04599   \}\par
04600 \par
04601   random_seed_ = GTEST_FLAG(shuffle) ?\par
04602       GetRandomSeedFromFlag(GTEST_FLAG(random_seed)) : 0;\par
04603 \par
04604   {\cf20 // True iff at least one test has failed.}\par
04605   {\cf18 bool} failed = {\cf17 false};\par
04606 \par
04607   TestEventListener* repeater = listeners()->repeater();\par
04608 \par
04609   start_timestamp_ = GetTimeInMillis();\par
04610   repeater->OnTestProgramStart(*parent_);\par
04611 \par
04612   {\cf20 // How many times to repeat the tests?  We don't want to repeat them}\par
04613   {\cf20 // when we are inside the subprocess of a death test.}\par
04614   {\cf17 const} {\cf18 int} repeat = in_subprocess_for_death_test ? 1 : GTEST_FLAG(repeat);\par
04615   {\cf20 // Repeats forever if the repeat count is negative.}\par
04616   {\cf17 const} {\cf18 bool} forever = repeat < 0;\par
04617   {\cf19 for} ({\cf18 int} i = 0; forever || i != repeat; i++) \{\par
04618     {\cf20 // We want to preserve failures generated by ad-hoc test}\par
04619     {\cf20 // assertions executed before RUN_ALL_TESTS().}\par
04620     ClearNonAdHocTestResult();\par
04621 \par
04622     {\cf17 const} TimeInMillis start = GetTimeInMillis();\par
04623 \par
04624     {\cf20 // Shuffles test cases and tests if requested.}\par
04625     {\cf19 if} (has_tests_to_run && GTEST_FLAG(shuffle)) \{\par
04626       random()->Reseed(random_seed_);\par
04627       {\cf20 // This should be done before calling OnTestIterationStart(),}\par
04628       {\cf20 // such that a test event listener can see the actual test order}\par
04629       {\cf20 // in the event.}\par
04630       ShuffleTests();\par
04631     \}\par
04632 \par
04633     {\cf20 // Tells the unit test event listeners that the tests are about to start.}\par
04634     repeater->OnTestIterationStart(*parent_, i);\par
04635 \par
04636     {\cf20 // Runs each test case if there is at least one test to run.}\par
04637     {\cf19 if} (has_tests_to_run) \{\par
04638       {\cf20 // Sets up all environments beforehand.}\par
04639       repeater->OnEnvironmentsSetUpStart(*parent_);\par
04640       ForEach(environments_, SetUpEnvironment);\par
04641       repeater->OnEnvironmentsSetUpEnd(*parent_);\par
04642 \par
04643       {\cf20 // Runs the tests only if there was no fatal failure during global}\par
04644       {\cf20 // set-up.}\par
04645       {\cf19 if} (!Test::HasFatalFailure()) \{\par
04646         {\cf19 for} ({\cf18 int} test_index = 0; test_index < total_test_case_count();\par
04647              test_index++) \{\par
04648           GetMutableTestCase(test_index)->Run();\par
04649         \}\par
04650       \}\par
04651 \par
04652       {\cf20 // Tears down all environments in reverse order afterwards.}\par
04653       repeater->OnEnvironmentsTearDownStart(*parent_);\par
04654       std::for_each(environments_.rbegin(), environments_.rend(),\par
04655                     TearDownEnvironment);\par
04656       repeater->OnEnvironmentsTearDownEnd(*parent_);\par
04657     \}\par
04658 \par
04659     elapsed_time_ = GetTimeInMillis() - start;\par
04660 \par
04661     {\cf20 // Tells the unit test event listener that the tests have just finished.}\par
04662     repeater->OnTestIterationEnd(*parent_, i);\par
04663 \par
04664     {\cf20 // Gets the result and clears it.}\par
04665     {\cf19 if} (!Passed()) \{\par
04666       failed = {\cf17 true};\par
04667     \}\par
04668 \par
04669     {\cf20 // Restores the original test order after the iteration.  This}\par
04670     {\cf20 // allows the user to quickly repro a failure that happens in the}\par
04671     {\cf20 // N-th iteration without repeating the first (N - 1) iterations.}\par
04672     {\cf20 // This is not enclosed in "if (GTEST_FLAG(shuffle)) \{ ... \}", in}\par
04673     {\cf20 // case the user somehow changes the value of the flag somewhere}\par
04674     {\cf20 // (it's always safe to unshuffle the tests).}\par
04675     UnshuffleTests();\par
04676 \par
04677     {\cf19 if} (GTEST_FLAG(shuffle)) \{\par
04678       {\cf20 // Picks a new random seed for each iteration.}\par
04679       random_seed_ = GetNextRandomSeed(random_seed_);\par
04680     \}\par
04681   \}\par
04682 \par
04683   repeater->OnTestProgramEnd(*parent_);\par
04684 \par
04685   {\cf19 return} !failed;\par
04686 \}\par
04687 \par
04688 {\cf20 // Reads the GTEST_SHARD_STATUS_FILE environment variable, and creates the file}\par
04689 {\cf20 // if the variable is present. If a file already exists at this location, this}\par
04690 {\cf20 // function will write over it. If the variable is present, but the file cannot}\par
04691 {\cf20 // be created, prints an error and exits.}\par
04692 {\cf18 void} WriteToShardStatusFileIfNeeded() \{\par
04693   {\cf17 const} {\cf18 char}* {\cf17 const} test_shard_file = posix::GetEnv(kTestShardStatusFile);\par
04694   {\cf19 if} (test_shard_file != NULL) \{\par
04695     FILE* {\cf17 const} file = posix::FOpen(test_shard_file, {\cf22 "w"});\par
04696     {\cf19 if} (file == NULL) \{\par
04697       ColoredPrintf(COLOR_RED,\par
04698                     {\cf22 "Could not write to the test shard status file \\"%s\\" "}\par
04699                     {\cf22 "specified by the %s environment variable.\\n"},\par
04700                     test_shard_file, kTestShardStatusFile);\par
04701       fflush(stdout);\par
04702       exit(EXIT_FAILURE);\par
04703     \}\par
04704     fclose(file);\par
04705   \}\par
04706 \}\par
04707 \par
04708 {\cf20 // Checks whether sharding is enabled by examining the relevant}\par
04709 {\cf20 // environment variable values. If the variables are present,}\par
04710 {\cf20 // but inconsistent (i.e., shard_index >= total_shards), prints}\par
04711 {\cf20 // an error and exits. If in_subprocess_for_death_test, sharding is}\par
04712 {\cf20 // disabled because it must only be applied to the original test}\par
04713 {\cf20 // process. Otherwise, we could filter out death tests we intended to execute.}\par
04714 {\cf18 bool} ShouldShard({\cf17 const} {\cf18 char}* total_shards_env,\par
04715                  {\cf17 const} {\cf18 char}* shard_index_env,\par
04716                  {\cf18 bool} in_subprocess_for_death_test) \{\par
04717   {\cf19 if} (in_subprocess_for_death_test) \{\par
04718     {\cf19 return} {\cf17 false};\par
04719   \}\par
04720 \par
04721   {\cf17 const} Int32 total_shards = Int32FromEnvOrDie(total_shards_env, -1);\par
04722   {\cf17 const} Int32 shard_index = Int32FromEnvOrDie(shard_index_env, -1);\par
04723 \par
04724   {\cf19 if} (total_shards == -1 && shard_index == -1) \{\par
04725     {\cf19 return} {\cf17 false};\par
04726   \} {\cf19 else} {\cf19 if} (total_shards == -1 && shard_index != -1) \{\par
04727     {\cf17 const} Message msg = Message()\par
04728       << {\cf22 "Invalid environment variables: you have "}\par
04729       << kTestShardIndex << {\cf22 " = "} << shard_index\par
04730       << {\cf22 ", but have left "} << kTestTotalShards << {\cf22 " unset.\\n"};\par
04731     ColoredPrintf(COLOR_RED, {\cf22 "%s"}, msg.GetString().c_str());\par
04732     fflush(stdout);\par
04733     exit(EXIT_FAILURE);\par
04734   \} {\cf19 else} {\cf19 if} (total_shards != -1 && shard_index == -1) \{\par
04735     {\cf17 const} Message msg = Message()\par
04736       << {\cf22 "Invalid environment variables: you have "}\par
04737       << kTestTotalShards << {\cf22 " = "} << total_shards\par
04738       << {\cf22 ", but have left "} << kTestShardIndex << {\cf22 " unset.\\n"};\par
04739     ColoredPrintf(COLOR_RED, {\cf22 "%s"}, msg.GetString().c_str());\par
04740     fflush(stdout);\par
04741     exit(EXIT_FAILURE);\par
04742   \} {\cf19 else} {\cf19 if} (shard_index < 0 || shard_index >= total_shards) \{\par
04743     {\cf17 const} Message msg = Message()\par
04744       << {\cf22 "Invalid environment variables: we require 0 <= "}\par
04745       << kTestShardIndex << {\cf22 " < "} << kTestTotalShards\par
04746       << {\cf22 ", but you have "} << kTestShardIndex << {\cf22 "="} << shard_index\par
04747       << {\cf22 ", "} << kTestTotalShards << {\cf22 "="} << total_shards << {\cf22 ".\\n"};\par
04748     ColoredPrintf(COLOR_RED, {\cf22 "%s"}, msg.GetString().c_str());\par
04749     fflush(stdout);\par
04750     exit(EXIT_FAILURE);\par
04751   \}\par
04752 \par
04753   {\cf19 return} total_shards > 1;\par
04754 \}\par
04755 \par
04756 {\cf20 // Parses the environment variable var as an Int32. If it is unset,}\par
04757 {\cf20 // returns default_val. If it is not an Int32, prints an error}\par
04758 {\cf20 // and aborts.}\par
04759 Int32 Int32FromEnvOrDie({\cf17 const} {\cf18 char}* var, Int32 default_val) \{\par
04760   {\cf17 const} {\cf18 char}* str_val = posix::GetEnv(var);\par
04761   {\cf19 if} (str_val == NULL) \{\par
04762     {\cf19 return} default_val;\par
04763   \}\par
04764 \par
04765   Int32 result;\par
04766   {\cf19 if} (!ParseInt32(Message() << {\cf22 "The value of environment variable "} << var,\par
04767                   str_val, &result)) \{\par
04768     exit(EXIT_FAILURE);\par
04769   \}\par
04770   {\cf19 return} result;\par
04771 \}\par
04772 \par
04773 {\cf20 // Given the total number of shards, the shard index, and the test id,}\par
04774 {\cf20 // returns true iff the test should be run on this shard. The test id is}\par
04775 {\cf20 // some arbitrary but unique non-negative integer assigned to each test}\par
04776 {\cf20 // method. Assumes that 0 <= shard_index < total_shards.}\par
04777 {\cf18 bool} ShouldRunTestOnShard({\cf18 int} total_shards, {\cf18 int} shard_index, {\cf18 int} test_id) \{\par
04778   {\cf19 return} (test_id % total_shards) == shard_index;\par
04779 \}\par
04780 \par
04781 {\cf20 // Compares the name of each test with the user-specified filter to}\par
04782 {\cf20 // decide whether the test should be run, then records the result in}\par
04783 {\cf20 // each TestCase and TestInfo object.}\par
04784 {\cf20 // If shard_tests == true, further filters tests based on sharding}\par
04785 {\cf20 // variables in the environment - see}\par
04786 {\cf20 // http://code.google.com/p/googletest/wiki/GoogleTestAdvancedGuide.}\par
04787 {\cf20 // Returns the number of tests that should run.}\par
04788 {\cf18 int} UnitTestImpl::FilterTests(ReactionToSharding shard_tests) \{\par
04789   {\cf17 const} Int32 total_shards = shard_tests == HONOR_SHARDING_PROTOCOL ?\par
04790       Int32FromEnvOrDie(kTestTotalShards, -1) : -1;\par
04791   {\cf17 const} Int32 shard_index = shard_tests == HONOR_SHARDING_PROTOCOL ?\par
04792       Int32FromEnvOrDie(kTestShardIndex, -1) : -1;\par
04793 \par
04794   {\cf20 // num_runnable_tests are the number of tests that will}\par
04795   {\cf20 // run across all shards (i.e., match filter and are not disabled).}\par
04796   {\cf20 // num_selected_tests are the number of tests to be run on}\par
04797   {\cf20 // this shard.}\par
04798   {\cf18 int} num_runnable_tests = 0;\par
04799   {\cf18 int} num_selected_tests = 0;\par
04800   {\cf19 for} ({\cf18 size_t} i = 0; i < test_cases_.size(); i++) \{\par
04801     TestCase* {\cf17 const} test_case = test_cases_[i];\par
04802     {\cf17 const} std::string &test_case_name = test_case->name();\par
04803     test_case->set_should_run({\cf17 false});\par
04804 \par
04805     {\cf19 for} ({\cf18 size_t} j = 0; j < test_case->test_info_list().size(); j++) \{\par
04806       TestInfo* {\cf17 const} test_info = test_case->test_info_list()[j];\par
04807       {\cf17 const} std::string test_name(test_info->name());\par
04808       {\cf20 // A test is disabled if test case name or test name matches}\par
04809       {\cf20 // kDisableTestFilter.}\par
04810       {\cf17 const} {\cf18 bool} is_disabled =\par
04811           internal::UnitTestOptions::MatchesFilter(test_case_name,\par
04812                                                    kDisableTestFilter) ||\par
04813           internal::UnitTestOptions::MatchesFilter(test_name,\par
04814                                                    kDisableTestFilter);\par
04815       test_info->is_disabled_ = is_disabled;\par
04816 \par
04817       {\cf17 const} {\cf18 bool} matches_filter =\par
04818           internal::UnitTestOptions::FilterMatchesTest(test_case_name,\par
04819                                                        test_name);\par
04820       test_info->matches_filter_ = matches_filter;\par
04821 \par
04822       {\cf17 const} {\cf18 bool} is_runnable =\par
04823           (GTEST_FLAG(also_run_disabled_tests) || !is_disabled) &&\par
04824           matches_filter;\par
04825 \par
04826       {\cf17 const} {\cf18 bool} is_selected = is_runnable &&\par
04827           (shard_tests == IGNORE_SHARDING_PROTOCOL ||\par
04828            ShouldRunTestOnShard(total_shards, shard_index,\par
04829                                 num_runnable_tests));\par
04830 \par
04831       num_runnable_tests += is_runnable;\par
04832       num_selected_tests += is_selected;\par
04833 \par
04834       test_info->should_run_ = is_selected;\par
04835       test_case->set_should_run(test_case->should_run() || is_selected);\par
04836     \}\par
04837   \}\par
04838   {\cf19 return} num_selected_tests;\par
04839 \}\par
04840 \par
04841 {\cf20 // Prints the given C-string on a single line by replacing all '\\n'}\par
04842 {\cf20 // characters with string "\\\\n".  If the output takes more than}\par
04843 {\cf20 // max_length characters, only prints the first max_length characters}\par
04844 {\cf20 // and "...".}\par
04845 {\cf17 static} {\cf18 void} PrintOnOneLine({\cf17 const} {\cf18 char}* str, {\cf18 int} max_length) \{\par
04846   {\cf19 if} (str != NULL) \{\par
04847     {\cf19 for} ({\cf18 int} i = 0; *str != {\cf23 '\\0'}; ++str) \{\par
04848       {\cf19 if} (i >= max_length) \{\par
04849         printf({\cf22 "..."});\par
04850         {\cf19 break};\par
04851       \}\par
04852       {\cf19 if} (*str == {\cf23 '\\n'}) \{\par
04853         printf({\cf22 "\\\\n"});\par
04854         i += 2;\par
04855       \} {\cf19 else} \{\par
04856         printf({\cf22 "%c"}, *str);\par
04857         ++i;\par
04858       \}\par
04859     \}\par
04860   \}\par
04861 \}\par
04862 \par
04863 {\cf20 // Prints the names of the tests matching the user-specified filter flag.}\par
04864 {\cf18 void} UnitTestImpl::ListTestsMatchingFilter() \{\par
04865   {\cf20 // Print at most this many characters for each type/value parameter.}\par
04866   {\cf17 const} {\cf18 int} kMaxParamLength = 250;\par
04867 \par
04868   {\cf19 for} ({\cf18 size_t} i = 0; i < test_cases_.size(); i++) \{\par
04869     {\cf17 const} TestCase* {\cf17 const} test_case = test_cases_[i];\par
04870     {\cf18 bool} printed_test_case_name = {\cf17 false};\par
04871 \par
04872     {\cf19 for} ({\cf18 size_t} j = 0; j < test_case->test_info_list().size(); j++) \{\par
04873       {\cf17 const} TestInfo* {\cf17 const} test_info =\par
04874           test_case->test_info_list()[j];\par
04875       {\cf19 if} (test_info->matches_filter_) \{\par
04876         {\cf19 if} (!printed_test_case_name) \{\par
04877           printed_test_case_name = {\cf17 true};\par
04878           printf({\cf22 "%s."}, test_case->name());\par
04879           {\cf19 if} (test_case->type_param() != NULL) \{\par
04880             printf({\cf22 "  # %s = "}, kTypeParamLabel);\par
04881             {\cf20 // We print the type parameter on a single line to make}\par
04882             {\cf20 // the output easy to parse by a program.}\par
04883             PrintOnOneLine(test_case->type_param(), kMaxParamLength);\par
04884           \}\par
04885           printf({\cf22 "\\n"});\par
04886         \}\par
04887         printf({\cf22 "  %s"}, test_info->name());\par
04888         {\cf19 if} (test_info->value_param() != NULL) \{\par
04889           printf({\cf22 "  # %s = "}, kValueParamLabel);\par
04890           {\cf20 // We print the value parameter on a single line to make the}\par
04891           {\cf20 // output easy to parse by a program.}\par
04892           PrintOnOneLine(test_info->value_param(), kMaxParamLength);\par
04893         \}\par
04894         printf({\cf22 "\\n"});\par
04895       \}\par
04896     \}\par
04897   \}\par
04898   fflush(stdout);\par
04899 \}\par
04900 \par
04901 {\cf20 // Sets the OS stack trace getter.}\par
04902 {\cf20 //}\par
04903 {\cf20 // Does nothing if the input and the current OS stack trace getter are}\par
04904 {\cf20 // the same; otherwise, deletes the old getter and makes the input the}\par
04905 {\cf20 // current getter.}\par
04906 {\cf18 void} UnitTestImpl::set_os_stack_trace_getter(\par
04907     OsStackTraceGetterInterface* getter) \{\par
04908   {\cf19 if} (os_stack_trace_getter_ != getter) \{\par
04909     {\cf17 delete} os_stack_trace_getter_;\par
04910     os_stack_trace_getter_ = getter;\par
04911   \}\par
04912 \}\par
04913 \par
04914 {\cf20 // Returns the current OS stack trace getter if it is not NULL;}\par
04915 {\cf20 // otherwise, creates an OsStackTraceGetter, makes it the current}\par
04916 {\cf20 // getter, and returns it.}\par
04917 OsStackTraceGetterInterface* UnitTestImpl::os_stack_trace_getter() \{\par
04918   {\cf19 if} (os_stack_trace_getter_ == NULL) \{\par
04919 {\cf21 #ifdef GTEST_OS_STACK_TRACE_GETTER_}\par
04920     os_stack_trace_getter_ = {\cf17 new} GTEST_OS_STACK_TRACE_GETTER_;\par
04921 {\cf21 #else}\par
04922     os_stack_trace_getter_ = {\cf17 new} OsStackTraceGetter;\par
04923 {\cf21 #endif  }{\cf20 // GTEST_OS_STACK_TRACE_GETTER_}\par
04924   \}\par
04925 \par
04926   {\cf19 return} os_stack_trace_getter_;\par
04927 \}\par
04928 \par
04929 {\cf20 // Returns the TestResult for the test that's currently running, or}\par
04930 {\cf20 // the TestResult for the ad hoc test if no test is running.}\par
04931 TestResult* UnitTestImpl::current_test_result() \{\par
04932   {\cf19 return} current_test_info_ ?\par
04933       &(current_test_info_->result_) : &ad_hoc_test_result_;\par
04934 \}\par
04935 \par
04936 {\cf20 // Shuffles all test cases, and the tests within each test case,}\par
04937 {\cf20 // making sure that death tests are still run first.}\par
04938 {\cf18 void} UnitTestImpl::ShuffleTests() \{\par
04939   {\cf20 // Shuffles the death test cases.}\par
04940   ShuffleRange(random(), 0, last_death_test_case_ + 1, &test_case_indices_);\par
04941 \par
04942   {\cf20 // Shuffles the non-death test cases.}\par
04943   ShuffleRange(random(), last_death_test_case_ + 1,\par
04944                {\cf17 static_cast<}{\cf18 int}{\cf17 >}(test_cases_.size()), &test_case_indices_);\par
04945 \par
04946   {\cf20 // Shuffles the tests inside each test case.}\par
04947   {\cf19 for} ({\cf18 size_t} i = 0; i < test_cases_.size(); i++) \{\par
04948     test_cases_[i]->ShuffleTests(random());\par
04949   \}\par
04950 \}\par
04951 \par
04952 {\cf20 // Restores the test cases and tests to their order before the first shuffle.}\par
04953 {\cf18 void} UnitTestImpl::UnshuffleTests() \{\par
04954   {\cf19 for} ({\cf18 size_t} i = 0; i < test_cases_.size(); i++) \{\par
04955     {\cf20 // Unshuffles the tests in each test case.}\par
04956     test_cases_[i]->UnshuffleTests();\par
04957     {\cf20 // Resets the index of each test case.}\par
04958     test_case_indices_[i] = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(i);\par
04959   \}\par
04960 \}\par
04961 \par
04962 {\cf20 // Returns the current OS stack trace as an std::string.}\par
04963 {\cf20 //}\par
04964 {\cf20 // The maximum number of stack frames to be included is specified by}\par
04965 {\cf20 // the gtest_stack_trace_depth flag.  The skip_count parameter}\par
04966 {\cf20 // specifies the number of top frames to be skipped, which doesn't}\par
04967 {\cf20 // count against the number of frames to be included.}\par
04968 {\cf20 //}\par
04969 {\cf20 // For example, if Foo() calls Bar(), which in turn calls}\par
04970 {\cf20 // GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in}\par
04971 {\cf20 // the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.}\par
04972 std::string GetCurrentOsStackTraceExceptTop(UnitTest* {\cf20 /*unit_test*/},\par
04973                                             {\cf18 int} skip_count) \{\par
04974   {\cf20 // We pass skip_count + 1 to skip this wrapper function in addition}\par
04975   {\cf20 // to what the user really wants to skip.}\par
04976   {\cf19 return} GetUnitTestImpl()->CurrentOsStackTraceExceptTop(skip_count + 1);\par
04977 \}\par
04978 \par
04979 {\cf20 // Used by the GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_ macro to}\par
04980 {\cf20 // suppress unreachable code warnings.}\par
04981 {\cf17 namespace }\{\par
04982 {\cf17 class }ClassUniqueToAlwaysTrue \{\};\par
04983 \}\par
04984 \par
04985 {\cf18 bool} IsTrue({\cf18 bool} condition) \{ {\cf19 return} condition; \}\par
04986 \par
04987 {\cf18 bool} AlwaysTrue() \{\par
04988 {\cf21 #if GTEST_HAS_EXCEPTIONS}\par
04989   {\cf20 // This condition is always false so AlwaysTrue() never actually throws,}\par
04990   {\cf20 // but it makes the compiler think that it may throw.}\par
04991   {\cf19 if} (IsTrue({\cf17 false}))\par
04992     {\cf19 throw} ClassUniqueToAlwaysTrue();\par
04993 {\cf21 #endif  }{\cf20 // GTEST_HAS_EXCEPTIONS}\par
04994   {\cf19 return} {\cf17 true};\par
04995 \}\par
04996 \par
04997 {\cf20 // If *pstr starts with the given prefix, modifies *pstr to be right}\par
04998 {\cf20 // past the prefix and returns true; otherwise leaves *pstr unchanged}\par
04999 {\cf20 // and returns false.  None of pstr, *pstr, and prefix can be NULL.}\par
05000 {\cf18 bool} SkipPrefix({\cf17 const} {\cf18 char}* prefix, {\cf17 const} {\cf18 char}** pstr) \{\par
05001   {\cf17 const} {\cf18 size_t} prefix_len = strlen(prefix);\par
05002   {\cf19 if} (strncmp(*pstr, prefix, prefix_len) == 0) \{\par
05003     *pstr += prefix_len;\par
05004     {\cf19 return} {\cf17 true};\par
05005   \}\par
05006   {\cf19 return} {\cf17 false};\par
05007 \}\par
05008 \par
05009 {\cf20 // Parses a string as a command line flag.  The string should have}\par
05010 {\cf20 // the format "--flag=value".  When def_optional is true, the "=value"}\par
05011 {\cf20 // part can be omitted.}\par
05012 {\cf20 //}\par
05013 {\cf20 // Returns the value of the flag, or NULL if the parsing failed.}\par
05014 {\cf17 const} {\cf18 char}* ParseFlagValue({\cf17 const} {\cf18 char}* str,\par
05015                            {\cf17 const} {\cf18 char}* flag,\par
05016                            {\cf18 bool} def_optional) \{\par
05017   {\cf20 // str and flag must not be NULL.}\par
05018   {\cf19 if} (str == NULL || flag == NULL) {\cf19 return} NULL;\par
05019 \par
05020   {\cf20 // The flag must start with "--" followed by GTEST_FLAG_PREFIX_.}\par
05021   {\cf17 const} std::string flag_str = std::string({\cf22 "--"}) + GTEST_FLAG_PREFIX_ + flag;\par
05022   {\cf17 const} {\cf18 size_t} flag_len = flag_str.length();\par
05023   {\cf19 if} (strncmp(str, flag_str.c_str(), flag_len) != 0) {\cf19 return} NULL;\par
05024 \par
05025   {\cf20 // Skips the flag name.}\par
05026   {\cf17 const} {\cf18 char}* flag_end = str + flag_len;\par
05027 \par
05028   {\cf20 // When def_optional is true, it's OK to not have a "=value" part.}\par
05029   {\cf19 if} (def_optional && (flag_end[0] == {\cf23 '\\0'})) \{\par
05030     {\cf19 return} flag_end;\par
05031   \}\par
05032 \par
05033   {\cf20 // If def_optional is true and there are more characters after the}\par
05034   {\cf20 // flag name, or if def_optional is false, there must be a '=' after}\par
05035   {\cf20 // the flag name.}\par
05036   {\cf19 if} (flag_end[0] != {\cf23 '='}) {\cf19 return} NULL;\par
05037 \par
05038   {\cf20 // Returns the string after "=".}\par
05039   {\cf19 return} flag_end + 1;\par
05040 \}\par
05041 \par
05042 {\cf20 // Parses a string for a bool flag, in the form of either}\par
05043 {\cf20 // "--flag=value" or "--flag".}\par
05044 {\cf20 //}\par
05045 {\cf20 // In the former case, the value is taken as true as long as it does}\par
05046 {\cf20 // not start with '0', 'f', or 'F'.}\par
05047 {\cf20 //}\par
05048 {\cf20 // In the latter case, the value is taken as true.}\par
05049 {\cf20 //}\par
05050 {\cf20 // On success, stores the value of the flag in *value, and returns}\par
05051 {\cf20 // true.  On failure, returns false without changing *value.}\par
05052 {\cf18 bool} ParseBoolFlag({\cf17 const} {\cf18 char}* str, {\cf17 const} {\cf18 char}* flag, {\cf18 bool}* value) \{\par
05053   {\cf20 // Gets the value of the flag as a string.}\par
05054   {\cf17 const} {\cf18 char}* {\cf17 const} value_str = ParseFlagValue(str, flag, {\cf17 true});\par
05055 \par
05056   {\cf20 // Aborts if the parsing failed.}\par
05057   {\cf19 if} (value_str == NULL) {\cf19 return} {\cf17 false};\par
05058 \par
05059   {\cf20 // Converts the string value to a bool.}\par
05060   *value = !(*value_str == {\cf23 '0'} || *value_str == {\cf23 'f'} || *value_str == {\cf23 'F'});\par
05061   {\cf19 return} {\cf17 true};\par
05062 \}\par
05063 \par
05064 {\cf20 // Parses a string for an Int32 flag, in the form of}\par
05065 {\cf20 // "--flag=value".}\par
05066 {\cf20 //}\par
05067 {\cf20 // On success, stores the value of the flag in *value, and returns}\par
05068 {\cf20 // true.  On failure, returns false without changing *value.}\par
05069 {\cf18 bool} ParseInt32Flag({\cf17 const} {\cf18 char}* str, {\cf17 const} {\cf18 char}* flag, Int32* value) \{\par
05070   {\cf20 // Gets the value of the flag as a string.}\par
05071   {\cf17 const} {\cf18 char}* {\cf17 const} value_str = ParseFlagValue(str, flag, {\cf17 false});\par
05072 \par
05073   {\cf20 // Aborts if the parsing failed.}\par
05074   {\cf19 if} (value_str == NULL) {\cf19 return} {\cf17 false};\par
05075 \par
05076   {\cf20 // Sets *value to the value of the flag.}\par
05077   {\cf19 return} ParseInt32(Message() << {\cf22 "The value of flag --"} << flag,\par
05078                     value_str, value);\par
05079 \}\par
05080 \par
05081 {\cf20 // Parses a string for a string flag, in the form of}\par
05082 {\cf20 // "--flag=value".}\par
05083 {\cf20 //}\par
05084 {\cf20 // On success, stores the value of the flag in *value, and returns}\par
05085 {\cf20 // true.  On failure, returns false without changing *value.}\par
05086 {\cf18 bool} ParseStringFlag({\cf17 const} {\cf18 char}* str, {\cf17 const} {\cf18 char}* flag, std::string* value) \{\par
05087   {\cf20 // Gets the value of the flag as a string.}\par
05088   {\cf17 const} {\cf18 char}* {\cf17 const} value_str = ParseFlagValue(str, flag, {\cf17 false});\par
05089 \par
05090   {\cf20 // Aborts if the parsing failed.}\par
05091   {\cf19 if} (value_str == NULL) {\cf19 return} {\cf17 false};\par
05092 \par
05093   {\cf20 // Sets *value to the value of the flag.}\par
05094   *value = value_str;\par
05095   {\cf19 return} {\cf17 true};\par
05096 \}\par
05097 \par
05098 {\cf20 // Determines whether a string has a prefix that Google Test uses for its}\par
05099 {\cf20 // flags, i.e., starts with GTEST_FLAG_PREFIX_ or GTEST_FLAG_PREFIX_DASH_.}\par
05100 {\cf20 // If Google Test detects that a command line flag has its prefix but is not}\par
05101 {\cf20 // recognized, it will print its help message. Flags starting with}\par
05102 {\cf20 // GTEST_INTERNAL_PREFIX_ followed by "internal_" are considered Google Test}\par
05103 {\cf20 // internal flags and do not trigger the help message.}\par
05104 {\cf17 static} {\cf18 bool} HasGoogleTestFlagPrefix({\cf17 const} {\cf18 char}* str) \{\par
05105   {\cf19 return} (SkipPrefix({\cf22 "--"}, &str) ||\par
05106           SkipPrefix({\cf22 "-"}, &str) ||\par
05107           SkipPrefix({\cf22 "/"}, &str)) &&\par
05108          !SkipPrefix(GTEST_FLAG_PREFIX_ {\cf22 "internal_"}, &str) &&\par
05109          (SkipPrefix(GTEST_FLAG_PREFIX_, &str) ||\par
05110           SkipPrefix(GTEST_FLAG_PREFIX_DASH_, &str));\par
05111 \}\par
05112 \par
05113 {\cf20 // Prints a string containing code-encoded text.  The following escape}\par
05114 {\cf20 // sequences can be used in the string to control the text color:}\par
05115 {\cf20 //}\par
05116 {\cf20 //   @@    prints a single '@' character.}\par
05117 {\cf20 //   @R    changes the color to red.}\par
05118 {\cf20 //   @G    changes the color to green.}\par
05119 {\cf20 //   @Y    changes the color to yellow.}\par
05120 {\cf20 //   @D    changes to the default terminal text color.}\par
05121 {\cf20 //}\par
05122 {\cf20 // TODO(wan@google.com): Write tests for this once we add stdout}\par
05123 {\cf20 // capturing to Google Test.}\par
05124 {\cf17 static} {\cf18 void} PrintColorEncoded({\cf17 const} {\cf18 char}* str) \{\par
05125   GTestColor color = COLOR_DEFAULT;  {\cf20 // The current color.}\par
05126 \par
05127   {\cf20 // Conceptually, we split the string into segments divided by escape}\par
05128   {\cf20 // sequences.  Then we print one segment at a time.  At the end of}\par
05129   {\cf20 // each iteration, the str pointer advances to the beginning of the}\par
05130   {\cf20 // next segment.}\par
05131   {\cf19 for} (;;) \{\par
05132     {\cf17 const} {\cf18 char}* p = strchr(str, {\cf23 '@'});\par
05133     {\cf19 if} (p == NULL) \{\par
05134       ColoredPrintf(color, {\cf22 "%s"}, str);\par
05135       {\cf19 return};\par
05136     \}\par
05137 \par
05138     ColoredPrintf(color, {\cf22 "%s"}, std::string(str, p).c_str());\par
05139 \par
05140     {\cf17 const} {\cf18 char} ch = p[1];\par
05141     str = p + 2;\par
05142     {\cf19 if} (ch == {\cf23 '@'}) \{\par
05143       ColoredPrintf(color, {\cf22 "@"});\par
05144     \} {\cf19 else} {\cf19 if} (ch == {\cf23 'D'}) \{\par
05145       color = COLOR_DEFAULT;\par
05146     \} {\cf19 else} {\cf19 if} (ch == {\cf23 'R'}) \{\par
05147       color = COLOR_RED;\par
05148     \} {\cf19 else} {\cf19 if} (ch == {\cf23 'G'}) \{\par
05149       color = COLOR_GREEN;\par
05150     \} {\cf19 else} {\cf19 if} (ch == {\cf23 'Y'}) \{\par
05151       color = COLOR_YELLOW;\par
05152     \} {\cf19 else} \{\par
05153       --str;\par
05154     \}\par
05155   \}\par
05156 \}\par
05157 \par
05158 {\cf17 static} {\cf17 const} {\cf18 char} kColorEncodedHelpMessage[] =\par
05159 {\cf22 "This program contains tests written using "} GTEST_NAME_ {\cf22 ". You can use the\\n"}\par
05160 {\cf22 "following command line flags to control its behavior:\\n"}\par
05161 {\cf22 "\\n"}\par
05162 {\cf22 "Test Selection:\\n"}\par
05163 {\cf22 "  @G--"} GTEST_FLAG_PREFIX_ {\cf22 "list_tests@D\\n"}\par
05164 {\cf22 "      List the names of all tests instead of running them. The name of\\n"}\par
05165 {\cf22 "      TEST(Foo, Bar) is \\"Foo.Bar\\".\\n"}\par
05166 {\cf22 "  @G--"} GTEST_FLAG_PREFIX_ {\cf22 "filter=@YPOSTIVE_PATTERNS"}\par
05167     {\cf22 "[@G-@YNEGATIVE_PATTERNS]@D\\n"}\par
05168 {\cf22 "      Run only the tests whose name matches one of the positive patterns but\\n"}\par
05169 {\cf22 "      none of the negative patterns. '?' matches any single character; '*'\\n"}\par
05170 {\cf22 "      matches any substring; ':' separates two patterns.\\n"}\par
05171 {\cf22 "  @G--"} GTEST_FLAG_PREFIX_ {\cf22 "also_run_disabled_tests@D\\n"}\par
05172 {\cf22 "      Run all disabled tests too.\\n"}\par
05173 {\cf22 "\\n"}\par
05174 {\cf22 "Test Execution:\\n"}\par
05175 {\cf22 "  @G--"} GTEST_FLAG_PREFIX_ {\cf22 "repeat=@Y[COUNT]@D\\n"}\par
05176 {\cf22 "      Run the tests repeatedly; use a negative count to repeat forever.\\n"}\par
05177 {\cf22 "  @G--"} GTEST_FLAG_PREFIX_ {\cf22 "shuffle@D\\n"}\par
05178 {\cf22 "      Randomize tests' orders on every iteration.\\n"}\par
05179 {\cf22 "  @G--"} GTEST_FLAG_PREFIX_ {\cf22 "random_seed=@Y[NUMBER]@D\\n"}\par
05180 {\cf22 "      Random number seed to use for shuffling test orders (between 1 and\\n"}\par
05181 {\cf22 "      99999, or 0 to use a seed based on the current time).\\n"}\par
05182 {\cf22 "\\n"}\par
05183 {\cf22 "Test Output:\\n"}\par
05184 {\cf22 "  @G--"} GTEST_FLAG_PREFIX_ {\cf22 "color=@Y(@Gyes@Y|@Gno@Y|@Gauto@Y)@D\\n"}\par
05185 {\cf22 "      Enable/disable colored output. The default is @Gauto@D.\\n"}\par
05186 {\cf22 "  @G--"} GTEST_FLAG_PREFIX_ {\cf22 "print_time=0@D\\n"}\par
05187 {\cf22 "      Don't print the elapsed time of each test.\\n"}\par
05188 {\cf22 "  @G--"} GTEST_FLAG_PREFIX_ {\cf22 "output=xml@Y[@G:@YDIRECTORY_PATH@G"}\par
05189     GTEST_PATH_SEP_ {\cf22 "@Y|@G:@YFILE_PATH]@D\\n"}\par
05190 {\cf22 "      Generate an XML report in the given directory or with the given file\\n"}\par
05191 {\cf22 "      name. @YFILE_PATH@D defaults to @Gtest_details.xml@D.\\n"}\par
05192 {\cf21 #if GTEST_CAN_STREAM_RESULTS_}\par
05193 {\cf22 "  @G--"} GTEST_FLAG_PREFIX_ {\cf22 "stream_result_to=@YHOST@G:@YPORT@D\\n"}\par
05194 {\cf22 "      Stream test results to the given server.\\n"}\par
05195 {\cf21 #endif  }{\cf20 // GTEST_CAN_STREAM_RESULTS_}\par
05196 {\cf22 "\\n"}\par
05197 {\cf22 "Assertion Behavior:\\n"}\par
05198 {\cf21 #if GTEST_HAS_DEATH_TEST && !GTEST_OS_WINDOWS}\par
05199 {\cf22 "  @G--"} GTEST_FLAG_PREFIX_ {\cf22 "death_test_style=@Y(@Gfast@Y|@Gthreadsafe@Y)@D\\n"}\par
05200 {\cf22 "      Set the default death test style.\\n"}\par
05201 {\cf21 #endif  }{\cf20 // GTEST_HAS_DEATH_TEST && !GTEST_OS_WINDOWS}\par
05202 {\cf22 "  @G--"} GTEST_FLAG_PREFIX_ {\cf22 "break_on_failure@D\\n"}\par
05203 {\cf22 "      Turn assertion failures into debugger break-points.\\n"}\par
05204 {\cf22 "  @G--"} GTEST_FLAG_PREFIX_ {\cf22 "throw_on_failure@D\\n"}\par
05205 {\cf22 "      Turn assertion failures into C++ exceptions.\\n"}\par
05206 {\cf22 "  @G--"} GTEST_FLAG_PREFIX_ {\cf22 "catch_exceptions=0@D\\n"}\par
05207 {\cf22 "      Do not report exceptions as test failures. Instead, allow them\\n"}\par
05208 {\cf22 "      to crash the program or throw a pop-up (on Windows).\\n"}\par
05209 {\cf22 "\\n"}\par
05210 {\cf22 "Except for @G--"} GTEST_FLAG_PREFIX_ {\cf22 "list_tests@D, you can alternatively set "}\par
05211     {\cf22 "the corresponding\\n"}\par
05212 {\cf22 "environment variable of a flag (all letters in upper-case). For example, to\\n"}\par
05213 {\cf22 "disable colored text output, you can either specify @G--"} GTEST_FLAG_PREFIX_\par
05214     {\cf22 "color=no@D or set\\n"}\par
05215 {\cf22 "the @G"} GTEST_FLAG_PREFIX_UPPER_ {\cf22 "COLOR@D environment variable to @Gno@D.\\n"}\par
05216 {\cf22 "\\n"}\par
05217 {\cf22 "For more information, please read the "} GTEST_NAME_ {\cf22 " documentation at\\n"}\par
05218 {\cf22 "@G"} GTEST_PROJECT_URL_ {\cf22 "@D. If you find a bug in "} GTEST_NAME_ {\cf22 "\\n"}\par
05219 {\cf22 "(not one in your own code or tests), please report it to\\n"}\par
05220 {\cf22 "@G<"} GTEST_DEV_EMAIL_ {\cf22 ">@D.\\n"};\par
05221 \par
05222 {\cf18 bool} ParseGoogleTestFlag({\cf17 const} {\cf18 char}* {\cf17 const} arg) \{\par
05223   {\cf19 return} ParseBoolFlag(arg, kAlsoRunDisabledTestsFlag,\par
05224                        &GTEST_FLAG(also_run_disabled_tests)) ||\par
05225       ParseBoolFlag(arg, kBreakOnFailureFlag,\par
05226                     &GTEST_FLAG(break_on_failure)) ||\par
05227       ParseBoolFlag(arg, kCatchExceptionsFlag,\par
05228                     &GTEST_FLAG(catch_exceptions)) ||\par
05229       ParseStringFlag(arg, kColorFlag, &GTEST_FLAG(color)) ||\par
05230       ParseStringFlag(arg, kDeathTestStyleFlag,\par
05231                       &GTEST_FLAG(death_test_style)) ||\par
05232       ParseBoolFlag(arg, kDeathTestUseFork,\par
05233                     &GTEST_FLAG(death_test_use_fork)) ||\par
05234       ParseStringFlag(arg, kFilterFlag, &GTEST_FLAG(filter)) ||\par
05235       ParseStringFlag(arg, kInternalRunDeathTestFlag,\par
05236                       &GTEST_FLAG(internal_run_death_test)) ||\par
05237       ParseBoolFlag(arg, kListTestsFlag, &GTEST_FLAG(list_tests)) ||\par
05238       ParseStringFlag(arg, kOutputFlag, &GTEST_FLAG(output)) ||\par
05239       ParseBoolFlag(arg, kPrintTimeFlag, &GTEST_FLAG(print_time)) ||\par
05240       ParseInt32Flag(arg, kRandomSeedFlag, &GTEST_FLAG(random_seed)) ||\par
05241       ParseInt32Flag(arg, kRepeatFlag, &GTEST_FLAG(repeat)) ||\par
05242       ParseBoolFlag(arg, kShuffleFlag, &GTEST_FLAG(shuffle)) ||\par
05243       ParseInt32Flag(arg, kStackTraceDepthFlag,\par
05244                      &GTEST_FLAG(stack_trace_depth)) ||\par
05245       ParseStringFlag(arg, kStreamResultToFlag,\par
05246                       &GTEST_FLAG(stream_result_to)) ||\par
05247       ParseBoolFlag(arg, kThrowOnFailureFlag,\par
05248                     &GTEST_FLAG(throw_on_failure));\par
05249 \}\par
05250 \par
05251 {\cf21 #if GTEST_USE_OWN_FLAGFILE_FLAG_}\par
05252 {\cf18 void} LoadFlagsFromFile({\cf17 const} std::string& path) \{\par
05253   FILE* flagfile = posix::FOpen(path.c_str(), {\cf22 "r"});\par
05254   {\cf19 if} (!flagfile) \{\par
05255     fprintf(stderr,\par
05256             {\cf22 "Unable to open file \\"%s\\"\\n"},\par
05257             GTEST_FLAG(flagfile).c_str());\par
05258     fflush(stderr);\par
05259     exit(EXIT_FAILURE);\par
05260   \}\par
05261   std::string contents(ReadEntireFile(flagfile));\par
05262   posix::FClose(flagfile);\par
05263   std::vector<std::string> lines;\par
05264   SplitString(contents, {\cf23 '\\n'}, &lines);\par
05265   {\cf19 for} ({\cf18 size_t} i = 0; i < lines.size(); ++i) \{\par
05266     {\cf19 if} (lines[i].empty())\par
05267       {\cf19 continue};\par
05268     {\cf19 if} (!ParseGoogleTestFlag(lines[i].c_str()))\par
05269       g_help_flag = {\cf17 true};\par
05270   \}\par
05271 \}\par
05272 {\cf21 #endif  }{\cf20 // GTEST_USE_OWN_FLAGFILE_FLAG_}\par
05273 \par
05274 {\cf20 // Parses the command line for Google Test flags, without initializing}\par
05275 {\cf20 // other parts of Google Test.  The type parameter CharType can be}\par
05276 {\cf20 // instantiated to either char or wchar_t.}\par
05277 {\cf17 template} <{\cf17 typename} CharType>\par
05278 {\cf18 void} ParseGoogleTestFlagsOnlyImpl({\cf18 int}* argc, CharType** argv) \{\par
05279   {\cf19 for} ({\cf18 int} i = 1; i < *argc; i++) \{\par
05280     {\cf17 const} std::string arg_string = StreamableToString(argv[i]);\par
05281     {\cf17 const} {\cf18 char}* {\cf17 const} arg = arg_string.c_str();\par
05282 \par
05283     {\cf17 using} internal::ParseBoolFlag;\par
05284     {\cf17 using} internal::ParseInt32Flag;\par
05285     {\cf17 using} internal::ParseStringFlag;\par
05286 \par
05287     {\cf18 bool} remove_flag = {\cf17 false};\par
05288     {\cf19 if} (ParseGoogleTestFlag(arg)) \{\par
05289       remove_flag = {\cf17 true};\par
05290 {\cf21 #if GTEST_USE_OWN_FLAGFILE_FLAG_}\par
05291     \} {\cf19 else} {\cf19 if} (ParseStringFlag(arg, kFlagfileFlag, &GTEST_FLAG(flagfile))) \{\par
05292       LoadFlagsFromFile(GTEST_FLAG(flagfile));\par
05293       remove_flag = {\cf17 true};\par
05294 {\cf21 #endif  }{\cf20 // GTEST_USE_OWN_FLAGFILE_FLAG_}\par
05295     \} {\cf19 else} {\cf19 if} (arg_string == {\cf22 "--help"} || arg_string == {\cf22 "-h"} ||\par
05296                arg_string == {\cf22 "-?"} || arg_string == {\cf22 "/?"} ||\par
05297                HasGoogleTestFlagPrefix(arg)) \{\par
05298       {\cf20 // Both help flag and unrecognized Google Test flags (excluding}\par
05299       {\cf20 // internal ones) trigger help display.}\par
05300       g_help_flag = {\cf17 true};\par
05301     \}\par
05302 \par
05303     {\cf19 if} (remove_flag) \{\par
05304       {\cf20 // Shift the remainder of the argv list left by one.  Note}\par
05305       {\cf20 // that argv has (*argc + 1) elements, the last one always being}\par
05306       {\cf20 // NULL.  The following loop moves the trailing NULL element as}\par
05307       {\cf20 // well.}\par
05308       {\cf19 for} ({\cf18 int} j = i; j != *argc; j++) \{\par
05309         argv[j] = argv[j + 1];\par
05310       \}\par
05311 \par
05312       {\cf20 // Decrements the argument count.}\par
05313       (*argc)--;\par
05314 \par
05315       {\cf20 // We also need to decrement the iterator as we just removed}\par
05316       {\cf20 // an element.}\par
05317       i--;\par
05318     \}\par
05319   \}\par
05320 \par
05321   {\cf19 if} (g_help_flag) \{\par
05322     {\cf20 // We print the help here instead of in RUN_ALL_TESTS(), as the}\par
05323     {\cf20 // latter may not be called at all if the user is using Google}\par
05324     {\cf20 // Test with another testing framework.}\par
05325     PrintColorEncoded(kColorEncodedHelpMessage);\par
05326   \}\par
05327 \}\par
05328 \par
05329 {\cf20 // Parses the command line for Google Test flags, without initializing}\par
05330 {\cf20 // other parts of Google Test.}\par
05331 {\cf18 void} ParseGoogleTestFlagsOnly({\cf18 int}* argc, {\cf18 char}** argv) \{\par
05332   ParseGoogleTestFlagsOnlyImpl(argc, argv);\par
05333 \}\par
05334 {\cf18 void} ParseGoogleTestFlagsOnly({\cf18 int}* argc, {\cf18 wchar_t}** argv) \{\par
05335   ParseGoogleTestFlagsOnlyImpl(argc, argv);\par
05336 \}\par
05337 \par
05338 {\cf20 // The internal implementation of InitGoogleTest().}\par
05339 {\cf20 //}\par
05340 {\cf20 // The type parameter CharType can be instantiated to either char or}\par
05341 {\cf20 // wchar_t.}\par
05342 {\cf17 template} <{\cf17 typename} CharType>\par
05343 {\cf18 void} InitGoogleTestImpl({\cf18 int}* argc, CharType** argv) \{\par
05344   {\cf20 // We don't want to run the initialization code twice.}\par
05345   {\cf19 if} (GTestIsInitialized()) {\cf19 return};\par
05346 \par
05347   {\cf19 if} (*argc <= 0) {\cf19 return};\par
05348 \par
05349   g_argvs.clear();\par
05350   {\cf19 for} ({\cf18 int} i = 0; i != *argc; i++) \{\par
05351     g_argvs.push_back(StreamableToString(argv[i]));\par
05352   \}\par
05353 \par
05354   ParseGoogleTestFlagsOnly(argc, argv);\par
05355   GetUnitTestImpl()->PostFlagParsingInit();\par
05356 \}\par
05357 \par
05358 \}  {\cf20 // namespace internal}\par
05359 \par
05360 {\cf20 // Initializes Google Test.  This must be called before calling}\par
05361 {\cf20 // RUN_ALL_TESTS().  In particular, it parses a command line for the}\par
05362 {\cf20 // flags that Google Test recognizes.  Whenever a Google Test flag is}\par
05363 {\cf20 // seen, it is removed from argv, and *argc is decremented.}\par
05364 {\cf20 //}\par
05365 {\cf20 // No value is returned.  Instead, the Google Test flag variables are}\par
05366 {\cf20 // updated.}\par
05367 {\cf20 //}\par
05368 {\cf20 // Calling the function for the second time has no user-visible effect.}\par
05369 {\cf18 void} InitGoogleTest({\cf18 int}* argc, {\cf18 char}** argv) \{\par
05370 {\cf21 #if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
05371   GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);\par
05372 {\cf21 #else  }{\cf20 // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
05373   internal::InitGoogleTestImpl(argc, argv);\par
05374 {\cf21 #endif  }{\cf20 // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
05375 \}\par
05376 \par
05377 {\cf20 // This overloaded version can be used in Windows programs compiled in}\par
05378 {\cf20 // UNICODE mode.}\par
05379 {\cf18 void} InitGoogleTest({\cf18 int}* argc, {\cf18 wchar_t}** argv) \{\par
05380 {\cf21 #if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
05381   GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);\par
05382 {\cf21 #else  }{\cf20 // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
05383   internal::InitGoogleTestImpl(argc, argv);\par
05384 {\cf21 #endif  }{\cf20 // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)}\par
05385 \}\par
05386 \par
05387 std::string TempDir() \{\par
05388 {\cf21 #if defined(GTEST_CUSTOM_TEMPDIR_FUNCTION_)}\par
05389     {\cf19 return} GTEST_CUSTOM_TEMPDIR_FUNCTION_();\par
05390 {\cf21 #endif}\par
05391 {\cf21 #if GTEST_OS_WINDOWS_MOBILE}\par
05392   {\cf19 return} {\cf22 "\\\\temp\\\\"};\par
05393 {\cf21 #elif GTEST_OS_WINDOWS}\par
05394   {\cf17 const} {\cf18 char}* temp_dir = internal::posix::GetEnv({\cf22 "TEMP"});\par
05395   {\cf19 if} (temp_dir == NULL || temp_dir[0] == {\cf23 '\\0'})\par
05396     {\cf19 return} {\cf22 "\\\\temp\\\\"};\par
05397   {\cf19 else} {\cf19 if} (temp_dir[strlen(temp_dir) - 1] == {\cf23 '\\\\'})\par
05398     {\cf19 return} temp_dir;\par
05399   {\cf19 else}\par
05400     {\cf19 return} std::string(temp_dir) + {\cf22 "\\\\"};\par
05401 {\cf21 #elif GTEST_OS_LINUX_ANDROID}\par
05402   {\cf19 return} {\cf22 "/sdcard/"};\par
05403 {\cf21 #else}\par
05404   {\cf19 return} {\cf22 "/tmp/"};\par
05405 {\cf21 #endif  }{\cf20 // GTEST_OS_WINDOWS_MOBILE}\par
05406 \}\par
05407 \par
05408 \}  {\cf20 // namespace testing}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB gtest/src/gtest_main.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest_main.cc}
{\xe \v gtest/src/gtest_main.cc}
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "gtest/gtest.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GTEST_API_} int {\b main} (int argc, char **argv)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 
{\xe \v main\:gtest_main.cc}
{\xe \v gtest_main.cc\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GTEST_API_} int main (int  {\i argc}, char **  {\i argv})}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b gtest_main.cc} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 34}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00034                                            \{\par
00035   printf({\cf22 "Running main() from gtest_main.cc\\n"});\par
00036   testing::InitGoogleTest(&argc, argv);\par
00037   {\cf19 return} RUN_ALL_TESTS();\par
00038 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::InitGoogleTest()} \'E8 {\b RUN_ALL_TESTS()}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gtest_main.cc\par \pard\plain 
{\tc\tcl2 \v gtest/src/gtest_main.cc}
{\xe \v gtest/src/gtest_main.cc}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // Copyright 2006, Google Inc.}\par
00002 {\cf20 // All rights reserved.}\par
00003 {\cf20 //}\par
00004 {\cf20 // Redistribution and use in source and binary forms, with or without}\par
00005 {\cf20 // modification, are permitted provided that the following conditions are}\par
00006 {\cf20 // met:}\par
00007 {\cf20 //}\par
00008 {\cf20 //     * Redistributions of source code must retain the above copyright}\par
00009 {\cf20 // notice, this list of conditions and the following disclaimer.}\par
00010 {\cf20 //     * Redistributions in binary form must reproduce the above}\par
00011 {\cf20 // copyright notice, this list of conditions and the following disclaimer}\par
00012 {\cf20 // in the documentation and/or other materials provided with the}\par
00013 {\cf20 // distribution.}\par
00014 {\cf20 //     * Neither the name of Google Inc. nor the names of its}\par
00015 {\cf20 // contributors may be used to endorse or promote products derived from}\par
00016 {\cf20 // this software without specific prior written permission.}\par
00017 {\cf20 //}\par
00018 {\cf20 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}\par
00019 {\cf20 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}\par
00020 {\cf20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}\par
00021 {\cf20 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}\par
00022 {\cf20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}\par
00023 {\cf20 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}\par
00024 {\cf20 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}\par
00025 {\cf20 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}\par
00026 {\cf20 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}\par
00027 {\cf20 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}\par
00028 {\cf20 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}\par
00029 \par
00030 {\cf21 #include <stdio.h>}\par
00031 \par
00032 {\cf21 #include "gtest/gtest.h"}\par
00033 \par
00034 GTEST_API_ {\cf18 int} main({\cf18 int} argc, {\cf18 char} **argv) \{\par
00035   printf({\cf22 "Running main() from gtest_main.cc\\n"});\par
00036   testing::InitGoogleTest(&argc, argv);\par
00037   {\cf19 return} RUN_ALL_TESTS();\par
00038 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\'D4\'E0\'E9\'EB main.cpp\par \pard\plain 
{\tc\tcl2 \v main.cpp}
{\xe \v main.cpp}
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <gtest/gtest.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b calcSum} (int a, int b)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'C2\'EE\'E7\'E2\'F0\'E0\'F9\'E0\'E5\'F2 \'F1\'F3\'EC\'EC\'F3 \'FD\'EB\'E5\'EC\'E5\'ED\'F2\'EE\'E2, \'E5\'F1\'EB\'E8 a>b. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST} (test001, a_equal_b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST} (test002, a_less_b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST} (test003, a_more_b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
main \'D2\'EE\'F7\'EA\'E0 \'E2\'F5\'EE\'E4\'E0 \'E2 \'EF\'F0\'E8\'EB\'EE\'E6\'E5\'ED\'E8\'E5 }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D4\'F3\'ED\'EA\'F6\'E8\'E8\par
\pard\plain 
{\xe \v calcSum\:main.cpp}
{\xe \v main.cpp\:calcSum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int calcSum (int  {\i a}, int  {\i b})}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'C2\'EE\'E7\'E2\'F0\'E0\'F9\'E0\'E5\'F2 \'F1\'F3\'EC\'EC\'F3 \'FD\'EB\'E5\'EC\'E5\'ED\'F2\'EE\'E2, \'E5\'F1\'EB\'E8 a>b. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'C5\'F1\'EB\'E8 a \'F0\'E0\'E2\'ED\'EE b, \'E2\'EE\'E7\'E2\'F0\'E0\'F9\'E0\'E5\'F2 \'E7\'ED\'E0\'F7\'E5\'ED\'E8\'E5 a. \'C8\'ED\'E0\'F7\'E5, b. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'C0\'E2\'F2\'EE\'F0\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
I \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'C2\'E5\'F0\'F1\'E8\'FF\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
1.1 \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'D1\'EC. \'F2\'E0\'EA\'E6\'E5\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b main} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'CF\'F0\'E5\'E4\'F3\'EF\'F0\'E5\'E6\'E4\'E5\'ED\'E8\'FF\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\'FD\'F2\'EE \'EF\'F0\'E8\'EC\'E5\'F0, \'E0 \'ED\'E5 \'ED\'E0\'F1\'F2\'EE\'FF\'F9\'E0\'FF \'F4\'F3\'ED\'EA\'F6\'E8\'FF \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'C2\'ED\'E8\'EC\'E0\'ED\'E8\'E5\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\'FD\'F2\'EE \'F2\'EE\'F7\'ED\'EE \'EF\'F0\'E8\'EC\'E5\'F0, \'E0 \'ED\'E5 \'ED\'E0\'F1\'F2\'EE\'FF\'F9\'E0\'FF \'F4\'F3\'ED\'F6\'E8\'FF \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'CD\'E5\'EE\'E1\'F5\'EE\'E4\'E8\'EC\'EE \'F1\'E4\'E5\'EB\'E0\'F2\'FC:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid \'EC\'EE\'E6\'ED\'EE \'E4\'EE\'E1\'E0\'E2\'E8\'F2\'FC \'E5\'F9\'E5 \'F4\'F3\'ED\'F6\'E8\'FE \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'C0\'F0\'E3\'F3\'EC\'E5\'ED\'F2\'FB\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i a} \cell }{\'CF\'E5\'F0\'E2\'FB\'E9 \'EF\'E0\'F0\'E0\'EC\'E5\'F2\'F0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i b} \cell }{\'C2\'F2\'EE\'F0\'EE\'E9 \'EF\'E0\'F0\'E0\'EC\'E5\'F2\'F0 \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'C2\'EE\'E7\'E2\'F0\'E0\'F9\'E0\'E5\'F2\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\'F0\'E5\'E7\'F3\'EB\'FC\'F2\'E0\'F2 \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'CE\'F8\'E8\'E1\'EA\'E0:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 int} a=3;\par
{\cf18 int} b=2;\par
{\cf18 int} actual=calcSum(a,b);\par
}
 \par
}{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b main.cpp} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 21}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00022 \{\par
00023     {\cf19 if}(a>b)\par
00024     \{\par
00025         {\cf19 return} a+b;\par
00026     \}\par
00027    {\cf19 else}\par
00028     \{\par
00029         {\cf19 if}(a==b)\par
00030         \{\par
00031             {\cf19 return} a;\par
00032         \}\par
00033     \}\par
00034     {\cf19 return} b;\par
00035 \}\par
}
{
\ql
\'C8\'F1\'EF\'EE\'EB\'FC\'E7\'F3\'E5\'F2\'F1\'FF \'E2 {\b TEST()}.}\par
}
{\xe \v main\:main.cpp}
{\xe \v main.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
main \'D2\'EE\'F7\'EA\'E0 \'E2\'F5\'EE\'E4\'E0 \'E2 \'EF\'F0\'E8\'EB\'EE\'E6\'E5\'ED\'E8\'E5 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'C0\'F0\'E3\'F3\'EC\'E5\'ED\'F2\'FB\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argc} \cell }{\'F7\'E8\'F1\'EB\'EE \'E0\'F0\'E3\'F3\'EC\'E5\'ED\'F2\'EE\'E2 \'EA\'EE\'EC\'E0\'ED\'E4\'ED\'EE\'E9 \'F1\'F2\'F0\'EE\'EA\'E8 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argv} \cell }{\'E0\'F0\'E3\'F3\'EC\'E5\'ED\'F2\'FB \'EA\'EE\'EC\'E0\'ED\'E4\'ED\'EE\'E9 \'F1\'F2\'F0\'EE\'EA\'E8 \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'C2\'EE\'E7\'E2\'F0\'E0\'F9\'E0\'E5\'F2\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\'EA\'EE\'E4 \'E7\'E0\'E2\'E5\'F0\'F8\'E5\'ED\'E8\'FF \par
}}}{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b main.cpp} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 89}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00090 \{\par
00091     ::testing::InitGoogleTest(&argc,argv);\par
00092 \par
00093     {\cf19 return} RUN_ALL_TESTS();\par
00094 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b testing::InitGoogleTest()} \'E8 {\b RUN_ALL_TESTS()}.}\par
}
{\xe \v TEST\:main.cpp}
{\xe \v main.cpp\:TEST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST (test001 , a_equal_b )}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b main.cpp} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 42}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00043 \{\par
00044 \par
00045     {\cf18 int} a=2;\par
00046     {\cf18 int} b=2;\par
00047 \par
00048     {\cf18 int} actual=calcSum(a,b);\par
00049     {\cf18 int} expected=2;\par
00050 \par
00051 \par
00052     ASSERT_EQ(actual, expected );\par
00053 \par
00054 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ASSERT_EQ} \'E8 {\b calcSum()}.}\par
}
{\xe \v TEST\:main.cpp}
{\xe \v main.cpp\:TEST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST (test002 , a_less_b )}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b main.cpp} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 56}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00057 \{\par
00058 \par
00059     {\cf18 int} a=2;\par
00060     {\cf18 int} b=3;\par
00061 \par
00062     {\cf18 int} actual=calcSum(a,b);\par
00063     {\cf18 int} expected=3;\par
00064 \par
00065 \par
00066     ASSERT_EQ(actual, expected );\par
00067 \par
00068 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ASSERT_EQ} \'E8 {\b calcSum()}.}\par
}
{\xe \v TEST\:main.cpp}
{\xe \v main.cpp\:TEST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST (test003 , a_more_b )}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
\'D1\'EC. \'EE\'EF\'F0\'E5\'E4\'E5\'EB\'E5\'ED\'E8\'E5 \'E2 \'F4\'E0\'E9\'EB\'E5 {\b main.cpp} \'F1\'F2\'F0\'EE\'EA\'E0 {\b 70}}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00071 \{\par
00072 \par
00073     {\cf18 int} a=3;\par
00074     {\cf18 int} b=2;\par
00075 \par
00076     {\cf18 int} actual=calcSum(a,b);\par
00077     {\cf18 int} expected=5;\par
00078 \par
00079 \par
00080     ASSERT_EQ(actual, expected );\par
00081 \par
00082 \}\par
}
{
\ql
\'CF\'E5\'F0\'E5\'EA\'F0\'E5\'F1\'F2\'ED\'FB\'E5 \'F1\'F1\'FB\'EB\'EA\'E8 {\b ASSERT_EQ} \'E8 {\b calcSum()}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main.cpp\par \pard\plain 
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
\'D1\'EC. \'E4\'EE\'EA\'F3\'EC\'E5\'ED\'F2\'E0\'F6\'E8\'FE.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <gtest/gtest.h>}\par
00002 \par
00021 {\cf18 int} calcSum({\cf18 int} a,{\cf18 int} b)\par
00022 \{\par
00023     {\cf19 if}(a>b)\par
00024     \{\par
00025         {\cf19 return} a+b;\par
00026     \}\par
00027    {\cf19 else}\par
00028     \{\par
00029         {\cf19 if}(a==b)\par
00030         \{\par
00031             {\cf19 return} a;\par
00032         \}\par
00033     \}\par
00034     {\cf19 return} b;\par
00035 \}\par
00036 \par
00037 {\cf20 //TEST}\par
00038 {\cf20 //a=2, b=2, expected=2}\par
00039 {\cf20 //a=2, b=3, expected=3}\par
00040 {\cf20 //a=3, b=2, expected 5}\par
00041 \par
00042 TEST ( test001, a_equal_b)\par
00043 \{\par
00044 \par
00045     {\cf18 int} a=2;\par
00046     {\cf18 int} b=2;\par
00047 \par
00048     {\cf18 int} actual=calcSum(a,b);\par
00049     {\cf18 int} expected=2;\par
00050 \par
00051 \par
00052     ASSERT_EQ(actual, expected );\par
00053 \par
00054 \}\par
00055 \par
00056 TEST ( test002, a_less_b)\par
00057 \{\par
00058 \par
00059     {\cf18 int} a=2;\par
00060     {\cf18 int} b=3;\par
00061 \par
00062     {\cf18 int} actual=calcSum(a,b);\par
00063     {\cf18 int} expected=3;\par
00064 \par
00065 \par
00066     ASSERT_EQ(actual, expected );\par
00067 \par
00068 \}\par
00069 \par
00070 TEST ( test003, a_more_b)\par
00071 \{\par
00072 \par
00073     {\cf18 int} a=3;\par
00074     {\cf18 int} b=2;\par
00075 \par
00076     {\cf18 int} actual=calcSum(a,b);\par
00077     {\cf18 int} expected=5;\par
00078 \par
00079 \par
00080     ASSERT_EQ(actual, expected );\par
00081 \par
00082 \}\par
00089 {\cf18 int} main({\cf18 int} argc, {\cf18 char}* argv[])\par
00090 \{\par
00091     ::testing::InitGoogleTest(&argc,argv);\par
00092 \par
00093     {\cf19 return} RUN_ALL_TESTS();\par
00094 \}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \'C0\'EB\'F4\'E0\'E2\'E8\'F2\'ED\'FB\'E9 \'F3\'EA\'E0\'E7\'E0\'F2\'E5\'EB\'FC\par 
\pard\plain 
{\tc \v \'C0\'EB\'F4\'E0\'E2\'E8\'F2\'ED\'FB\'E9 \'F3\'EA\'E0\'E7\'E0\'F2\'E5\'EB\'FC}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
